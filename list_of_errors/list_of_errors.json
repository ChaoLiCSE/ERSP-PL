{"hw": "hw1", "fix": ["let rec sumList xs = match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'"], "bad": ["let rec sumList xs = match xs with\n| [] -> []\n| h1::h2::t -> h1+h2 sumList t", "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x+1 sumList xs'", "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x sumList xs'", "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x + sumList xs'", "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') ->  1 sumList xs'", "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x sumList xs'", "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x + sumList xs'", "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x sumList xs'", "let rec sumList xs = match xs with\n| [] -> []\n| x::xs' -> x sumList xs'"], "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type ('a -> 'b -> 'c) list -> 'd list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b -> 'c) list -> 'd list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type ('a -> 'b -> 'c) list -> 'd list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b -> 'c) list -> 'd list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type ('a -> 'b -> 'c) list -> 'd list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b -> 'c) list -> 'd list\n", "Error: This expression has type ('a -> 'b -> 'c) list -> 'd list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b -> 'c) list -> 'd list\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = match n with\n| _ -> (n mod 10) + digitsOfInt  (n/10)"], "bad": ["let rec digitsOfInt n = match n with\n| n < 0 -> []\n| _     -> n%10 digitsOfInt  n/10", "let rec digitsOfInt n = match n with\n| _     -> n%10 digitsOfInt  n/10", "let rec digitsOfInt n = match n with\n| _     -> n mod 10 digitsOfInt  n/10", "let rec digitsOfInt n = match n with\n| (n mod 10) + digitsOfInt  (n/10)"], "message": ["Error: Syntax error\n", "Error: Unbound value %\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Characters 39-40:\n  | (n mod 10) + digitsOfInt  (n/10);;\n    ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif (n<0) \nthen 0\nelse\n(n mod 10) + digitsOfInt  (n/10)"], "bad": ["let rec digitsOfInt n = match true with\n| n<0 -> 0\n| _ -> (n mod 10) + digitsOfInt  (n/10)"], "message": ["Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663"], "bad": ["let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\ndigitsOfInt  (n/10) :: (n mod 10)", "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\ndigitsOfInt (n/10) :: (n mod 10)", "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\n(digitsOfInt (n/10) ):: (n mod 10)"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec sum n = \nif n < 0 \nthen failwith\"TBD\"\nelse (n mod 10) + digitalRoot n/10"], "bad": ["let rec digitalRoot n = \nlet temp = (sum n) in \nif temp > 10\nthen digitalRoot temp", "let rec sum n = \nif n < 0 \nthen failwith\"TBD\"\nelse n%10 + digitalRoot n/10"], "message": ["Error: Unbound value sum\n", "Error: Unbound value %\n"], "problem": "digitalRoot"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = additivePersistence_helper (n, 0)"], "bad": ["let rec additivePersistence n = additivePersistence (n, 0)"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), 1+1)"], "bad": ["let rec sum (n, i) = \nif n < 10\nthen sumList (digitsOfInt n) i\nelse sumList (digitsOfInt n) 1+1"], "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), 1+1)"], "bad": ["let rec sum [n;i] = \nif n < 10 || []\nthen [sumList (digitsOfInt n); i]\nelse [sumList (digitsOfInt n); 1+1]"], "message": ["Error: This variant expression is expected to have type bool\n       The constructor [] does not belong to type bool\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  hd :: listReverse tl"], "bad": ["let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> tl :: listReverse hd", "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  listReverse tl :: hd"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  (listReverse tl) @ hd"], "bad": ["let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  (listReverse tl) :: hd"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec listReverse l = match l with\n| [] -> []\n| _::tl -> listReverse tl", "let _ = listReverse [1; 2; 3; 4]"], "bad": ["let _ = listReverse [1; 2; 3; 4]", "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  \nif hd != [] \nthen (listReverse tl) :: hd\nelse hd"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec last l = match l with \n| [] -> []\n| _::tl -> last tl", "let _ = last [1; 2; 3; 4]"], "bad": ["let rec last l = match l with \n| [] -> []\n| _::tl2::tl -> last tl2"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec last l = match l with \n| x::[] -> x\n| hd::tl -> last tl\n| [] -> failwith \"NO ELEMENT\"", "let _ = last [1; 2; 3; 4]"], "bad": ["let rec last l = match l with \n| [] -> 0\n| hd::tl -> last tl :: hd"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec last l = match l with \n| x::[] -> x\n| hd::tl -> last tl \n| [] -> failwith \"NO ELEMENT\"", "let _ = last [1; 2; 3; 4]", "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> let x = last tl"], "bad": ["let rec listReverse l = match l with\n| [] -> []\n| _ -> let x = last tl"], "message": ["Error: Syntax error\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse (hd::l)"], "bad": ["let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> let x = last l", "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> let x = last l in\nif x > 0\nthen x\nelse x", "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> let x = last l in\nif x > 0\nthen x::x\nelse x::x", "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse(hd::l) tl"], "message": ["Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl @ hd"], "bad": ["let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl @ hd"], "message": ["Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl @ [hd]", "let _ = listReverse [1; 2; 3; 4]"], "bad": ["let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl :: [hd]", "let _ = listReverse [1; 2; 3; 4]"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4]"], "bad": ["let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl @ [hd]"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = palindrome \"malayalam\""], "bad": ["let palindrome w = \nif explode w = listReverse (explode w)\nthen true\nelse false"], "message": ["Error: Unbound value l\n"], "problem": "palindrome"}
{"hw": "hw1", "fix": ["let a = []", "let b = 3", "let _ = fun a b"], "bad": ["let f = fun x l -> x::l"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let b = []", "let a = 3"], "bad": ["let _ = f a b"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec last l = match l with \n| x::[] -> x\n| hd::tl -> last tl\n| [] -> []"], "bad": ["let rec last l = match l with \n| x::[] -> x\n| hd::tl -> last tl\n| [] -> []"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]", "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let digits n = digitsOfInt (abs n)", "let sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), i+1)", "let rec additivePersistence_helper (n, i) = \nlet temp = (sum (n,i)) in\nlet (num, count) = temp in \nif num >= 10\nthen additivePersistence_helper (num, count)\nelse count", "let rec additivePersistence n = additivePersistence_helper (n, 0)", "let _ = additivePersistence 9876", "let rec digitalRoot n = \nlet temp = sumList (digitsOfInt n) in\nif temp >= 10\nthen digitalRoot temp\nelse temp", "let _ = digitalRoot 9876", "let rec listReverse l = match l with \n| [] -> 0\n| hd::tl -> listReverse tl :: hd"], "bad": ["let rec listReverse l = \nfailwith \"err\""], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4]"], "bad": ["let rec listReverse l = match l with \n| [] -> 0\n| hd::tl -> listReverse tl"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]", "let rec last l = match l with \n| x::[]  -> x\n| hd::tl -> last tl\n| []     ->  failwith \"error\"", "let rec removeLast l = match l with \n| x::[]  -> []\n| hd::tl -> hd::removeLast tl\n| []     -> []", "let rec listReverse l = \nlet x = last l in\nlet y = removeLast l in\nif (y=[])\nthen x::y\nelse x::listReverse y", "let _ = listReverse [1; 2; 3; 4]", "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]", "let rec reversed n = \nif (n<=0) \nthen []\nelse\n(n mod 10) :: reversed  (n/10)", "let rec digitsOfInt n = \nlistReverse (reversed n)", "let _ = digitsOfInt 3124"], "bad": ["let rec digitsOfInt n = \nlistReverse reversed n", "let _ = digitsOfInt 3124"], "message": ["Error: Unbound value rlistReverse\nHint: Did you mean listReverse?\nError: Unbound value rlistReverse\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value rlistReverse\nHint: Did you mean listReverse?\n", "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "listReverse"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = \nwwhile (f,b)"], "bad": ["let fixpoint (f,b) = \nlet b' = f b in\nif b'=b then\nb\nelse \nfixpoint (f,b')"], "message": ["Error: This expression has type 'a * 'b -> 'a * 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b -> 'a * 'b\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = \nlet f b = (f b, b=f b) in\nwwhile (f,b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "bad": ["let fixpoint (f,b) = \nlet b' = (b, (f b = b)) in \nwwhile (f,b')", "let fixpoint (f,b) = \nlet b' = (b, (f b < b)) in \nwwhile (f,b')", "let fixpoint (f,b) = \nlet f' = (f b, f'=b ) in\nwwhile (f',b)", "let fixpoint (f,b) = \nlet f' = (f b, f b=b ) in\nwwhile (f',b)", "let fixpoint (f,b) = \nlet f b = (f b, b=f b) in\nwwhile (f,b)"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: Unbound value f'\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) =\nlet f b = (f b, f b = b) in\nwwhile (f, b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "bad": ["let fixpoint (f,b) = \nlet f' = f b -> (f b, b=f b) in\nwwhile(f',b)", "let fixpoint (f,b) = \nlet f' = fun f -> fun b -> (f b, b=f b) in\nwwhile(f',b)", "let fixpoint (f,b) =\nfailwith \"to be d\""], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "Error: Syntax error\n", "Error: This expression has type ('a -> 'a) -> 'a -> 'a * bool\n       but an expression was expected of type ('a -> 'a) -> ('a -> 'a) * bool\n       Type 'a -> 'a * bool is not compatible with type ('a -> 'a) * bool \n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) =\nlet f b = let b' = f b in b=b' in b'", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "bad": ["let fixpoint (f,b) =\nlet f b = let b' = f b in b=b'", "let fixpoint (f,b) =\nlet f b = let b' = f b in b=b' in\n\nlet g x = (x-1) in fixpoint (g,8)"], "message": ["Error: Unbound value b'\n", "Error: Syntax error\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let a = Succ(Succ(Zero))"], "bad": ["let a = Succ(Zero)"], "message": ["Error: This expression has type nat but an expression was expected of type\n         int\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let b = to_int (Succ(Succ(Zero)))"], "bad": ["let b = to_int (Succ(Zero))"], "message": ["Error: This function has type nat -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let b = exprToString Sine(VarX)"], "bad": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin\"^ exprToString m"], "message": ["Error: This expression has type expr -> string\n       but an expression was expected of type string\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"", "let b = exprToString (Sine(VarX))"], "bad": ["let b = exprToString (Sine(VarX))"], "message": ["Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let b = exprToString (Cosine(VarX))"], "bad": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToStirng m ^ \"+\" ^ exprToString n ^ \")/2)\"", "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\""], "message": ["Error: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type expr\n", "Error: Unbound value exprToStirng\nHint: Did you mean exprToString?\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n) -> exprToString m ^ \"*\" ^ exprToString n\n| Tresh (m,n,o,p) -> \n\"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^exprToString o^\":\"^exprToString p"], "bad": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n) -> exprToString m ^ \"*\" ^ exprToString n"], "message": ["Error: Syntax error\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let b = exprToString (Average(Cosine(VarX),VarY))"], "bad": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n) -> exprToString m ^ \"*\" ^ exprToString n\n| Thresh (m,n,o,p) -> \n\"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^exprToString o^\":\"^exprToString p"], "message": ["Error: This variant pattern is expected to have type expr\n       The constructor Tresh does not belong to type expr\nHint: Did you mean Thresh?\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let _ = eval(Sine,0.5,0.)"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| Sine m -> sin(pi*. (eval m))\n| _ -> x", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| _ -> x"], "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'b\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'b\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval((Sine(VarX)),0.3,0.)"], "bad": ["let _ = eval((Sine(VarX)),0.5,0.)"], "message": ["Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m, n) -> eval(m,x,y) *. eval(n,x,y)"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y)+.eval (n,x,y))/2.", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y))/2.", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2."], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr,0.5,0.2)"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| Thresh (m,n,o,p) -> \neval (m,x,y) < eval (n,x,y) ? eval (o,x,y) : eval (p,x,y)", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = rand"], "bad": ["let rec build (rand, depth) = rand 1 2"], "message": ["Error: Unbound value i\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = let num = rand 4 53 in\nmatch num with\n| _ -> VarX"], "bad": ["let rec build (rand, depth) = rand 3 4"], "message": ["Error: Unbound value rand\nHint: Did you mean land?\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) =\nif depth = 0\nthen\nlet num = rand in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))", "let y = doRandomGray(5,1,5)"], "bad": ["let rec build (rand, depth) =\nif depth = 0\nthen\nlet num = rand in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"], "message": ["Error: Unbound value x1\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let g2 () = (5,3,2)", "let g3 () = (4,1,5)"], "bad": ["let g1 () = (8,3,4)"], "message": ["Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) = \nlet (b',c') = f b in \nif c'\nthen wwhile (f,b')\nelse b'", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) =\nlet f b = (f b, f b != b) in\nwwhile (f, b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)", "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p^\")\"", "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "let _ = exprToString sampleExpr1", "let buildX()                       = VarX", "let buildY()                       = VarY", "let buildSine(e)                   = Sine(e)", "let buildCosine(e)                 = Cosine(e)", "let buildAverage(e1,e2)            = Average(e1,e2)", "let buildTimes(e1,e2)              = Times(e1,e2)", "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "let pi = 4.0 *. atan 1.0", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)", "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr,0.5,0.2)", "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num = rand in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))", "let g1 () = (8,3,4)", "let g2 () = (5,3,2)", "let g3 () = (4,1,5)", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"], "bad": ["let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"], "message": ["Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) =\nif depth = 0\nthen\nlet nums (a,b) = rand in\nlet num = rand in \nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet nums (a,b) = rand in\nlet num = rand in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"], "bad": ["let rec build (rand, depth) =\nif depth = 0\nthen\nlet nums (a,b) = rand in\nlet num = rand in \nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet nums (a,b) = rand in\nlet num = rand in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"], "message": ["Error: This pattern matches values of type int\n       but a pattern was expected which matches values of type 'a * 'b -> 'c\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"], "bad": ["let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"], "message": ["Error: Unbound value rand\nHint: Did you mean land?\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| _ -> buildCosine(build(rand,depth-1))"], "bad": ["let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"], "message": ["Error: This variant expression is expected to have type expr\n       The constructor BuildSine does not belong to type expr\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 2 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildCosine(build(rand,depth-1))"], "bad": ["let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 2 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildCosine(build(rand,depth-1))"], "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * expr\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let _ = exprToString(Divide(Divide(VarX,VarY),VarX))"], "bad": ["let _ = exprToString(Divide(VarX,VarY))"], "message": ["Error: This expression has type int but an expression was expected of type\n         expr\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let _ = eval (Square(VarX),1.0,0.5)"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Square m -> eval(m,x,y)**2\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Square m -> eval(m,x,y)**2.0\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)"], "message": ["Error: This variant expression is expected to have type expr\n       The constructor Square does not belong to type expr\nError: This variant pattern is expected to have type expr\n       The constructor Divide does not belong to type expr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This variant expression is expected to have type expr\n       The constructor Square does not belong to type expr\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = max_float"], "bad": ["let _ = max_float(2.0,2.0)", "let _ = max_float(100.0)", "let _ = max_float 100.0", "let _ = max_float 100.0", "let _ = max_float 100.0", "let _ = max_float"], "message": ["Error: This expression has type float\n       This is not a function; it cannot be applied.\n", "Error: This expression has type float\n       This is not a function; it cannot be applied.\n", "Error: This expression has type float\n       This is not a function; it cannot be applied.\n", "Error: This expression has type float\n       This is not a function; it cannot be applied.\n", "Error: This expression has type float\n       This is not a function; it cannot be applied.\n", "Error: This expression has type float\n       This is not a function; it cannot be applied.\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let _ = 1.0/max_float"], "bad": ["let _ = max_float -. min_float"], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let _ = (1.0/.max_float)*.min_float"], "bad": ["let _ = 1.0/.max_float"], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Square m         -> \"(\" ^ exprToString m ^ \"^2)\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| MyExpr (m,n,o)   -> \"(\" ^ exprToString m ^ \"<\" ^ exprToString n ^\"?sqrt(|\" ^\nexprToString o ^ \"|)\" ^ \":\" ^ \"(\" ^ exprToString o ^ \n\"/2)\"\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p^\")\"", "let _ = exprToString(MyExpr(VarX,VarY,VarX))"], "bad": ["let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Square m         -> \"(\" ^ exprToString m ^ \"^2)\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| MyExpr (m,n,o)   -> \"(\" ^ exprToString m ^ \"<\" ^ expToString  ^\"?sqrt(|\" ^\nexprToString o ^ \"|)\" ^ \":\" ^ \"(\" ^ exprToString o ^ \n\"/2)\"\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p^\")\"", "let _ = expToString(MyExpr(VarX,VarY,VarX))", "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Square m         -> \"(\" ^ exprToString m ^ \"^2)\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| MyExpr (m,n,o)   -> \"(\" ^ exprToString m ^ \"<\" ^ exprToString  ^\"?sqrt(|\" ^\nexprToString o ^ \"|)\" ^ \":\" ^ \"(\" ^ exprToString o ^ \n\"/2)\"\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p^\")\"", "let _ = exprToString(MyExpr(VarX,VarY,VarX))"], "message": ["NO ERROR FROM MINIMAL PROGRAM!!!\nError: This variant expression is expected to have type expr\n       The constructor MyExpr does not belong to type expr\n", "Error: Unbound value expToString\nHint: Did you mean exprToString?\n", "Error: Unbound value expToString\nHint: Did you mean exprToString?\nError: Unbound value expToString\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value expToString\nHint: Did you mean exprToString?\n", "Error: This expression has type expr -> string\n       but an expression was expected of type string\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let _ = eval (MyExpr(VarX,VarY,VarX),1.0, 2.0)"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Square m -> eval(m,x,y)**2.0\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| MyExpr(m,n,o) -> \nif eval(m,x,y) < eval (n,x,y)\nthen sqrt(abs_float(eval(o,x,y)))\nelse eval(o,x,y) /. 2.\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)"], "message": ["Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval (sampleExpr,0.5,0.2)"], "bad": ["let _ = eval (sampleExpr1,0.5,0.2)"], "message": ["Error: This expression has type expr/2623\n       but an expression was expected of type expr/2890\nError: This expression has type expr/2962\n       but an expression was expected of type expr/2984\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type expr/2623\n       but an expression was expected of type expr/2890\n"], "problem": "eval"}
{"hw": "hw1", "fix": ["let rec sumList xs = match xs with\nh :: t -> h + sumList t\n| [] -> 0", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]"], "bad": ["let rec sumList [xs] =", "let rec sumList xs[] =", "let rec sumList xs = (* failwith \"TBD:sumList\" *) \n\nlet _ = sumList [1; 2; 3; 4]"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt (-352663)"], "bad": ["let _ = digitsOfInt -352663"], "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digits n = digitsOfInt (abs n)", "digits (-124074)"], "bad": ["let rec digits n = digitsOfInt (abs n)\n\ndigits (-124074)"], "message": ["Error: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "digitsOfInt"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "uncomment after implementing assoc", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "bad": ["let rec assoc (d,k,l) = \nlet temp = l in\nlet rec helper acc (d,k,l) = \nmatch temp with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper (d,k,l) t\nin helper (d,k,l) acc", "uncomment after implementing assoc", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper (d,k,l) acc", "uncomment after implementing assoc", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "message": ["Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'b * 'a * 'c\n", "Error: Unbound value uncomment\n", "Error: Unbound value assoc\n", "Error: Unbound value assoc\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type ('d * 'e) list\n", "Error: Unbound value uncomment\n", "Error: Unbound value assoc\n", "Error: Unbound value assoc\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen)\nthen \nseen\nelse \nh :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"], "bad": ["et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"], "message": ["Error: Unbound value l\n", "Error: Syntax error\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\n| Cube     of expr\n| Addition of expr * expr", "let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin(pi*\" ^ (exprToString a) ^ \")\"\n| Cosine a -> \"cos(pi*\" ^ (exprToString a) ^ \")\"\n| Average (a,b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a,b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a,b,c,d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\"\n| _ -> \"_\"\n| Cube a -> \"(\" ^ (exprToString a) ^ \"*\" ^ (exprToString a) ^ \"*\" ^ (exprToString a) ^ \")\"\n| Addition (a,b) -> \"(\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) \")\""], "bad": ["let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin(pi*\" ^ (exprToString a) ^ \")\"\n| Cosine a -> \"cos(pi*\" ^ (exprToString a) ^ \")\"\n| Average (a,b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a,b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a,b,c,d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\"\n| _ -> \"_\"\n| Cube a -> \"(\" ^ (exprToString a) ^ \"*\" ^ (exprToString a) ^ \"*\" ^ (exprToString a) ^ \")\""], "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = \nmatch e with\nVarX -> x\n| VarY -> y\n| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )\n| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )\n| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)\n| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )\n| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))\nthen (eval (c,x,y))\nelse (eval (d,x,y))\n| Cube a -> (eval (a,x,y) ) *. (eval  (a,x,y) ) *. (eval (a,x,y) )\n| Addition (a,b) -> eval(a,x,y) +. eval"], "bad": ["let rec eval (e,x,y) = \nmatch e with\nVarX -> x\n| VarY -> y\n| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )\n| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )\n| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)\n| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )\n| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))\nthen (eval (c,x,y))\nelse (eval (d,x,y))\n| Cube a -> (eval a) * (eval  a) *(eval a)", "let rec eval (e,x,y) = \nmatch e with\nVarX -> x\n| VarY -> y\n| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )\n| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )\n| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)\n| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )\n| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))\nthen (eval (c,x,y))\nelse (eval (d,x,y))\n| Cube a -> (eval (a,x,y) ) * (eval  (a,x,y) ) * (eval (a,x,y) )", "let rec eval (e,x,y) = \nmatch e with\nVarX -> x\n| VarY -> y\n| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )\n| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )\n| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)\n| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )\n| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))\nthen (eval (c,x,y))\nelse (eval (d,x,y))\n| Cube a -> (eval (a,x,y) ) *. (eval  (a,x,y) ) *. (eval (a,x,y) )"], "message": ["Error: This expression has type string but an expression was expected of type\n         int\n", "Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen)\nthen \nseen\nelse \nh :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) = \nmatch f b with\n(k,v) -> \nif v\nthen wwhile (f, k)\nelse k", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) = wwhile ((let g x = let xx = (f x) in (xx, xx!=x) in g),b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)", "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\n| Cube     of expr\n| Addition of expr * expr", "let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin(pi*\" ^ (exprToString a) ^ \")\"\n| Cosine a -> \"cos(pi*\" ^ (exprToString a) ^ \")\"\n| Average (a,b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a,b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a,b,c,d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\"\n| _ -> \"_\"\n| Cube a -> \"(\" ^ (exprToString a) ^ \"*\" ^ (exprToString a) ^ \"*\" ^ (exprToString a) ^ \")\"\n| Addition (a,b) -> \"(\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")\"", "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "let _ = exprToString sampleExpr1", "let buildX()                       = VarX", "let buildY()                       = VarY", "let buildSine(e)                   = Sine(e)", "let buildCosine(e)                 = Cosine(e)", "let buildAverage(e1,e2)            = Average(e1,e2)", "let buildTimes(e1,e2)              = Times(e1,e2)", "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "let buildCube(e)                   = Cube(e)", "let buildAddition(e1,e2)           = Addition(e1,e2)", "let pi = 4.0 *. atan 1.0", "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )\n| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )\n| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)\n| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )\n| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))\nthen (eval (c,x,y))\nelse (eval (d,x,y))\n| Cube a -> (eval (a,x,y) ) *. (eval  (a,x,y) ) *. (eval (a,x,y) )\n| Addition (a,b) -> eval(a,x,y) +. eval(b,x,y)", "sin 0.3", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr1,0.5,0.2)", "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "let rec build (rand,depth) =\nif depth = 0 \nthen\nmatch rand(1,3) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse \nmatch rand(1,10) with\n| 3 -> buildSine( build(rand,depth-1) ) \n| 4 -> buildCosine( build(rand,depth-1) )\n| 5 -> buildAverage( (build(rand,depth-1)), build(rand,depth-1) )\n| 6 -> buildTimes( (build(rand,depth-1)), build(rand,depth-1) )\n| 7 -> buildThresh( build(rand,depth-1), build(rand,depth-1), build(rand,depth-1), build(rand,depth-1) )\n| 8 -> buildCube( build(rand,depth-1) )\n| 9 -> buildAddition ( build(rand,depth-1),  build(rand,depth-1) )\n| _ -> build(rand,depth)", "let g1 () = (0, 1, 9)", "let g2 () = (8, 3, 5)", "let g3 () = (110, 0, 10)", "let c1 () = (6, 1, 7)", "let c2 () = (4, 0, 4)", "let c3 () = (2, 6, 9)", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type test = unit -> string", "let key = \"\"", "let prefix130 = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")", "let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0", "let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)", "let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))", "let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p", "let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max"], "bad": ["let rec build (rand,depth) =\nif depth = 0 \nthen\nmatch rand(1,3) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse \nmatch rand(1,10) with\n| 3 -> buildSine( build(rand,depth-1) ) \n| 4 -> buildCosine( build(rand,depth-1) )\n| 5 -> buildAverage( (build(rand,depth-1)), build(rand,depth-1) )\n| 6 -> buildTimes( (build(rand,depth-1)), build(rand,depth-1) )\n| 7 -> buildThresh( build(rand,depth-1), build(rand,depth-1), build(rand,depth-1), build(rand,depth-1) )\n| 8 -> buildCube( build(rand,depth-1) )\n| 9 -> buildAddition ( build(rand,depth-1),  build(rand,depth-1) )\n| _ -> build(rand,depth)"], "message": ["Error: Unbound value buildX\nHint: Did you mean build?\n"], "problem": "build"}
{"hw": "hw2", "fix": ["type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\n| Tan      of expr\n| Sin_Avg  of expr * expr * expr", "let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin(pi*\" ^ (exprToString a) ^ \")\"\n| Cosine a -> \"cos(pi*\" ^ (exprToString a) ^ \")\"\n| Average (a,b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a,b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a,b,c,d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\"\n| _ -> \"_\"\n| Tan a -> \"tan(pi*\" ^ (exprToString a) ^ \")\"\n| Arc (a,b,c) -> \"sin(pi*(\" ^ (exprToString  a) ^ \"+\" ^ (exprToString  b) ^ (exprToString c) ^ \")\""], "bad": ["let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin(pi*\" ^ (exprToString a) ^ \")\"\n| Cosine a -> \"cos(pi*\" ^ (exprToString a) ^ \")\"\n| Average (a,b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a,b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a,b,c,d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\"\n| _ -> \"_\"\n| Tan a -> \"tan(pi*\" ^ (exprToString a) ^ \")\"\n| Arc (a,b,c) -> \"sin(pi*\" ^ (exprToString (a (b,c)) ) ^ \")\""], "message": ["Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["exprToString Sin_Avg(1,2,3)"], "bad": ["let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin(pi*\" ^ (exprToString a) ^ \")\"\n| Cosine a -> \"cos(pi*\" ^ (exprToString a) ^ \")\"\n| Average (a,b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a,b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a,b,c,d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\"\n| _ -> \"_\"\n| Tan a -> \"tan(pi*\" ^ (exprToString a) ^ \")\"\n| Sin_Avg (a,b,c) -> \"sin(pi*(\" ^ (exprToString  a) ^ \"+\" ^ (exprToString  b) ^ (exprToString c) ^ \")/3)\""], "message": ["Error: This variant pattern is expected to have type expr\n       The constructor Arc does not belong to type expr\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["exprToString (Tan VarX)"], "bad": ["exprToString (Sin_Avg (VarX, VarY, VarX))"], "message": ["Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"], "problem": "exprToString"}
{"hw": "hw3", "fix": ["let f a b = a + b"], "bad": ["let f a b - a + b"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let rec sqsum xs = \nmatch xs with\n[] -> 0\n| h::t -> (h*h) + (sqsum t)", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]"], "bad": ["let rec sqsum xs = \nmatch xs with\n[] -> []\n| h::t -> (h*h) + (sqsum t)"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = (a*a) in\nlet base = 0 in\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = (a*a) in\nlet base = [] in\nList.fold_left f base xs"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = a + 1 in\nList.fold_left f base xs"], "message": ["Error: Unbound value a\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = a + x in\nlet base = 0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = match a with\n[] -> x\n| h::t -> h x in \nlet base = fs in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = match a with\n[] -> x\n| h::t -> h x in \nlet base = 0 in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'a) list -> 'a -> 'a\n       but an expression was expected of type\n         ('a -> 'a) list -> 'a -> ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n", "Error: This expression has type ('a -> 'a) list -> 'a -> 'a\n       but an expression was expected of type\n         ('a -> 'a) list -> 'a -> ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let _ = pipe []"], "bad": ["let _ = pipe [] 3"], "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = match a with\n[] -> []\n| h::t -> h::[] in\nlet base = [] in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = match a with\n[] -> []\n| h::t -> (h x) \nin\nlet base = 3 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = match a with\n[] -> x\n| h::t -> (h x) in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b list) list -> 'a -> 'b list\n       but an expression was expected of type\n         ('a -> 'b list) list -> 'a -> ('a -> 'b list) list\n       Type 'b list is not compatible with type ('a -> 'b list) list \n", "Error: This expression has type ('a -> 'a) list -> 'a -> 'a\n       but an expression was expected of type\n         ('a -> 'a) list -> 'a -> ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let rec myFunc f a b = \nmatch b with\n[] -> a\n| h::t -> myFunc f (f a h) t", "myFunc (fun x y -> x + y) 0 [1;2;3]"], "bad": ["let myFunc f a b = \nmatch b with\n[] -> a\n| h::t -> myFunc f (f a h) t", "myFunc (fun x y -> x + y) 0 [1;2;3]"], "message": ["Error: Unbound value myFunc\n", "Error: Unbound value myFunc\n"], "problem": "???"}
{"hw": "hw3", "fix": ["myFunc (fun x y -> fun x -> y )  (fun g -> g) [1;2;3]"], "bad": ["myFunc (fun x y -> x y)  (fun x -> x) [1;2;3]", "myFunc (fun x y -> x (y) )  (fun x -> x) [1;2;3]", "myFunc (fun x y -> x y )  (fun g -> g) [1;2;3]"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n", "Error: This expression has type 'a but an expression was expected of type\n         'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n", "Error: This expression has type 'a but an expression was expected of type\n         'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let _ = pipe [fun x -> x*x] 3"], "bad": ["let _ = pipe [fun x -> x; fun x -> x*x] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         int -> int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (fun x -> x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "let _ = pipe [] 3"], "bad": ["let _ = pipe [] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let _ = pipe [(fun x -> x + 1); (fun x -> x*x)] 3"], "bad": ["let _ = pipe [fun x -> x + 1; fun x -> x*x] 3"], "message": ["Error: This expression should not be a function, the expected type is\nint\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "let _ = pipe [(fun x -> x*x); (fun x -> x + 1)] 3"], "bad": ["let _ = pipe [(fun x -> x*x); (fun x -> x + 1)] 3"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let _ = myFunc (fun x y -> x) 0 [1;2;3;4]"], "bad": ["let _ = myFunc (fun x y -> x) [1;2;3;4]"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ \" \" ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ \" \" x in\nlet base = [] in\nlet l = t in\nList.fold_left f base l", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ \" \" ^ x in\nlet base = [] in\nlet l = t in\nList.fold_left f base l"], "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let stringOfList f l = sepConcat (f l)"], "bad": ["let stringOfList f l = ssepConcat (f l)"], "message": ["Error: Unbound value ssepConcat\nHint: Did you mean sepConcat?\nError: Unbound value ssepConcat\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value ssepConcat\nHint: Did you mean sepConcat?\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = List.map f l"], "bad": ["let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: This expression has type int -> string list -> string\n       but an expression was expected of type int -> string\n       Type string list -> string is not compatible with type string \n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = \"[\" ^ ( sepConcat \";\" (List.map f l) ) ^ \"]\""], "bad": ["let stringOfList f l = List.map f (sepConcat l)", "let stringOfList f l = \"[\" ^ sepConcat ^ \";\" ^ List.map f l ^ \"]\"", "let stringOfList f l = \"[\" ^ (sepConcat \";\" List.map f l) ^ \"]\""], "message": ["Error: This expression has type string list -> string\n       but an expression was expected of type 'a list\n", "Error: This expression has type string -> string list -> string\n       but an expression was expected of type string\n", "Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let _ = stringOfList string_of_int [1;2;3;4;5;6]"], "bad": ["let _ = stringOfList float_of_int [1;2;3;4;5;6]"], "message": ["Error: This expression has type int -> float\n       but an expression was expected of type int -> string\n       Type float is not compatible with type string \n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let rec clone x n = let i = 0 in\nif i < n\nthen x :: ( clone x (n-1) )\nelse []"], "bad": ["let rec clone x n = let i = 0 in\nif i < n\nthen x :: (clone x n-1)\nelse []", "let rec clone x n = let i = 0 in\nif i < n\nthen (clone x n-1) :: x :: []\nelse []"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = if List.length l1 < List.length l2\nthen true\nelse false", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]"], "bad": ["let padZero l1 l2 = let length_diff = (List.length l1 - List.length l2) in \nif length_diff < 0\nthen \nlength_diff = (List.length l1 - List.length l2)\nelse \nlength_diff"], "message": ["Error: This expression has type int but an expression was expected of type\n         bool\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (fun x a -> x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "bad": ["let _ = pipe [fun x -> x + 3] 3", "let pipe fs = \nlet f a x = (fun x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: Syntax error: operator expected.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (fun x a -> x a) x a in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "let _ = pipe [] 3"], "bad": ["let _ = pipe [] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (fun y -> x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = (fun -> x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (fun x a -> x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = (fun a x -> x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =  (fun x -> x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = function x a  in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = function x  in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =  (x (a) ) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["List.split [(1, \"hello\")]"], "bad": ["List.split ([1], [2])", "List.combine ([1], [2])", "List.split ([1], [2])", "List.split [[1], \"hello\"", ")", "]", "List.split [[1], \"hello\"", ")", "]", "List.split [[1], \"hello\"", ")", "]"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = \nmatch l with\n| []   -> 0\n| h::t -> h*i", "let _ = mulByDigit 9 [9;9;9;9]"], "bad": ["let rec mulByDigit i l = \nmatch l with\n| []   -> []\n| h::t -> h*i", "let _ = mulByDigit 9 [9;9;9;9]"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::m::t -> (mulByDigit m::t) @ ( (h*i)/10 ) + (m*i) mod 10 :: ( (h*i) mod 10 ) :: []", "let _ = mulByDigit 9 [9;8;9;9]"], "bad": ["let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::m::t -> (mulByDigit m::t) :: ( (h*i)/10 ) + (m*i) mod 10 :: ( (h*i) mod 10 ) :: []"], "message": ["Error: This expression has type 'a list -> 'b list list\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside 'a list -> 'b list list\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["List.combine [0; 0; 9;9] [1;0;0;2]"], "bad": ["List.split [0; 0; 9;9] [1;0;0;2]"], "message": ["Error: This function has type ('a * 'b) list -> 'a list * 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "???"}
{"hw": "hw3", "fix": ["List.map (fun x -> x + 1) [1;2;3]", "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let _ = sqsum [10;9;8;]", "let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + 1)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \" ---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = \"[\" ^ ( sepConcat \";\" (List.map f l) ) ^ \"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n =\nif n > 0\nthen x :: ( clone x (n-1) )\nelse []", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let _ = clone 0 2", "let padZero l1 l2 = if List.length l1 < List.length l2\nthen\n( List.append ( clone 0 (List.length l2 - List.length l1) ) l1, l2)\nelse\n(l1, List.append ( clone 0 (List.length l1 - List.length l2) ) l2)", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let rec removeZero l =\nmatch l with\n| [] -> []\n| h :: t -> \nif h = 0\nthen removeZero t\nelse l", "let _ = removeZero [0;0;0;1;0;0;2]", "let _ = removeZero [9;9]", "let _ = removeZero [0;0;0;0]", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n(list1, list2) -> match list1 with\n[] -> match x with\n(h1,h2) -> ((h1+h2)::list1, list2)\n\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> (h1 + h2, a)\nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> h1 + h2\nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> h1 + h2\nin\nlet base = 0 in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> h1 + h2\nin\nlet base = 0 in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> (a, h1 + h2)\nin\nlet base = 0 in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> a\nin\nlet base = 0 in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> match a with (v1,v2) -> (v1+h1+v2+h2)\nin\nlet base = (0,0) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> match a with (v1,v2) -> (v1+h1, v2+h2)\nin\nlet base = (0,0) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> match a with (v1,v2) -> [(v1+h1, v2+h2)]\nin\nlet base = (0,0) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a -> int * int -> int * 'a\n       but an expression was expected of type 'a -> int * int -> 'a\n       The type variable 'a occurs inside int * 'a\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type 'a -> int * int -> 'a * int\n       but an expression was expected of type 'a -> int * int -> 'a\n       The type variable 'a occurs inside 'a * int\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int * int -> int * int -> int\n       but an expression was expected of type\n         int * int -> int * int -> int * int\n       Type int is not compatible with type int * int \n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int * int -> int * int -> (int * int) list\n       but an expression was expected of type\n         int * int -> int * int -> int * int\n       Type (int * int) list is not compatible with type int * int \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n(list1, list2) -> (list1, list2)\nin\nlet base = ([0],[0]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n(list1, list2) -> list1\nin\nlet base = ([0],[0]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a * 'b -> 'c -> 'a\n       but an expression was expected of type 'a * 'b -> 'c -> 'a * 'b\n       The type variable 'a occurs inside 'a * 'b\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([],[]) -> ([],[])\n| (list1, list2) -> (list1, list2)\nin\nlet base = ([0],[0]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n(list1, list2) -> match (list1, list2) with\n[] -> ([], [])\nin\nlet base = ([0],[0]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b * 'c\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([],[]) -> match x with\n| ([],[]) -> a\n| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([],[]) -> match x with\n| [] -> ([], [])\n| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\n| (list1, list2) -> ([1], [1])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type 'c list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (lh1::lt1, lh2::lt2) -> (lh1::lt1, lh2::lt2)\n| ([],[]) -> match x with\n| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (lh1::lt1, lh2:;lt2) -> (lh1::lt1, lh2:;lt2)\n| ([],[]) -> match x with\n| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (lh1::lt1, lh2::lt2) -> (lh1::lt1, lh2:;lt2)\n| ([],[]) -> match x with\n| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error: type expected.\n", "Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(v1,v2) -> match a with\n(h1::t1, h2::t2) -> (v1 :: h1::t1, v2::h2::t2)\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(v1,v2) -> ( ( v1::a), (v2::a) )\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a list -> 'a * 'a -> 'a list * 'a list\n       but an expression was expected of type 'a list -> 'a * 'a -> 'a list\n       Type 'a list * 'a list is not compatible with type 'a list \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["List.rev (List.combine [0;0; 9;9] [1;0;0;2])"], "bad": ["List.rev List.combine [0;0; 9;9] [1;0;0;2]"], "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "???"}
{"hw": "hw3", "fix": ["List.rev (List.combine  [9;9;9;9] [0; 9;9;9])"], "bad": ["List.rev (List.combine  [9;9;9;9] [0; 9;9;9]) :: (0,0)"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type (int * int) list list\n"], "problem": "???"}
{"hw": "hw3", "fix": ["(List.rev (List.combine  [9;9;9;9] [0; 9;9;9])) @ [(0,0)]"], "bad": ["(List.rev (List.combine  [9;9;9;9] [0; 9;9;9])) :: (0,0)", "(List.rev (List.combine  [9;9;9;9] [0; 9;9;9])) @ (0,0)"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type (int * int) list list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type (int * int) list\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = match x with\n(v1,v2) -> match a with\n(list1, list2) -> match list1 with\n| [] -> ( (v1*v2)/10::list1, (v1*v2) mod 10::list2 )\n| (h::t) -> (((v1*v2)+h)/10::list1, ((v1*v2)+h) mod 10 :: list2) in\nlet base = ([], []) in\nlet args = List.append (List.rev (List.combine l1 l2))  [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = match x with\n(v1,v2) -> match a with\n(list1, list2) -> match list1 with\n| [] -> ( (v1*v2)/10::list1, (v1*v2) mod 10::list2 )\n| (h::t) -> (((v1*v2)+h)/10::list1, ((v1*v2)+h) mod 10 :: list2) in\nlet base = ([]. []) in\nlet args = List.append (List.rev (List.combine l1 l2))  [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let _ = bigAdd [8;1] [8;1;0]"], "bad": ["let _ = bigAdd [8;1] [8;1;0]\n\nList.map (fun x -> x*10 ) [1;2;3]"], "message": ["Error: This function has type int list -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let _ = bigAdd [0] [81000; 8100; 810; 81]", "List.map (fun x -> x*10 ) [1;2;3]", "let rec mulByDigit i l = match (List.rev l) with\n| []   -> 0\n| h::t -> (mulByDigit i (List.rev t) * 10 ) + h*i", "let _ = mulByDigit 9 [9;9;9;9]"], "bad": ["let rec mulByDigit i l = match (List.rev l) with\n| []   -> false\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h1::t1 -> let rec helper acc v = [v] = [0]\n(* if v = 0 \nthen \nacc \nelse \nhelper ( (v mod 10) :: acc) (v/10) *)\nin helper [] h1"], "message": ["Error: This expression has type bool but an expression was expected of type\n         'a list\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = match (List.rev l) with\n| []   -> 0\n| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i )"], "bad": ["let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i ) :: []", "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i )"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["List.map (fun x -> x + 1) [1;2;3]", "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let _ = sqsum [10;9;8;]", "let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + 1)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \" ---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = \"[\" ^ ( sepConcat \";\" (List.map f l) ) ^ \"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n =\nif n > 0\nthen x :: ( clone x (n-1) )\nelse []", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let _ = clone 0 2", "let padZero l1 l2 = if List.length l1 < List.length l2\nthen\n( List.append ( clone 0 (List.length l2 - List.length l1) ) l1, l2)\nelse\n(l1, List.append ( clone 0 (List.length l1 - List.length l2) ) l2)", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let rec removeZero l =\nmatch l with\n| [] -> []\n| h :: t -> \nif h = 0\nthen removeZero t\nelse l", "let _ = removeZero [0;0;0;1;0;0;2]", "let _ = removeZero [9;9]", "let _ = removeZero [0;0;0;0]", "(0,0) :: (List.rev (List.combine  [9;9;9;9] [0; 9;9;9]))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(v1,v2) -> match a with\n(list1, list2) -> match list1 with\n| [] -> ( (v1+v2)/10::list1, (v1+v2) mod 10::list2 )\n| (h::t) -> ((v1+v2+h)/10::list1, (v1+v2+h) mod 10 :: list2)\nin\nlet base = ([],[]) in\nlet args = List.append (List.rev (List.combine l1 l2))  [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]", "let _ = bigAdd [0] [81000; 8100; 810; 81]", "List.map (fun x -> x*10 ) [1;2;3]", "let rec mulByDigit i l = match l with\n[] -> []\n| h::t -> let helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper (v mod 10)::acc (v/10)\nin helper [] h"], "bad": ["let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i )"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = match l with\n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10)\nin helper [] h"], "bad": ["let rec mulByDigit i l = match l with\n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper (v mod 10)::acc (v/10)\nin helper [] h"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n[] -> []\n| h::t -> [h]\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )"], "bad": ["let rec mulByDigit i l = match (List.rev l) with\n[] -> int list []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n[] -> int list []\n| h::t -> bigAdd h (adder t)\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )", "let rec mulByDigit i l = match (List.rev l) with\n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n[] -> []\n| h::t -> bigAdd h (adder t)\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )", "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n[] -> []\n| h::t -> h\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )"], "message": ["Error: Unbound value int\n", "Error: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n", "Error: This expression has type int list\n       but an expression was expected of type int list list\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n| [] -> []\n| h::t -> ( bigAdd h (adder t) )\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )", "let _ = mulByDigit 9 [9;9;9;9]"], "bad": ["let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n| [] -> []\n| h::t -> [( bigAdd h (adder t) )]\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (x(a)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let pipe fs = \nlet f a x = f(x(a)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun -> (x(a)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun a x -> (x(a)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int\n       Type int is not compatible with type int -> int \n", "Error: Syntax error\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) \nin ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: [])"], "bad": ["let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nmatch ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with\n[] -> []\n| x::y -> let rec adder w = match w with\n| [] -> []\n| a::b -> ( bigAdd a (adder b) )\nin \nadder (h::t)"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) \nin\nmatch ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with\n| [] -> []\n| x::y -> let rec adder w = match w with\n| [] -> []\n| a::b -> ( bigAdd a (adder b) )\nin \n[adder (x::y)]"], "bad": ["let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) \nin\nmatch ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with\n| [] -> []\n| x::y -> let rec adder w = match w with\n| [] -> []\n| a::b -> ( bigAdd a (adder b) )\nin \nadder (h::t)", "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) \nin\nmatch ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with\n| [] -> []\n| x::y -> let rec adder w = match w with\n| [] -> []\n| a::b -> ( bigAdd a (adder b) )\nin \nadder (x::y)"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = \nmatch l with\n[] -> []\n| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []\nwith \n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen \nacc\nelse \nv mod 10 :: []\nin helper [] h"], "bad": ["let rec mulByDigit i l = \nmatch l with\n[] -> []\n| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []\nwith \n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen \nacc\nelse \nv mod 10\nin helper [] h"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin helper [] h", "let _ = mulByDigit 9 [1;2;3;4]"], "bad": ["let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> if v = 0\nthen\nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin helper [] h"], "message": ["Error: Unbound value v\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nlet rec helper acc v = \nif v = 0\nthen\nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin helper [] ([List.fold_left f base ((mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [])])", "let _ = mulByDigit 9 [1;2;3;4]"], "bad": ["let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nlet rec helper acc v = \nif v = 0\nthen\nacc\nelse\nhelper (v mod 10) :: acc (v/10)\nin helper [] ([List.fold_left f base ((mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [])])"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = match x with\n(k,v) -> ([k],v) in \nlet base = ([], [0]) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = match x with\n{k,v} -> ([k],v) in \nlet base = ([], [0]) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: Syntax error\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let somef i l = match (List.rev l) with\n| [] -> []\n| h::t ->\nlet rec helper acc v =  \nif v = 0\nthen \nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin bigAdd (mulByDigit i (List.rev (List.map (fun x -> x*10) t ) )) (helper [] (h*i))", "somef 90000 [9;9]"], "bad": ["let somef i l = match (List.rev l) with\n| [] -> []\n| h::t ->\nlet rec helper acc v =  \nif v = 0\nthen \nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin bigAdd (mulByDigit i (List.rev (List.map (fun x -> x*10) t ) )) (helper [] (h*i)) *", ")\n\nsomef 90000 [9;9]"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["[1;0] @ (clone 0 1)"], "bad": ["[1,0] @ clone 0 1", "[1,0] @ (clone 0 1)"], "message": ["Error: This expression has type int list\n       but an expression was expected of type (int * int) list\n       Type int is not compatible with type int * int \n", "Error: This expression has type int list\n       but an expression was expected of type (int * int) list\n       Type int is not compatible with type int * int \n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ((mulByDigit x l1) @ (clone 0 numZeroes)) (prevRes) )  in\nlet base = (1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = match a with\n(numZeroes, prevRes) -> (numZeroes+1, bigAdd ( (mulByDigit x l1) @ (clone 0 numZeroes) prevRes))", "let base = (1, []) in\nlet args = l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = match a with\n(numZeroes, prevRes) -> (numZeroes+1, bigAdd ( (mulByDigit x l1) @ (clone 0 numZeroes) prevRes)) in\nlet base = (1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = match a with\n(numZeroes, prevRes) -> (numZeroes+1, bigAdd ( ( (mulByDigit x l1) @ (clone 0 numZeroes) ) prevRes)) in\nlet base = (1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = match a with\n(numZeroes, prevRes) -> (numZeroes+1, bigAdd ( ( (mulByDigit x l1) @ (clone 0 numZeroes) ) (prevRes) )) in\nlet base = (1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: Syntax error\n", "Error: Unbound value l2\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( [i*x] @ (clone 0 numZeroes) ) (prevRes) ) in\nlet base = (0, []) in\nlet (_,res) = List.fold_left f base (List.rev l) in\nres"], "bad": ["let rec mulByDigit i l = \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd (i*x @ (clone 0 numZeroes)) (prevRes) ) in\nlet base = (0, []) in\nlet (_,res) = List.fold f base (List.rev l) in\nres", "let rec mulByDigit i l = \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( (i*x) @ (clone 0 numZeroes)) (prevRes) ) in\nlet base = (0, []) in\nlet (_,res) = List.fold f base (List.rev l) in\nres", "let rec mulByDigit i l = \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( [i*h] @ (clone 0 numZeroes) ) (prevRes) ) in\nlet base = (0, []) in\nlet (_,res) = List.fold f base (List.rev l) in\nres", "let rec mulByDigit i l = \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( [i*x] @ (clone 0 numZeroes) ) (prevRes) ) in\nlet base = (0, []) in\nlet (_,res) = List.fold f base (List.rev l) in\nres"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         'a list\n", "Error: Unbound value h\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value h\n", "Error: Unbound value List.fold\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value List.fold\n"], "problem": "mulByDigit"}
{"hw": "hw1", "fix": ["let digitalRoot n = (*failwith \"TBD\"*)\n\nlet rec loop x =\nsumList (digitsOfInt (abs n))", "let _ = digitalRoot 9876"], "bad": ["let digitalRoot n = (*failwith \"TBD\"*)\n\nlet rec loop x = function\nsumList digitsOfInt (abs x)", "let digitalRoot n = (*failwith \"TBD\"*)\n\nlet rec loop x = function\nsumList (digitsOfInt (abs x))", "let digitalRoot n = (*failwith \"TBD\"*)\n\nlet rec loop x = match n with\nsumList (digitsOfInt (abs x))"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "digitalRoot"}
{"hw": "hw1", "fix": ["let listReverse l = (*failwith \"TBD\"*)\nlet rec rev x l = match x with\n| [] -> x\n| h::t -> rev (h::x) t in\nrev[] l"], "bad": ["let listReverse l = (*failwith \"TBD\"*)\nlet rec rev x = match l with\n| [] -> x\n| h::t -> rev (h::x) t in\nrev[] l", "let listReverse l = (*failwith \"TBD\"*)\nlet rec rev x = match x with\n| [] -> x\n| h::t -> rev (h::x) t in\nrev[] l"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'b -> 'c\n", "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let listReverse l = (*failwith \"TBD\"*)\nlet rec rev x = function\n| [] -> x\n| h::t -> rev (h::x) t in\nrev[] l", "let _ = listReverse [1; 2; 3; 4]"], "bad": ["let listReverse l = (*failwith \"TBD\"*)\nlet rec rev x l = function\n| [] -> x\n| h::t -> rev (h::x) t in\nrev[] l"], "message": ["Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let digitalRoot n = (*failwith \"TBD\"*)\nlet x = n in\nlet rec loop x =\nif x < 10 then x\nelse loop( sumList (digitsOfInt ( abs x ) ) )", ";;"], "bad": ["let digitalRoot n = (*failwith \"TBD\"*)\nlet x = n in\nlet rec loop x =\nif x < 10 then x\nelse loop( sumList (digitsOfInt ( abs x ) ) )"], "message": ["Error: Syntax error\n"], "problem": "digitalRoot"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = (*failwith \"to be written\" in*)\nif List.mem h seen then\nseen\nelse \nh::seen\nin (*list of seen elts*)\nlet rest' = (*failwith \"to be written\" in *)\nt\nin (*orig list*)\nhelper (seen',rest')\n\nin\nList.rev (helper ([],l))"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = (*failwith \"to be written\" in*)\n\nin (*list of seen elts*)\nlet rest' = (*failwith \"to be written\" in *)\nt\nin (*orig list*)\nif List.mem h seen then\nhelper (seen',rest')\nelse \nh::seen'\nhelper (seen', rest')\n\nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(*let seen' = failwith \"to be written\" in*)\n\n(*in list of seen elts*)\nlet rest' = (*failwith \"to be written\" in *)\nt\nin (*orig list*)\nif List.mem h seen then\nhelper (seen',rest')\nelse \nh::seen'\nhelper (seen', rest')\n\nin\nList.rev (helper ([],l))"], "message": ["Error: Syntax error\n", "Error: Unbound value seen'\nHint: Did you mean seen?\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n|[] -> d\n|(ki,vi)::l -> if k = ki then vi\nelse assoc (d,k,l)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = (*failwith \"to be written\" in*)\nif List.mem h seen then\nseen\nelse \nh::seen\nin (*list of seen elts*)\nlet rest' = (*failwith \"to be written\" in *)\nt\nin (*orig list*)\nhelper (seen',rest')\n\nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet c' = f b in\nif c' = b \nthen c'\nelse wwhile (f, c')", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "bad": ["let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "message": ["Error: This expression has type int -> int * bool\n       but an expression was expected of type int -> int\n       Type int * bool is not compatible with type int \n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet c' = f b in\n(*let b' = in*)\nif c' = b \nthen c'\nelse wwhile (f, c')"], "bad": ["let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet c' = f b in\nlet b' = b in\nif c' = b \nthen c'\nelse wwhile (c', b')"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a -> 'a\n       The type variable 'a occurs inside 'a -> 'a\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper = f b in\nmatch helper with\n| (x, y) -> if y \nthen wwhile (f, x)\nelse x"], "bad": ["let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper f b = \n(b', bool c') in\nmatch c' with\n| false -> b'\n| true -> wwhile (f, b')", "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper f b = \n(b', bool c') in\nmatch helper with\n| (int, bool) -> if c' = false then b'\nelse wwhile (f, b')", "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper f b = \n(int b', bool c') in\nmatch helper with\n| false -> if c' = false then b'\n| true -> wwhile (f, b')", "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet b' f b = \n(b', bool c') in\nmatch helper with\n| false -> if c' = false then b'\n| true -> wwhile (f, b')", "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet b' = f b in\nlet p = (b', bool c') in\nmatch c' with\n| false -> b'\n| true  -> wwhile (f, b')", "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet f b = (b', c') in\nmatch c' with\n| false -> b'\n| true  -> wwhile (f, b')", "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet b' = int in\nlet c' = bool in\nlet f b = (b', c') in\nmatch c' with\n| false -> b'\n| true  -> wwhile (f, b')"], "message": ["Error: Unbound value b'\n", "Error: Unbound value b'\n", "Error: Unbound value int\n", "Error: Unbound value b'\n", "Error: Unbound value bool\n", "Error: Unbound value b'\n", "Error: Unbound value int\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((*(failwith \"to be written\")*)\nlet g b =\nlet self = f b in\nmatch self with\n| b -> (self, true)\n| _ -> (self, false)\nin g\n,b)"], "bad": ["let fixpoint (f,b) = wwhile ((*(failwith \"to be written\")*)\nlet g b =\nlet self = f b in\nmatch  with\n| b -> (self, true)\n| _ -> (self, false)\nin g\n,b)"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "bad": ["let fixpoint (f,b) = wwhile ((*(failwith \"to be written\")*)\nlet g =\nlet self = f b in\nmatch self with\n| b -> (self, true)\n| _ -> (self, false)\nin g\n,b)"], "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper = f b in\nmatch helper with\n| (x, y) -> if y = false\nthen x\nelse wwhile (f, x)", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) = wwhile ((*(failwith \"to be written\")*)\nlet g b =\nlet self = f b in\nmatch b with\n| self -> (self, false)\n| _ -> (self, true)\nin g\n,b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)", "let _ = fixpoint (collatz, 3)"], "message": ["Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "bad": ["let fixpoint (f,b) = wwhile ((*(failwith \"to be written\")*)\nlet g b = \nlet helper = f b in\nmatch helper with\n| b -> if f = b\nthen (f, false)\nelse (f, true)\nin g\n,b)", "let fixpoint (f,b) = wwhile ((*(failwith \"to be written\")*)\nlet g b = \nlet helper = f b in\nmatch helper with\n| f-> if f = b\nthen (f, false)\nelse (f, true)\nin g\n,b)"], "message": ["Error: This expression has type 'a -> ('a -> 'a * 'b) * bool\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a -> 'a * 'b\n", "Error: This expression has type 'a but an expression was expected of type\n         'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = (*failwith \"to be written\"*)\nmatch e with\nVarX           -> x\n| VarY           -> y\n| Sine e         -> sin(pi*. eval (e,x,y))\n| Cosine e       -> cos(pi*. eval (e,x,y))\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\n(*Thresh = e1<e2?e3:e4*)\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)"], "bad": ["let _ = eval (sampleExpr,0.5,0.2)", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)"], "message": ["Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n", "Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")"], "bad": ["let _ = eval (sampleExpr1,0.5,0.2)"], "message": ["Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n|[] -> d\n|(ki,vi)::l -> if k = ki then vi\nelse assoc (d,k,l)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = (*failwith \"to be written\" in*)\nif List.mem h seen then\nseen\nelse \nh::seen\nin (*list of seen elts*)\nlet rest' = (*failwith \"to be written\" in *)\nt\nin (*orig list*)\nhelper (seen',rest')\n\nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper = f b in\nmatch helper with\n| (x, y) -> if y = false\nthen x\nelse wwhile (f, x)", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) = wwhile ((*(failwith \"to be written\")*)\nlet g b = \nlet helper = f b in\nmatch helper with\n| f-> if f = b\nthen (f, false)\nelse (f, true)\nin g\n,b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)", "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "let rec exprToString e = (*failwith \"to be written\"*)\nmatch e with\nVarX           -> \"x\"\n| VarY           -> \"y\"\n| Sine e         -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e       -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1,e2)-> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")\" ^ \"/\" ^ \"2\" ^\")\"\n| Times (e1,e2)  -> exprToString e1 ^ \"*\" ^ exprToString e2\n(*Thresh = e1<e2?e3:e4*)\n| Thresh (e1,e2,e3,e4)-> \"(\" ^exprToString e1^ \"<\" ^exprToString e2^ \"?\" ^exprToString e3^ \":\" ^exprToString e4^ \")\"", "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "let _ = exprToString sampleExpr1", "let buildX()                       = VarX", "let buildY()                       = VarY", "let buildSine(e)                   = Sine(e)", "let buildCosine(e)                 = Cosine(e)", "let buildAverage(e1,e2)            = Average(e1,e2)", "let buildTimes(e1,e2)              = Times(e1,e2)", "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "let pi = 4.0 *. atan 1.0", "let rec eval (e,x,y) = (*failwith \"to be written\"*)\nmatch e with\nVarX           -> x\n| VarY           -> y\n| Sine e         -> sin(pi*. eval (e,x,y))\n| Cosine e       -> cos(pi*. eval (e,x,y))\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\n(*Thresh = e1<e2?e3:e4*)\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr,0.5,0.2)", "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage(buildTimes (buildY(),buildY()),buildCosine (buildX())))),buildCosine (buildTimes (buildSine (buildCosine(buildY())),buildAverage (buildSine (buildX()), buildTimes(buildX(),buildX()))))))),buildY())))", "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "let rec build (rand, depth) = (*failwith \"to be implemented\"*)\nlet rng = rand(0,9) in\nif depth >= 0 then \nmatch rand (0,2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \nmatch rng with\n| 0 -> build(rand,depth-1)\n| 1 -> build(rand,depth-1)\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\n| 7 -> buildExpwn(build(rand, depth-1))\n| 8 -> buildLogTen(build(rand, depth-1))"], "bad": ["let rec build (rand, depth) = (*failwith \"to be implemented\"*)\nlet rng = rand(0,9) in\nif depth >= 0 then \nmatch rand 0 2 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \nmatch rng with\n| 0 -> build(rand,depth-1)\n| 1 -> build(rand,depth-1)\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\n| 7 -> buildExpwn(build(rand, depth-1))\n| 8 -> buildLogTen(build(rand, depth-1))", "let rec build (rand, depth) = (*failwith \"to be implemented\"*)\nlet rng = rand(0,9) in\nif depth >= 0 then \nmatch rand (0,2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \nmatch rng with\n| 0 -> build(rand,depth-1)\n| 1 -> build(rand,depth-1)\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\n| 7 -> buildExpwn(build(rand, depth-1))\n| 8 -> buildLogTen(build(rand, depth-1))"], "message": ["Error: Unbound value emitGrayscale\n", "Error: This expression has type int but an expression was expected of type\n         int * int\n"], "problem": "build"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)@[n mod 10]"], "bad": ["let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| digitsOfInt(n/10)::(n mod 10)", "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> [0]\n| digitsOfInt(n/10)::(n mod 10)", "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| digitsOfInt (n/10)::(n mod 10)", "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| digitsOfInt n/10::(n mod 10)", "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| digitsOfInt (n/10)::(n mod 10)", "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| _ -> digitsOfInt (n/10)::(n mod 10)", "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)::(n mod 10)", "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)@(n mod 10)"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n = 0 then [0]\nelse let rec getDigits n = match n with\n| 0 -> []\n| _ -> myAppend (getDigits (n/10)) (n mod 10)", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663"], "bad": ["let rec digitsOfInt n = \nif n = 0 then [0]\nelse let rec getDigits n = match n with\n| 0 -> []\n| _ -> myAppend (getDigits (n/10) (n mod 10))"], "message": ["Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n = 0 then [0]\nelse let rec getDigits n = \nif n > 0 then myAppend (getDigits (n/10)) (n mod 10)\nelse []", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663"], "bad": ["let rec digitsOfInt n = \nif n = 0 then [0]\nelse let rec getDigits m = match m with\n| 0 -> []\n| _ -> myAppend (getDigits (m/10)) (m mod 10)"], "message": ["Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = match n with\n| 0 -> 1\n| _ -> 1 + additivePersistence (sumList digits n)", "let _ = additivePersistence 9876"], "bad": ["let rec additivePersistence n = match n with\n| 0 -> 1\n| _ -> 1 + additivePersistence sumList digits n"], "message": ["Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec listCompare l k = \nif (List.hd l) = [] && (List.hd k) = [] then true\nelse if (List.hd l) != (List.hd k) then false\nelse listCompare (List.tl l) (List.tl k)"], "bad": ["let rec listCompare l k = \nif List.hd l = [] && List.hd k = [] then true\nelse if List.hd l != List.hd k then false\nelse listCompare List.tl l List.tl k"], "message": ["Error: This function has type 'a list list -> 'a list list -> bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]", "let rec digitsOfInt n = \nif n = 0 then [0]\nelse getDigits n", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let digits n = digitsOfInt (abs n)", "let rec additivePersistence n = \nif (n/10) = 0 then 0\nelse 1 + additivePersistence (sumList (digits n))", "let _ = additivePersistence 9876", "let rec digitalRoot n = \nif (n/10) = 0 then n\nelse digitalRoot (sumList (digits n))", "let _ = digitalRoot 9876", "let rec listReverse l = match l with\n| [] -> []\n| h::t -> myAppend (listReverse t) h", "let _ = listReverse [1; 2; 3; 4]", "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]", "let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0", "let palindrome w = (explode w) = (listReverse (explode w))", "type test = unit -> string", "let key        = \"\"", "let prefix130  = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")", "let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max"], "bad": ["let palindrome w = listCompare (explode w) (listReverse (explode w))"], "message": ["Error: This expression has type char list\n       but an expression was expected of type 'a list list\n       Type char is not compatible with type 'a list \n"], "problem": "palindrome"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = \nlet helper (b', c') = \nif c' then wwhile (f, b')\nelse b'\nin f b"], "bad": ["let rec wwhile (f,b) = \nlet helper (b', c') = \nif c' then wwhile (f, b')\nelse b'\nin f b'"], "message": ["Error: Unbound value b'\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = match f b with\n| (b', c') -> if c' then wwhile (f, b')\nelse b'"], "bad": ["let rec wwhile (f,b) = \nlet (b', c') = \nif c' then wwhile (f, b')\nelse b'\nin f b", "let rec wwhile (f,b) = \nif c' then wwhile (f, b')\nelse b'\nin f b(b', c')"], "message": ["Error: Unbound value c'\n", "Error: Unbound value c'\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((fun f' -> (f b, b != (f b))),b)"], "bad": ["let fixpoint (f,b) = wwhile ((let f' = (f b, b != (f b))),b)", "let fixpoint (f,b) = wwhile ((let fun f' = (f b, b != (f b))),b)"], "message": ["Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["et _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr,0.5,0.2)"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e' -> sin(pi *. (eval (e'(e', x, y))))\n| Average (e1, e2) -> (((eval (e1, x, y)) +. (eval (e2, x, y)))/2)\n| Times (e1, e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y)))\n| Thresh (e1, e2, e3, e4) -> (if ((eval (e1, x, y))<(eval (e2, x, y))) then (eval (e3, x, y)) else (eval (e4, x, y)))", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e' -> sin(pi *. (eval (e', x, y)))\n| Average (e1, e2) -> (((eval (e1, x, y)) +. (eval (e2, x, y)))/2)\n| Times (e1, e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y)))\n| Thresh (e1, e2, e3, e4) -> (if ((eval (e1, x, y))<(eval (e2, x, y))) then (eval (e3, x, y)) else (eval (e4, x, y)))", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e' -> sin(pi *. (eval (e', x, y)))\n| Average (e1, e2) -> (((eval (e1, x, y)) +. (eval (e2, x, y)))/.(2.0))\n| Times (e1, e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y)))\n| Thresh (e1, e2, e3, e4) -> (if ((eval (e1, x, y))<(eval (e2, x, y))) then (eval (e3, x, y)) else (eval (e4, x, y)))"], "message": ["Error: Syntax error\n", "Error: This expression has type expr\n       This is not a function; it cannot be applied.\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "eval"}
{"hw": "hw3", "fix": ["let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\""], "bad": ["let stringOfList f l = \"[\" ^ (List.map f \"; \" l) ^ \"]\"", "let stringOfList f l = \"[\" ^ (List.map f (\"; \" l)) ^ \"]\"", "let stringOfList f l = \"[\" ^ (List.map (f \"; \") l) ^ \"]\""], "message": ["Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = (fun y -> x (a y)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n = \nif n < 1 then []\nelse x::(clone x (n-1))", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nif (len1 < len2) then ((List.append (clone 0 (len2-len1)) l1), l2)\nelse (l1, (List.append (clone 0 (len1-len2)) l2))"], "bad": ["let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\n(len1 < len2) ? ((List.append (clone 0 (len2-len1)) l1), l2) : (l1, (List.append (clone 0 (len1-len2)) l2))", "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\n(len1 < len2) ? ((List.append (clone 0 (len2-len1)) l1), l2) : (l1, (List.append (clone 0 (len1-len2)) l2))"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = (fun y -> x (a y)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n = \nif n < 1 then []\nelse x::(clone x (n-1))", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\n((List.append (clone 0 (len2-len1)) l1), (List.append (clone 0 (len1-len2)) l2))", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let rec removeZero l = match l with\n| [] -> []\n| h::t -> \nif h = 0 then removeZero t\nelse h::t", "let _ = removeZero [0;0;0;1;0;0;2]", "let _ = removeZero [9;9]", "let _ = removeZero [0;0;0;0]", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (i, l) -> match x with\n| (x1, x2) -> (((x1+x2+i)/10), (((x1+x2+i) mod 10)::l))\nin\nlet base = (0, []) in\nlet args = (List.rev (List.combine (0::l1) (0::l2))) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]", "let rec mulByDigit i l = \nif i = 0 then l\nelse mulByDigit ((i-1), (bigAdd l l))"], "bad": ["let rec mulByDigit i l = \nlet (i', l') = (0, (List.rev l)) in\nmatch l' with\n| [] -> []\n| h::t -> (((h*i)+i') mod 10)::(mulByDigit ((((h*i)+i')/10), t))\nin\nList.rev (mulByDigit i l)"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = bigAdd l (mulByDigit (i-1) l)"], "bad": ["let rec mulByDigit i l = \nif i > 0 then mulByDigit ((i-1), (bigAdd l l))\nelse l"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = match i with\n| 0 -> l\n| _ -> bigAdd l (mulByDigit (i-1) l)"], "bad": ["let rec mulByDigit i l = if i > 0 then bigAdd l (mulByDigit (i-1) l)"], "message": ["Error: This expression has type int list\n       but an expression was expected of type unit\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x =  match a with\n| (i, l) -> match x with\n| [] -> (i, [0])\n| h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i))) \nin\nlet base = (0, []) in\nlet args =  List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x =  match a with\n| (i, l) -> match x with\n| [] -> []\n| h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i) \nin\nlet base = (0, []) in\nlet args =  List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x =  match a with\n| (i, l) -> match x with\n| [] -> []\n| h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i)) \nin\nlet base = (0, []) in\nlet args =  List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x =  match a with\n| (i, l) -> match x with\n| [] -> []\n| h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i))) \nin\nlet base = (0, []) in\nlet args =  List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Characters 109-110:\n  | h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i) \n                             ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Characters 92-93:\n  | h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i)) \n            ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x =  match a with\n| (i, l) -> ((i+1), bigAdd l (List.append (mulByDigit x l1) (clone 0 i))) \nin\nlet base = (0, []) in\nlet args =  List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let _ = bigMul [9;9;9;9] [9;9;9;9]", "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "bigMul"}
{"hw": "hw1", "fix": ["let _ = additivePersistence 0"], "bad": ["let _ additivePersistence 0", "let _ additivePersistence 10"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let _ = listReverse [(1,2); (3,4)]"], "bad": ["let _ = listReverse [(a,b); (c,d)];\n\n\n\n(* explode : string -> char list \n* (explode s) is the list of characters in the string s in the order in \n*   which they appear\n* e.g.  (explode \"Hello\") is ['H';'e';'l';'l';'o']\n*)\nlet explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0", "let _ = listReverse [(a,b); (c,d)]"], "message": ["Error: Syntax error\n", "Error: Unbound value a\n"], "problem": "listReverse"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "bad": ["wwhile (f, 3)", "let fixpoint (f,b) =\nlet b' = f b in\nif b' = b\nthen b\nelse fixpoint (f, b')", "let rec fixpoint (f,b) =\nlet b' = f b in\nif b' = b\nthen b\nelse fixpoint (f, b')"], "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["g 0.739085"], "bad": ["g 0"], "message": ["Error: Unbound value fixpoint\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "let _ = exprToString sampleExpr1"], "bad": ["let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sin e'    -> \"sin (pi*\"^expr e'^\")\"\n| Cos e'    -> \"cos (pi*\"^expr e'^\")\"\n| Average e1, e2  -> \"((\"^esprToString e1^\" + \"^exprToString e2^\"/2)\"\n| Times e1, e2    -> (exprToString e1)^\" * \"^exprToString e2\n| Thresh e1, e2, e3, e4    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\"", "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e'    -> \"sin (pi*\"^expr e'^\")\"\n| Cosine e'    -> \"cos (pi*\"^expr e'^\")\"\n| Average e1, e2  -> \"((\"^esprToString e1^\" + \"^exprToString e2^\"/2)\"\n| Times e1, e2    -> (exprToString e1)^\" * \"^exprToString e2\n| Thresh e1, e2, e3, e4    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\"", "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e'    -> \"sin (pi*\"^expr e'^\")\"\n| Cosine e'    -> \"cos (pi*\"^expr e'^\")\"\n| Average (e1, e2)  -> \"((\"^esprToString e1^\" + \"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\" * \"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\"", "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e'    -> \"sin (pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos (pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^esprToString e1^\" + \"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\" * \"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\"", "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e'    -> \"sin (pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos (pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\" + \"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\" * \"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\""], "message": ["Error: Unbound constructor Varx\nHint: Did you mean VarX or VarY?\n", "Error: This variant pattern is expected to have type expr\n       The constructor Sin does not belong to type expr\nHint: Did you mean Sine?\n", "Error: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type expr\n", "Error: Unbound value expr\nHint: Did you mean exp?\n", "Error: Unbound value esprToString\nHint: Did you mean exprToString?\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let _ = buildX()"], "bad": ["let _ = buildSine(0.5)", "let _ = buildSine(Sine 0.5)", "let _ = buildSine(Sine VarX)"], "message": ["Error: Syntax error: operator expected.\n", "Error: This expression has type float but an expression was expected of type\n         expr\n", "Error: This expression has type float but an expression was expected of type\n         expr\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let _ = eval (Average(VarX,VarY), 0.5, 0.5)"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (eval x'+ eval y')/2", "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (eval x' y + eval x y')/2", "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (eval VarX x' y + eval VarY x y')/2", "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (eval (VarX, x', y) + eval (VarY, x, y'))/2", "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (x'+y')/2", "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (x+y)/2"], "message": ["Error: This expression has type expr but an expression was expected of type\n         int\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "Error: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b) * ('a -> 'b)\n", "Error: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)\n", "Error: This expression has type expr but an expression was expected of type\n         int\n", "Error: This expression has type expr but an expression was expected of type\n         int\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval (Average(VarX,VarY), 0.5, 0.5)"], "bad": ["let rec eval (e,x,y) = match e with\n| Average (x', y') -> (x+y)/2"], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval (Average(VarX,VarY), 0.5, 0.5)"], "bad": ["let rec eval (e,x,y) = match e with\n| Average (x', y') -> (x +. y)/2", "let rec eval (e,x,y) = match e with\n| Average (x', y') -> (x .+ y)/2", "let rec eval (e,x,y) = match e with\n| Average (x', y') -> (x +. y)/2", "let rec eval (e,x,y) = match e with\n| Average (x', y') -> (x +. y) ./ 2", "let rec eval (e,x,y) = match e with\n| Average (x', y') -> (x +. y) /. 2", "let rec eval (e,x,y) = match e with\n| Average (x', y') -> (x +. y) /. 2.0"], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: Syntax error: operator expected.\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval (Sine(VarX, VarY), 0.5,0.5)"], "bad": ["let rec eval (e,x,y) = match e with\n| Sine e'\t\t-> sin (pi *. eval(e'))\n| Cosine e'\t\t-> cos (pi *. eval(e'))\n| Average (x', y')      -> (x +. y) /. 2.0\n| Times (x', y')\t-> x *. y", "let rec eval (e,x,y) = match e with\n| Sine e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (x', y')      -> (x +. y) /. 2.0\n| Times (x', y')\t-> x *. y"], "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'b\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'b\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval (Sine(Average(VarX,VarY)), 1.0, 1.0)"], "bad": ["let _ = eval (Sine(Average(VarX,VarY)), 0.5, 0.5)"], "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (x', y')      -> (x +. y) /. 2.0\n| Times   (x', y')\t-> x *. y"], "bad": ["let _ = eval (Cosine(Average(VarX,VarY)), 0.0, 0.0)"], "message": ["Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval (Thresh(VarX,VarY,Sine(VarY),Cosine(VarX)), 1.0, 2.0)"], "bad": ["let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cos(VarY), 1.0, 2.0))", "let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cos(VarY)), 1.0, 2.0)", "let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cosine(VarY)), 1.0, 2.0)"], "message": ["Characters 13-14:\n  let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cos(VarY), 1.0, 2.0);;\n               ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: The constructor Thresh expects 4 argument(s),\n       but is applied here to 6 argument(s)\n", "Error: This variant expression is expected to have type expr\n       The constructor Cos does not belong to type expr\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cosine(VarX)), 0.5, 1.0)", "let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cosine(VarX)), 1.0, 0.5)"], "bad": [")", "let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cosine(VarX)), 1.0, 0.5)"], "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "Error: Syntax error\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")"], "bad": ["let _ = eval (sampleExpr1,0.5,0.2)"], "message": ["Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval (Cosine(Average),0.5,0.2)"], "bad": ["let _ = eval (Sine(VarX),0.5,0.0)"], "message": ["Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let trand = makeRand(10,39)"], "bad": ["let trand = makeRand(10,39)"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let x = trand(1,4)"], "bad": ["let x = trand(1,4)"], "message": ["Error: Unbound value rand\nHint: Did you mean land or trand?\nError: Unbound value rand\nHint: Did you mean land?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value rand\nHint: Did you mean land or trand?\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let _ = doRandomGray(2,12,12321)"], "bad": ["let _ = doRandomGray(2,12,45)"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let _ = doRandomColor(8, -8168564, 9342315)"], "bad": ["let _ = doRandomColor(8, -81685634, 9342315)"], "message": ["Error: This expression has type float but an expression was expected of type\n         int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type float but an expression was expected of type\n         int\n"], "problem": "???"}
{"hw": "hw2", "fix": ["acos 1.0"], "bad": ["tan 1.0"], "message": ["Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "???"}
{"hw": "hw2", "fix": ["exp 1.0"], "bad": ["acos (-1.0)"], "message": ["Error: This expression has type float -> float\n       but an expression was expected of type int\n"], "problem": "???"}
{"hw": "hw2", "fix": ["log (-.5)"], "bad": ["log (-1.0)"], "message": ["Error: This expression has type float -> float\n       but an expression was expected of type int\n"], "problem": "???"}
{"hw": "hw2", "fix": ["log10 (1.0)"], "bad": ["log (-0.5)"], "message": ["Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "???"}
{"hw": "hw2", "fix": ["log10 (-0.5)"], "bad": ["log10 (0.5)"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let temp1 = FunckyCube(SquareRoot(VarY),SquareRoot(VarX),SquareRoot(VarY))", "let _ = exprToString temp1"], "bad": ["let _ = exprToString FunckyCube(SquareRoot(VarY),SquareRoot(VarX),SquareRoot(VarY))"], "message": ["Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "let _ = exprToString sampleExpr1", "let temp1 = FunckyRoot(SquareRoot(VarY),SquareRoot(VarX),SquareRoot(VarY))"], "bad": ["let rec exprToString e = match e with\n| VarX         -> \"x\"\n| VarY         -> \"y\"\n| Sine e'      -> \"sin(pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos(pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\"+\"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\"*\"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^\nexprToString e3^\":\"^exprToString e4^\")\"\n| SquareRoot e'\t\t  -> \"sqrt(\"^exprToString e'^\")\"\n| FunckyRoot (e1,e2,e3)   -> \n\"sqrt(sqrt(\"^exprToString e1^\")+sqrt(\"^exprToString e2^\")+sqrt(\"^exprToString e3^\"))\""], "message": ["Error: This variant pattern is expected to have type expr\n       The constructor FunckyCube does not belong to type expr\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,7) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareRoot(build(rand, depth-1))"], "bad": ["let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,8) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareRoot(build(rand, depth-1))"], "message": ["Error: This expression has type expr/4327\n       but an expression was expected of type expr/3809\nError: This expression has type expr/4495\n       but an expression was expected of type expr/4485\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type expr/4327\n       but an expression was expected of type expr/3809\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,7) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareRoot(build(rand, depth-1))\n| 8 -> buildFunckySine(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"], "bad": ["let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,7) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareRoot(build(rand, depth-1))\n| 8 -> buildFunckySine(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"], "message": ["Error: Syntax error\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "let _ = doRandomGray(9,1000,-12)", "let _ = doRandomGray(10,-1000,-2000)", "let _ = doRandomGray(12,-1000,5768713)", "let _ = doRandomColor(8, 245234, 471265)", "let _ = doRandomColor(11, -1021271, 65601173)", "let _ = doRandomColor(10, 934541, -34112173)", "let g1 () = (9,1000,-12)", "let g2 () = (10,-1000,-2000)", "let g3 () = (12,-1000,5768713)", "let c1 () = (8, 245234, 471265)", "let c2 () = (11, -1021271, 65601173)", "let c3 () = (10, 934541, -34112173)"], "bad": ["let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,7) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareCosine(build(rand, depth-1))"], "message": ["Error: This expression has type expr/6967\n       but an expression was expected of type expr/6204\nError: This expression has type expr/7094\n       but an expression was expected of type expr/7085\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type expr/6967\n       but an expression was expected of type expr/6204\n"], "problem": "build"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a ** x in\nlet base = 0.0 in\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = \nmatch x with \n| []    -> a\n| h::t  -> f (a + h**2) t in\nlet base = 0 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = a ** x in\nlet base = 0 in\nList.fold_left f base xs"], "message": ["Error: Unbound value f\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let _ = sqsum [(-1);(-2)]"], "bad": ["let _ = sqsum [(-1);(-2)e]"], "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["(|>) 0 (fun x -> x + 1)"], "bad": ["|> 0 (fun x -> x + 1)"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let foldl f b xs =\nlet rec helper res = function\n| []   -> res\n| h::t -> helper (f res h) t\nin helper b xs"], "bad": ["let foldl f b xs =\nlet rec helper res = function\n| []   -> res\n| h::t -> helper (f res h) t"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let foo xs = \nmatch xs with\n| [] -> fun x -> x\n| h::t -> h"], "bad": ["foo [(fun x -> x+1); (fun y -> y-1)]", "let foo xs = \nmatch xs with\n| [] -> xs\n| h::t -> h"], "message": ["Error: This expression should not be a function, the expected type is\n'a list\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = \nmatch x with \n| a   -> fun x -> x\n| h::t -> h\nin\n\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = \nmatch x with \n| a   -> fun x -> x\n| h::t -> h\nin\n\nlet base = [] in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'b -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = \nmatch x with \n| []   -> a\n| h::t -> h\nin\n\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = \nmatch x with \n| []   -> b\n| h::t -> h\nin\n\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "message": ["Error: Unbound value b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let pipe fs = \nlet f a x = x a in\nlet base = 'a in\nList.fold_left f base fs"], "message": ["Error: This expression should not be a function, the expected type is\n('a -> 'a) list\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = \nmatch x with \n| [] -> a \n| h::t -> t\nin\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'b list\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let temp = List.fold_left (fun x y-> x+1) 0 []"], "bad": ["let temp = List.fold_left (fun x -> x + 1) 0 []"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> int\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let temp = List.fold_left (fun x y-> y x) 1 [(fun y -> y+1)]"], "bad": ["let temp = List.fold_left (fun x y-> x+y) 1 [(fun y -> y+1)]"], "message": ["Error: This expression should not be a function, the expected type is\nint\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun xs -> x (a xs) in  (* a fun that takes xs as input\nfor fun 'a' and take that output\nas input for fun 'x' *)\nlet base = (fun b -> b) in (* a fun that takes 'b as input, and \nreturn 'b as output *)\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun xs -> x (a xs) in  (* a fun that takes xs as input\nfor fun 'a' and take that output\nas input for fun 'x' *)\nlet base = (fun 'b -> b') in (* a fun that takes 'b as input, and \nreturn 'b as output *)\nList.fold_left f base fs"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let _ = stringOfList (fun x -> string_of_int (x+1)) [1;2;3;4]"], "bad": ["let _ = stringOfList (fun x -> x+1) [1;2;3;4]", "let _ = stringOfList (fun x -> int_of_string x+1) [1;2;3;4]", "let _ = stringOfList (fun x -> string_of_int x+1) [1;2;3;4]"], "message": ["Error: This expression has type int but an expression was expected of type\n         string\n", "Error: This expression has type int but an expression was expected of type\n         string\n", "Error: This expression has type string but an expression was expected of type\n         int\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let rec clone x n = \nlet f a x = List.append a x in\nlet base = [] in\nList.fold_right f x base"], "bad": ["let rec clone x n = \nlet f a x = List.append a x in\nlet base = [] in\nList.fold_right f x b"], "message": ["Error: Unbound value b\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let rec clone x n = \nlet aux acc n = \nif n  <= 0\nthen acc\nelse clone (List.append x acc) (n-1)\nin\naux [] n"], "bad": ["let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list -> int -> 'a list\n       but an expression was expected of type 'b list\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let rec clone x n = \nlet aux acc n = \nif n  <= 0\nthen acc\nelse clone (List.append acc x) (n-1)\nin\naux [] n"], "bad": ["let _ = clone 3 5", "let _ = clone \"foo\" 2"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let rec clone x n = \nlet aux acc n = \nif n  <= 0\nthen acc\nelse clone (List.append x acc ) (n-1)\nin\naux [] n"], "bad": ["let rec clone x n = \nlet aux acc n = \nif n  <= 0\nthen acc\nelse clone (List.append [x] acc ) (n-1)\nin\naux [] n"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["List.append [\"a\"] []"], "bad": ["List.append [a] []"], "message": ["Error: Unbound value a\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let rec clone x n = \nlet rec aux acc n = \nif n  <= 0\nthen acc\nelse aux (List.append [x] acc ) (n-1)\nin\naux [] n"], "bad": ["let rec clone x n = \nlet aux acc n = \nif n  <= 0\nthen acc\nelse clone (List.append [x] acc ) (n-1)\nin\naux [] n", "let rec clone x n = \nlet aux acc n = \nif n  <= 0\nthen acc\nelse aux (List.append [x] acc ) (n-1)\nin\naux [] n"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: Unbound value aux\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let _ = clone 2 (-1)"], "bad": ["let _ = clone 2 -1"], "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nif l1 < l2\nthen ((List.append (clone 0 (len2-len1)) l1), l2)\nelse (l1, (List.append (clone 0 (len1-len2)) l2))"], "bad": ["let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nif l1 < l2\nthen ((List.append (clone 0 (len2-len1)) l1), l2)\nelse (l1, (List.append (clone 0 (len1-len2) l2)))"], "message": ["Error: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let _ = clone 4 (-12)"], "bad": ["let _ = List.append((clone 0 3) [1;2;3])"], "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let _ =  List.length [9;9]"], "bad": ["let _ len1 = List.length [9;9]"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let (x,y,z) = p"], "bad": ["let p = (1,\"john\", 0.1)"], "message": ["Error: Unbound value padZero\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let _ = List.rev (List.combine [0;0;9;9] [1;0;0;2])"], "bad": ["let _ = List.combine [0;0;9;9] [1;0;0;2]"], "message": ["Error: Unbound value bigAdd\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let _ = 11 mod 10"], "bad": ["let _ = 11/ 10"], "message": ["Error: Unbound value bigAdd\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let _ = foo [] [1;2;3;4;5] [1;0;1;0]"], "bad": ["let rec foo acc t1 t2 = \nmatch t2 with\n| [] -> acc\n| h::t -> foo (List.append [(t1,h)] acc) t", "let _ = foo [1;2;3;4;5] [1;0;1;0]", "let rec foo acc t1 t2 = \nmatch t2 with\n| [] -> acc\n| h::t -> foo (List.append [(t1,h)] acc) t", "let _ = foo [] [1;2;3;4;5] [1;0;1;0]", "let rec foo acc t1 t2 = \nmatch t2 with\n| [] -> acc\n| h::t -> foo (List.append [(t1,h)] acc) t1 t"], "message": ["Error: Syntax error\n", "Error: This expression has type 'a list -> ('a list * 'a) list\n       but an expression was expected of type ('a list * 'a) list\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'a\n", "Error: This expression has type 'a list -> ('a list * 'a) list\n       but an expression was expected of type ('a list * 'a) list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b -> 'c\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let rec removeZero l = \nmatch l with\n| []   -> []\n| h::t ->\nif h == 0\nthen removeZero t\nelse l", "let _ = removeZero [0;0;0;1;0;0;2]", "let _ = removeZero [9;9]", "let _ = removeZero [0;0;0;0]", "let _ = 11/ 10", "let _ = 11 mod 10", "let _ = 10 mod 10", "let _ = List.rev (List.combine [0;0;9;9] [1;0;0;2])", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (cin, l) = a in\nlet result   = n1+n2+cin in\nlet cout     = result / 10 in\nlet r        = result mod 10 in\nmatch l with \n| []   -> (cout, List.append [cout] (List.append [r] []))\n| h::t -> (cout, List.append [cout] (List.append [r] t)) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]", "let rec mulByDigit i l = \nlet rec aux acc n = \nmatch n with\n| 0 -> acc\n| _ -> aux (bigAdd acc l) (n-1) in\naux [0] i", "let _ = mulByDigit 9 [9;9;9;9]", "let rec foo acc t1 t2 = \nmatch t2 with\n| [] -> acc\n| h::t -> foo (List.append [(t1, h)] acc) t1 t", "let _ = foo [] [9;9;9] [1;2;3;4]", "let bigMul l1 l2 = \nlet f a x =  \nlet (l, i) = x in\nlet (m, s) = a in\nlet result = bigAdd s (List.append (mulByDigit i l) (clone 0 m) in\n(m*10, result)\nin\nlet base = (1, []) in\nlet args = \nlet rec helper acc l1 l2 = \nmatch l2 with\n| []   -> acc\n| h::t -> helper (List.append [(l1,h)] acc) l1 t in\nhelper [] l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x =  \nlet (l, i) = x in\nlet (m, s) = a in\nlet result = bigAdd s ((mulByDigit i l)*m) in\n(m*10, result)\nin\nlet base = (1, []) in\nlet args = \nlet rec helper acc l1 l2 = \nmatch l2 with\n| []   -> acc\n| h::t -> helper (List.append [(l1,h)] acc) l1 t in\nhelper [] l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type 'a * int list\n       but an expression was expected of type int\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let _ = bigMul [9;9;9;9] [9;9;9;9]", "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"], "bad": ["let bigMul l1 l2 = \nlet f a x =  \nlet (l, i) = x in\nlet (m, s) = a in\nlet result = bigAdd s (List.append (mulByDigit i l) (clone 0 m)) in\n(m*10, result)\nin\nlet base = (1, []) in\nlet args = \nlet rec helper acc l1 l2 = \nmatch l2 with\n| []   -> acc\n| h::t -> helper (List.append [(l1,h)] acc) l1 t in\nhelper [] l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Characters 92-93:\n  let result = bigAdd s (List.append (mulByDigit i l) (clone 0 m) in\n                        ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "bigMul"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| h::t -> if h = k then h else assoc(d,k,t)"], "bad": ["let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| h::t -> if h = k then return h else assoc(d,k,t)"], "message": ["Error: Unbound value return\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| h::t -> if h = k then h else assoc(d,k,t)"], "bad": ["let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "message": ["Error: This expression has type string but an expression was expected of type\n         int\n", "Error: This expression has type string but an expression was expected of type\n         int\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| (ki,vi)::t -> if ki = k then vi else assoc(d,k,t)"], "bad": ["let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "message": ["Error: This expression has type string but an expression was expected of type\n         int\n", "Error: This expression has type string but an expression was expected of type\n         int\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let buildOp2(a,b,a_less,b_less)    = Op2(a,b,a_less)"], "bad": ["let buildOp2()                     = Op2(e1,e2,e3)", "let buildOp2(a,b,a_less,b_less)    = Op2(a,b,a_less,b_less)"], "message": ["Error: Unbound value e1\n", "Error: The constructor Op2 expects 3 argument(s),\n       but is applied here to 4 argument(s)\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = (*failwith \"to be implemented\" *) if depth = -1\nthen \nlet randNum = rand(1,2) in\nlet randNum2 = rand(3,4) in\nif (randNum = 1 && randNum2 = 3) then buildSine(buildOp1(buildX())) else\nif (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )", ") else\nif (randNum = 2 && randNum2 = 3) then buildCosine(buildOp1(buildX())) else\nbuildCosine(buildOp2(build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))\n)", "let g1 () = (1,2,3)", "let g2 () = (1,2,3)", "let g3 () = (1,2,3)", "let c1 () = (1,2,3)", "let c2 () = (1,2,3)", "let c3 () = (1,2,3)", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type test = unit -> string", "let key = \"\"", "let prefix130 = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")", "let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0", "let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)", "let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))", "let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p", "let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max"], "bad": ["let rec build (rand, depth) = (*failwith \"to be implemented\" *)\nlet randNum = rand(1,2) in\nlet randNum2 = rand(3,4) in\nif (randNum = 1 && randNum2 = 3) then buildSine(buildOp1(buildX())) else\nif (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(buildX(),buildY(),buildX())) else\nif (randNum = 2 && randNum2 = 3) then buildCosine(buildOp1(buildX())) else\nbuildCosine(buildOp2(buildY(),buildX(),buildY()))"], "message": ["Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr * expr * expr * 'd\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = (*failwith \"to be implemented\" *) if depth > -1\nthen \nlet randNum = rand(1,2) in\nlet randNum2 = rand(3,4) in\nif (randNum = 1 && randNum2 = 3) then buildX() else\nif (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )", ") else\nif (randNum = 2 && randNum2 = 3) then buildCosine(buildOp1(buildX())) else\nbuildCosine(buildOp2(build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))\n)", "let g1 () = (1,2,3)", "let g2 () = (1,2,3)", "let g3 () = (1,2,3)", "let c1 () = (1,2,3)", "let c2 () = (1,2,3)", "let c3 () = (1,2,3)", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type test = unit -> string", "let key = \"\"", "let prefix130 = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")", "let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0", "let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)", "let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))", "let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p", "let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max"], "bad": ["let rec build (rand, depth) = (*failwith \"to be implemented\" *) if depth = -1\nthen \nlet randNum = rand(1,2) in\nlet randNum2 = rand(3,4) in\nif (randNum = 1 && randNum2 = 3) then buildX() else\nif (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )"], "message": ["Error: This expression has type expr but an expression was expected of type\n         unit\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nif depth = 0\nthen \nbuildSine(buildX())\nelse\nlet randNum = rand(1,2) in\nlet randNum2 = rand(1,2) in\nlet randNum3 = rand(1,2) in\nmatch (randNum, randNum2) with\n| (1,1) -> buildSine(build(rand, depth -1))\n| (2,2) -> buildCosine(build(rand, depth - 1))\n| _     -> match randNum3 with\n| 1 -> buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )\n| 2 -> buildCosine(buildOp2(build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )", "let g1 () = (1,2,3)", "let g2 () = (1,2,3)", "let g3 () = (1,2,3)", "let c1 () = (1,2,3)", "let c2 () = (1,2,3)", "let c3 () = (1,2,3)", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type test = unit -> string", "let key = \"\"", "let prefix130 = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")", "let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0", "let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)", "let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))", "let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p", "let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max"], "bad": ["let rec build (rand, depth) = \nif depth = 0\nthen \nbuildSine(buildX())\nelse\nlet randNum = rand(1,2) in\nlet randNum2 = rand(1,2) in\nlet randNum3 = rand(1,2) in\nmatch (randNum, randNum2) with\n| (1,1) -> buildSine(buildX())\n| (2,2) -> buildCosine(buildX())\n| _     -> match randNum3 with\n| 1 -> buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )\n| 2 -> buildCosine(buildOp2(build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )"], "message": ["Error: Syntax error\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| h::t -> let(s, x) = h in\nif (s = k) then x else assoc(d,k,t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "bad": ["let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| h::t -> let(s, x) = h\nif s = k then x else assoc(d,k,t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| h::t -> let(s, x) = h\nif (s = k) then x else assoc(d,k,t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "message": ["Error: Syntax error\n", "Error: Unbound value assoc\n", "Error: Syntax error\n", "Error: Unbound value assoc\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = \nlet f x = let xx = f(x) in (xx, xx = x) in \nwwhile (f,b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "bad": ["let fixpoint (f,b) = wwhile (((*failwith \"to be written\"*)fun x -> f(x), x = f(x)),b)\n\n(* uncomment after implementing fixpoint *)\n*\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let fixpoint (f,b) = wwhile ((let f x = let xx = f(x) in (xx, xx = x)),b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value fixpoint\n", "Error: Syntax error: operator expected.\n", "Error: Unbound value fixpoint\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)"], "bad": ["let fixpoint (f,b) = \nlet g x = let xx = f(x) in (xx, xx = x) in \nwwhile (g,b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Syntax error\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)"], "bad": ["let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx = x)\nwwhile (g,b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx = x) in\nwwhile (g,b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value fixpoint\n", "Error: Syntax error\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)"], "bad": ["let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx != x) in\nwwhile (g,b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Syntax error\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y \n| Sine a -> sin(pi *. eval(a))\n| Cosine (a) -> cos(pi *. eval(a))\n| Average (a, b) -> ((eval(a) +. eval(b)) / 2)\n| Times (a, b) -> eval(a) *. eval(b)\n| Thresh (a, b, c, d) -> if(eval(a) < eval(b)) then  eval(c) else eval(d)", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)"], "bad": ["let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y \n| Sine (a) -> sin(pi *. eval(a))\n| Cosine (a) -> cos(pi *. eval(a))\n| Average (a, b) -> (((eval(a) +. eval(b)) / 2)\n| Times (a, b) -> eval(a) *. eval(b)\n| Thresh (a, b, c, d) -> if(eval(a) < eval(b)) then  eval(c) else eval(d)\n(*failwith \"to be written\"*)\n\n\n(* uncomment after implementing eval*)\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y \n| Sine (a) -> sin(pi *. eval(a))\n| Cosine (a) -> cos(pi *. eval(a))\n| Average (a, b) -> ((eval(a) +. eval(b)) / 2)\n| Times (a, b) -> eval(a) *. eval(b)\n| Thresh (a, b, c, d) -> if(eval(a) < eval(b)) then  eval(c) else eval(d)", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)"], "message": ["Error: Syntax error\n", "Characters 151-152:\n  | Average (a, b) -> (((eval(a) +. eval(b)) / 2)\n                      ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let g1 () = failwith \"to be implemented\"", "let g2 () = failwith \"to be implemented\"", "let g3 () = failwith \"to be implemented\"", "let c1 () = failwith \"to be implemented\"", "let c2 () = failwith \"to be implemented\"", "let c3 () = failwith \"to be implemented\"", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")"], "bad": ["let rec build (rand, depth) = \nif(depth = 0) then if(rand(0, 2) < 1) then buildX() else buildY() else let x = rand(0, 5) in\nif( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1))) else if( x = 4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))", "let rec build (rand, depth) = \nif(depth = 0) then if(rand(0, 2) < 1) then buildX() else buildY() else let x = rand(0, 5) in\nif( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1))) else if( x = 4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))", "let rec build (rand, depth) = \nif(depth = 0) then if(rand(0, 2) < 1) then buildX() else buildY() else let x = rand(0, 5) in\nif( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1)))", "let rec build (rand, depth) = \nif(depth = 0) then if(rand(0, 2) < 1) then buildX() else buildY() else let x = rand(0, 5) in\n(*if( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1))) else if( x = 4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))*)\nmatch x with\n| 0 -> buildSine(build(rand, (depth - 1)))\n| 1 -> buildCosine(build(rand, (depth -1)))\n| 2 -> buildAverage(build(rand, (depth -1)), build(rand, (depth -1)))\n| 3 -> buildTimes(build(rand, (depth -1)), build(rand, (depth -1)))\n| 4 -> buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))"], "message": ["Error: This expression has type unit -> expr\n       but an expression was expected of type expr\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let _ = doRandomGray(9, 0, 5)"], "bad": ["let _ = doRandomGray(8, 0, 5)"], "message": ["Error: Unbound value doRandomGrey\nHint: Did you mean doRandomGray?\nError: Unbound value doRandomGrey\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value doRandomGrey\nHint: Did you mean doRandomGray?\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let _ = sumList []"], "bad": ["let _ = sumList 1"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let _ = 12 mod 10"], "bad": ["let _ = div(12, 10)", "let _ = mod 12 10", "let _ = (mod 12 10)", "let _ = mod(12 10)", "let _ = mod(12, 10)", "let _ = 12 % 10", "let _ = 12 % 10", "let _ = Mod(12, 10)", "let _ = mod(12, 10)", "let _ = mod 12 10", "let _ = Mod 12 10"], "message": ["Error: Unbound value div\n", "Error: Syntax error\n", "Characters 8-9:\n  let _ = (mod 12 10);;\n          ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value %\n", "Error: Unbound value %\n", "Error: Unbound constructor Mod\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let _ = 12 / 10"], "bad": ["let _ = 12 div 10", "let _ = 12.0 div 10", "let _ = 12 div 10", "let _ = 12 div 10", "let _ = 12  10"], "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type float\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec additivePersAndRoot xs pers =\nlet theSum = sumList xs in\nif theSum < 10 then (pers, theSum)\nelse additivePersAndRoot (digits theSum) (pers + 1)"], "bad": ["let rec additivePersAndRoot xs pers =\nlet theSum = sumList xs;\nlet nextArr = digits theSum in \nif (sumList xs) < 10 then (pers, theSum)\nelse additivePersAndRoot(nextArr (pers + 1))", "let _ = additivePersAndRoot [1, 1] 0", "let rec additivePersAndRoot xs pers =\nlet theSum = sumList xs", "let nextArr = digits theSum in \nif (sumList xs) < 10 then (pers, theSum)\nelse additivePersAndRoot(nextArr (pers + 1))", "let rec additivePersAndRoot xs pers =\nlet theSum = sumList xs;\nlet nextArr = digits theSum in \nif (sumList xs) < 10 then (pers, theSum)\nelse additivePersAndRoot(nextArr (pers + 1))", "let rec additivePersAndRoot xs pers =\nlet theSum = sumList xs in\nif theSum < 10 then (pers, theSum)\nelse additivePersAndRoot((digits theSum) (pers + 1))"], "message": ["Error: Syntax error\n", "Error: This function has type int -> int * int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Syntax error\n", "Error: Unbound value theSum\n", "Error: Syntax error\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let _ = additivePersAndRoot [1] 0"], "bad": ["let _ = additivePersAndRoot [1, 1] 0"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let _ = additivePersAndRoot (2::[1]) 0"], "bad": ["let _ = additivePersAndRoot 2::[1] 0"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let _ = additivePersAndRoot (9::(8::(7::[6]))) 0"], "bad": ["let _ = additivePersAndRoot ([9, 8, 7, 6]) 0", "let _ = additivePersAndRoot (9::(8::(7::(6)))) 0", "let _ = additivePersAndRoot (9::(8::(7::(6)))) 0"], "message": ["Error: This expression has type 'a * 'b * 'c * 'd\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let (l, r) = additivePersAndRoot (abs (-2)) 0"], "bad": ["let (l, r) = additivePersAndRoot abs(-2) 0"], "message": ["Error: This function has type int -> int -> int * int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec listReverse l = \nmatch l with\n[] -> []\n| r::h ->\n(listReverse h) @ [r]"], "bad": ["let rec listReverse l = \nmatch l with\n[] -> []\n| r:h ->\n(listReverse h) @ [r]", "let rec listReverse l = \nmatch l with\n[] -> []\n| r:h ->\n(listReverse h) @ [r]"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec lasts w =\nlet l::h = w in\nmatch h with\n[] -> l\n| r::h ->\nlasts h", "let palindrome w = \nlet ex = explode w in\nex[0] && ex[_end]"], "bad": ["let palindrome w = \nlet ex = explode w in\nex[0] && ex[", "end", "]", "let palindrome w = \nlet ex = explode w in\nex[0] && ex[_end]"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type char list\n       This is not a function; it cannot be applied.\n"], "problem": "palindrome"}
{"hw": "hw1", "fix": ["let palindrome w = \nlet ex = explode w in\nlet revex = listReverse ex in\nex = revex"], "bad": ["let palindrome w = \nlet ex = explode w in\nlet revex = listReverese ex in\nex = revex", "let palindrome w = \nlet ex = explode w in\nlet revex = listReverese ex in\nex = revex"], "message": ["Error: Unbound value listReverese\nHint: Did you mean listReverse?\nError: Unbound value listReverese\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value listReverese\nHint: Did you mean listReverse?\n", "Error: Unbound value listReverese\nHint: Did you mean listReverse?\nError: Unbound value listReverese\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value listReverese\nHint: Did you mean listReverse?\n"], "problem": "palindrome"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\nif n <= 0 then []\nelse \ndigitsOfInt (n / 10) @ (n mod 10)", "let _ = digitsOfInt 0", "let _ = digitsOfInt (-3)", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663"], "bad": ["let rec digitsOfInt n =\nif n <= 0 then []\nelse \nlet next_tail = digitsOfInt (n / 10) in\nmatch next_tail with\nx::xs -> \nxs @ [x :: (n mod 10)]"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\nif n <= 0 then []\nelse (digitsOfInt (n / 10)) @ [n mod 10]", "let _ = digitsOfInt 0", "let _ = digitsOfInt (-3)", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663"], "bad": ["let rec digitsOfInt n =\nif n <= 0 then []\nelse (digitsOfInt (n / 10)) :: (n mod 10)"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec backCons xs x =\nmatch xs with\n[] -> x\n| y::ys ->\ny :: x", "let _ = backCons [1; 2] 3"], "bad": ["let rec backCons xs x =\nmatch xs with\n[] -> x\n| y::ys ->\n(backCons ys) :: y :: x", "let _ = backCons [1; 2] 3"], "message": ["Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list -> 'a list\n", "Error: Unbound value backCons\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec backCons xs x =\nmatch xs with\n[] -> [x]\n| y::ys ->\ny :: [x]", "let _ = backCons [1; 2] 3"], "bad": ["let _ = backCons ([1; 2] 3)", "let _ = backCons [1; 2] 3", "let rec backCons xs x =\nmatch xs with\n[] -> x\n| y::ys ->\ny :: [x]", "let _ = backCons [1; 2] 3"], "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let _ = additivePersistence (-9876)"], "bad": ["let _ = additivePersistence -9860"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let _ = additivePersistence (abs (-9876))"], "bad": ["let _ = additivePersistence abs (-9876)"], "message": ["Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "additivePersistence"}
{"hw": "hw2", "fix": ["char_of_int(2)"], "bad": ["int_to_char(2)"], "message": ["Error: Unbound value int_to_char\nHint: Did you mean int_of_char?\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let long_list = \nlet rec assemble n l = \nif n < 1000000 then\nassemble (n+1) ((n, string_of_int(n)) :: l)\nelse\nl\nin\nassemble 1 []"], "bad": ["let long_list = \nlet rec assemble n l = \nif n < 1000000 then\nassemble (n+1) (n, string_of_char(n)) :: l\nelse\nl\nin\nassemble 1 []", "let long_list = \nlet rec assemble n l = \nif n < 1000000 then\nassemble (n+1) (n, string_of_int(n)) :: l\nelse\nl\nin\nassemble 1 []"], "message": ["Error: Unbound value string_of_char\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "bad": ["let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl  -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _\t\t-> d"], "message": ["Error: Unbound value assoc_tl\nHint: Did you mean assoc?\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let _ = assoc (-1,123, [(123, 1)])"], "bad": ["let _ = assoc (-1,\"d\", [(\"d\", 1)])"], "message": ["Error: This expression has type string but an expression was expected of type\n         char\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let _ = assoc ([], 123, [(123, \"sad\"); (321, \"happy\")])"], "bad": ["let _ = assoc (\"null\",123, [(123, \"sad\"; (321, \"happy\")])", "let _ = assoc (\"null\", 123, [(123, \"sad\"); (321, \"happy\")])"], "message": ["Characters 28-29:\n  let _ = assoc (\"null\",123, [(123, \"sad\", (321, \"happy\")]);;\n                              ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Characters 28-29:\n  let _ = assoc (\"null\",123, [(123, \"sad\"; (321, \"happy\")]);;\n                              ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let _ = assoc ('c', 123, [(123, \"sad\"); (321, \"happy\")])"], "bad": ["let _ = assoc (\"null\", 123, [(123, \"sad\"); (321, \"happy\")])"], "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let long_list = \nlet rec assemble n l = \nif n < 10000000 then\nassemble (n+1) ((string_of_int(n), n) :: l)\nelse\nl\nin\nassemble 1 []", "let _ = assoc(-1, \"13\", long_list)"], "bad": ["let _ = assoc (\"null\", 123, [(123, \"sad\"); (321, \"happy\")])"], "message": ["Error: This expression has type string but an expression was expected of type\n         char\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)"], "bad": ["let fixpoint (f,b) = wwhile ((f),b)"], "message": ["Error: This expression has type 'a -> bool\n       but an expression was expected of type 'a -> 'a * bool\n       Type bool is not compatible with type 'a * bool \n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((f b),b)"], "bad": ["let fixpoint (f,b) = wwhile ((f (=)),b)"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let g f b = (b, (b = (f b)))"], "bad": ["let g f b = (b = (f b))"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let g b = (b, (b = (f b)))"], "bad": ["let _ = f", "let f x = let xx = x*x*x in (xx, xx < 100)"], "message": ["Error: Unbound value f\n", "Error: Unbound value f\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let f x = x + x", "let g (f, x) = let xx = f x in (xx, xx = f x)"], "bad": ["let h = g f", "let h = g f 1"], "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "Error: This expression has type int -> int * bool\n       but an expression was expected of type ('a -> 'a) * 'a\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value fixpoint\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let fixpoint (f,b) = wwhile ((let g h x = let xx = h x in (xx, x != xx) in g f),b)"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr,0.5,0.2)"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> if (eval(e1, x, y) < eval(e2, x, y)) then eval(e3, x, y) else eval(e4, x, y)"], "message": ["Error: Syntax error\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> randX()"], "bad": ["let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildAverage(first_forced, build(rand, depth - 1), build(rand, depth - 1))", "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1))", "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))"], "message": ["Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr * expr\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr * expr\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr * expr * expr * expr\n"], "problem": "build"}
{"hw": "hw2", "fix": ["set _ = build(rand, 5)"], "bad": ["let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> randX()", "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> buildX()"], "message": ["Error: Unbound value randX\nHint: Did you mean rand?\n", "Error: Unbound value randX\nHint: Did you mean rand?\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let _ = build(makeRand, 5)", "let g1 () = failwith \"to be implemented\"", "let g2 () = failwith \"to be implemented\"", "let g3 () = failwith \"to be implemented\"", "let c1 () = failwith \"to be implemented\"", "let c2 () = failwith \"to be implemented\"", "let c3 () = failwith \"to be implemented\"", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type test = unit -> string", "let key = \"\"", "let prefix130 = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")", "let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0", "let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)", "let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))", "let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p", "let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max"], "bad": ["let _ = build(rand, 5)", "let _ = build(makeRand, 5)"], "message": ["Error: Syntax error\n", "Error: Unbound value rand\nHint: Did you mean land?\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let _ = acos(pi)"], "bad": ["let _ = acos(1.0)"], "message": ["Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let _ = acos(0)"], "bad": ["let _ = acos(1.0)"], "message": ["Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let pi = 4.0 *. atan 1.0", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Accossin(e1, e2) -> (acos(eval(e1)) *. asin(eval(e2))) *. 2.0 /. (pi *. pi)", "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(0, 2) in\nif bin_rand = 0 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(0, 6) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 0 -> buildSine(first_forced)\n| 1 -> buildCosine(first_forced)\n| 2 -> buildAverage(first_forced, build(rand, depth - 1))\n| 3 -> buildTimes(first_forced, build(rand, depth - 1))\n| 4 -> buildThresh(first_forced, build(rand, depth - 1), \nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> buildAcossin(first_forced, build(rand, depth - 1))", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))"], "bad": ["let buildAcossin(e1,e2)\t\t   = Acossin(e1,e2)"], "message": ["Error: Unbound value buildAcossin\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)"], "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["doRandomGray(1, 111, 1005)"], "bad": ["doRandomGray(1, 111, 1005)", "doRandomGray(8, 111, 1005)", "doRandomGray(3, 111, 1005)", "doRandomGray(4, 111, 1005)", "doRandomGray(5, 111, 1005)", "doRandomGray(10, 111, 1005)"], "message": ["Error: Unbound value doRandomGray\n", "Error: Unbound value doRandomGray\n", "Error: Unbound value doRandomGray\n", "Error: Unbound value doRandomGray\n", "Error: Unbound value doRandomGray\n", "Error: Unbound value doRandomGray\n"], "problem": "???"}
{"hw": "hw2", "fix": ["doRandomGray(12, 6543, 35241)"], "bad": ["doRandomGray(2, 111, 1005)", "doRandomGray(6, 1315, 666)", "doRandomGray(13, 6543, 35241)"], "message": ["Error: Unbound value doRandomGray\n", "Error: Unbound value doRandomGray\n", "Error: Unbound value doRandomGray\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (+) (x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = (+) (x a) in\nlet base = 0 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (+) (a x) in\nlet base = 0 in\nList.fold_left f base fs"], "message": ["Error: This expression has type int but an expression was expected of type\n         int -> int\n", "Error: This expression has type int but an expression was expected of type\n         int -> int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = a in\nlet base =  0 in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (fun a -> a) in\nlet base =  (fun x -> x) in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let pipe fs = \nlet f a x = (fun a -> a) in\nlet base =  0 in\nList.fold_left f base fs"], "message": ["Error: This function has type 'a list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base =  0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = (fun r s -> a) in\nlet base =  (fun r s -> 0) in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base =  0 in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base =  (fun x -> []) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base =  (fun) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base =  (fun n -> ) in\nList.fold_left f base fs"], "message": ["Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base =  (fun n -> n) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base =  (fun x -> ) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base =  (fun -> y) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base =  (fun y) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base =  (fun n -> n) in\nList.fold_left f base fs"], "message": ["Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (fun y -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = (fun y -> x a) in\nlet base =  in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (fun y -> x a) in\nlet base = 0 in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (fun _ -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = (fun -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (fun _ -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = (fun _ -> x a) in\nlet base = (fun _ -> _) in\nList.fold_left f base fs"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (fun _ -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = (fun _ -> x a) in\nlet base = [] in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (fun _ -> x a) in\nlet base = 0 in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'b -> 'c\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (fun _ -> x) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = (fun _ -> a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (fun y -> x y) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         int -> int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["fun x -> 3"], "bad": ["fun -> 3"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (let myfun = x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "bad": ["let pipe fs = \nlet f a x = (let rec = x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (let myfun = x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (let myfun _ = x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (let myfun = (x a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (let myfun x a = x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (let myfun x a -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (let myfun = x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "message": ["Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (let myfun = x a in myfun) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = (let rec myfun = x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = (a x) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (fun y -> x) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = (fun y -> (y a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (fun y -> a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n", "Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (fun _ -> (x a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = (fun y -> x -> (x a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (fun _ x -> (x a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "message": ["Characters 27-28:\n  let f a x = (fun y -> x -> (x a)) in\n              ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: This expression has type 'a -> 'b -> 'c -> ('a -> 'd) -> 'd\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> ('a -> 'd) -> 'd\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (x a) in\nlet base = (fun _ -> 0) in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun _ -> base) in\nList.fold_left f base fs"], "message": ["Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Syntax error: operator expected.\n", "Error: Unbound value base\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (x a) in\nlet base = (fun y -> y ) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = (x a) in\nlet base = (fun y -> y -> 0) in\nList.fold_left f base fs"], "message": ["Characters 47-48:\n  let base = (fun y -> y -> 0) in\n             ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let _ = pipe [] 3"], "bad": ["let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         int -> int\n", "Error: This expression has type int but an expression was expected of type\n         int -> int\n", "Error: This expression has type int but an expression was expected of type\n         int -> int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (x (x a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = (x (a a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (x (a x)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n", "Error: This expression has type (('a -> 'b) -> 'a) -> ('a -> 'b) -> 'b\n       but an expression was expected of type\n         (('a -> 'b) -> 'a) -> ('a -> 'b) -> ('a -> 'b) -> 'a\n       The type variable 'b occurs inside ('a -> 'b) -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (x (a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = (x (a)) in\nlet base = (fn y -> y) in\nList.fold_left f base fs"], "message": ["Characters 49-50:\n  let base = (fn y -> y) in\n             ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (x a) in\nlet base = (f) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = (x a) in\nlet base = (fun _ -> y) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (x a) in\nlet base = (f a) in\nList.fold_left f base fs"], "message": ["Error: Unbound value y\n", "Error: Unbound value a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "let _ = pipe []"], "bad": ["let _ = pipe [(fun x -> x + x); (fun x -> x + 3)]"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (fun _ -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (fun z -> a z) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = (fun z -> z a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x a in\nlet base = \"\" in\nlet l = [fun x -> x ^ sep] in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x a in\nlet base = \"\" in\nlet l = (^) sep in\nList.fold_left f base l", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x a in\nlet base = \"\" in\nlet l = fun x -> x ^ sep in\nList.fold_left f base l"], "message": ["Error: This expression has type string -> string\n       but an expression was expected of type (string -> string) list\n", "Error: This expression has type string -> string\n       but an expression was expected of type (string -> string) list\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base = \"\" in\nlet l = [fun x -> x ^ sep] in\nList.fold_left f base l"], "message": ["Error: This expression has type (string -> string) list\n       but an expression was expected of type string list\n       Type string -> string is not compatible with type string \n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let stringOfList f l = \nmatch l with\n| []    -> \"[]\"\n| x::xs ->\nlet g a x = a ^ \"; \" ^ (f x) in\nlet base = f x in\nList.fold_left g base xs"], "bad": ["let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let stringOfList f l = \nmatch l with\n| []    -> \"[]\"\n| x::xs ->\nlet g a x = a ^ \"; \" ^ (f x) in\nlet base = f x in\nList.fold_left f base xs"], "message": ["Error: This expression has type int but an expression was expected of type\n         string\n", "Error: This expression has type 'a -> string\n       but an expression was expected of type 'a -> 'b -> 'a\n       Type string is not compatible with type 'b -> 'a \n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let rec clone x n =\nlet rec clone_RT acc n =\nif n <= 0 then \nacc\nelse \nclone_RT (x::acc) (n-1)\nin\nclone_RT [] n"], "bad": ["let rec clone x n =\nlet rec clone_RT acc n =\nif n <= 0 then acc\nelse clone (x::acc) (n-1)\nin\nclone_RT [] n", "let rec clone x n =\nlet rec clone_RT acc n =\nif n <= 0 then \nacc\nelse \nclone (x::acc) (n-1)\nin\nclone_RT [] n"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nlet diff = len1 - len2 in\nif diff < 0 then\n(List.append (clone 0 (-diff)) l1, l2)\nelse\n(List.append (clone 0 diff) l2, l1)"], "bad": ["let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nlet diff = len1 - len2 in\nif diff < 0 then\nList.append (List.append ((clone 0 (-diff)), len1), len2)\nelse\nList.append (List.append (clone 0 (diff), len2), len1)", "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nlet diff = len1 - len2 in\nif diff < 0 then\nList.append (List.append ((clone 0 (-diff)), len1), len2)", ")\nelse\nList.append (List.append (clone 0 (diff), len2), len1)", "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nlet diff = len1 - len2 in\nif diff < 0 then\n(List.append (clone 0 (-diff), len1), len2)\nelse\n(List.append (clone 0 (diff), len2), len1)", "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nlet diff = len1 - len2 in\nif diff < 0 then\n(List.append (clone 0 (-diff)) len1, len2)\nelse\n(List.append (clone 0 diff) len2, len1)"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: Syntax error\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = ([0], [0]) in\nlet base = ([0], [0]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = 0 in\nlet base = 0 in\nlet args = (l1, l1) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (1,2) in\nlet base = 0 in\nlet args = (l1, l1) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (0, 0) in\nlet base = (0, 0) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (0, 0) in\nlet base = (0, 0) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a * 'a\n       but an expression was expected of type 'b list\n", "Error: This expression has type int but an expression was expected of type\n         int * int\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (0, []) in\nlet base = (0, []) in\nlet args = (clone 0 (List.length l1)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = ([0], [0]) in\nlet base = ([0], [0]) in\nlet args = (l1, 2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = ([0], [0]) in\nlet base = ([0], [0]) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = ([0], [0]) in\nlet base = (0, 0) in\nlet args = (0, clone 0 List.length l1) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = ([0], [0]) in\nlet base = (0, []) in\nlet args = (0, clone 0 List.length l1) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (0, []) in\nlet base = (0, []) in\nlet args = (0, clone 0 List.length l1) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (0, []) in\nlet base = (0, []) in\nlet args = (0, clone 0 (List.length l1)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a * int\n       but an expression was expected of type 'b list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int * int list\n       but an expression was expected of type 'a list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \n(t, (h + x)::y)\nin\nlet base = (List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \nlet sum = h + x in\n(t, sum::y)", "let base = (List.reverse l1, []) in\nlet args = List.reverse l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \nlet sum = h + x in\n(t, sum::y)", "let base = (List.reverse l1, []) in\nlet args = List.reverse l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \nlet sum =  in\n(t, (h + x)::y) in\nlet base = (List.reverse l1, []) in\nlet args = List.reverse l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \nlet sum = \n(t, (h + x)::y) in\nlet base = (List.reverse l1, []) in\nlet args = List.reverse l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \nlet sum = \n(t, (h + x)::y) in\nlet base = (List.reverse l1, []) in\nlet args = List.reverse l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \n(t, (h + x)::y)\nin\nlet base = (List.reverse l1, []) in\nlet args = List.reverse l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \n(t, (h + x)::y)\nin\nlet base = (List.rev l1, []) in\nlet args = List.reverse l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value List.reverse\n", "Error: Unbound value List.reverse\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = ((List.rev l1, 0), []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = ((List.rev l1, carry), []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Unbound value carry\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x + carry in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = ((0::(List.rev l1), 0), []) in\nlet args = 0::(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x + carry in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = (0::(List.rev l1, 0), []) in\nlet args = 0::(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x + carry in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = (0::(List.rev l1), 0), []"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x + carry in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = ((List.rev (0::l1), 0), []) in\nlet args = List.rev (0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x + carry in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = ((List.rev 0::l1, 0), []) in\nlet args = List.rev 0::l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let _ = bigAdd [-1] [-2; -3]"], "bad": ["let _ = bigAdd [-1] [-2, -3]"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = \nlet rec mulByDigit_RT i acc =\nif i = 1 then acc\nelse mulByDigit_RT (i-1) (bigAdd acc l)\nin\nmulByDigit_RT i []"], "bad": ["let rec mulByDigit i l = \nlet mulByDigit_RT i acc =\nif i = 1 then acc\nelse mulByDigit_RT (i-1) (bigAdd acc l)\nin\nmulByDigit_RT i []"], "message": ["Error: Unbound value mulByDigit_RT\nHint: Did you mean mulByDigit?\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = match a with\n| (i, acc) -> \nlet digmul = mulByDigit (i * x) l2 in\n(i * 10, bigAdd digmul acc)\n| _ -> failwith \"wtf\" in\nlet base = (1, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = match a with\n| (i, acc) -> ([], acc) \n| _ -> failwith \"wtf\" in\nlet base = (0, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type int * 'a list\n       but an expression was expected of type 'b list * 'c\n       Type int is not compatible with type 'b list \n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let _ = sepConcat \"X\" [\"hello\"]", "(sepConcat \"; \")"], "bad": ["let _ = sepConcat \"X\" [\"hello\"]\n\n\n(sepConcat \"; \")"], "message": ["Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["List.map string_of_int"], "bad": ["List.map string_of_in"], "message": ["Error: Unbound value string_of_in\nHint: Did you mean string_of_int?\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let stringOfList f l = \n\"[\" ^ (stringOfList f (List.map f l)) ^ \"]\""], "bad": ["let stringOfList f l = \n\"[\" ^ List map f (List.map f l) ^ \"]\"", "let stringOfList f l = \n\"[\" ^ stringOfList (List.map f l) ^ \"]\""], "message": ["Error: Syntax error\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b -> string\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]"], "bad": ["sepConcat \"; \" [[1;0];[2];[3]]", "List.map string_of_int [[1;0];[2];[3]]", "sepConcat \"; \" [[1;0];[2];[3]]"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["List.map"], "bad": ["List.map f l", "let R f l =\nList.map f l", "let R f l =\nList.map f l", "let R f l =\nList.map f l", "let Rr f l =\nList.map f l", "let Rr f l =\nList.map f"], "message": ["Error: Unbound value f\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let stringOfList f l = (List.map f l);"], "bad": ["let stringOfList f l = \"[\" ^ (List.map f l) ^ \"]\""], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let _ = bigMul [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9] []"], "bad": ["let _ = bigMul [1] [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9]", "let _ = bigMul [10] [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9]", "let _ = bigMul [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9] [10]"], "message": ["Error: Unbound value bigMul\n", "Error: Unbound value bigMul\n", "Error: Unbound value bigMul\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = (fun z -> x (a z)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 10", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 10", "let _ = pipe [(fun x -> x ^ \" is the best\");(fun x-> x ^ \" student. \"); (fun x -> x ^ x)] \"Idan\"", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"; \" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "let _ = stringOfList string_of_int []", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n =\nlet rec clone_TR acc n =\nif n <= 0 then \nacc\nelse \nclone_TR (x::acc) (n-1)\nin\nclone_TR [] n", "let _ = clone [] 2", "let _ = clone 1 10000", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let _ = clone clone (3)", "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nlet diff = len1 - len2 in\nif diff < 0 then\n(List.append (clone 0 (-diff)) l1, l2)\nelse\n(l1, List.append (clone 0 diff) l2)", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let rec removeZero l = \nmatch l with \n| [] -> []\n| x::xs -> \nif x = 0 then\nremoveZero xs\nelse\nl", "let _ = removeZero [0;0;0;1;0;0;2]", "let _ = removeZero [9;9]", "let _ = removeZero [0;0;0;0]", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x + carry in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = ((List.rev (0::l1), 0), []) in\nlet args = List.rev (0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [] []", "let _ = bigAdd [0] []", "let _ = bigAdd [] [0]", "let _ = bigAdd [1] []", "let _ = bigAdd [] [1]", "let _ = bigAdd [-1] [1]", "let _ = bigAdd [-1] [-2; -3]", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [1;0;0;2] [4;4]", "let _ = bigAdd [9;9;9;9] [9;9;9]", "let _ = bigAdd (clone 1 100000) (clone 1 100000)", "let rec mulByDigit i l = \nlet rec mulByDigit_RT i acc =\nif i = 0 then acc\nelse mulByDigit_RT (i-1) (bigAdd acc l)\nin\nmulByDigit_RT i []", "let _ = mulByDigit 9 [9;9;9;9]", "let bigMul l1 l2 = \nlet f a x = \nlet (i, acc) = a in\nlet digmul = mulByDigit (i * x) l2 in\n(i * 10, bigAdd digmul acc) in\nlet base = (1, []) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "let _ = bigMul [9;9;9;9] [9;9;9;9]", "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]", "let _ = bigMul [1;2] [3;4]", "let _ = bigMul [1;2;3] [9;9]", "let _ = bigMul [4;1;3] [4;2;4;5;0;8;9]", "let _ = bigMul [] [0]", "let _ = bigMul [0] []", "let _ = bigMul [] []", "let _ = bigMul [1;2;3] [0]", "let _ = bigMul [0] [2;3;4]", "let _ = bigMul [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9] []", "let _ = bigMul [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9] [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9]", "let _ = bigMul [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9;1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9;1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9] [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9;1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9;1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9;1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9]"], "bad": ["let _ = mulByDigit 9 [9;9;9;9]", "let bigMul l1 l2 = \nlet f a x = \nlet (i, acc) = a in\nlet digmul = mulByDigit (i * x) l2 in\n(i * 10, bigAdd digmul acc) in\nlet base = (1, []) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "let _ = bigMul [9;9;9;9] [9;9;9;9]", "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]", "let _ = bigMul [1;2] [3;4]", "let _ = bigMul [1;2;3] [9;9]", "let _ = bigMul [4;1;3] [4;2;4;5;0;8;9]", "let _ = bigMul [] [0]", "let _ = bigMul [0] []", "let _ = bigMul [] []", "let _ = bigMul [1;2;3] [0]", "let _ = bigMul [0] [2;3;4]", "let _ = bigMul [1;9;4;5;2;3] []", "let _ = bigMul [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6] []"], "message": ["Error: Unbound value mulByDigit\n", "Error: Unbound value mulByDigit\n", "Error: Unbound value mulByDigit\n", "Error: Unbound value bigMul\n", "Error: Unbound value bigMul\n", "Error: Unbound value bigMul\n", "Error: Unbound value bigMul\n", "Error: Unbound value bigMul\n", "Error: Unbound value bigMul\n", "Error: Unbound value bigMul\n", "Error: Unbound value bigMul\n", "Error: Unbound value bigMul\n", "Error: Unbound value bigMul\n", "Error: Unbound value bigMul\n"], "problem": "bigMul"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n <= 0 then []\nelse n mod 10 :: digitsOfInt (n / 10)"], "bad": ["let rec digitsOfInt n myList = \nif (n <= 0)\nthen myList\nelse digitsOfInt (n/10)  (n mod 10 ::myList)\nmatch n with \n| 0 -> [0]\n| _ -> digitsOfInt n []", "let rec digitsOfInt n myList = match n with\n| n <= 0 -> []\n| _      -> n mod 10 :: digitsOfInt (n / 10)", "let rec digitsOfInt n = match n with\n| n <= 0 -> []\n| _      -> n mod 10 :: digitsOfInt (n / 10)"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num"], "bad": ["let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList n in\nnum + additivePersistence num"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nif (n < 10) \nthen counter\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num"], "bad": ["let rec additivePersistence n = \nif (n < 10) \nthen counter\nelse \nlet myList = digits n in\nlet num = sumList myList in\nlet counter = counter + 1 \nnum + additivePersistence num", "let rec additivePersistence n = \nif (n < 10) \nthen counter\nelse \nlet myList = digits n in\nlet num = sumList myList in\nlet counter = counter + 1", "let rec additivePersistence n = \nif (n < 10) \nthen counter\nelse \nlet myList = digits n in\nlet num = sumList myList in\nlet counter = counter + 1"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num"], "bad": ["let rec additivePersistence n = \nif (n < 10) \nthen counter\nelse \nlet myList = digits n in\nlet num = sumList myList in\nlet counter = 0 in\ncounter = counter + 1\nnum + additivePersistence num", "let rec additivePersistence n = \nif (n < 10) \nthen \nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num"], "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nif (n < 10) \nthen []\nelse \nlet myList = digits n in\n(*let num = sumList myList in*)\nmyList"], "bad": ["let rec additivePersistence n = \nif (n < 10) \nthen []\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \n1 + additivePersistence (sumList (digits n))"], "bad": ["let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \n1 + additivePersistence sumList (digits n)"], "message": ["Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec digitalRoot n = \nif (n < 10)\nthen n\nelse\nadditivePersistence ( sumList (digits n))"], "bad": ["let rec digitalRoot n = \nif (n < 10)\nthen digRoot = n\nelse\nadditivePersistence ( sumList (digits n))", "let rec digitalRoot n = \nif (n < 10)\nthen root = n\nelse\nadditivePersistence ( sumList (digits n))", "let rec digitalRoot n = \nif (n < 10)\nthen root = n\nelse\nadditivePersistence ( sumList (digits n))"], "message": ["Error: Unbound value digRoot\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value digRoot\n", "Error: Unbound value root\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value root\n", "Error: Unbound value root\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value root\n"], "problem": "digitalRoot"}
{"hw": "hw1", "fix": ["let rec listReverse l = match l with \n| [] -> []\n| h::t -> []", "let _ = \"a\" :: \"b\" :: \"c\""], "bad": ["let rec listReverse l = match l with \n| [] -> []\n| h::t ->", "let _ = \"a\" :: \"b\" :: \"c\"", "let rec listReverse l = match l with \n| [] -> []\n| h::t -> 0", "let _ = \"a\" :: \"b\" :: \"c\""], "message": ["Error: Syntax error\n", "Error: This expression has type string but an expression was expected of type\n         string list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type string but an expression was expected of type\n         string list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = \"a\" :: \"b\" :: \"c\" :: [\"d\"]"], "bad": ["let _ = \"a\" :: \"b\" :: [\"c\"] :: [\"d\"]"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec append list1 list2 = match list1 with \n| [] -> []\n| h::t -> h :: list2"], "bad": ["let rec append list1 list2 = match list1 with \n| [] -> []\n| h::t -> h :: append list2"], "message": ["Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'a list\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let _ = append [\"a\"] [\"b\"]"], "bad": ["let _ = append [a] [b]"], "message": ["Error: Unbound value a\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse (append t [h] )"], "bad": ["let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse ( append ( t [h] ) )", "let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse append ( t [h] )", "let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse (append ( t [h] ))"], "message": ["Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let append list1 list2 = match list1 with \n| [] -> list2\n| h::t -> h :: append t list2"], "bad": ["let append list1 list2 = match list1 with \n| [] -> list2\n| h::t -> h :: append [] t"], "message": ["Error: Unbound value listReverse\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec listReverse l = match l with \n| [] -> l\n| h::t -> listReverse (append t [h])"], "bad": ["let rec listReverse l = match l with \n| [] -> []\n| h::t -> append ( t [h])", "let rec listReverse l = match l with \n| [] -> []\n| h::t -> append t [h]", "let _ = listReverse [1; 2; 3; 4]", "let rec listReverse l = match l with \n| [] -> []\n| h::t -> listReverse (append t [h])", "let _ = listReverse [1; 2; 3; 4]"], "message": ["Error: Unbound value append\n", "Error: Unbound value append\n", "Error: Unbound value append\n", "Error: Unbound value listReverse\n", "Error: Unbound value append\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec listReverse l = match l with \n| [] -> l\n| h::t -> append t [h]", "let _ = listReverse [1; 2; 3; 4]"], "bad": ["let _ = listReverse [1; 2; 3; 4]"], "message": ["Error: Unbound value append\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse ([(n mod 10)] append digitsOfInt (n/10) )"], "bad": ["let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]", "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse ([n mod 10] append digitsOfInt (n/10) )", "let _ = digitsOfInt 3124"], "message": ["Error: Unbound value listReverse\n", "Error: Unbound value listReverse\n", "Error: Unbound value listReverse\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse (append [n mod 10] (digitsOfInt (n/10)) )", "let _ = digitsOfInt 3124"], "bad": ["let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse (append [n mod 10] digitsOfInt (n/10) )", "let _ = digitsOfInt 3124"], "message": ["Error: Unbound value listReverse\n", "Error: Unbound value listReverse\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = palindrome \"a\"", "let _ = palindrome \"malayalam\"", "let _ = palindrome \"myxomatosis\"", "type test = unit -> string", "let key        = \"\"", "let prefix130  = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")", "let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max"], "bad": ["let palindrome w = match w with \n| \"\" -> true\n| _ -> \nlet myString = explode w in\nlet reverseString = listReverse myString in\nif myString = reverseString\nthen true\nelse false", "let _ = palindrome \"malayalam\"", "let _ = palindrome \"myxomatosis\"", "let _ = palindrome \"\"", "let _ = palindrome \"a\""], "message": ["Error: Unbound value reverseList\n", "Error: Unbound value listReverse\n", "Error: Unbound value palindrome\n", "Error: Unbound value palindrome\n", "Error: Unbound value palindrome\n"], "problem": "palindrome"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)"], "bad": ["let fixpoint (f,b) = wwhile (fun x -> let b = (f x) in (b, b != x),b)"], "message": ["Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t  -> \"x\"\n| VarY\t\t  -> \"y\"\n| Sine(t)\t  -> (\"sin(pi*\"^(expr t)^\")\")\n| Cosine(t)\t  -> (\"cos(pi*\"^(expr t)^\")\")\n| Average(s, t) -> (\"((\"^(expr s)^\"+\"^(expr t)^\")/2)\" )\n| Times(s, t) -> ((expr s)^\"*\"^(expr t))\n| Thresh(s, t, u, v) -> (\"(\"^(expr s)^\"<\"^(expr t)^\"?\"^(expr u)^\":\"^(expr v)^\")\")"], "bad": ["let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t  -> \"x\"\n| VarY\t\t  -> \"y\"\n| Sine(t)\t  -> (\"sin(pi*\"^(expr t)^\")\")\n| Cosine(t)\t  -> (\"cos(pi*\"^(expr t)^\")\")\n| Average(s, t) -> (\"((\"^(ex s)^\"+\"^(ex t)^\")/2)\" )\n| Times(s, t) -> ((ex s)^\"*\"^(ex t))\n| Thresh(s, t, u, v) -> (\"(\"^(ex s)^\"<\"^(ex t)^\"?\"^(ex u)^\":\"^(ex v)^\")\")", "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t  -> \"x\"\n| VarY\t\t  -> \"y\"\n| Sine(t)\t  -> (\"sin(pi*\"^(expr t)^\")\")\n| Cosine(t)\t  -> (\"cos(pi*\"^(expr t)^\")\")\n| Average(s, t) -> (\"((\"^(expr s)^\"+\"^(expr t)^\")/2)\" )\n| Times(s, t) -> ((ex s)^\"*\"^(expr t))\n| Thresh(s, t, u, v) -> (\"(\"^(expr s)^\"<\"^(expr t)^\"?\"^(expr u)^\":\"^(expr v)^\")\")"], "message": ["Error: Unbound value ex\n", "Error: Unbound value ex\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"\n| Sine a\t      -> (\"sin(pi*\"^(expr a)^\")\")\n| Cosine a\t      -> (\"cos(pi*\"^(expr a)^\")\")\n| Average (a, b)      -> (\"((\"^(expr a)^\"+\"^(expr b)^\")/2)\" )\n| Times (a, b)\t      -> ((expr a)^\"*\"^(expr b))\n| Thresh (a, b, c, d) -> (\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\")"], "bad": ["let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"\n| Sine a\t      -> (\"sin(pi*\"^(expr a)^\")\")\n| Cosine a\t      -> (\"cos(pi*\"^(expr a)^\")\")\n| Average a, b        -> (\"((\"^(expr a)^\"+\"^(expr b)^\")/2)\" )\n| Times a, b\t      -> ((expr a)^\"*\"^(expr b))\n| Thresh a, b, c, d   -> (\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\")"], "message": ["Error: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type expr\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = \nmatch (f, b) with\n| (b', y) -> \nif y = false\nthen b'\nelse wwhile (f, b')"], "bad": ["let rec wwhile (f,b) = \nlet check = (f, b') in\nmatch check with\n| (b', y) -> \nif y = false\nthen b'\nelse wwhile (f, b')", "let rec wwhile (f,b) = \nlet check = (f b') in\nmatch check with\n| (b', y) -> \nif y = false\nthen b'\nelse wwhile (f, b')", "let rec wwhile (f,b) = \nlet check = (f b') in\nmatch check with\n| (b', y) -> \nif y = false\nthen b'\nelse wwhile (f, b')"], "message": ["Error: Unbound value b'\n", "Error: Unbound value b'\n", "Error: Unbound value b'\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = \nmatch (f, b) with\n| (x, y) -> \nif y = false\nthen x\nelse wwhile (f, x)"], "bad": ["let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "message": ["Error: This expression has type int -> int * bool\n       but an expression was expected of type bool\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = \nlet check = (f b) in\nmatch check with\n| (x, y) -> \nif y = false\nthen x\nelse wwhile (f, x)"], "bad": ["let rec wwhile (f,b) = \nlet check = (f b) in\nmatch (f, b) with\n| (x, y) -> \nif y = false\nthen x\nelse wwhile (f, x)"], "message": ["Error: This expression has type bool -> 'a\n       but an expression was expected of type bool\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((fun x ->\nlet b = (f x) in\n(b, b != x)),b)"], "bad": ["let fixpoint (f,b) = wwhile (fun x \nlet b = (f x) in\n(b, b != x),b)", "let fixpoint (f,b) = wwhile (fun x ->\nlet b = (f x) in\n(b, b != x),b)", "let fixpoint (f,b) = wwhile (fun x ->\nlet b = (f x) in\n(b, b != x),b)"], "message": ["Error: Syntax error: operator expected.\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": [" _ = fixpoint (collatz, 3)"], "message": ["Error: Syntax error\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"  \n| Sine a\t      -> \"sin(pi*\"^(expr a)^\")\"\n| Cosine a\t      -> \"cos(pi*\"^(expr a)^\")\"\n| Average (a, b)      -> \"((\"^(expr a)^\"+\"^(expr b)^\")/2)\"\n| Times (a, b)\t      -> (expr a)^\"*\"^(expr b)\n| Thresh (a, b, c, d) -> \n\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\""], "bad": ["let rec exprToString e = \n(*let expr = exprToString in*)\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"  \n| Sine a\t      -> \"sin(pi*\"^(expr a)^\")\"\n| Cosine a\t      -> \"cos(pi*\"^(expr a)^\")\"\n| Average (a, b)      -> \"((\"^(expr a)^\"+\"^(expr b)^\")/2)\"\n| Times (a, b)\t      -> (expr a)^\"*\"^(expr b)\n| Thresh (a, b, c, d) -> \n\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\""], "message": ["Error: Unbound value expr\nHint: Did you mean exp?\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)"], "bad": [" _ = fixpoint (collatz, 9001)", " _ = fixpoint (collatz, 9001)", " g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = \nif l = [] then d else\nmatch l with h::t ->\nmatch h with (a, b) ->\nif a = k then b\nelse assoc (d, k, t)"], "bad": ["let rec assoc (d,k,l) = \nmatch dkl with (d, k, l) ->\nif l = [] then d else\nmatchl", "with h::t ->\nmatch h with (a, b) ->\nif a = k then b\nelse assoc (d, k, t)", "let rec assoc (d,k,l) = \nif l = [] then d else\nmatchl", "with h::t ->\nmatch h with (a, b) ->\nif a = k then b\nelse assoc (d, k, t)"], "message": ["Error: Unbound value dkl\n", "Error: Syntax error\n", "Error: Unbound value matchl\n", "Error: Syntax error\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) =\nmatch (d, k, l) with\n| (d, k, l) ->\nif l = [] \nthen d\nelse\nmatch l with h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)"], "bad": ["let rec assoc (d,k,l) =\nmatch (d, k, l) with\n| [] -> 0\n| (d, k, l) ->\nif l = [] \nthen d\nelse\nmatch l with h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)"], "message": ["Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b * 'c * 'd\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = \nlet check = (f b) in\nmatch check with\n| (x', y) -> \nif y = false\nthen x'\nelse wwhile (f, x')"], "bad": ["let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "message": ["Error: This expression has type int -> int * bool\n       but an expression was expected of type bool\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = if depth > 0 then \n\nlet r = (rand (0, 5)) in \nlet d = (depth - 1) in \n\nmatch r with\n| 0 -> buildSine((build (rand, d)))\n| 1 -> buildCosine((build (rand, d)))\n| 2 -> buildAverage((build (rand, d)), (build (rand, d)))\n| 3 -> buildTimes((build (rand, d)), (build (rand, d)))\n| 4 -> buildThresh((build (rand, d)), (build (rand, d)), (build (rand, d)), (build (rand, d)))\n\nelse \n\nlet r = (rand (0, 2)) in \n\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()"], "bad": ["let g1 () = build (2, 2)", "let g2 () = build (2, 5)", "let g1 () = build (rand(0, 5), 2)"], "message": ["Error: This expression has type int but an expression was expected of type\n         int * int -> int\n", "Error: This expression has type int but an expression was expected of type\n         int * int -> int\n", "Error: Unbound value rand\nHint: Did you mean land?\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n(eval(a, x, y) *. eval(a, x, y)) +. (eval(b, x, y) *. eval(c, x, y))\n| Tan a -> sin (pi *. eval(a, x, y)) /. cos (pi *. eval(a, x, y))"], "bad": ["let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n(eval(a, x, y) *. eval(a, x, y)) + (eval(b, x, y) *. eval(c, x, y))", "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n(eval(a, x, y) * eval(a, x, y)) + (eval(b, x, y) *. eval(c, x, y))", "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n(eval(a, x, y) *. eval(a, x, y)) +. (eval(b, x, y) *. eval(c, x, y))"], "message": ["Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type float\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nif depth < 0 \nthen \nlet r = (rand (0, 2)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\nelse \nlet d = depth - 1 in \nmatch rand(0, 7) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| 5 -> buildPoly(build (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| 6 -> buildTan( build (rand, d))\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up \"", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let g1 () =  (1 ,4, 16)", "let g2 () =  (3 ,9,27)", "let g3 () =  (4,16, 64)", "let c1 () = (5,7,10)", "let c2 () = (6,7,8)", "let c3 () = (6,7,8)", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type test = unit -> string", "let key = \"\"", "let prefix130 = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")", "let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0", "let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)", "let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))", "let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p", "let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max"], "bad": ["let rec build (rand, depth) = \nif depth < 0 \nthen \nlet r = (rand (0, 2)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\nelse \nlet d = depth - 1 in \nmatch rand(0, 7) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| 5 -> buildPoly(build (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| 6 -> buildTan( build (rand, d))\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up \""], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"], "problem": "build"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun b -> x(a b) in\nlet base = fun x -> x in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "bad": ["let pipe fs = \nlet f a x = fun b -> x(a y) in\nlet base = fun x -> x in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "message": ["Error: Unbound value y\n", "Error: Unbound value pipe\n", "Error: Unbound value pipe\n", "Error: Unbound value pipe\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\""], "bad": ["let stringOfList f l = \"[\" ^ (sep \"; \" (List.map f l)) & \"]\"", "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) & \"]\""], "message": ["Error: Unbound value sep\n", "Error: This expression has type string but an expression was expected of type\n         bool\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (l1, l2)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)"], "bad": ["let padZero l1 l2 = \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (a, b)\nelse if a < b\nthen (clone 0 (a - b) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)", "let padZero l1 l2 = \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (a, b)\nelse if a < b\nthen ((clone 0 (a - b) @ l1), l2)\nelse (l1, clone 0 (a - b) @ l2)", "let padZero l1 l2 = \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (a, b)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)", "let padZero l1 l2 = \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (a, b)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (x1, x2) = x in\nlet res = x1 + x2 + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n| h::t -> (newCarry, newCarry :: res mod 10 :: t) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet c = fst x + snd x in\nmatch a with\n| h::t -> (h+c)/10::(h+c mod 10) :: t\n| _ -> (c/10)::[c mod 10] in\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (x1, x2) = x in\nlet res = x1 + x2 + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry : res mod 10 : [])\n|h::t -> (newCarry, newCarry :: res mod 10 :: t) in\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (x1, x2) = x in\nlet res = x1 + x2 + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 : [])\n|h::t -> (newCarry, newCarry :: res mod 10 :: t) in\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (x1, x2) = x in\nlet res = x1 + x2 + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n|h::t -> (newCarry, newCarry :: res mod 10 :: t) in\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (x1, x2) = x in\nlet res = x1 + x2 + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n| h::t -> (newCarry, newCarry :: res mod 10 :: t) \nin\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (x1, x2) = x in\nlet res = x1 + x2 + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n| h::t -> (newCarry, newCarry :: res mod 10 :: t) \nin\nlet base = [] in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type 'a list\n       but an expression was expected of type int * int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int * int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int * int list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if List.length l1 < List.length l2\nthen (clone 0 (List.length l2 - List.length l1)) @ l1, l2\nelse l1, (clone 0 (List.length l1 - List.length l2)) @ l2"], "bad": ["let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if List.length l1 < List.length l2\nthen clone 0 (List.length l2 - List.length l1) @ l1, l2\nelse l1, clone 0 (List.length l1 - List.length l2 @ l2)", "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if List.length l1 < List.length l2\nthen (clone 0 (List.length l2 - List.length l1) @ l1, l2)\nelse l1, clone 0 (List.length l1 - List.length l2 @ l2)", "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if List.length l1 < List.length l2\nthen (clone 0 (List.length l2 - List.length l1)) @ l1, l2\nelse l1, clone 0 (List.length l1 - List.length l2 @ l2)"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = let (b, c) = a in\nlet (_, d) = x in\nlet res = bigAdd (mulByDigit d l1 @ clone 0 b) c in\n(b + 1, res)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = let a = (b, c)  in\nlet x = (_, d) in\nlet y = bigAdd (mulByDigit d l1 @ clone c b) c in\n(b + 1, c)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = let a = (b, c)  in\nlet  (_, d) = x in\nlet y = bigAdd (mulByDigit d l1 @ clone c b) c in\n(b + 1, c)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = let (b, c) = a in\nlet  (_, d) = x in\nlet y = bigAdd (mulByDigit d l1 @ clone c b) c in\n(b + 1, c)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: Syntax error: operator expected.\n", "Error: Unbound value b\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value b\n", "Error: This expression has type int but an expression was expected of type\n         int list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = let (b, c) = a in\nlet (_, d) = x in\nlet e = bigAdd (mulByDigit d l1 @ clone 0 b) c in\n(b + 1, e)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = let a = (b, c) in\nlet x = (_, d) in\nlet e = bigAdd (mulByDigit d l1 @ clone 0 b) c in\n(b + 1, e)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (b, c) = x in\nlet res = b + c + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n| h::t -> (newCarry, newCarry :: res mod 10 :: t) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (b, c) = x in\nlet res = x + x + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n| h::t -> (newCarry, newCarry :: res mod 10 :: t) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (addC, resOfAdd) = a in\nlet (i1, i2) = x in\nlet result = i1 + i2 + addC in\nlet nextCarry = result / 10 in\nmatch resOfAdd with \n| [] -> (nextCarry, [nextCarry] @ [result mod 10] @ [])\n| h::t -> (nextCarry, [nextCarry] @ [result mod 10] @ t) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (addC, resOfAdd) = a in\nlet (i1, i2) = x in\nlet result = i1 + i2 + addC in\nlet nextCarry = result / 10 in\nmatch resOfAdd with \n| [] -> (nextCarry, nextCarry @ [result mod 10] @ [])\n| h::t -> (nextCarry, nextCarry @ [result mod 10] @ t) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = let (b, c) = a in\nlet (_, d) = x in\nlet e = bigAdd (mulByDigit d l1 @ clone 0 b) c in\n(b + 1, e)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in\nlet (_, res) = List.fold_left f base args in\nres", "let _ = bigMul [9;9;9;9] [9;9;9;9]", "let _ = bigMul [] [0]", "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"], "bad": ["let bigMul l1 l2 = \nlet f a x = let (b, c) = a in\nlet (_, d) = x in\nlet e = bigAdd (mulByDigit d l1 @ clone 0 b) c in\n(b + 1, e)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) List.rev l2  in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This function has type 'a list -> 'b list -> ('a * 'b) list\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type 'a list -> 'b list -> ('a * 'b) list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "bigMul"}
{"hw": "hw1", "fix": ["let rec sumList xs = match xs with\n[] ->0\n| h::t -> h + t", "let _ = sumList [1; 2; 3; 4]"], "bad": ["let rec sumList xs = function [] -> int", "let rec sumList xs = \n[] -> 0\n| h::t -> h + t", "let rec sumList xs = [] -> 0\n| h::t -> h + t", "let rec sumList xs = [] -> 0\n| h::t -> h + t"], "message": ["Error: Unbound value int\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let rec sumList xs = \nList.fold_left (+) xs"], "bad": ["let rec sumList xs = match xs with\n[] ->0\n| h::t -> h + t in xs", "let rec sumList xs = function (*failwith \"TBD:sumList\"*)\nList.fold_left (+) xs"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: Syntax error\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let rec sumList xs = match xs with\n[] -> 0"], "bad": ["let rec sumList xs = match xs with\n| [] -> 0\n| x :: xs -> List.fold_left x + xs"], "message": ["Error: This expression has type 'a -> 'b list -> 'a\n       but an expression was expected of type int\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let rec sumList xs = match xs with\n[] -> 0\n| h::t -> 1"], "bad": ["let rec sumList xs = match xs with\n[] -> 0\n| h::t -> h + sum t", "let rec sumList xs = match xs with\n[] -> 0\n| h::t in xs -> h + sum t"], "message": ["Error: Unbound value sum\n", "Error: Syntax error: pattern expected.\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs"], "bad": ["let rec sumList xs = match xs with\n[] -> int\n| h::t -> 1", "let rec sumList xs = \n[] -> res + 0\n| x :: xs -> x + sumList xs", "let rec sumList xs = \n[] -> 0\n| x :: xs -> x + sumList xs", "let rec sumList xs = \n[] -> 0\n| x :: xs -> x + sumList xs", "let rec sumList xs = \n[] -> 0\n| x :: xs -> x + sumList xs"], "message": ["Error: Unbound value int\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = match n with\n0 -> []\n| n -> n / 10 :: digitsOfInt n"], "bad": ["let rec digitsOfInt n = match n with\n0 -> []\n| n -> n / 10 ::[] digitsOfInt n"], "message": ["Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\nif n < 0 then []\nelse match n /10 with\n0 -> [0]\n| _ -> digitsOfInt n"], "bad": ["let rec digitsOfInt n =\nif n < 0 then -> []\nelse n -> n / 10 ::[] digitsOfInt n", "let rec digitsOfInt n =\nif n < 0 then []\nelse n / 10 ::[] digitsOfInt n", "let rec digitsOfInt n =\nif n < 0 then []\nelse match n /10 with\n0 -> [0]\n| _ -> digitsOfIn n []", "let rec digitsOfInt n =\nif n < 0 then []\nelse match n /10 with\n0 -> [0]\n| _ -> digitsOfInt n []"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value digitsOfIn\nHint: Did you mean digitsOfInt?\n", "Error: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt (-1)"], "bad": ["let _ = digitsOfInt 0"], "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 0", "let _ = digitsOfInt (-1)", "let _ = digitsOfInt 3124"], "bad": ["let rec digitsOfInt n =\nif n < 0 then []\nelse match (n mod 10) with\n_ -> _::[] digitsOfInt (n / 10)", "let rec digitsOfInt n =\nif n < 0 then []\nelse match (n mod 10) with\n_ -> digitsOfInt (n/10)::[]", "let rec digitsOfInt n =\nif n < 0 then []\nelse match (n mod 10) with\n_ -> digitsOfInt (n/10) ::[]", "let rec digitsOfInt n =\nif n < 0 then []\nelse digitOfInt (n/10) :: []", "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10) :: []", "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10)"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: Unbound value digitOfInt\nHint: Did you mean digitsOfInt?\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 0"], "bad": ["let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = match n with\n0 -> [0]\n| _ -> loop (n/10) (n mod 10)", "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = \nif n = 0 then x\nelse\n(n mod 10)::x\nmatch n with \n0 -> [0]\n| x -> loop n []", "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = \nif n = 0 then x\nelse loop (n/10) (n mod 10::x) in match n with\n0 -> [0]\n| _ -> loop n []"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = sumList [1; 3; 5; 7; 9; 11]", "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = \nif n = 0 then x\nelse match n with\n0 -> [0]\n| _ -> loop (n/10) (n mod 10::[])"], "bad": ["let _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(* `digitsOfInt n` should return `[]` if `n` is not positive,\nand otherwise returns the list of digits of `n` in the \norder in which they appear in `n`. *)\n\n(* digitsOfInt : int -> int list  *)\n(1 mod 10 ::4)", "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = \nif n = 0 then x\nelse match n with\n0 -> [0]\n| _ -> loop (n/10) (n mod 10::[])"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10 + n mod 10) (1+x) in match n with \n0 -> 0\n| _ -> 1"], "bad": ["let rec additivePersistence n = \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10 + n mod 10) x in match n with\n0 -> 0\n_ -> x + 1", "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10 + n mod 10) (1+x) in match n with \n0 -> 0\n_ -> 1", "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10 + n mod 10) (1+x) in match n with \n0 -> 0\n| _ -> 1"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let _ = additivePersistence 12"], "bad": ["let _ additivePersistence 0", "let _ = additivePersistence 0"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "let _ = sumList []", "let _ = sumList [1]", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]", "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec r_digitsOfInt n x = \nif n = 0 then x\nelse r_digitsOfInt (n/10) (n mod 10::x) \nin match n with\n0 -> [0]\n| _ -> r_digitsOfInt n []", "let _ = digitsOfInt 0", "let _ = digitsOfInt (-1)", "let _ = digitsOfInt 1", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let digits n = digitsOfInt (abs n)", "let _ = digits (-1234)", "let _ = digits 0", "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec r_addPersist n x =\nif n = 0 then x\nelse r_addPersist (n/10) (1+x) \nin match n with \n0 -> 0\n| _ -> r_addPersist n (-1)", "let _ = additivePersistence 0", "let _ = additivePersistence 12", "let _ = additivePersistence 9876", "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n < 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 0\n| _ -> r_digitalRoot n 0"], "bad": ["let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n = 0 then m\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> m\n| - -> r_digitalRoot n 0", "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n = 0 then m\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> m\n| _ -> r_digitalRoot n 0", "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n = 0 then m\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> r_digital root m 0\n| _ -> r_digitalRoot n 0", "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n = 0 then m\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> r_digitalRoot m 0\n| _ -> r_digitalRoot n 0", "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n < then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 0\n| _ -> r_digitalRoot n m", "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n < 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 0\n| _ -> r_digitalRoot n m"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value m\n", "Error: Unbound value r_digital\n", "Error: Unbound value m\n", "Error: Syntax error\n"], "problem": "digitalRoot"}
{"hw": "hw1", "fix": ["let _ = digitalRoot 0", "let _ = digitalRoot 1"], "bad": ["let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif n <= 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 123\n| _ -> r_digitalRoot n (-1)"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "problem": "digitalRoot"}
{"hw": "hw1", "fix": ["let rec sumList xs = \nmatch xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "let _ = sumList []", "let _ = sumList [1]", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]", "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec r_digitsOfInt n x = \nif n = 0 then x\nelse r_digitsOfInt (n / 10) (n mod 10 :: x) \nin match n with\n0 -> [0]\n| _ -> r_digitsOfInt n []", "let _ = digitsOfInt 0", "let _ = digitsOfInt (-1)", "let _ = digitsOfInt 1", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let digits n = digitsOfInt (abs n)", "let _ = digits (-1234)", "let _ = digits 0", "let rec additivePersistence n = \nif n <= 9 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 then x\nelse if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)\nelse r_addPersist (n / 10) (n mod 10 + m) x\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 1", "let _ = additivePersistence 0", "let _ = additivePersistence 1", "let _ = additivePersistence 12", "let _ = additivePersistence 8888", "let _ = additivePersistence 9876", "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif (n + m) <= 9 then n + m\nelse if (n = 0) && (m > 9) then r_digitalRoot m 0\nelse r_digitalRoot (n / 10) (n mod 10 + m)\nin match n with\n0 -> 0\n| _ -> r_digitalRoot n 0", "let _ = digitalRoot 0", "let _ = digitalRoot 1", "let _ = digitalRoot 12", "let _ = digitalRoot 66", "let _ = digitalRoot 9876", "let _ = digitalRoot 8888", "let rec listReverse l = \nmatch l with\n[] -> []\n| h::t -> listReverse t @ h"], "bad": ["let rec listReverse l =\nif l = [] then []\nelse let rec r_listReverse l x = match l with\n[] -> []\n| h::t -> r_listReverse t []::h", "let rec listReverse l =\nif l = [] then []\nelse let rec r_listReverse l x = match l with\n[] -> []\n| h::t -> r_listReverse t h::[]", "let rec listReverse l = match l with\n[] -> []\n| h::t -> listReverse t ::h", "let rec listReverse l = \nmatch l with\n[] -> []\n| h::t -> listReverse t @ h"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4]"], "bad": ["let rec listReverse l = \nmatch l with\n[] -> []\n| h::t -> listReverse t @ h::[]"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 0"], "bad": ["let rec digitsOfInt n = \nif n < 0 then []\nelse\nmatch n with \n0 -> [0]\n| _ -> digitsOfInt (n / 10) @ (n mod 10)::[]"], "message": ["Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse let rec r_digitsOfInt n x = \nif n = 0 then x\nelse r_digitsOfInt (n / 10) (n mod 10 :: [])", "let _ = digitsOfInt 0", "let _ = digitsOfInt (-1)", "let _ = digitsOfInt 1"], "bad": ["let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10)::[]"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10)::[] \nin match n with \n0 -> [0]\n| _ -> digitsOfInt n @ []", "let _ = digitsOfInt 0", "let _ = digitsOfInt (-1)", "let _ = digitsOfInt 1"], "bad": ["let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10)::[]"], "message": ["Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec sumList xs = \nmatch xs with \n[] -> 0\n| h::t -> h + sumList t", "let _ = sumList []", "let _ = sumList [1]", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]", "let rec digitsOfInt n = \nif n < 0 then []\nelse let rec r_digitsOfInt n x = \nif n = 0 then x\nelse r_digitsOfInt (n / 10) (n mod 10 :: x) \nin match n with\n0 -> [0]\n| _ -> r_digitsOfInt n []", "let _ = digitsOfInt 0", "let _ = digitsOfInt (-1)", "let _ = digitsOfInt 1", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let digits n = digitsOfInt (abs n)", "let _ = digits (-1234)", "let _ = digits 0", "let rec additivePersistence n = \nif n <= 9 then 0\nelse let rec r_addPersist n m x =\nif (n + m) <= 9 then x\nelse if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)\nelse r_addPersist (n / 10) (n mod 10 + m) x\nin match n with \n0 -> 0\n| _ -> r_addPersist n 0 1", "let _ = additivePersistence 0", "let _ = additivePersistence 1", "let _ = additivePersistence 12", "let _ = additivePersistence 8888", "let _ = additivePersistence 9876", "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif (n + m) <= 9 then n + m\nelse if (n = 0) && (m > 9) then r_digitalRoot m 0\nelse r_digitalRoot (n / 10) (n mod 10 + m)\nin match n with\n0 -> 0\n| _ -> r_digitalRoot n 0", "let _ = digitalRoot 0", "let _ = digitalRoot 1", "let _ = digitalRoot 12", "let _ = digitalRoot 66", "let _ = digitalRoot 9876", "let _ = digitalRoot 8888", "let rec listReverse l = \nmatch l with\n[] -> []\n| h::t -> listReverse t @ h::[]", "let _ = listReverse []", "let _ = listReverse [\"a\"]", "let _ = listReverse [1; 2; 3; 4]", "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]", "let _ = listReverse [1; 2]", "let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0", "let palindrome w = match w with\n[] -> true\n| _ -> false", "type test = unit -> string", "let key        = \"\"", "let prefix130  = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")", "let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max"], "bad": ["let palindrome w = \nlet orig_Esplode = esplode w and\nlet reverse_Esplode = explode reverseList w", "let palindrome w = \norig_Esplode = esplode w", "let palindrome w = \nif w = [] then true\nelse\nlet orig_Esplode = esplode w and\nlet reverse_Esplode = explode reverseList w in \nlet rec r_palindrome orig_Esplode revserse_Esplode = \nlet h1 = h::orig_Esplode \nand h2 = h::reverse_Esplode\nif h1 = h2 then r_panlindrome orig_Esplode reverse_Esplode\nelse false", "let palindrome w = \nif w = [] then true\nelse\nlet rec r_palindrome esplode w esplode reverseList w = true", "let palindrome w = \nif w = [] then true", "let palindrome w = match w with\n[] -> true\n| _ -> false"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value orig_Esplode\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This variant expression is expected to have type unit\n       The constructor true does not belong to type unit\n"], "problem": "palindrome"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 0"], "bad": ["let rec digitsOfInt n = \nmatch n with\n| [] -> []\n| 0 -> [0]\n| _ -> digitsOfInt (n / 10) @ (n mod 10)", "let rec digitsOfInt n = \nif n < 0 then []\nelse\nmatch n with \n| 0 -> [0]\n| _ -> digitsOfInt (n / 10) @ (n mod 10)", "let rec digitsOfInt n = \nif n < 0 then []\nelse\nmatch n with \n| 0 -> [0]\n| _ -> digitsOfInt (n / 10) :: (n mod 10)", "let rec digitsOfInt n = \nif n < 0 then []\nelse\nmatch n with \n| 0 -> [0]\n| _ -> digitsOfInt (n / 10) :: (n mod 10 ::[])", "let rec digitsOfInt n = \nif n < 0 then []\nelse\nmatch n with \n| 0 -> [0]\n| _ -> digitsOfInt (n / 10) @ (n mod 10 ::[])"], "message": ["Error: Syntax error\n", "Error: This pattern matches values of type int\n       but a pattern was expected which matches values of type 'a list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse match n with \n| 0 -> [0]\n| _ -> \nif (n /10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])\nelse []"], "bad": ["let rec digitsOfInt n = \nif n < 0 then []\nelse match n with \n| 0 -> [0]\n| _ -> \nif (n /10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])\nelse []"], "message": ["Error: This expression has type int list\n       but an expression was expected of type unit\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = additivePersistence 0", "let _ = additivePersistence 1"], "bad": ["let rec additivePersistence n = \nif sumList (digitsOfInt n) < 9 then 0\nelse 1 + additivePersistence sumList n", "let rec additivePersistence n = \nif sumList (digitsOfInt n) < 9 then 0\nelse 1 + additivePersistence (sumList n)", "let rec additivePersistence n = \nif sumList (digitsOfInt n) < 9 then 0\nelse 1 + additivePersistence (sumList (digitsOfInt n))"], "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let _ = digitalRoot 0", "let _ = digitalRoot 1", "let _ = digitalRoot 12", "let _ = digitalRoot 66", "let _ = digitalRoot 9876", "let _ = digitalRoot 8888"], "bad": ["let rec digitalRoot n = \nif n <= 9 then n\nelse if sumList (digitsOfInt n) < 9 then sumList (digitsOfInt n)\nelse digitalRoot (sumList (digitsOfInt n))"], "message": ["Error: Syntax error\n"], "problem": "digitalRoot"}
{"hw": "hw1", "fix": ["let palindrome w = \nmatch w with \n| [] -> true\n| _  -> \nlet ex = esplode w in \nlet rec r_palindrome ex = match ex with\n| [] -> true\n| h1::t1 -> false"], "bad": ["let palindrome w = \nmatch w with \n| [] -> true\n| _  -> \nlet rec r_palindrome w = \nmatch w with\n| [] -> true\n| h1::t1 -> \nmatch reverseList t1 with\n| h2::t2 ->\nif h1 = h2 then r_palindrome t2\nelse false", "let palindrome w = \nmatch w with \n| [] -> true\n| _  -> \nlet rec r_palindrome w = \nmatch w with\n| [] -> true\n| h1::t1 -> \nmatch reverseList t1 with\n| h2::t2 ->\nif h1 = h2 then r_palindrome t2\nelse false\n| _ -> false", "let palindrome w = \nmatch w with \n| [] -> true\n| _  -> \nlet ex = esplode w in \nlet rec r_palindrome ex = match ex with\n| [] -> true\n| h1::t1 -> \nmatch reverseList t1 with\n| [] -> true\n| h2::t2 ->\nif h1 = h2 then r_palindrome t2\nelse false", "let palindrome w = \nmatch w with \n| [] -> true\n| _  -> false"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "palindrome"}
{"hw": "hw1", "fix": ["let _ = palindrome \"malayalam\"", "let _ = palindrome \"myxomatosis\""], "bad": ["let palindrome w = \nlet ex = esplode w in\nlet rev_ex = reverseList ex in\nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false", "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false in\nlet ex = esplode w in\nlet rev_ex = reverseList ex", "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false in\nlet rev_ex = reverseList ex in \nlet ex = esplode w", "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false in\nr_palindrome (esplode w) (reverseList (esplode w))", "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false in\nr_palindrome (esplode w) (reverseList (explode w))", "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false in\nr_palindrome (explode w) (reverseList (explode w))", "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false \nin\nr_palindrome (explode w) (reverseList (explode w))", "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false \nin\nr_palindrome (explode w) (listReverse (explode w))"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value esplode\nHint: Did you mean explode?\nError: Unbound value esplode\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value esplode\nHint: Did you mean explode?\n", "Error: Unbound value esplode\nHint: Did you mean explode?\n", "Error: Unbound value reverseList\n", "Error: Unbound value reverseList\n"], "problem": "palindrome"}
{"hw": "hw1", "fix": ["let append x l = match l with\n| [] -> x::[]\n| _ -> x :: l"], "bad": ["let rec append x l = match l with\n| [] -> []\n| h::t -> h :: (append t l)"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let _ = append [0] [1;2]"], "bad": ["let _ = append [0] [1;2]", "let append x l = match l with\n| [] -> x :: []\n| h::t -> x ::h::t"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let append x l = \nlet helper x l acc =\nmatch x with \n| [] -> l\n| h::t -> helper t l h::acc in\nhelper x l []"], "bad": ["let append x l = \nmatch x with \n| [] -> l\n| h::t -> h::t::l", "let rec append x l = \nmatch x with \n| [] -> l\n| h::t -> h::(rec t l)", "let rec append x l = \nmatch x with \n| [] -> l\n| h::t -> h::(append t l)"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: Syntax error: operator expected.\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let _ = append [0] [1;2]"], "bad": ["let append x l = \nlet rec helper x acc =\nmatch x with \n| [] -> acc\n| h::t -> (helper t (h::acc)) in\nhelper x l"], "message": ["Error: This expression has type 'a list -> 'b\n       but an expression was expected of type 'a list\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let _ = listReverse []", "let _ = listReverse [\"a\"]", "let _ = listReverse [1; 2; 3; 4]", "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]", "let _ = listReverse [1; 2]"], "bad": ["let rec listReverse l = \nmatch l with\n| [] -> []\n| h::t -> append (listReverse t) [h]"], "message": ["Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = append [0] [1;2]", "let _ = append [] [1]", "let _ = append [1;2;3] [1]"], "bad": ["let rec append x l = match x with\n| [] -> l\n| h::t -> h::(append t l)"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with \n| []   -> d\n| h::t -> match h with\n| (k1,v1) -> if k = k1 then v1\nelse assoc (d,k,t)"], "bad": ["let rec assoc (d,k,l) = match l with \n| []   -> d\n| h::t -> match h with\n| (k1,v1) -> if k = k1 then \nelse assoc (d,k,t)"], "message": ["Error: Syntax error\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen \nthen helper (seen, t) \nelse helper (h::seen, t) in\nlet rest' = helper (seen', t) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = if List.mem (h, seen) then helper (h::seen, t) in\nlet rest' = helper (seen', t) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = if List.mem h seen", ") then helper (h::seen, t) in\nlet rest' = helper (seen', t) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = if List.mem h seen then helper (h::seen, t) in\nlet rest' = helper (seen', t) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "message": ["Error: This expression has type ('a * 'b) list -> bool\n       but an expression was expected of type bool\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then\nseen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then\nseen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "message": ["Error: This expression has type 'a list -> bool\n       but an expression was expected of type bool\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen\nelse seen in \nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then h::seen", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen\nelse seen", "let rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1,1,2]"], "message": ["Error: Unbound value seen'\nHint: Did you mean seen?\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let _ = removeDuplicates [1,1,2]"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then h::seen\nelse seen", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen \nthen h::seen\nelse seen", "let rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = seen", "let rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = seen", "let rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let _ = removeDuplicates [1,1,2]"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen \nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type unit\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let f x = \nlet xx = x*x*x in (xx,xx<100)", "let _  = wwhile (f,2)"], "bad": ["let rec wwhile (f,b) =\nlet (b', c') = f b in \nmatch c' with\n| False -> b'\n| True  -> while (f, b')", "let rec wwhile (f,b) =\nlet (b', c') = f b in \nmatch c' with\n| False -> b'\n| True  -> wwhile (f, b')", "let rec wwhile (f,b) =\nlet (b', c') = f b in \nmatch c' with\n| false -> b'\n| true  -> wwhile (f, b')"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound constructor False\nHint: Did you mean false?\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "let _ = exprToString sampleExpr1"], "bad": ["let rec exprToString e = match e with\n| VarX                       -> \"x\"\n| VarY                       -> \"y\"\n| Sine  (ex)                 -> \"sin (pi*)\" ^ exprToString ex ^ \")\"\n| Cosine  (ex)               -> \"cos (pi*)\" ^ exprToString ex ^ \")\"\n| Average (ex1, ex2)         -> \"((\" ^ exprToSring ex1 ^ \" + \" ^ exprToString ex2 ^ \")/2)\" \n| Times (ex1, ex2)           -> exprToString expr1 ^ \" * \" ^ exprToString expr2\n| Thresh (ex1, ex2, ex3, ex4) -> \"(\" ^ exprToString expr1 ^ \"<\" ^ exprToString expr2 ^ \" ? \" ^ exprToString expr3 ^ \" : \" ^ exprToString expr4 ^ \")\"", "let rec exprToString e = match e with\n| VarX                       -> \"x\"\n| VarY                       -> \"y\"\n| Sine  (ex)                 -> \"sin (pi*)\" ^ exprToString ex ^ \")\"\n| Cosine  (ex)               -> \"cos (pi*)\" ^ exprToString ex ^ \")\"\n| Average (ex1, ex2)         -> \"((\" ^ exprToString ex1 ^ \" + \" ^ exprToString ex2 ^ \")/2)\" \n| Times (ex1, ex2)           -> exprToString expr1 ^ \" * \" ^ exprToString expr2\n| Thresh (ex1, ex2, ex3, ex4) -> \"(\" ^ exprToString expr1 ^ \"<\" ^ exprToString expr2 ^ \" ? \" ^ exprToString expr3 ^ \" : \" ^ exprToString expr4 ^ \")\"", "let rec exprToString e = match e with\n| VarX                       -> \"x\"\n| VarY                       -> \"y\"\n| Sine  (ex)                 -> \"sin (pi*)\" ^ exprToString ex ^ \")\"\n| Cosine  (ex)               -> \"cos (pi*)\" ^ exprToString ex ^ \")\"\n| Average (ex1, ex2)         -> \"((\" ^ exprToString ex1 ^ \" + \" ^ exprToString ex2 ^ \")/2)\" \n| Times (ex1, ex2)           -> exprToString ex1 ^ \" * \" ^ exprToString ex2\n| Thresh (ex1, ex2, ex3, ex4) -> \"(\" ^ exprToString expr1 ^ \"<\" ^ exprToString expr2 ^ \" ? \" ^ exprToString expr3 ^ \" : \" ^ exprToString expr4 ^ \")\"", "let rec exprToString e = match e with\n| VarX                       -> \"x\"\n| VarY                       -> \"y\"\n| Sine  (ex)                 -> \"sin (pi*)\" ^ exprToString ex ^ \")\"\n| Cosine  (ex)               -> \"cos (pi*)\" ^ exprToString ex ^ \")\"\n| Average (ex1, ex2)         -> \"((\" ^ exprToString ex1 ^ \" + \" ^ exprToString ex2 ^ \")/2)\" \n| Times (ex1, ex2)           -> exprToString ex1 ^ \" * \" ^ exprToString ex2\n| Thresh (ex1, ex2, ex3, ex4) -> \"(\" ^ exprToString ex1 ^ \"<\" ^ exprToString ex2 ^ \" ? \" ^ exprToString ex3 ^ \" : \" ^ exprToString ex4 ^ \")\""], "message": ["Error: This variant pattern is expected to have type expr\n       The constructor Tresh does not belong to type expr\nHint: Did you mean Thresh?\n", "Error: Unbound value exprToSring\nHint: Did you mean exprToString?\n", "Error: Unbound value expr1\nHint: Did you mean expm1?\n", "Error: Unbound value expr1\nHint: Did you mean expm1?\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr,0.5,0.2)"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex) -> sin(pi * (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi * eval (ex,x,y))\n| Average (ex1, ex2) -> (eval (ex1,x,y) + eval (ex2,x,y) )/ 2\n| Times (ex1, ex2) -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1, ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> let ex1 = eval(ex,x,y) in sin(pi * ex1)\n| Cosine (ex) -> cos(pi * eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y) )/ 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi * (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi * eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y)) / 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y)) / 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y)) / 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) / 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) /. 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) / 2.\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) /. 2.\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) /. 2.\n| Times (ex1,ex2)   -> eval (ex1,x,y) *. eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"], "message": ["Error: Syntax error\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nif depth = 0 then \nlet x = rand(0,1) in\nmatch x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand (0,4) in match r with\n| 0 -> buildSine(build (rand, depth-1))\n| 1 -> buildCosine( build (rand, depth-1))\n| 2 -> buildAverage( build (rand, depth -1), build (rand, depth -1))\n| 3 -> buildTimes( build (rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))"], "bad": ["let rec build (rand, depth) = \nif depth = 0 then \nlet x = rand(0,1) in\nmatch x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand (1,5) in match r with\n| 1 -> buildSine(build (rand, depth-1))\n| 2 -> buildCosine( build (rand, depth-1))\n| 3 -> buildAverage( build (rand, depth -1), build (rand, depth -1))\n| 4 -> buildTimes( build (rand, depth-1), build(rand, depth-1))\n| 5 -> buildTresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))", "let rec build (rand, depth) = \nif depth = 0 then \nlet x = rand(0,1) in\nmatch x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand (1,5) in match r with\n| 1 -> buildSine(build (rand, depth-1))\n| 2 -> buildCosine( build (rand, depth-1))\n| 3 -> buildAverage( build (rand, depth -1), build (rand, depth -1))\n| 4 -> buildTimes( build (rand, depth-1), build(rand, depth-1))\n| 5 -> buildThresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))"], "message": ["Error: Syntax error\n", "Error: Unbound value buildTresh\nHint: Did you mean buildThresh?\nError: Unbound value buildTresh\nHint: Did you mean buildTimes?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value buildTresh\nHint: Did you mean buildThresh?\n"], "problem": "build"}
{"hw": "hw2", "fix": ["assoc\n(-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "bad": ["assoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with \n| []   -> d\n| h::t -> match h with\n| (k1,v1) -> \nif k = k1 then v1\nelse assoc (d,k,t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen \nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) = \nlet (b', c') = f b in \nmatch c' with\n| false -> b'\n| true  -> wwhile (f, b')", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) = \nlet f x = \nlet c = f x in (c, c != x) in\nwwhile (f, b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)", "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "let rec exprToString e = match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"", "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "let _ = exprToString sampleExpr1", "let buildX()                       = VarX", "let buildY()                       = VarY", "let buildSine(e)                   = Sine(e)", "let buildCosine(e)                 = Cosine(e)", "let buildAverage(e1,e2)            = Average(e1,e2)", "let buildTimes(e1,e2)              = Times(e1,e2)", "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "let pi = 4.0 *. atan 1.0", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (e)   -> sin(pi *. (eval (e,x,y)))\n| Cosine (e) -> cos(pi *. eval (e,x,y))\n| Average (e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\n| Times (e1,e2)   -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2, e3, e4) -> if eval (e1,x,y) < eval (e2,x,y) then eval (e3,x,y) else eval (e4,x,y)", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "let _ = eval (sampleExpr,0.5,0.2)", "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "let rec build (rand, depth) = \nif depth = 0 then \nlet x = rand(0,2) in\nmatch x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand (0,5) in match r with\n| 0 -> buildSine(build (rand, depth-1))\n| 1 -> buildCosine( build (rand, depth-1))\n| 2 -> buildAverage( build (rand, depth -1), build (rand, depth -1))\n| 3 -> buildTimes( build (rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))", "let g1 () = (3, 1, 8)", "let g2 () = (11, 2, 13)", "let g3 () = (4, 1, 2)", "let c1 () = (9, 3, 9)", "let c2 () = (9, 2, 3)", "let c3 () = (10, 1, 12)", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type test = unit -> string", "let key = \"\"", "let prefix130 = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")", "let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0", "let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)", "let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))", "let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p", "let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max"], "bad": ["let rec build (rand, depth) = \nif depth = 0 then \nlet x = rand(0,1) in\nmatch x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand (0,4) in match r with\n| 0 -> buildSine(build (rand, depth-1))\n| 1 -> buildCosine( build (rand, depth-1))\n| 2 -> buildAverage( build (rand, depth -1), build (rand, depth -1))\n| 3 -> buildTimes( build (rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))"], "message": ["Error: Unbound value rand\nHint: Did you mean land?\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "let _ = exprToString sampleExpr1", "let _ = exprToString (NewExprA(VarX,VarY), 1, 1)"], "bad": ["let rec exprToString e = match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" exprToString e1 ^ \":\" exprToString e2\n| NewExprB (e1,e2,e3) -> \"(\" exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" ^ exprToString ex ^ \")\"", "let rec exprToString e = match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" ^ exprToString e1 ^ \":\" exprToString e2\n| NewExprB (e1,e2,e3) -> \"(\" exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" ^ exprToString ex ^ \")\"", "let rec exprToString e = match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" ^ exprToString e1 ^ \":\" ^ exprToString e2\n| NewExprB (e1,e2,e3) -> \"(\" exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" ^ exprToString ex ^ \")\"", "let rec exprToString e = match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" ^ exprToString e1 ^ \":\" ^ exprToString e2\n| NewExprB (e1,e2,e3) -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" ^ exprToString ex ^ \")\"", "let rec exprToString e = match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" ^ exprToString e1 ^ \":\" ^ exprToString e2\n| NewExprB (e1,e2,e3) -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" ^ exprToString e3 ^ \")\""], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: Unbound value ex\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" ^ exprToString e1 ^ \":\" ^ exprToString e2 ^ \")\"s\n| NewExprB (e1,e2,e3) -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" ^ exprToString e3 ^ \")\""], "bad": ["let _ = exprToString (NewExprA(VarX,VarY))"], "message": ["Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let _ = eval (NewExprA(VarX, VarY), -1., 1.)"], "bad": ["let _ = eval (NewExprA(VarX, VarY), 1., -1.)"], "message": ["Error: This variant expression is expected to have type expr\n       The constructor Vary does not belong to type expr\nHint: Did you mean VarX or VarY?\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (e)   -> sin(pi *. (eval (e,x,y)))\n| Cosine (e) -> cos(pi *. eval (e,x,y))\n| Average (e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\n| Times (e1,e2)   -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2, e3, e4) -> if eval (e1,x,y) < eval (e2,x,y) then eval (e3,x,y) else eval (e4,x,y)\n| NewExprA (e1,e2) -> if eval(e1,x,y) > eval(e2,x,y) then eval (e1,x,y) else eval(e2,x,y)\n| NewExprB (e1,e2,e3) -> eval(e1,x,y) +. eval(e2,x,y) -. eval(e3,x,y)", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (NewExprA(VarX, VarY), -0.5, -1.)", "let _ = eval (NewExprB(VarX, VarY, VarX), 1.,-1.)"], "bad": ["let _ = eval (NewExprB(VarX, VarY, VarX), -1.,-1.,-1.)", "let _ = eval (NewExprB(VarX, VarY, VarX), -1.,-1.)"], "message": ["Error: This expression has type 'a * 'b * 'c * 'd\n       but an expression was expected of type expr * float * float\n", "Error: This expression has type 'a * 'b * 'c * 'd\n       but an expression was expected of type expr * float * float\n"], "problem": "eval"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs"], "bad": ["let _ = sqsum []"], "message": ["Error: Unbound value sqsum\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun a -> x in\nlet base = fun y -> y in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = f a in\nlet base = x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base = x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base = [] in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun a - x in\nlet base = fun y -> y in\nList.fold_left f base fs"], "message": ["Error: Unbound value f\n", "Error: Unbound value x\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let _ = pipe [] 3"], "bad": ["let pipe fs = \nlet f a x = a -> x in\nlet base =  y in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun f a -> f x in\nlet base = fun y -> y in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         int -> int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun f a -> x in\nlet base = fun y -> y in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun f x -> f a in\nlet base = fun y -> y in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'd -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'd -> 'c\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun f x -> fun f a -> f a x in\nlet base = fun y -> y in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let pipe fs = \nlet f a x = fun f x -> f a in\nlet base = fun y -> y in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun f a -> fun f x -> f z in\nlet base = fun y -> fun y in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun f a -> fun f x -> f z in\nlet base = fun y in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun f a -> fun f x -> f z in\nlet base = fun y -> z in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun f a -> fun f x -> f w in\nlet base = fun y -> z in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun f a -> fun f x  in\nlet base = fun y -> z in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun f a -> fun f x in\nlet base = fun y -> z in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun f x -> fun f a in\nlet base = fun y -> z in\nList.fold_left f base fs"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'd -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'd -> 'c\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value z\n", "Error: Unbound value w\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun f x -> fun f a -> f a x in\nlet base = fun y -> y in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun f x -> fun f a -> fun f a x in\nlet base = fun y -> y in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun z -> x (a z) in\nlet base = fun z -> z in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let pipe fs = \nlet f a x = fun f x -> fun f a -> f a x in\nlet base = fun y z-> z in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun f x -> f (x a) in\nlet base = fun z -> z in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun z -> f (x a) in\nlet base = fun z -> z in\nList.fold_left f base fs"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> ('b -> 'a -> 'c) -> 'b -> 'c\n", "Error: This expression has type 'a -> 'b -> 'b\n       but an expression was expected of type\n         'a -> 'b -> ('c -> 'b -> 'd) -> 'c -> 'd\n       The type variable 'b occurs inside ('c -> 'b -> 'd) -> 'c -> 'd\n", "Error: This expression has type 'a -> 'b -> ('c -> 'd) -> ('a -> 'c) -> 'd\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('c -> 'd) -> ('a -> 'c) -> 'd\n", "Error: Unbound value f\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = h in\nlet l = \"\" in\nList.fold_left f base l"], "message": ["Error: This expression has type string but an expression was expected of type\n         string list\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a x in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep in\nlet base = h ^ sep in\nlet l = h in\nList.fold_left f base l"], "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l"], "bad": ["let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]"], "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = sl in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = \"\" in\nList.fold_left f base l"], "message": ["Error: This expression has type string but an expression was expected of type\n         string list\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = sep in\nlet l = sl in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = t in\nlet l = sl in\nList.fold_left f base l"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sep ^ a in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sep ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base "], "message": ["Error: This expression has type string list -> string\n       but an expression was expected of type string\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep ^ a in\nlet base = sep in\nlet l = sl in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep ^ a in\nlet base = a in\nlet l = sl in\nList.fold_left f base l"], "message": ["Error: Unbound value a\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ sep ^ a in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ sep ^ a in\nlet base =  in\nlet l = sl in\nList.fold_left f base l"], "message": ["Error: Syntax error\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = [] in\nlet l = sl in\nList.fold_left f base l"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let stringOfList f l = List.map sepConcat l"], "bad": ["let stringOfList f l = List.map \"[\" ^ sepConcat l ^ \"]\""], "message": ["Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = fun z -> x (a z) in\nlet base = fun z -> z in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = List.map (f (sepConcat \"\" l))"], "bad": ["let stringOfList f l = List.map sepConcat \"\" l", "let stringOfList f l = List.map f (sepConcat \"\" l)", "let stringOfList f l = List.map f (sepConcat l)", "let stringOfList f l = List.map f (sepConcat \"\" l)"], "message": ["Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n", "Error: This expression has type string list -> string\n       but an expression was expected of type 'a list\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = (List.map f l)"], "bad": ["let stringOfList f l = sepConcat (List.map f l)"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let _ = string_of_int"], "bad": ["string_of_int [1;2;3;4;5;6]"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let rec clone x n = \nif n <= 0 then []\nelse\nclone (x) (n-1)"], "bad": ["let rec clone x n = \nif x <= 0 then []\nelse\nclone x::[] (n-1)", "let rec clone x n = \nif x <= 0 then []\nelse\nclone (x::[]) (n-1)", "let rec clone x n = \nif n <= 0 then []\nelse\nclone (x::[]) (n-1)", "let rec clone x n = \nif n <= 0 then x\nelse\nclone (x::[]) (n-1)"], "message": ["Error: This expression has type 'a -> 'b list\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside 'a -> 'b list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let rec clone x n = \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> h::clone t (n-1)"], "bad": ["let rec clone x n = \nif n <= 0 then []\nelse\nclone (x) (n-1)\nin clone [] n", "let rec clone x n = \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> clone h::x (n-1)"], "message": ["Error: Unbound value n\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let rec clone x n = \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> h :: clone t (n-1)"], "bad": ["let _ = clone 3 5", "let rec clone x n = \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> clone t (n-1) :: h", "let rec clone x n = \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> clone t (n-1) :: h ::[]"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let rec clone x n = \nif n <= 0 then []\nelse x :: clone x (n-1)"], "bad": ["let _ = clone 3 5"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let rec clone x n = \nif n <= 0 then []\nelse x :: clone x (n-1)"], "bad": ["let rec clone x n = "], "message": ["Error: Syntax error\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nlet l = List.length l1 - List.length l2 in\nif l < 0 then ((clone 0 ((-1)*l) @ l2), l2)\nelse (l1, clone 0 l @ l2)"], "bad": ["let padZero l1 l2 = \nlet l = List.length l1 - List.length l2 in\nif l < 0 then ((clone 0 ((-1)*l) @ l2), l2)\nelse (l1, clone 0 l :: l2)"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = fun z -> x (a z) in\nlet base = fun z -> z in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n = \nif n <= 0 then []\nelse x :: clone x (n-1)", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let padZero l1 l2 = \nlet l = List.length l1 - List.length l2 in\nif l < 0 then ((clone 0 ((-1)*l) @ l1), l2)\nelse (l1, clone 0 l @ l2)"], "bad": ["let padZero l1 l2 = \nlet l = List.length l1 - List.length l2 in\nif l < 0 then ((clone 0 ((-1)*l) @ l1), l2)\nelse (l1, clone 0 l @ l2)"], "message": ["Error: Unbound value clone\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = fun z -> x (a z) in\nlet base = fun z -> z in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n = \nif n <= 0 then []\nelse x :: clone x (n-1)", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let padZero l1 l2 = \nlet l = List.length l1 - List.length l2 in\nif l < 0 then ((clone 0 ((-1)*l) @ l1), l2)\nelse (l1, clone 0 l @ l2)", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let rec removeZero l = match l with\n| [] -> []\n| h::t-> \nif h = 0 then removeZero t\nelse h::t", "let _ = removeZero [0;0;0;1;0;0;2]", "let _ = removeZero [9;9]", "let _ = removeZero [0;0;0;0]", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x + a in\nlet base = 0 in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x + a in\nlet base = 0 in\nlet args = x mod 10 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x + a in\nlet base = 0 in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Unbound value a\n", "Error: Unbound value x\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let _ = bigAdd [9;9] [1;0;0;2]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10 :: []\n| h::t -> (a+h) mod 10 :: t in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10\n| h::t -> (a+h) mod 10 in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10 :: []\n| h::t -> (a+h) mod 10 :: [] in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10 :: []\n| h::t -> (a+h) mod 10 :: (a+h)/10 in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10 :: []\n| h::t -> (a+h) mod 10 :: (a+h)/10 in\nlet base = (0,0) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10\n| h::t -> (a+h) mod 10 in\nlet base = (0,0) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10\n| h::t -> (a+h) mod 10 in\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10\n| h::t -> (a+h) mod 10 in\nlet base = [0] in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (c,d) -> c in macth x", "with\n| (add1, add2) -> ((c + add1 + add2) mod 10, (c + add1 + add2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (x,y) -> x in macth x", "with\n| (add1, add2) -> ((x + add1 + add2) mod 10, (x + add1 + add2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (x,y) -> x in match x with\n| (add1, add2) -> ((x + add1 + add2) mod 10, (x + add1 + add2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (x,y) -> x in match x with\n| (add1, add2) -> (x + add1 + add2) mod 10", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet carry = match a with\n| (x,y) -> x in \nmatch x with\n| (add1, add2) -> \nlet new_carry = (carry + add1 + add2) / 10 in\nlet digit = (carry + add1 + add2) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int -> int list -> int list\n       but an expression was expected of type int -> int list -> int\n       Type int list is not compatible with type int \n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int -> int list -> int list\n       but an expression was expected of type int -> int list -> int\n       Type int list is not compatible with type int \n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int * int\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let _ = bigAdd [9;9] [1;0;0;2]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (add1, add2) -> ((add1 + add2 + a)/ 10, ((add1 + add2 + a) mod 10)::reest)  in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (add1, add2) -> ((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::reest)  in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (add1, add2) -> ((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)  in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n", "Error: Unbound value reest\nHint: Did you mean rest?\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let _ = removeZero [0;0;0;0]", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (x,y) -> ((carry/10), (carry mod 10)::rest)\n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)  in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let _ = removeZero [\n\n\nlet bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n\n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)  in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = removeZero [\n\n\nlet bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n\n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)  in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [9;9]"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)", "let base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [9;9]", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]", "let _ = 10/10"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)\n| (_,_) -> ((carry/10), (carry mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This pattern matches values of type unit\n       but a pattern was expected which matches values of type 'a * 'b\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let _ = removeZero [0;0;0;0]"], "bad": ["let _ = removeZero [9;9]"], "message": ["Error: Syntax error\n"], "problem": "removeZero"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nif x = [] then a\nelse\nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [9;9]", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (_,_) -> (carry::rest)\n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nif x = () then a\nelse\nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error: operator expected.\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nlet carry = \nmatch a with\n| (x,y) -> x in\nmatch x with \n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd ["], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nif x = (Nil,Nil) then a\nelse\nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nif x = (,) then a\nelse\nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error: operator expected.\n", "Error: Unbound constructor Nil\n", "Error: Syntax error: operator expected.\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \nif List.length rest = List.length l1 || List.length rest = List.length l2 then\n(0, carry::rest)\nelse\n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \nif List.length rest = List.length l1 or List.length rest = List.length l2 then\ncarry::rest\nelse\n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \nif List.length rest = List.length l1 or List.length rest = List.length l2 then\n(0, carry::rest)\nelse\n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let _ = bigAdd [9;9] [9;9]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> \nif List.length rest >= List.length l1 || \nList.length rest >= List.length l2 \nthen\n(0, carry::rest)\nelse match x with \n| (add1, add2) ->\n((add1 + add2 + carry)/ 10, \n((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Unbound value =>\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let _ = bigAdd [9;9] [9;9]", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) ->\n((add1 + add2 + carry)/ 10, \n((add1 + add2 + carry) mod 10)::rest) in\nif List.length rest >= List.length l1 || \nList.length rest >= List.length l2 \nthen\n(0, ((add1 + add2 + carry)/ 10,)::rest)in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) ->\n((add1 + add2 + carry)/ 10, \n((add1 + add2 + carry) mod 10)::rest) in\nif List.length rest >= List.length l1 || \nList.length rest >= List.length l2 \nthen\n(0, ((add1 + add2 + carry)/ 10)::rest)in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) ->\nlet new_carry = (add1 + add2 + carry) / 10 in\nlet result = (add1 + add2 + carry) mod 10 :: rest in\nif(List.length result >= List.length l1 ||\nList.length result >= List.length l2) then\n(0, carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n", "Error: Syntax error: operator expected.\n", "Error: Unbound value rest\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) ->\nlet new_carry = (add1 + add2 + carry) / 10 in\nlet result = (add1 + add2 + carry) mod 10 :: rest in\nif(List.length result >= List.length l1 ||\nList.length result >= List.length l2) && new_carry > 0 then\n(0, carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let _ = bigAdd [5;0] [5;0]"], "message": ["Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = \nlet f a x = match a with\n| (carry, rest) -> \nlet new_carry = ((i * x) + carry) / 10 in\nlet result = (((i * x) + carry) mod 10) :: rest in\nif List.length result = List.length l && new_carry = 1 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nList.fold_left f base (List.rev l)"], "bad": ["let rec mulByDigit i l = \nlet f a x = match a with\n| (carry, rest) -> match x with \n| (mul1, mul2) ->\nlet new_carry = ((mul1 * mul2) + carry) / 10 in\nlet result = (((mul1 * mul2) + carry) mod 10) :: rest in\nif(List.length result = List.length l1 ||\nList.length result = List.length l2) && new_carry = 1 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nList.fold_left f base (List.rev l)", "let rec mulByDigit i l = \nlet f a x = match a with\n| (carry, rest) -> match x with \n| (mul1, mul2) ->\nlet new_carry = ((mul1 * mul2) + carry) / 10 in\nlet result = (((mul1 * mul2) + carry) mod 10) :: rest in\nif(List.length result = List.length l) && new_carry = 1 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nList.fold_left f base (List.rev l)"], "message": ["Error: Unbound value add1\n", "Error: Unbound value l1\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = fun z -> x (a z) in\nlet base = fun z -> z in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n = \nif n <= 0 then []\nelse x :: clone x (n-1)", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let padZero l1 l2 = \nlet l = List.length l1 - List.length l2 in\nif l < 0 then ((clone 0 ((-1)*l) @ l1), l2)\nelse (l1, clone 0 l @ l2)", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let _ = padZero [] [1;0;0]", "let rec removeZero l = match l with\n| [] -> []\n| h::t-> \nif h = 0 then removeZero t\nelse h::t", "let _ = removeZero [0;0;0;1;0;0;2]", "let _ = removeZero [9;9]", "let _ = removeZero [0;0;0;0]", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) ->\nlet new_carry = (add1 + add2 + carry) / 10 in\nlet result = ((add1 + add2 + carry) mod 10) :: rest in\nif(List.length result = List.length l1 ||\nList.length result = List.length l2) && new_carry = 1 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [9;9]", "let _ = bigAdd [1] [9;9]", "let _ = bigAdd [5;0] [5;0]", "let _ = bigAdd [9;0;0] [1;0;0]", "let _ = bigAdd [1;2] [1;3]", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]", "let _ = bigAdd [] []", "let _ = bigAdd [0] []", "let _ = bigAdd [3] []", "let _ = bigAdd [0] [0]", "let rec mulByDigit i l = \nlet f a x = match a with\n| (carry, rest) -> \nlet new_carry = ((i * x) + carry) / 10 in\nlet result = (((i * x) + carry) mod 10) :: rest in\nif List.length result = List.length l && new_carry > 0 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nlet (_, res) = List.fold_left f base (List.rev l) in res", "let _ = mulByDigit 9 [9;9;9;9]", "let _ = mulByDigit 1 [0]", "let bigMul l1 l2 = \nlet f a x = match a with\n| (index, rest) -> (index + 1, \nbigAdd rest ((mulByDigit x l1)@clone 0 index)) in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "let _ = bigMul [9;9;9;9] [9;9;9;9]", "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]", "let _ = bigMul [0] [0]", "let _ = bigMul [1;1;1;1;1] [9;9;9]", "let key = \"\"", "let prefix130 = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")", "let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0", "let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)", "let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))", "let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p", "let wrap_curried_2 f (a,b) = f a b"], "bad": ["let bigMul l1 l2 = \nlet f a x = match a with\n| (index, rest) -> \nlet new_index = index + 1 in\nlet results = bigAdd rest ((mulByDigit x l1)@clone 0 index)", ") in\n(new_index, result) in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: Unbound value l1\n", "Error: Syntax error\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let _ = bigMul [1;5] [1;5]"], "bad": ["let _ = bigMul [1;5] [1;5]"], "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "problem": "bigMul"}
{"hw": "hw1", "fix": ["let rec sumList xs = \nmatch xs with\n[] -> 0\n| xs -> List.hd xs + (sumList (List.tl xs))", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]"], "bad": ["let rec sumList xs = \nmatch xs with\n[] -> 0\n| xs -> List.hd xs + (sumList List.tl xs)", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]"], "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value sumList\n", "Error: Unbound value sumList\n", "Error: Unbound value sumList\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse  digitsOfInt (n/10) @ [n mod 10]", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663"], "bad": ["let rec digitsOfInt n = \nif n < 0 then []\nelse  digitsOfInt (n/10) @ n mod 10", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: Unbound value digitsOfInt\n", "Error: Unbound value digitsOfInt\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)\nelse acc", "let additivePersistence n = additiveHelper n 0", "let _ = additivePersistence 9876"], "bad": ["let additivePersistence n =\nif n > 9 then additivePersistence (List.fold_left (+) (digitsOfInt n))\nelse n", "let _ = additivePersistence 9876", "let additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)\nelse acc", "let additivePersistence n = additiveHelper n 0", "let _ = additivePersistence 9876", "let additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)\nelse acc", "let additivePersistence n = additiveHelper n 0", "let _ = additivePersistence 9876"], "message": ["Error: Unbound value additivePersistence\n", "Error: Unbound value additivePersistence\n", "Error: Unbound value additiveHelper\n", "Error: Unbound value additiveHelper\n", "Error: Unbound value additivePersistence\n", "Error: Unbound value additiveHelper\n", "Error: Unbound value additiveHelper\n", "Error: Unbound value additivePersistence\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["append [2;3;4] [1]"], "bad": ["append [2,3,4] [1]", "append [2,3,4] [1]"], "message": ["Error: This expression has type int but an expression was expected of type\n         int * int * int\n", "Error: This expression has type int but an expression was expected of type\n         int * int * int\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc d k ls", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "bad": ["let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else \n\n\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)", "let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)"], "message": ["Error: Syntax error\n", "Error: This expression has type 'a but an expression was expected of type\n         ('a * 'b) list\n       The type variable 'a occurs inside ('a * 'b) list\n", "Error: This expression has type 'a but an expression was expected of type\n         ('a * 'b) list\n       The type variable 'a occurs inside ('a * 'b) list\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if lk = lk then lv else assoc (d,k,ls)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "bad": ["let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if lk = lk then lv else assoc d k ls"], "message": ["Error: This expression has type 'a -> 'b -> 'c\n       but an expression was expected of type\n         ('a -> 'b -> 'c) * ('d * ('a -> 'b -> 'c)) list * 'e\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "bad": ["let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         ('a * 'b) list\n       The type variable 'a occurs inside ('a * 'b) list\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile2 (f, 2)"], "bad": ["let f x = let xx = x*x*x in (xx, xx < 100 in\nwwhile2 (f, 2)"], "message": ["Characters 28-29:\n  let f x = let xx = x*x*x in (xx, xx < 100 in\n                              ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((f (f b)),b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let fixpoint (f,b) = wwhile ((fun (f b) -> if f b = b then b else f b),b)", "let fixpoint (f,b) = wwhile ((fun -> if f b = b then b else f b),b)", "let fixpoint (f,b) = wwhile ((fun (f b)-> if f b = b then b else f b),b)", "let fixpoint (f,b) = wwhile ((fun (f, b)-> if f b = b then b else f b),b)"], "message": ["Characters 34-35:\n  let fixpoint (f,b) = wwhile ((fun (f b) -> if f b = b then b else f b),b);;\n                                    ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error: operator expected.\n", "Characters 34-35:\n  let fixpoint (f,b) = wwhile ((fun (f b)-> if f b = b then b else f b),b);;\n                                    ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: This expression has type 'a but an expression was expected of type\n         (('a -> 'a) * 'a) * bool\n       The type variable 'a occurs inside (('a -> 'a) * 'a) * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((fun f' -> if f b = b then (b,false) else (f b, true)),b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "bad": ["let fixpoint (f,b) = wwhile ((fun f' -> if f b != b then (b,true) else (f b, false)),b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((fun rec f'-> if f b = b then (b,false) else (f b, true)),b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)"], "bad": ["let fixpoint (f,b) = wwhile ((fun f'-> if f b = b then (b,false) else (f b, true)),b)"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) * 'a\n       The type variable 'a occurs inside ('a -> 'a) * 'a\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = \nlet (b',c') = f b in match c' with\n| false -> b'\n|     _ -> wwhile (f, b')", "let rec wwhile2 (f,b) = let (b', c') = f b in if not c' then b' else wwhile2(f,b')", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile2 (f, 2)"], "bad": ["let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile2 (f, 2)", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile2 (f, 2)", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "message": ["Error: Unbound value wwhile2\n", "Error: Unbound value wwhile2\n", "Error: Unbound value wwhile2\n", "Error: Unbound value wwhile\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' =  if not (List.mem h seen) then h::seen else seen in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) = \nlet (b',c') = f b in match c' with\n| false -> b'\n|     _ -> wwhile (f, b')", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) = wwhile ((fun (f,b) -> match f b with | b -> (b, false) | _ -> (f b, true)),b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "bad": ["let fixpoint (f,b) = wwhile ((fun (f,b) -> if f b = b then (f b, false) else (f b, true)),b)", "let fixpoint (f,b) = wwhile ((fun (f,b) -> match b with | f b -> (f b, false) | _ -> (f b, true)),b)", "let fixpoint (f,b) = wwhile ((fun (f,b) -> match b with | (f b) -> (f b, false) | _ -> (f b, true)),b)", "let fixpoint (f,b) = wwhile ((fun (f,b) -> match b with | f b = b -> (f b, false) | _ -> (f b, true)),b)", "let fixpoint (f,b) = wwhile ((fun (f,b) -> match b with | (f b) = b -> (f b, false) | _ -> (f b, true)),b)", "let fixpoint (f,b) = wwhile ((fun (f,b) -> match f b with | b -> (f b, false) | _ -> (f b, true)),b)"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) * 'a\n       The type variable 'a occurs inside ('a -> 'a) * 'a\n", "Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) * 'a\n       The type variable 'a occurs inside ('a -> 'a) * 'a\n", "Error: Syntax error: operator expected.\n", "Characters 58-59:\n  let fixpoint (f,b) = wwhile ((fun (f,b) -> match b with | (f b) -> (f b, false) | _ -> (f b, true)),b);;\n                                                            ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error: operator expected.\n", "Characters 58-59:\n  let fixpoint (f,b) = wwhile ((fun (f,b) -> match b with | (f b) = b -> (f b, false) | _ -> (f b, true)),b);;\n                                                            ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "bad": ["let fixpoint (f,b) = wwhile ((fun a -> if b = (f b) then (b,false) else ((f b),true)),b)"], "message": ["Error: Unbound value fixpoint\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr,0.5,0.2)"], "bad": ["let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w) < eval(t) then eval(u) else eval(z)\n| Times (t,u) -> eval(t) * eval(u)\n| Average (t,u) -> (eval(t) * eval(u)) / 2\n| Cosine t -> cos(pi * eval(t))\n| Sine t -> sin(pi * eval(t))\n| VarX -> x\n| VarY -> y", "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| Times (t,u) -> eval(t,x,y) * eval(u,x,y)\n| Average (t,u) -> (eval(t,x,y) * eval(u,x,y)) / 2\n| Cosine t -> cos(pi * eval(t,x,y))\n| Sine t -> sin(pi * eval(t,x,y))\n| VarX -> x\n| VarY -> y", "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| Times (t,u) -> eval(t,x,y) * eval(u,x,y)\n| Average (t,u) -> (eval(t,x,y) * eval(u,x,y)) / 2\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y", "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| Times (t,u) -> eval(t,x,y) * eval(u,x,y)\n| Average (t,u) -> (eval(t,x,y) * eval(u,x,y)) / 2\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y", "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| Times (t,u) -> eval(t,x,y) *. eval(u,x,y)\n| Average (t,u) -> (eval(t,x,y) *. eval(u,x,y)) /. 2.0\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y"], "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'b\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'b\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: Unbound value eval\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"], "bad": ["let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine(buildHelper(rand, max_depth, curr_depth + 1))\n| 4 -> buildAverage(buildHelper(rand, max_depth, curr_depth + 1), \nbuildHelper(rand, max_depth, curr_depth + 1))\n| 5 -> buildTimes(buildHelper(rand, max_depth, curr_depth + 1 ), \nbuildHelper(rand, max_depth, curr_depth + 1))\n| 6 -> buildThresh(buildHelper(rand, max_depth, curr_depth + 1),\nbuildHelper(rand, max_depth, curr_depth + 1),\nbuildHelper(rand, max_depth, curr_depth + 1),\nbuildHelper(rand, max_depth, curr_depth + 1))\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), \nbuildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))", ")\nelse match rand(0,1) with\n| 0 -> buildX\n| 1 -> buildY", "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), \nbuildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))", "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), \nbuildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))", ")\nelse match rand(0,1) with\n| 0 -> buildX\n| 1 -> buildY", "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), \nbuildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))", ")\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))", ")\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX ()\n| 1 -> buildY ()\n| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))", ")\nelse match rand(0,1) with\n| 0 -> buildX ()\n| 1 -> buildY ()", "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX \n| 1 -> buildY \n| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))", ")\nelse match rand(0,1) with\n| 0 -> buildX \n| 1 -> buildY", "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> VarX\n| 1 -> VarY \n| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))", "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"], "message": ["Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type int * int -> int\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type int * int -> int\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: Syntax error\n", "Error: This expression has type unit -> expr\n       but an expression was expected of type unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: Syntax error\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: Syntax error\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: Syntax error\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: Syntax error\n", "Error: This expression has type unit -> expr\n       but an expression was expected of type unit\n", "Error: Syntax error\n", "Error: This variant expression is expected to have type unit\n       The constructor VarX does not belong to type unit\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"], "bad": ["let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,(depth - 1))\n| 3 -> buildCosine(build rand (depth - 1))\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"], "message": ["Error: This function has type (int * int -> int) * int -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Characters 118-119:\n  | 2 -> buildSine(build (rand,(depth - 1))\n                  ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()"], "bad": ["let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()"], "message": ["Error: Syntax error\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) (eval(u,x,y))))\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| Tan t -> tan(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y"], "bad": ["let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesMod (w,t,u) -> (eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) eval(u,x,y) )\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y", "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) eval(u,x,y)))\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y", "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) (eval(u,x,y))))\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y"], "message": ["Error: This expression has type expr but an expression was expected of type\n         float\n", "Error: This function has type float -> float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type float -> float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "eval"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + (x * x) in\nlet base =  0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = fun y -> x(a y) in\nlet base = fun x -> x in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n = \nif n <= 0 then []\nelse x::(clone x (n-1))", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let padZero l1 l2 = \nlet dl = (List.length l1) - (List.length l2)\nin match dl with\n| 0 -> (l1,l2)\n| _ -> \nif dl > 0 then (l1, ((clone 0 dl) @ l2))\nelse (((clone 0 (dl / -1)) @ l1), l2)", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h == 0 then removeZero t else h::t", "let _ = removeZero [0;0;0;1;0;0;2]", "let _ = removeZero [9;9]", "let _ = removeZero [0;0;0;0]", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| [] -> []\n| (x,y)::t -> ((x+y)/10)::((x+y)mod 10)::t"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| [] -> []\n| (x,y)::t -> ((x+y)/10)::((x+y)%10)", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| [] -> []\n| (x,y)::t -> ((x+y)/10)::((x+y)%10)::t", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| [] -> []\n| (x,y)::t -> ((x+y)/10)::((x+y)%10)::a", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| [] -> []\n| (x,y)::t -> ((x+y)/10)::((x+y)%10) @ a"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| [] -> []\n| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t\n| _ -> []", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t\n| _ -> a", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2) @ (0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2) @ (0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::t\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2) @ (0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::t\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2) @ (0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2) @ (0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)::(0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add l1 l2 = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)::(0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::a::((w+y) mod 10)\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)::(0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)::(0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (*match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in *)\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (*match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in *)in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\"(*match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in *)in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\"(*match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in *)in\nlet base = [] in\nlet args =  (0, List.rev ((List.combine l1 l2))) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = [] in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = [] in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n", "Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n", "Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n", "Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list list\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type int * ('a * 'b) list\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  List.rev( List.combine l1 l2 ) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = [] in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  List.rev((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  List.rev((List.combine l1 l2) @ (0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  List.rev((List.combine l1 l2)::(0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  List.rev((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = [(0,0)] in\nlet args =  List.rev((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base =  in\nlet args =  List.rev((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type (int * int) list\n       but an expression was expected of type 'a * 'b\n", "Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = failwith \"TBD\" in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)", ")::t\n| [] -> [] in\nlet base = (_, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)", ") @ t\n| [] -> [] in\nlet base = (_, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)", ")\n| [] -> [] in\nlet base = (_, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t\n| [] -> [] \nin\nlet base = (_, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t\n| [] -> [] \nin\nlet base = (c, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10)::((w+y+z) mod 10)::t\n| [] -> [] \nin\nlet base = (c, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch x with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t\n| [] -> [] \nin\nlet base = (c, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t\n| [] -> [] \nin\nlet base = (c, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)\n| [] -> [] \nin\nlet base = (c, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)\n| [] -> (0,0)\nin\nlet base = (c, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)\n| [] -> (0,0)\nin\nlet base = (_, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)\n| [] -> (0,0)\nin\nlet base = (0, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t\n| [] -> (0,0)\nin\nlet base = (0, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| h::t -> ((h+z)/10)::((h+z) mod 10):: t \n| _ -> (z/10)::(z mod 10)in\nlet base = [] in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| h::t -> ((h+z)/10)::((h+z) mod 10):: t \n| _ -> ((z/10),[z mod 10])in\nlet base = [] in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| h::t -> ((h+z)/10)::((h+z) mod 10):: t \n| _ -> (z/10)::[z mod 10] in\nlet base = [] in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| h::t -> (((h+z)/10), ((h+z) mod 10)):: t \n| _ -> ((z/10),(z mod 10)) in\nlet base = [] in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| h::t -> (((h+z)/10), ((h+z) mod 10))::t \n| _ -> ((z/10),(z mod 10)) in\nlet base = [] in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y)", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y)\nin \nlet base = [] in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error: operator expected.\n", "Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n", "Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int * int\n", "Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n", "Error: This expression has type 'a list\n       but an expression was expected of type int * int\n", "Error: Unbound value c\n", "Error: Syntax error: operator expected.\n", "Error: This expression has type (int * int) list -> int * int -> int * int\n       but an expression was expected of type\n         (int * int) list -> int * int -> (int * int) list\n       Type int * int is not compatible with type (int * int) list \n", "Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type int list\n       but an expression was expected of type (int * int) list\n       Type int is not compatible with type int * int \n", "Error: This expression has type int list\n       but an expression was expected of type (int * int) list\n       Type int is not compatible with type int * int \n", "Error: Syntax error\n", "Error: This expression has type 'a list\n       but an expression was expected of type int * int list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0, _ ) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0, l) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = [] in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int * int\n       but an expression was expected of type int * int list\n       Type int is not compatible with type int list \n", "Error: Syntax error: operator expected.\n", "Error: Unbound value l\n", "Error: This expression has type 'a list\n       but an expression was expected of type int * int list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\n| _ -> ( ((z)/10), [z mod 10])\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\n| _ -> ( ((w+z)/10), ((w+z) mod 10))\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\n| _ -> ( ((z)/10), ((z) mod 10))\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Unbound value w\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) @ (0,0))in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2)::(0,0))in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2)::([0],[0]))in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w, [])   -> (w, (z/10)::(z mod 10))\n| (w, h::t) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = [] in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int * int list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,[]) -> ( ((w+z)/10), 0::((w+z)mod 10)::[])\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,[]) -> ( ((w+z)/10), 0::((w+z)mod 10)::y\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,[]) -> ( ((w+z)/10), 0::((w+z)mod 10)::y)\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)"], "message": ["Characters 104-105:\n  | (w,[]) -> ( ((w+z)/10), 0::((w+z)mod 10)::y\n              ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Unbound value y\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = \nlet l1 = List.rev l in\nlet l2 = [i] in\nlet mul (l1, l2) = \nlet f a x = let z = fst x * snd x in \nmatch a with\n| (w,y) -> (((w+z)/10), ((w+z) mod 10)::y)\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero(mul (padZero l1 l2))"], "bad": ["let rec mulByDigit i l = \nlet l1 = List.reverse l in\nlet l2 = [i] in\nlet mul (l1, l2) = \nlet f a x = let z = fst x * snd x in \nmatch a with\n| (w,y) -> (((w+z)/10), ((w+z) mod 10)::y)\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero(mul (padZero l1 l2))"], "message": ["Error: Unbound value List.reverse\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = \nlet rec helper i l acc = match i with\n| 0 -> [0]\n| 1 -> l\n| _ -> helper (i-1) l (bigAdd acc l)\nin \nhelper i l [0]"], "bad": ["let rec mulByDigit i l = \nlet rec helper acc n lis = match n with\n| 1 -> lis + acc\n| _ -> helper (n - 1) (bigAdd l lis)", "let rec mulByDigit i l = \nlet rec helper acc n lis = match n with\n| 1 -> lis + acc\n| _ -> helper (n - 1) (bigAdd l lis)\nin \nhelper [] i l", "let rec mulByDigit i l = \nlet rec helper acc n lis = match n with\n| 1 -> lis + acc\n| _ -> helper (n - 1) (bigAdd l lis)\nin \nhelper [0] i l", "let rec mulByDigit i l = \nlet rec helper acc n lis = match n with\n| 1 -> bigAdd lis acc\n| _ -> helper (n - 1) (bigAdd l lis)\nin \nhelper [0] i l"], "message": ["Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = \nlet rec helper w y acc = match i with\n| 0 -> [0]\n| 1 -> l\n| _ -> helper (w-1) y (bigAdd acc y)\nin \nhelper i l [0]", "let _ = mulByDigit 9 [9;9;9;9]"], "bad": ["let rec mulByDigit i l = \nlet rec helper w y acc = match i with\n| 0 -> [0]\n| 1 -> l\n| _ -> helper (w-1) y (bigAdd acc y)\nin \nhelper i l [10"], "message": ["Error: Syntax error\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = \nlet rec adder n li acc = match n with\n| 0 -> [0]\n| 1 -> bigAdd li acc\n| _ -> adder (n-1) li (bigAdd acc li) \nin \nadder i l [0]", "let _ = mulByDigit 9 [9;9;9;9]", "let _ = mulByDigit 0 [1;2;3]"], "bad": ["let _ = mulByDigit 0 [1;2;3]"], "message": ["Characters 17-18:\n  let _ = print130 (\"Compile\";;\n                   ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let _ = mulByDigit 999999999 [9;9;9;9]"], "bad": ["let _ = mulByDigit 5 [6;9;8;9]", "let _ = mulByDigit 3 [9;9;9;9]", "let _ = mulByDigit 0 [1;2;3]", "let _ = mulByDigit 9999999 [9;9;9;9;9;9;9;9;9;9;]"], "message": ["Error: Unbound value mulByDigit\n", "Error: Unbound value mulByDigit\n", "Error: Unbound value mulByDigit\n", "Error: Unbound value mulByDigit\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = match a with\n| (w,y) -> ( w, bigAdd a (mulByDigit (clone x (List.length y)) l1)) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = let z = fst x * snd x in\nmatch a with\n| (w,y) -> ((w+z)/10), ((w+z) mod 10)::y", ")\nin \nlet base = (0,[]) in\nlet args = failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = let z = fst x * snd x in\nmatch a with\n| (w,y) -> (((w+z)/10), ((w+z) mod 10)::y)\nin \nlet base = (0,[]) in\nlet args = failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let rec bigCombiner l1 l2 acc = \nmatch l1 with\n| [] -> acc\n| h::t -> mulByDigit h l2", "let _ = bigMul [9;9;9;9] [9;9;9;9]", "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"], "bad": ["let bigMul l1 l2 = \nlet f a x = match a with\n| (w,y) -> ( w, bigAdd y (mulByDigit (clone x (List.length y)) l1)) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = match a with\n| (w,y) -> ( w, bigAdd y (mulByDigit (x * (List.length y)) l1)) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": [";;", "let _ = bigMul [9;9;9;9] [9;9;9;9]", "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]", "let key = \"\"", "let prefix130 = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")", "let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0", "let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)", "let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))", "let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p", "let wrap_curried_2 f (a,b) = f a b"], "bad": ["let bigMul l1 l2 = \nlet f a x = x in \nlet base = (0, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: Syntax error\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let rec mulByTen n = match n with\n| 0 -> 0\n| 1 -> 10\n| _ -> 10 * (mulByTen (n-1))", "let bigMul l1 l2 = \nlet f a x =  \nlet (la, lb) = x in\nlet (i, acc) = a in\nmatch l1 with\n| [] -> (i, acc)\n| h::t -> let temp = mulByDigit h lb \nin (i + 1, ( bigAdd acc (temp * (mulByTen i))))"], "bad": ["let bigMul l1 l2 = \nlet f a x =  x in \nlet base = (0, []) in\nlet args = ( List.rev l1 , List.rev l2 ) in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: Syntax error\n"], "problem": "bigMul"}
{"hw": "hw1", "fix": ["let _ = additivePersistence 9876"], "bad": ["let rec additivePersistence (a, n) = \nif n < 10\nthen (n, 0)\nelse let (a', n') = (additivePersistence (a+1, sumList(digits n)))", "let rec additivePersistence (a, n) = \nif n < 10\nthen (n, 0)\nelse additivePersistence (a+1, sumList(digits n))", ")", "let rec additivePersistence (a, n) = \nif n < 10\nthen (n, 0)\nelse additivePersistence (a+1, sumList(digits n))"], "message": ["Error: Syntax error\n", "Error: Unbound value sumList\n", "Error: Syntax error\n", "Error: Unbound value sumList\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let _ = additivePersistence (0,9876)"], "bad": ["let rec additivePersistence (a, n) = \nif n < 10\nthen (a, n)\nelse additivePersistence (a+1, sumList(digits n))"], "message": ["Error: Unbound value sumList\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec sumList xs = match xs with\n[] -> 0\n| x :: xs -> x + sumList xs", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]", "let rec digitsOfInt n =\nif n < 0\nthen []\nelse if n >= 10 \nthen (digitsOfInt (n/10)) @ [n mod 10]\nelse [n]", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let _ = digitsOfInt (0-1)", "let digits n = digitsOfInt (abs n)", "let rec additivePersistence (a, n) = \nlet intFun ((a,n) : int * int) : (a,n)\nif n < 10\nthen (a, n)\nelse additivePersistence (a+1, sumList(digits n))", "let _ = additivePersistence (0,9876)", "let rec digitalRoot n = \nif n < 10\nthen n\nelse (digitalRoot (sumList (digits n)))", "let _ = digitalRoot 9876"], "bad": ["let _ = digitalRoot 9876"], "message": ["Error: Unbound value digitalRoot\n"], "problem": "digitalRoot"}
{"hw": "hw1", "fix": ["let rec additivePersistenceDigitalRoot (a, n) = \nif n < 10\nthen (a, n)\nelse additivePersistenceDigitalRoot (a+1, sumList(digits n))", "let rec additivePersistence (n) = \nlet (a, b) = additivePersistenceDigitalRoot (0, n)\nin a", "let _ = additivePersistence 9876"], "bad": ["let rec additivePersistence (a, n) = \nlet intFun (a, n) = \nif n < 10\nthen (a, n)\nelse intFun (a+1, sumList(digits n))\nin (4,5)"], "message": ["Error: Unbound value intFun\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 03124"], "bad": ["let _ = digitsOfInt o3124"], "message": ["Error: Unbound value o3124\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = List.nth ['a']  3"], "bad": ["let _ = head ['asd']", "let _ = list.head ['asd']", "let _ = List.head ['asd']", "let _ = List.nth (['asd'], 3)", "let _ = List.nth ['asd'], 3", "let _ = List.nth ['asd']  3"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let palindrome (w, p) = \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindrome (w, p + 1)"], "bad": ["let palindrome (w, p) = \nif (List.length w) > (2 * p) and ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindrome (w, p + 1)"], "message": ["Error: Syntax error\n"], "problem": "palindrome"}
{"hw": "hw1", "fix": ["let rec palindromeA (w, p) = \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindromeA (w, p + 1)", "let _ = palindromeA (['a'], 0)"], "bad": ["let _ = palindrome (['a'], 0);\n\nlet palindrome w = failwith \"TBD\"", "let palindromeA (w, p) = \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindromeA (w, p + 1)", "let _ = palindromeA (['a'], 0)", "let palindromeA (w, p) = \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindromeA (w, p + 1)", "let _ = palindromeA (['a'], 0)"], "message": ["Error: Syntax error\n", "Error: Unbound value palindromeA\nHint: Did you mean palindrome?\nError: Unbound value palindromeA\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value palindromeA\nHint: Did you mean palindrome?\n", "Error: Unbound value palindromeA\nHint: Did you mean palindrome?\nError: Unbound value palindromeA\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value palindromeA\nHint: Did you mean palindrome?\n", "Error: Unbound value palindromeA\nHint: Did you mean palindrome?\nError: Unbound value palindromeA\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value palindromeA\nHint: Did you mean palindrome?\n", "Error: Unbound value palindromeA\nHint: Did you mean palindrome?\nError: Unbound value palindromeA\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value palindromeA\nHint: Did you mean palindrome?\n"], "problem": "palindrome"}
{"hw": "hw1", "fix": ["let rec palindromeA (w, p) = \nif ((List.length w) > (2 * p)) && (((List.nth w p) = (List.nth w (List.length w - 1 - p))))\nthen true\nelse palindromeA (w, p + 1)", "let _ = palindromeA (['a','b', 'c'], 0)"], "bad": ["let _ = palindromeA (['a','b', 'c'], 0)"], "message": ["Error: Unbound value palindromeA\n"], "problem": "palindrome"}
{"hw": "hw1", "fix": ["let rec palindromeA (w, p) = \nif (List.length w) <= (2 * p)\nthen if ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse false\nelse palindromeA (w, p + 1)", "let _ = palindromeA ([], 0)"], "bad": ["let rec palindromeA (w, p) = \nif (List.length w) <= (2 * p)\nif ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse false\nelse palindromeA (w, p + 1)"], "message": ["Error: Syntax error\n"], "problem": "palindrome"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) =\nwwhile (if f b = b then (f b, false) else (f b, true),b)"], "bad": ["let fixpoint (f,b) =\nwwhile ((f, (f b) != b),b)", "let fixpoint (f,b) =\nwwhile ((f, f b = b),b)", "let fixpoint (f,b) =\nwwhile ((f, true),b)", "let fixpoint (f,b) =\nwwhile ((failwith \"asd\", true),b)", "let fixpoint (f,b) =\nwwhile ((failwith \"asd\", failwith \"asd\"),b)", "let fixpoint (f,b) =\nwwhile ((failwith \"asd\", undefined),b)", "let fixpoint (f,b) =\nwwhile ((failwith \"Asd\"),b)"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) =\nwwhile ((if f b = b then (failwith \"asd\") else failwith \"asd\") ,b)"], "bad": ["let fixpoint (f,b) =\nwwhile (if f b = b then (f b, false) else failwith \"asd\" ,b)", "let fixpoint (f,b) =\nwwhile ((if f b = b then (f b, false) else failwith \"asd\") ,b)", "let fixpoint (f,b) =\nwwhile ((if f b = b then failwith \"asd\" else failwith \"asd\") ,b)"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type bool -> bool * bool\n", "Error: This expression has type bool -> bool * bool\n       but an expression was expected of type bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) =\nwwhile ((if f b = b then (fun b''\n-> (f b, false)) else failwith \"asd\") ,b)"], "bad": ["let fixpoint (f,b) =\nwwhile ((if f b = b then (true, failwith \"asd\") else failwith \"asd\") ,b)", "let fixpoint (f,b) =\nwwhile ((if f b = b then (b, failwith \"asd\") else failwith \"asd\") ,b)", "let fixpoint (f,b) =\nwwhile ((if f b = b then (failwith \"Asd\", failwith \"asd\") else failwith \"asd\") ,b)", "let fixpoint (f,b) =\nwwhile ((if f b = b then (fun b''\n-> (failwith \"Asd\", failwith \"asd\")) else failwith \"asd\") ,b)"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) =\nwwhile ((if f b = b \nthen (fun b'' -> (f b, false)) \nelse (fun b'' -> (f b, true))), b)"], "bad": ["let fixpoint (f,b) =\nwwhile ((if f b = b \nthen (fun b''\n-> (f b, false)) \nelse (fun b'' -> (f b, true) ,b)", "let fixpoint (f,b) =\nwwhile ((if f b = b \nthen (fun b''\n-> (f b, false)) \nelse (fun b'' -> (f b, true))) ,b)"], "message": ["Characters 28-29:\n  wwhile ((if f b = b \n         ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Characters 29-30:\n  wwhile ((if f b = b \n          ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) =\nwwhile ((fun b' -> if f b' = b' \nthen (f b', false)\nelse (f b', true)), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) <. (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)"], "bad": ["let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi * eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0)", "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0)", "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) / 2.0)", "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)"], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)"], "bad": ["let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)"], "message": ["Error: Unbound value <.\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let g1 () = failwith \"to be implemented\"", "let g2 () = failwith \"to be implemented\"", "let g3 () = failwith \"to be implemented\"", "let c1 () = failwith \"to be implemented\"", "let c2 () = failwith \"to be implemented\"", "let c3 () = failwith \"to be implemented\"", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type test = unit -> string", "let key = \"\"", "let prefix130 = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")", "let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0", "let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)", "let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))", "let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p", "let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max"], "bad": ["let rec build (rand, depth) = \nlet r = rand (if depth = 0 then (6, 7) else (1, 5)) in\nmatch r with\n1 -> buildSine (build (rand, depth - 1))\n| 2 -> buildCosine (build (rand, depth - 1))\n| 3 -> buildAverage ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 4 -> buildTimes (build (rand, depth - 1)) (build (rand, depth - 1))\n| 5 -> buildThresh (build (rand, depth - 1)) (build (rand, depth - 1)) (build (rand, depth - 1)) (build (rand, depth - 1))\n| 6 -> VarX\n| 7 -> VarY", "let rec build (rand, depth) = \nlet r = rand (if depth = 0 then (6, 7) else (1, 5)) in\nmatch r with\n1 -> buildSine (build (rand, depth - 1))\n| 2 -> buildCosine (build (rand, depth - 1))\n| 3 -> buildAverage ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 4 -> buildTimes ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 5 -> buildThresh ((build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)))\n| 6 -> VarX\n| 7 -> VarY"], "message": ["Error: This function has type expr * expr -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type expr * expr -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let _ = log (0.0-1.0)"], "bad": ["let _ = log 1.0"], "message": ["Error: This expression has type float -> float\n       but an expression was expected of type int\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let _ = log (1.5-.2.0)"], "bad": ["let _ = log (0.5-1.0)", "let _ = log (1.5-1.0)", "let _ = log (1.5-.1.0)"], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "???"}
{"hw": "hw2", "fix": ["fabs"], "bad": ["abs"], "message": ["Error: Unbound value absf\nHint: Did you mean abs?\n"], "problem": "???"}
{"hw": "hw2", "fix": ["log 0.00001"], "bad": ["min 3.1 3.1"], "message": ["Error: This expression has type float\n       This is not a function; it cannot be applied.\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = (max 0.1 l') in (log l) /. (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)"], "bad": ["let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = (min 0.1 l') in (log l) / (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)", "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = (min 0.1 l') in (log l) /. (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)"], "message": ["Error: This expression has type int ref\n       This is not a function; it cannot be applied.\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' -1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> 1.0"], "bad": ["let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> max 1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> 1.0", "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' 1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> 1.0"], "message": ["Error: This expression has type int ref\n       but an expression was expected of type int\n", "Error: This expression has type int ref\n       This is not a function; it cannot be applied.\n"], "problem": "eval"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let _ = pipe [(fun x -> x)] 4"], "bad": ["let _ = pipe [(fun x -> x + 2)] 4", "let _ = pipe [(fun x -> 2)] 4"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a x in\nlet base = fun y -> y in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y + 3 in\nList.fold_left f base fs", "let _ = pipe [] 3"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y _+ 3 in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = a in\nlet base = fun y -> y in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = 3 + a in\nlet base = fun y -> y in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = 3 + a in\nlet base = fun y -> y in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y in\nList.fold_left f base fs", "(fun a -> a + 1) (fun b -> b + 3) 4"], "bad": ["let _ = pipe [(fun x -> x); (fun x -> x)] 4"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun g -> (x a) g in\nlet base = fun g -> g in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun g -> g (x a) in\nlet base = fun g -> g in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun g -> (x a) g in\nlet base = fun g -> g in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let pipe fs = \nlet f a x = fun g -> (a x) g in\nlet base = fun g -> g in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun g -> g (a x)  in\nlet base = fun g -> g in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun g -> g (x a)  in\nlet base = fun g -> g in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun g -> (g x) a  in\nlet base = fun g -> g in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun g -> (g a) x  in\nlet base = fun g -> g in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun g -> (a x) g in\nlet base = fun g -> g in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type ('a -> 'a -> 'b) -> 'a -> 'a -> 'b\n       but an expression was expected of type\n         ('a -> 'a -> 'b) -> 'a -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'a) -> 'a -> 'a\n       but an expression was expected of type ('a -> 'a) -> 'a\n       The type variable 'a occurs inside 'a -> 'a\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type 'a -> 'b -> ('b -> 'a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('b -> 'a -> 'c) -> 'c\n", "Error: This expression has type 'a -> 'b -> ('a -> 'b -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'b -> 'c) -> 'c\n", "Error: This expression has type ('a -> 'a -> 'b) -> 'a -> 'a -> 'b\n       but an expression was expected of type\n         ('a -> 'a -> 'b) -> 'a -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun g -> x (a g) in\nlet base = fun g -> g in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ \"a\" in\nlet base = failwith \"\" in\nlet l = sl in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = ^ \"a\" in\nlet base = failwith \"\" in\nlet l = sl in\nList.fold_left f base l"], "message": ["Error: Syntax error\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": [" h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = sepConcat \"; \" (List.map f l)"], "bad": ["let stringOfList f l = sepConcat \"; \" (map f l)"], "message": ["Error: Unbound value map\nHint: Did you mean max?\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let rec clone x n = match n with\n| 0 -> []\n| _ -> x :: clone x (n - 1)"], "bad": ["let rec clone x n = match n with\n| 0 -> []\n| x :: clone x (n - 1)"], "message": ["Error: Syntax error: pattern expected.\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nlet ll1 = List.length l1\nin let ll2 = List.length l2\nin ((clone 0 (ll2 - ll1)) @ l1, (clone 0 (ll1 - ll2)) @ l2)"], "bad": ["let padZero l1 l2 = \nlet l1 = List.length l1\nin let l2 = List.length l2\nin ((clone 0 (l2 - l1)) @ l1, (clone 0 (l1 - l2)) @ l2)"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) mod 10) in\nlet base = (0, 1) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in\nlet base = (0, 1) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int * int\n       but an expression was expected of type int * int list\n       Type int is not compatible with type int list \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) :: ds) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) :: ds) in\nlet base = (0, []) in\nlet args = List.reverse (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Unbound value List.reverse\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = (2, ds @ [(c + x1 + x2)]) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((2, ds @ [(c + x1 + x2)]) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Characters 65-66:\n  let f (c, ds) (x1, x2) = ((2, ds @ [(c + x1 + x2)]) in\n                           ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = if List.length ds = List.length l1 \nthen (0, (c + x1 + x2) / 10 :: (c + x1 + x2) mod 10 :: ds)\nelse ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = if List.length ds = List.length x1 \nthen (0, (c + x1 + x2) / 10 :: (c + x1 + x2) mod 10 :: ds)\nelse ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f (indent, acc) x = (0 :: indent, (List.fold_left bigAdd [] (clone l2 x)) @ indent) in\nlet base = ([], []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f (indent, acc) x = (0 :: indent, (List.fold_left bigAdd 0 (clone l2 x)) @ indent) in\nlet base = ([], []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "bigMul"}
{"hw": "hw1", "fix": ["let rec sumList xs = failwith \"TBD:sumList\""], "bad": ["val sumList : int list -> int", "sumList : int list -> int", "sumList : int list -> int", "val sumList : int list -> int", "val sumList : int list -> int", "let sumList : int list -> int", "let sumList : int list -> int", "let sumList : int list -> int", "sumList : int list -> int", "sumList : int list -> int"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let rec sumList xs =\nmatch xs with\n| [] -> []\n| let sum  = sum + hd :: sumLists tl", "failwith \"TBD:sumList\"", "let _ = sumList [1; 2; 3; 4]"], "bad": ["let rec sumList xs =\nmatch xs with\n| [] -> []\n| let sum in hd::tl -> sum = sum + hd :: sumLists tl"], "message": ["Error: Syntax error\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let rec sumList xs =\nmatch xs with\n| [] -> []\n| hd::tl -> hd + (sumList tl)", "failwith \"TBD:sumList\"", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]"], "bad": ["let rec sumList xs =\nmatch xs with\n| [] -> []\n| hd::tl -> sum  = sum + hd :: sumLists tl"], "message": ["Error: Unbound value sum\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let digitsOfInt n = \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663"], "bad": ["let _ = digitsOfInt 352663"], "message": ["Error: Unbound value sumList\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let digitsOfInt n = \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n acc"], "bad": ["let _ = digitsOfInt 345"], "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663"], "bad": ["let digitsOfInt n = \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n [7]"], "message": ["Error: Unbound value acc\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let digitsOfInt n = \nlet rec loop n tlist =\nif n = 0 then tlist\nelse loop (n/10) (n mod 10::tlist) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n [7]", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663"], "bad": ["let digitsOfInt n = \nlet rec loop n tlist =\nif n = 0 then tlist\nelse loop (n/10) (n mod 10::tlist)"], "message": ["Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)\nin\nahelper d k l", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "bad": ["let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\nmatch hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| () -> d\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "message": ["Error: Syntax error\n", "Error: Unbound value assoc\n", "Error: Unbound value assoc\n", "Error: Syntax error\n", "Error: Unbound value assoc\n", "Error: Unbound value assoc\n", "Error: Syntax error\n", "Error: Unbound value assoc\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen::h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = (seen::h) in\nlet rest' = (t) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: Unbound value removeDuplicates\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl 2 = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl hd = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl 2 = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a list list\n       The type variable 'a occurs inside 'a list list\n", "Error: This expression has type int but an expression was expected of type\n         'a list list\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem h tl = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl hd = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a list list\n       The type variable 'a occurs inside 'a list list\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) =\nlet rec wwhelper f b =\nlet (b', c') = f b in\nif (c' = false) then b'\nelse wwhelper f b'\nin wwhelper f b", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "bad": ["let rec wwhile (f,b) =\nlet rec wwhelper f b =\nlet (b', c') = f b;\nif (c' = false) then b'\nelse wwhelper f b'\nin wwhelper fb", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let rec wwhile (f,b) =\nlet rec wwhelper f b =\nlet (b', c') = f b;\nif (c' = false) then b'\nelse wwhelper f b'\nin wwhelper f b", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "message": ["Error: Syntax error\n", "Error: Unbound value wwhile\n", "Error: Syntax error\n", "Error: Unbound value wwhile\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let rec exprToString e =\nlet rec eTShelper e expr =\nlet e::= x \n| y \n| sin (pi*e) \n| cos (pi*e) \n| ((e + e)/2) \n| e * e \n| (e<e ? e : e) in\nmatch e with\n| VarX -> expr ^ e\n| VarY -> expr ^ e\n| Sine -> expr ^ e\n| Cosine -> expr ^ e\n| Average  -> expr ^ e\n| Times    -> expr ^ e\n| Thresh   -> expr ^ e\nin\neTShelper e \"\"", "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))"], "bad": ["let rec exprToString e =\nlet rec eTShelper e expr =\nlet e::= x \n| y \n| sin (pi*e) \n| cos (pi*e) \n| ((e + e)/2) \n| e * e \n| (e<e ? e : e) in\nmatch e with\n| VarX -> expr ^ e\n| VarY -> expr ^ e\n| Sine -> expr ^ e\n| Cosine -> expr ^ e\n| Average  -> expr ^ e\n| Times    -> expr ^ e\n| Thresh   -> expr ^ e\nin\neTShelper e \"\""], "message": ["Error: Syntax error: pattern expected.\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> float x\n| VarY -> float y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\nin\nevalhelper e x y", "let _ = eval(Sine(Varx), 0.5, -0.5)"], "bad": ["let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi * evalhelper p1)\n| Cosine(p1) -> evalhelper p1\nin\nevalhelper e x y", "let _ = eval(Sine(Varx), 0.5, -0.5)", "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1)\n| Cosine(p1) -> evalhelper p1\nin\nevalhelper e x y", "let _ = eval(Sine(Varx), 0.5, -0.5)", "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. float evalhelper p1)\n| Cosine(p1) -> evalhelper p1\nin\nevalhelper e x y", "let _ = eval(Sine(Varx), 0.5, -0.5)", "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1)\n| Cosine(p1) -> cos(pi *. evalhelper p1)\nin\nevalhelper e x y", "let _ = eval(Sine(Varx), 0.5, -0.5)", "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> float x\n| VarY -> float y\n| Sine(p1) -> sin(pi *. evalhelper p1)\n| Cosine(p1) -> cos(pi *. evalhelper p1)\nin\nevalhelper e x y", "let _ = eval(Sine(Varx), 0.5, -0.5)", "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> float x\n| VarY -> float y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1)\nin\nevalhelper e x y", "let _ = eval(Sine(Varx), 0.5, -0.5)"], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This variant expression is expected to have type expr\n       The constructor Varx does not belong to type expr\nHint: Did you mean VarX or VarY?\n", "Error: This expression has type 'a -> 'a -> 'a\n       but an expression was expected of type float\n", "Error: This variant expression is expected to have type expr\n       The constructor Varx does not belong to type expr\nHint: Did you mean VarX or VarY?\n", "Error: This function has type int -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This variant expression is expected to have type expr\n       The constructor Varx does not belong to type expr\nHint: Did you mean VarX or VarY?\n", "Error: This expression has type 'a -> 'a -> 'a\n       but an expression was expected of type float\n", "Error: This variant expression is expected to have type expr\n       The constructor Varx does not belong to type expr\nHint: Did you mean VarX or VarY?\n", "Error: This expression has type int -> int -> float\n       but an expression was expected of type float\n", "Error: This variant expression is expected to have type expr\n       The constructor Varx does not belong to type expr\nHint: Did you mean VarX or VarY?\n", "Error: This expression has type int -> int -> float\n       but an expression was expected of type float\n", "Error: This variant expression is expected to have type expr\n       The constructor Varx does not belong to type expr\nHint: Did you mean VarX or VarY?\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\nin\nevalhelper e x y", "let _ = eval(Sine(VarX), 0.5, -0.5)"], "bad": ["let _ = eval(Sine(VarX), 0.5, -0.5)"], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = sin(pi*.0.3)"], "bad": ["let _ = sin(pi*0.3)"], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"Var\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ (buildhelper 0 (depth-1) expr) ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\""], "bad": ["let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"Var\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 depth-1 expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 depth-1 expr ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"Var\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 depth-1 expr ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\""], "message": ["Error: This expression has type string -> string\n       but an expression was expected of type int\n", "Error: This expression has type string -> string\n       but an expression was expected of type int\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand 0 1 = 0) then \nexpr ^ \"((\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"+\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"*\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr)\n| 4 -> \nexpr ^ \"(\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"<\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"?\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \":\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "let _ = build (rand, 3)"], "bad": ["let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand 0 1 = 0) then \nexpr ^ \"((\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"+\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"*\" ^ (eTShelper p2 expr)\n| 4 -> \nexpr ^ \"(\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"<\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"?\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \":\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "let _ = build (rand, 3)"], "message": ["Error: Unbound value eTShelper\n", "Error: Unbound value rand\nHint: Did you mean land?\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let g1 () = failwith \"to be implemented\"", "let g2 () = failwith \"to be implemented\"", "let g3 () = failwith \"to be implemented\"", "let c1 () = failwith \"to be implemented\"", "let c2 () = failwith \"to be implemented\"", "let c3 () = failwith \"to be implemented\"", "let rand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let _ = build (rand, 3)"], "bad": ["let _ = build (rand, 3)"], "message": ["Error: Unbound value rand\nHint: Did you mean land?\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \n(*\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\n*)\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper 0 0 expr)\nelse buildCosine(buildhelper 0 0 expr)\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 3 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 4 ->\nbuildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| _ ->\nbuildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\""], "bad": ["let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n(*\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\n*)\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildCosine(buildhelper 0 (depth-1) expr)\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\nin\nlet num = rand(1,4) in \nbuildhelper num depth \"\"", "let rec build (rand, depth) = \n(*\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\n*)\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper (depth-1) (depth-1) expr)\nelse buildCosine(buildhelper 0 (depth-1) (depth-1) expr)\n| (2 || 3) ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| (4 || _) ->\nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\"", "let rec build (rand, depth) = \n(*\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\n*)\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper (depth-1) (depth-1) expr)\nelse buildCosine(buildhelper 0 (depth-1) (depth-1) expr)\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 3 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 4 ->\nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| _ ->\nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\"", "let rec build (rand, depth) = \n(*\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\n*)\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper 0 0 expr)\nelse buildCosine(buildhelper 0 0 expr)\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 3 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 4 ->\nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| _ ->\nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\""], "message": ["Error: This expression has type expr but an expression was expected of type\n         string\n", "Error: Syntax error: operator expected.\n", "Error: This function has type int -> int -> 'a -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a * 'b * 'c * 'd\n       but an expression was expected of type expr * expr\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile((let k x = f x = x in k b), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let fixpoint (f,b) = wwhile((let k x = f x != x in k b), b)", "let fixpoint (f,b) = wwhile((let k x = f x != b in k b), b)"], "message": ["Error: Unbound value fixpoint\n", "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile((let k x = f x = x in f), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)"], "bad": ["let fixpoint (f,b) = wwhile((fun k x -> f x = x), b)", "let fixpoint (f,b) = wwhile((let k x = f x = x", "), b)", "let fixpoint (f,b) = wwhile((let k x = f x = x;), b)", "let fixpoint (f,b) = wwhile((let k x = f x = x in k b), b)", "let fixpoint (f,b) = wwhile((let k x = f x != x in k b), b)", "let fixpoint (f,b) = wwhile((let k x = f x in (x, x=b)), b)"], "message": ["Error: Unbound value fixpoint\n", "Error: This function expects too many arguments, it should have type\n'a -> 'a * bool\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error\n", "Error: Syntax error: operator expected.\n", "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile((let k x = f x in (b, (k b)!=b)), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)"], "bad": ["let fixpoint (f,b) = wwhile({let k x = f x in (b, k b!=b)), b", "let fixpoint (f,b) = wwhile({let k x = f x in (b, (k b)!=b)), b", ")"], "message": ["Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)"], "bad": ["let fixpoint (f,b) = wwhile((let k x = f x in (b, b!=b)), b)", "let fixpoint (f,b) = wwhile(let k x = f x in (b, b!=b), b)", "let fixpoint (f,b) = wwhile(let k x = f x = y in (x, y!=x), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let fixpoint (f,b) = wwhile(let k x = f x = x in (x, x!=x), b)", "let fixpoint (f,b) = wwhile(let k x = let y = f x in (x, y!=x), b)", "let fixpoint (f,b) = wwhile(let k x = let y = f x in f x in (x, y!=x), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let fixpoint (f,b) = wwhile(let f x = let xx = x*x*x in (xx, xx < 100), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value fixpoint\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: Unbound value y\n", "Error: Unbound value fixpoint\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: Syntax error: operator expected.\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: Unbound value fixpoint\n", "Error: Syntax error: operator expected.\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)"], "bad": ["let fixpoint (f,b) = wwhile(let g x = f x in (x, x<100), b)", "let fixpoint (f,b) = wwhile(let g x = f x in (g x, x<100), b)", "let fixpoint (f,b) = wwhile(let g x = f x in g x in (x, x<100), b", ")", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let fixpoint (f,b) = wwhile(let g x = f x in g b in (x, x<100), b", ")", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let fixpoint (f,b) = wwhile((let g x = f x in g b in (x, x<100)", "), b", "let fixpoint (f,b) = wwhile(let g x = (f x) in g b in (x, x<100), b", ")", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1"], "message": ["Error: Unbound value fixpoint\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Characters 27-28:\n  let fixpoint (f,b) = wwhile(let g x = f x in g x in (x, x<100), b;;\n                             ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Error: Unbound value fixpoint\n", "Characters 27-28:\n  let fixpoint (f,b) = wwhile(let g x = f x in g b in (x, x<100), b;;\n                             ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Error: Unbound value fixpoint\n", "Characters 28-29:\n  let fixpoint (f,b) = wwhile((let g x = f x in g b in (x, x<100);;\n                              ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Characters 27-28:\n  let fixpoint (f,b) = wwhile(let g x = (f x) in g b in (x, x<100), b;;\n                             ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Error: Unbound value fixpoint\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "bad": ["let fixpoint (f,b) = wwhile(let g x = (f x) in g b, b)"], "message": ["Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile(let g x = f x in g b, b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "bad": ["let fixpoint (f,b) = wwhile(let g x = f x in g b != x, b)", "let fixpoint (f,b) = wwhile(let g x = f x in g b != b, b)"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "bad": ["let fixpoint (f,b) = wwhile(let g x = f x in (g b, (g b)!= b), b)", "let fixpoint (f,b) = wwhile(let xx = x*x*x in (xx, xx < 100), b)", "let fixpoint (f,b) = wwhile(let xx = b*b*b in (xx, xx < 100), b)", "let fixpoint (f,b) = wwhile(let f x = let xx = x*x*x in (xx, xx < 100), b)", "let fixpoint (f,b) = wwhile((let g x = f x in f), b)"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: Syntax error: operator expected.\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "bad": ["let fixpoint (f,b) = wwhile((let g f x = let y = f x in (y,y != x)), b)", "let fixpoint (f,b) = wwhile((let y = let g f x = f x in (y,y != x)), b)", "let fixpoint (f,b) = wwhile((let g x = f x != x in (y,y != x)), b)", "let fixpoint (f,b) = wwhile((let g x = f x in (x, x!=x)), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let fixpoint (f,b) = wwhile((let g x = f x !=x), b)", "let fixpoint (f,b) = wwhile((let g x = f x !=x in g b), b)", "let fixpoint (f,b) = wwhile((let g x = f x in g b), b)"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "Error: Syntax error: operator expected.\n", "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "bad": ["let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g b), b)", "let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g), b)"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile((let g b = let xx = f x in (xx, xx!=b) in g), b)"], "bad": ["let fixpoint (f,b) = wwhile((let g x = let xx = f x in (b, xx!=b) in g), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile((let g x = let xx = f xx in (xx, xx!=b) in g), b)"], "bad": ["let fixpoint (f,b) = wwhile((let g x = let xx = f b in (xx, xx!=b) in g), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g b), b)"], "bad": ["let fixpoint (f,b) = wwhile((let g xx = let xx = f x in (xx, xx!=b) in g), b)", "let fixpoint (f,b) = wwhile((let g x = xx = f x in (xx, xx!=b) in g", "let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Characters 28-29:\n  let fixpoint (f,b) = wwhile((let g x = xx = f x in (xx, xx!=b) in g;;\n                              ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=b) in inwwhile), b)"], "bad": ["let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile((let inwwhile x = f x in (inwwhile b, (inwwhile b)!=b)), b)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)"], "bad": ["let fixpoint (f,b) = wwhile((let inwwhile x = f x in (x, (inwwhile b)!=b)), b)", "let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=b)), b)", "let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=b) in inwwhile), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Syntax error: operator expected.\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=(f b)) in inwwhile), b)"], "bad": ["let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "message": ["Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value fixpoint\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)"], "bad": ["let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (res, res!=(f b)) in helper), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (f b, res!=(f b)) in helper), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (b, res!=(f b)) in helper), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (res, res!=b) in helper), b)"], "bad": ["let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)", "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (f b, res!=b) in helper), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (res, res!=(f b)) in helper), b)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (res, res!=(f b)) in \nprintf(\"%d\\n\", helper)), b)", "let fixpoint (f,b) = \nwwhile(let helper x = (f x != (f b)) in helper), b", ")", "let fixpoint (f,b) = \nwwhile(let helper x = (f x != (f b)) in helper b), b", "let fixpoint (f,b) = \nwwhile(let helper x = (f x != (f b)) in helper), b", "let fixpoint (f,b) = \nwwhile(let helper x = (f x, f x != (f b)) in helper), b", "let fixpoint (f,b) = \nwwhile(let helper x = (f x, f x = (f b)) in helper), b", "let fixpoint (f,b) = \nwwhile(let helper x = (f x, f x = (f b)) in helper b), b", ")", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let fixpoint (f,b) = \nwwhile(let helper x = (f x, f x = (f b)) in helper b, b)", "let fixpoint (f,b) = \nwwhile(let helper x = (f x, f x = (f b)) in helper b, b)", "let fixpoint (f,b) = \nwwhile((let helper x = (f x, f x = (f b)) in helper b), b)", "let fixpoint (f,b) = \nwwhile((let helper x = (f x, (f x)=(f b)) in helper b), b)", "let fixpoint (f,b) = \nwwhile((let helper x = (f x, (f x)=(f b)) in helper), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Syntax error\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Syntax error\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let fixpoint (f,b) = \nwwhile((let helper x = (f b, b=(f b)) in helper), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let fixpoint (f,b) = \nwwhile((let helper x = (f b, b=(f b)) in helper b), b)", "let fixpoint (f,b) = \nwwhile((let helper x = (f b, b=f b) in helper), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = \nwwhile((let helper x = (f x, b!=f x) in helper), b)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = \nwwhile((let helper x = (f x, b=f x) in helper), b)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = \nwwhile((let helper x = f x, b=f x in helper b), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)"], "bad": ["let fixpoint (f,b) = \nwwhile((let helper x = (f x, b=f x) in helper b), b)", "let fixpoint (f,b) = \nwwhile((let helper x = f x, b=f x in helper b), b)", "let fixpoint (f,b) = \nwwhile((let helper x = f x, b=f x in helper), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = \nwwhile((let helper x = (f x, f x = b) in helper), b)"], "bad": ["let fixpoint (f,b) = \nwwhile((let helper x = (f x, b=f x) in helper b), b)", "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b=f x) in (helper b)), b)", "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b=f x) in helper b), b)", "let fixpoint (f,b) = \nwwhile((let helper b = (f b, b=f x) in helper), b)", "let fixpoint (f,b) = \nwwhile((let helper b = (f b, b=f b) in helper), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b < 10) in helper), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let fixpoint (f,b) = \nwwhile((let helper x = (f x, f x=x) in helper), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = \nwwhile((let helper x = (f b, x!=(f x)) in helper), b)"], "bad": ["let fixpoint (f,b) = \nwwhile((let helper x = (f x, (f x)=x) in helper b), b)", "let fixpoint (f,b) = \nwwhile((let helper x = (f x, (f x)=x) in helper), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let fixpoint (f,b) = \nwwhile((let helper x = (f x, x!=(f x)) in helper b), b)", "let fixpoint (f,b) = \nwwhile((let helper x = (f x, x!=(f x)) in helper), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let fixpoint (f,b) = \nwwhile((let helper x = (f x, x!=(f x)) in (helper b)), b)", "let fixpoint (f,b) = \nwwhile((let helper x = (f x, x!=(f x)) in helper b), b)", "let fixpoint (f,b) = \nwwhile((let helper x = (f x, x!=(f x)) in helper), b)", "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b!=(f x)) in helper), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = \nwwhile((let helper x = let xx = f x in (f x, x!=(f x)) in helper), b)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)"], "bad": ["let fixpoint (f,b) = \nwwhile((let helper x = let xx = f x in (xx, x!=(xx)) in helper), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)", "let fixpoint (f,b) = \nwwhile((let helper x = (f x, x!=(f x)) in helper), b)"], "message": ["Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n"], "problem": "fixpoint"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = (+)\nin\nlet base = f 2 xs\nin\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = base + xs**2 in\nList.fold_left f base xs", "let _ = sqsum []", "let sqsum xs = \nlet f a x = base**2 in\nlet base = base+a in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = base**2 in\nlet base = a in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = a**2 in\nlet base = a in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = int a**2 in\nlet base = a in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = a+base in\nlet base = a in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = a in\nlet base = a in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = (+) in\nlet base = a in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = (+) in\nlet base = base + f a x in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = (+) in\nlet base = f a x in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = (+) in\nlet base = base in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = (+) in\nlet base = a ** 2 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = (+) in\nlet base = 3**2 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = (+) in\nlet base = 2 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = (+) in\nlet base = base + 1 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = (+) in\nlet base = 0 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = (+)\nin\nlet base = base + a**2\nin\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = (+)\nin\nlet base = a**2\nin\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = (+)\nin\nlet base = f a**2 x\nin\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = (+)\nin\nlet base = f 2 x\nin\nList.fold_left f base xs"], "message": ["Error: Unbound value base\n", "Error: Unbound value sqsum\n", "Error: Unbound value base\n", "Error: Unbound value base\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: Unbound value int\n", "Error: Unbound value base\n", "Error: Unbound value a\n", "Error: Unbound value a\n", "Error: Unbound value base\n", "Error: Unbound value a\n", "Error: Unbound value base\n", "Error: Unbound value a\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         int -> int -> int\n", "Error: Unbound value base\n", "Error: This expression has type int but an expression was expected of type\n         int -> int -> int\n", "Error: Unbound value base\n", "Error: Unbound value a\n", "Error: Unbound value a\n", "Error: Unbound value x\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a in\nlet base = f 2 xs\nin\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = a**2 in\nlet base = f 2 xs\nin\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = a + base in\nlet base = f 2 xs\nin\nList.fold_left f base xs"], "message": ["Error: This expression has type int but an expression was expected of type\n         float\n", "Error: Unbound value base\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a*a in\nlet base = f 2 xs\nin\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = a*a in\nlet base = []\nin\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = a*a in\nlet base = _\nin\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> []\n| x::xs' -> f x xs'\nin\nList.fold_left f base xs"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a*a in\nlet base = 0\nin\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = x*x in\nlet base = f 2 xs\nin\nList.fold_left f base xs"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a*a in\nlet base = f 4 xs\nin\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = \nmatch x with\n| hd::tl -> hd * hd + f a tl\nin\nlet base = f 4 xs\nin\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = \nmatch x with\n| hd::tl -> hd * hd + (f a tl)\nin\nlet base = f 4 xs\nin\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = \nmatch x with\n| hd::tl -> hd * hd\nin\nlet base = f 4 xs\nin\nList.fold_left f base xs"], "message": ["Error: Unbound value f\n", "Error: Unbound value f\n", "Error: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + x*x in\nlet base = f 4 xs\nin\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]"], "bad": ["let sqsum xs = \nlet f a x = a + x*x in\nlet base = f 4 xs\nin\nList.fold_left f base xs"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a*a in\nlet base = f (f 0 xs) xs\nin\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = a*a in\nlet base = f a xs\nin\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = a*a in\nlet base = f base xs\nin\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = a*a in\nlet base = f (f a xs) xs\nin\nList.fold_left f base xs"], "message": ["Error: Unbound value a\n", "Error: Unbound value base\n", "Error: Unbound value a\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a*a in\nlet base = f 4 xs\nin\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = a*a in\nlet base = f _ xs\nin\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = a*a in\nlet base = f 4 thing\nin\nList.fold_left f base xs"], "message": ["Error: Syntax error\n", "Error: Unbound value thing\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a*a in\nlet base = f 8 xs\nin\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]"], "bad": ["let sqsum xs = \nlet f a x = a*a + x in\nlet base = f 4 xs\nin\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = a*a in\nlet base = base + f 4 xs\nin\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = a*a in\nlet base = f base xs\nin\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = a*a in\nlet base = f xs xs\nin\nList.fold_left f base xs"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: Unbound value base\n", "Error: Unbound value base\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> 0\n| hd::tl -> f (f 0 hd) tl\nin\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> base\n| hd::tl -> f (f base hd) tl\nin\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> 0\n| hd::tl -> f (f base hd) tl\nin\nList.fold_left f base xs"], "message": ["Error: Unbound value base\n", "Error: Unbound value base\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> 4\n| hd::tl -> f (f 2 hd) tl\nin\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]"], "bad": ["let sqsum xs = \nlet f a x =  \nmatch xs with\n| [] -> a\n| hd::tl -> f (f a hd) tl in\nlet base = 0\nin\nList.fold_left f base xs", "let sqsum xs = \nlet rec f a x =  \nmatch xs with\n| [] -> a\n| hd::tl -> f (f a hd) tl in\nlet base = 0\nin\nList.fold_left f base xs"], "message": ["Error: Unbound value f\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a*a in\nlet base = f 2 xs\nin\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = a*a in\nlet base = base\nin\nList.fold_left f base xs"], "message": ["Error: Unbound value base\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> f 0 xs\n| hd::tl -> f (f hd hd) tl\nin\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> f 0 xs\n| hd::tl -> f (f base hd) tl\nin\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> f 0 xs\n| hd::tl -> f (f a hd) tl\nin\nList.fold_left f base xs"], "message": ["Error: Unbound value base\n", "Error: Unbound value a\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| hd::tl -> f (f hd hd) tl\nin\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> xs\n| hd::tl -> f (f hd hd) tl\nin\nList.fold_left f base xs"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| hd::tl -> f hd hd + f (f hd hd) tl\nin\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| hd::tl -> f hd hd + f tl tl\nin\nList.fold_left f base xs"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = match xs with\n| [] -> a\n| hd::tl -> hd*hd in\nlet base = f 0 xs\nin\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = match xs with\n| [] -> a\n| hd::tl -> f hd tl in\nlet base = f 0 xs\nin\nList.fold_left f base xs"], "message": ["Error: Unbound value f\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = \nmatch xs with\n| [] -> a\n| hd::tl -> a + hd*hd in\nlet base = f 4 xs\nin\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = \nmatch xs with\n| [] -> a\n| hd::tl -> a + hd*hd in\nlet base = []\nin\nList.fold_left f base xs"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + x*x in\nlet base = match xs with\n| [] -> 0\n| hd::tl -> f 0 hd\nin\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = \nmatch xs with\n| [] -> a\n| hd::tl -> a + x*x in\nlet base = f 0 xs\nin\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = a + x*x in\nlet base = match xs with\n| [] -> []\n| hd::tl -> f 0 hd\nin\nList.fold_left f base xs"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + x*x in\nlet base = \nmatch xs with\n| [] -> f 0 0\n| hd::tl -> f 0 hd\nin\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = a + x*x in\nlet base = \nmatch xs with\n| [] -> f 0 []\n| hd::tl -> f 0 hd\nin\nList.fold_left f base xs"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + x*x in\nlet base = \nmatch xs with\n| [] -> 0\n| hd::tl -> f 0 hd\nin\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]"], "bad": ["let sqsum xs = \nlet f a x = a + x*x in\nlet base = \nmatch xs with\n| [] -> 0\n| hd::tl -> f -1 hd\nin\nList.fold_left f base xs"], "message": ["Error: This expression has type int -> int -> int\n       but an expression was expected of type int\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let _ = sqsum [1;2;3]", "List.fold_left (fun sum a -> sum + a * a) 0 [2;5;3;1]"], "bad": ["let _ = sqsum [1;2;3]\n\nList.fold_left (fun sum a -> sum + a * a) 0 [2;5;3;1]"], "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x in\nlet base = 0\nin\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "message": ["Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> x\nin\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a x in\nlet base = 0\nin\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let pipe fs = \nlet f a x =  in\nlet base = x\nin\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = x\nin\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Syntax error\n", "Error: Unbound value x\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> 0\nin\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "bad": ["let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x\nin\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> x\nin\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun x -> x a in\nlet base = fun x -> x\nin\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> 0\nin\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "bad": ["let pipe fs = \nlet f a x = fun x -> a x in\nlet base = x\nin\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> a\nin\nList.fold_left f base fs"], "message": ["Error: Unbound value x\n", "Error: Unbound value a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun y ->  a x in\nlet base = fun x -> x\nin\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun y ->  y a x in\nlet base = fun x -> x\nin\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b -> ('a -> 'b -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'b -> 'c) -> 'c\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun k -> x k(a) in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "bad": ["let pipe fs = \nlet f a x = fun y ->  a (y x) in\nlet base = fun x -> x\nin\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'c -> ('c -> 'a) -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'c -> 'a -> 'b\n       The type variable 'a occurs inside 'c -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun k -> x a in\nlet base = fun x -> x\nin\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         (int -> int) -> int\n", "Error: This expression has type int but an expression was expected of type\n         (int -> int) -> int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun k -> x k(k) in\nlet base = fun x -> x\nin\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun k -> x k(f a k) in\nlet base = fun x -> x\nin\nList.fold_left f base fs"], "message": ["Error: Unbound value f\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun k -> x k(a) in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         int -> int\n", "Error: This expression has type int but an expression was expected of type\n         int -> int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun k -> a x in\nlet base = fun y -> y\nin\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "bad": ["let pipe fs = \nlet f a x = fun k -> fun a x in\nlet base = fun y -> y\nin\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun k -> a k(x) in\nlet base = fun y -> y\nin\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: This expression has type ('a -> 'b -> 'c) -> 'b -> 'a -> 'c\n       but an expression was expected of type\n         ('a -> 'b -> 'c) -> 'b -> 'a -> 'b -> 'c\n       The type variable 'c occurs inside 'b -> 'c\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun k -> x k a in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "bad": ["let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun k -> x a k in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "bad": ["et _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "message": ["Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         (int -> int) -> int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))"], "bad": ["let rec clone x n =\nmatch n > 0 with\n| true -> x::(clone x n-1)\n| false -> x", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let rec clone x n =\nmatch n > 0 with\n| true -> x::(clone x n-1)\n| false -> x::[]", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let rec clone x n =\nmatch n > 0 with\n| true -> x @ clone x n-1\n| false -> x @ []", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let rec clone x n =\nmatch n > 0 with\n| true -> x @ clone x n-1\n| false -> []", "let rec clone x n =\nmatch n = 0 with\n| true -> x\n| false -> x @ clone x n-1", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let rec clone x n =\nmatch n = 0 with\n| true -> (x)\n| false -> (x) @ (clone x n-1)", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let rec clone x n =\nmatch n = 0 with\n| true -> []\n| false -> (x) @ (clone x n-1)", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let rec clone x n =\nmatch n = 0 with\n| true -> []\n| false -> (x) :: (clone x n-1)", "let rec clone x n =\nmatch n = 0 with\n| true -> []\n| false -> (x) @ (clone x n-1)", "let rec clone x n =\nmatch n = 0 with\n| true -> []\n| false -> (x) :: (clone x n-1)", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x n-1)", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: Unbound value clone\n", "Error: Unbound value clone\n", "Error: Unbound value clone\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: Unbound value clone\n", "Error: Unbound value clone\n", "Error: Unbound value clone\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: Unbound value clone\n", "Error: Unbound value clone\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: Unbound value clone\n", "Error: Unbound value clone\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: Unbound value clone\n", "Error: Unbound value clone\n", "Error: Unbound value clone\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: Unbound value clone\n", "Error: Unbound value clone\n", "Error: Unbound value clone\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: Unbound value clone\n", "Error: Unbound value clone\n", "Error: Unbound value clone\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: Unbound value clone\n", "Error: Unbound value clone\n", "Error: Unbound value clone\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\nclone 0 (List.length l1 - List.length l2) @ l2\nelse if (List.length l1 < List.length l2) then\nclone 0 (List.length l2 - List.length l1) @ l1", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]"], "bad": ["let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\n(clone 0 (List.length l1 - List.length l2)) @ l2\nelse if (List.length l1 < List.length l2) then\nclone 0 (List.length l2 - List.length l1) @ l1", "let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\n(clone 0 (List.length l1 - List.length l2)) @ l2\nelse if (List.length l1 < List.length l2) then\n(clone 0 (List.length l2 - List.length l1)) @ l1", "let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\nclone 0 (List.length l1 - List.length l2) @ l2\nelse if (List.length l1 < List.length l2) then\nclone 0 (List.length l2 - List.length l1) @ l1"], "message": ["Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\nl1::(clone 0 (List.length l1 - List.length l2) @ l2)\nelse if (List.length l1 < List.length l2) then\nl2::(clone 0 (List.length l2 - List.length l1) @ l1)", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]"], "bad": ["let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\nl1::(clone 0 (List.length l1 - List.length l2) @ l2)\nelse if (List.length l1 < List.length l2) then\nclone 0 (List.length l2 - List.length l1) @ l1"], "message": ["Error: This expression has type int list\n       but an expression was expected of type 'a list list\n       Type int is not compatible with type 'a list \n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\nl1::((clone 0 (List.length l1 - List.length l2)) @ l2)\nelse if (List.length l1 < List.length l2) then\nl2::((clone 0 (List.length l2 - List.length l1)) @ l1)", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]"], "bad": ["let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\nl1::((clone 0 (List.length l1 - List.length l2)) @ l2)\nelse if (List.length l1 < List.length l2) then\nl2::((clone 0 (List.length l2 - List.length l1)) @ l1)"], "message": ["Error: This expression has type int list\n       but an expression was expected of type 'a list list\n       Type int is not compatible with type 'a list \n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let padZero l1 l2 =\nmatch List.length l1 > List.length l2 with\n| true -> l1::((clone 0 (List.length l1 - List.length l2)) @ l2)\n| false -> ((clone 0 (List.length l2 - List.length l1)) @ [l1])::l2", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]"], "bad": ["let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\nl1@[(clone 0 (List.length l1 - List.length l2)) @ [l2]]\nelse if (List.length l1 < List.length l2) then\n((clone 0 (List.length l2 - List.length l1)) @ [l1])::l2"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let _ = ([0;0]@[1;1])"], "bad": ["let _ = [9;9;9;9]::([0;0]@[1;1])", "let _ = [9;9;9;9]::([0;0]::[1;1])", "let _ = [9;9;9;9]::([0;0]@[1;1])"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n"], "problem": "???"}
{"hw": "hw3", "fix": ["let _ = List.append ([0;0]@[1;1]) [1]"], "bad": ["let _ = ([0;0]@[1;1])::[1]", "let _ = List.append [0;0]@[1;1] [1]"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type 'a list\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let _ = (([0;0]@[1;1]), [1])", "let padZero l1 l2 =\nmatch List.length l1 > List.length l2 with\n| true -> (l1,((clone 0 (List.length l1 - List.length l2)) @ l2))\n| false -> (((clone 0 (List.length l2 - List.length l1)) @ [l1]),l2)"], "bad": ["let _ = [9;9;9;9]::([0;0]@[1;1])", "let padZero l1 l2 =\nmatch List.length l1 > List.length l2 with\n| true -> (l1,((clone 0 (List.length l1 - List.length l2)) @ l2))\n| false -> (((clone 0 (List.length l2 - List.length l1)) @ [l1]),l2)"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = [0] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a * 'b\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = f l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = () in\nlet base = ([],[]) in\nlet args = f l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = ([],[]) in\nlet args = f l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = in\nlet base = ([],[]) in\nlet args = f l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = ([],[]) in\nlet base = ([],[]) in\nlet args = f l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a list * 'b list\n       but an expression was expected of type int\n", "Error: Syntax error\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = \nlet comb a (hd::tl) =\na + hd\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i-9 != 0) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "let _ = mulByDigit 9 [9;9;9;9]"], "bad": ["let rec mulByDigit i l = \nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i/10 != 0) then\nhd*i mod 10::(hd*i/10 + mBDhelper i tl)\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "let rec mulByDigit i l = \nlet rec mBDhelper i x =\nmatch x with\n| [] -> 0\n| hd::tl ->\nif (hd*i/10 != 0) then\n(hd*i mod 10)::(hd*i/10 + mBDhelper i tl)\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "let rec mulByDigit i l = \nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i-9 != 0) then\n(hd*i/10)::(hd*i mod 10 + mBDhelper i tl)\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = \nlet comb a b =\nmatch b with\n| [] -> (a)\n| hd::tl -> (a + hd)\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i-9 != 0) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "let _ = mulByDigit 9 [9;9;9;9]"], "bad": ["let rec mulByDigit i l = \nlet comb a b =\nmatch b with\n| [] -> a\n| hd::tl -> a + hd\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i-9 != 0) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = \nlet comb a b =\nmatch b with\n| [] -> [a]\n| hd::tl -> [a + hd]::[tl]\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i > 9) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "let _ = mulByDigit 9 [9;9;9;9]"], "bad": ["let rec mulByDigit i l = \nlet comb a b =\nmatch b with\n| [] -> [a]\n| hd::tl -> [a + hd]::tl\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i > 9) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nlet carry =\nmatch a with\n| (x,y) -> x in\nmatch x with\n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = () in\nlet base = ([],[]) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a list * 'b list\n       but an expression was expected of type unit\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nmatch x with\n| (addend_a,addend_b) ->\nlet prevcarry = \nmatch a with\n| (x, y) -> x in\nlet new_carry = (prevcarry + addend_a + addend_b) / 10 in\nlet digit = (prevcarry + addend_a + addend_b) mod 10\nin\nmatch a with\n| (x,[]) -> (new_carry, new_carry::[digit]) \n| (x, c::d::y) -> (new_carry, new_carry::digit::d::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]"], "bad": ["let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nmatch x with\n| (addend_a,addend_b) ->\nlet prevcarry = \nmatch a with\n| (x, y) -> x in\nlet new_carry = (prevcarry + addend_a + addend_b) / 10 in\nlet digit = (prevcarry + addend_a + addend_b) mod 10\nin\nmatch a with\n| (x,[]) -> (new_carry, new_carry::digit) \n| (x, c::d::y) -> (new_carry, new_carry::digit::d::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0\nin\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = fun k -> x (a k) in\nlet base = fun y -> y\nin\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = \nmatch sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l =\nList.map f l", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n =\nlet rec clonehelper tx tn =\nmatch (tn = 0) with\n| true -> []\n| false -> tx :: clonehelper tx (tn - 1)\nin\nclonehelper x (abs n)", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let padZero l1 l2 =\nmatch List.length l1 > List.length l2 with\n| true -> (l1,(List.append (clone 0 (List.length l1 - List.length l2)) l2))\n| false -> ((List.append(clone 0 (List.length l2 - List.length l1)) l1),l2)", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let rec removeZero l =\nlet rec removeZH templ =\nmatch templ with\n| [] -> []\n| hd::tl -> \nif (hd = 0) then removeZH tl\nelse hd::tl\nin\nremoveZH l", "let _ = removeZero [0;0;0;1;0;0;2]", "let _ = removeZero [9;9]", "let _ = removeZero [0;0;0;0]", "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nmatch x with\n| (addend_a,addend_b) ->\nlet prevcarry = \nmatch a with\n| (x, y) -> x in\nlet new_carry = (prevcarry + addend_a + addend_b) / 10 in\nlet digit = (prevcarry + addend_a + addend_b) mod 10\nin\nmatch a with\n| (x, c::d::y) -> (new_carry, new_carry::digit::d::y)\n| _ -> (new_carry, new_carry::[digit]) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]", "let rec mulByDigit i l = \nlet comb a b =\nmatch b with\n| [] -> [a]\n| hd::tl -> List.append [a + hd] tl\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i > 9) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "let _ = mulByDigit 9 [9;9;9;9]", "let bigMul l1 l2 = \nlet f a x = l1 in\nlet base = ([], 1) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> (,)\n| hd::tl -> List.append (x,hd) (argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "let _ = bigMul [9;9;9;9] [9;9;9;9]", "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"], "bad": ["let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> (,)\n| hd::tl -> List.append (x,hd) (argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = l1 in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> (x,[])\n| hd::tl -> List.append (x,hd) (argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "let _ = bigMul [9;9;9;9] [9;9;9;9]", "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"], "bad": ["let bigMul l1 l2 = \nlet f a x = l1 in\nlet base = ([], 1) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> (x,[])\n| hd::tl -> List.append (x,[hd]) (argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = l1 in\nlet base = ([], 1) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> (x,0)\n| hd::tl -> List.append (x,hd) (argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = l1 in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| hd::tl -> \nif (tl=[]) then (x,hd) \nelse (x,hd)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "let _ = bigMul [9;9;9;9] [9;9;9;9]"], "bad": ["let bigMul l1 l2 = \nlet f a x = l1 in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> (x,[])\n| hd::tl -> List.append ((x,hd)) (argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0\nin\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = fun k -> x (a k) in\nlet base = fun y -> y\nin\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = \nmatch sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l =\nList.map f l", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n =\nlet rec clonehelper tx tn =\nmatch (tn = 0) with\n| true -> []\n| false -> tx :: clonehelper tx (tn - 1)\nin\nclonehelper x (abs n)", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let padZero l1 l2 =\nmatch List.length l1 > List.length l2 with\n| true -> (l1,(List.append (clone 0 (List.length l1 - List.length l2)) l2))\n| false -> ((List.append(clone 0 (List.length l2 - List.length l1)) l1),l2)", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let rec removeZero l =\nlet rec removeZH templ =\nmatch templ with\n| [] -> []\n| hd::tl -> \nif (hd = 0) then removeZH tl\nelse hd::tl\nin\nremoveZH l", "let _ = removeZero [0;0;0;1;0;0;2]", "let _ = removeZero [9;9]", "let _ = removeZero [0;0;0;0]", "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nmatch x with\n| (addend_a,addend_b) ->\nlet prevcarry = \nmatch a with\n| (x, y) -> x in\nlet new_carry = (prevcarry + addend_a + addend_b) / 10 in\nlet digit = (prevcarry + addend_a + addend_b) mod 10\nin\nmatch a with\n| (x, c::d::y) -> (new_carry, new_carry::digit::d::y)\n| _ -> (new_carry, new_carry::[digit]) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]", "let rec mulByDigit i l = \nlet comb a b =\nmatch b with\n| [] -> [a]\n| hd::tl -> List.append [a + hd] tl\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i > 9) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "let _ = mulByDigit 9 [9;9;9;9]", "let bigMul l1 l2 = \nlet f a x = a::x in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| hd::tl -> \nif (tl=[]) then [(x,hd)]\nelse (x,hd)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "let _ = bigMul [9;9;9;9] [9;9;9;9]", "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"], "bad": ["let bigMul l1 l2 = \nlet f a x = List.combine a x in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| hd::tl -> \nif (tl=[]) then [(x,hd)]\nelse (x,hd)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "let _ = bigMul [9;9;9;9] [9;9;9;9]", "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]", "let bigMul l1 l2 = \nlet f a x = a::x in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| hd::tl -> \nif (tl=[]) then [(x,hd)]\nelse (x,hd)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type 'a list -> 'b list -> ('a * 'b) list\n       but an expression was expected of type 'a list -> 'b list -> 'a list\n       The type variable 'a occurs inside 'a * 'b\n", "Error: This expression has type 'a list\n       but an expression was expected of type int * 'b list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int * 'b list\n", "Error: This expression has type 'a -> 'a list -> 'a list\n       but an expression was expected of type 'a -> 'a list -> 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let change x =\nlet rec changehelper acc x =\nmatch x with\n| [] -> []\n| hd::tl -> changehelper (acc*10 + hd) tl\nin changehelper 0 x", "let _ = change [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9]"], "bad": ["let change x =\nlet rec changehelper acc x =\nmatch x with\n| [] -> []\n| hd::tl -> changehelper (acc ^ int_to_string hd) tl\nin changehelper \"\" x", "let change x =\nlet rec changehelper acc x =\nmatch x with\n| [] -> []\n| hd::tl -> changehelper (acc ^ int_of_string hd) tl\nin changehelper \"\" x", "let _ = change [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9]"], "message": ["Error: Unbound value int_to_string\nHint: Did you mean int_of_string?\n", "Error: This expression has type int but an expression was expected of type\n         string\n", "Error: This expression has type int but an expression was expected of type\n         string\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n >0 then n/10::[n mod 10]\nelse []"], "bad": ["let rec digitsOfInt n = match n with \n0 -> []\n| n -> [n % 10]::digitsOfInt (n/10)", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let rec digitsOfInt n = \nif n > 0 then digitsOfInt(n/10)::n mod 10\nelse []", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let rec digitsOfInt n = \nif n > 0 then digitsOfInt n/10::n mod 10\nelse []", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let rec digitsOfInt n = \nif n >0 then n/10::n mod 10\nelse []"], "message": ["Error: Unbound value %\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n > 0 then (n mod 10) :: (digitsOfInt (n/10))\nelse []"], "bad": ["if n > 0 then (n mod 10) :: (digitsOfInt (n/10))\nelse []", "et rec digitsOfInt n = \nif n > 0 then (n mod 10) :: (digitsOfInt (n/10))\nelse []"], "message": ["Error: Unbound value n\n", "Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse sumList(digitsOfInt n)"], "bad": ["let rec additivePersistence n = match n with\n| [] -> []\n| h :: t -> t + digitsOfInt (additivePersistence h)", "let rec additivePersistence n = \nif n < 10 then n + sum\nelse let sum _ = sumList (digitsOfInt(n))", "let rec additivePersistence n = \nif n < 10 then n + sum\nelse let sum _ = sumList (digitsOfInt n)", "let rec additivePersistence n = \nif n < 10 then n + sum\nelse let sum _ = additivePersistence sumList (digitsOfInt n)", "let rec additivePersistence n = \nif n < 10 then n + sum\nelse let sum = additivePersistence sumList (digitsOfInt n)", "let additivePersistence n = \nif n < 10 then count\nelse (sumList (digitsOfInt n), count + 1)", "let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse (sumList (digitsOfInt n), count + 1)", "let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse sumList (digitsOfInt n) count + 1"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value count\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n", "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let additivePersistence n = \nlet count = 0 in\nif n < 10 then 1\nelse 1 + sumList(digitsOfInt n)"], "bad": ["let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse count + 1 sumList(digitsOfInt n)", "let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse count + 1 in sumList(digitsOfInt n)"], "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: Unbound value n\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nif n < 10 then 1\nelse 1 + additivePersistence (sumList(digitsOfInt n))"], "bad": ["let rec additivePersistence n = \nif n < 10 then 1\nelse 1 + additivePersistence sumList(digitsOfInt n)"], "message": ["Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec digitalRoot n = \nlet sum = 0 in\nif n < 10 then n + sum\nelse sum = digitalRoot(sumList(digitsOfInt n))", "let _ = digitalRoot 9876"], "bad": ["let rec digitalRoot n = \nif n < 10 then n + sum\nelse let sum = digitalRoot(sumList(digitsOfInt n))"], "message": ["Error: Syntax error\n"], "problem": "digitalRoot"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x with\n| (s,i) -> if s = k then i\nelse assoc(d,k,xs)"], "bad": ["let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x\n| (s,i) -> if s = k then i\nelse assoc(d,k,xs)"], "message": ["Error: Syntax error\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"], "bad": ["et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h = seen) = false then seen' @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h = seen) = false then seen@ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h = seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", " _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"], "message": ["Error: Unbound value et\n", "Error: Unbound value et\n", "Error: Unbound value et\n", "Error: Unbound value et\n", "Error: Syntax error\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", ")", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr,0.5,0.2)"], "bad": ["let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) + eval(w,x,y))/2.0)\n| Times(v,w) -> eval(v,x,y) * eval(v,x,y)\n| Thresh(a,b,c,d) -> (eval(a,x,y) < eval(b,x,y) ? eval(c,x,y) : eval(d,x,y))", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr,0.5,0.2)", "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) + eval(w,x,y))/2.0)\n| Times(v,w) -> eval(v,x,y) * eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)", ")", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr,0.5,0.2)", "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) + eval(w,x,y))/2.0)\n| Times(v,w) -> eval(v,x,y) * eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", ")", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr,0.5,0.2)", "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) + .eval(w,x,y))/2.0)\n| Times(v,w) -> eval(v,x,y) * eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", ")", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr,0.5,0.2)", "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/2.0)\n| Times(v,w) -> eval(v,x,y) * eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", ")", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr,0.5,0.2)", "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) * eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", ")", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr,0.5,0.2)"], "message": ["Error: Syntax error\n", "Error: Unbound value eval\n", "Error: Unbound value eval\n", "Error: Unbound value eval\n", "Characters 217-218:\n  | Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y);;\n                          ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Error: Unbound value eval\n", "Error: Unbound value eval\n", "Error: Unbound value eval\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: Syntax error\n", "Error: Unbound value eval\n", "Error: Unbound value eval\n", "Error: Unbound value eval\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error\n", "Error: Unbound value eval\n", "Error: Unbound value eval\n", "Error: Unbound value eval\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: Syntax error\n", "Error: Unbound value eval\n", "Error: Unbound value eval\n", "Error: Unbound value eval\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: Syntax error\n", "Error: Unbound value eval\n", "Error: Unbound value eval\n", "Error: Unbound value eval\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"], "bad": ["let rec build (rand, depth) = \nif depth > 0 \nthen d = d -1 in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,d))\n| 1 -> buildCosine(build(rand,d))\n| 2 -> buildAverage(build(rand,d))\n| 3 -> buildTimes(build(rand,d))\n| 4 -> buildThresh(build(rand,d))", "let rec build (rand, depth) = \nif depth > 0 \nthen depth = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))", "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))", "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,depth)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))", "let rec build (rand, depth) = \nif depth > 0 \nthen let d = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,d)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))", "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,depth)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))", "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,depth)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"], "message": ["Error: Unbound value d\n", "Error: This expression has type bool but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         expr * expr\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr * expr * expr * expr\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildY()"], "bad": [" rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"], "message": ["Error: Syntax error\n"], "problem": "build"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun nest -> (x(a nest))  in\nlet base = fun x -> x in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "bad": ["let pipe fs = \nlet f a x = f nest -> x(a nest)  in\nlet base = f x -> x in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let pipe fs = \nlet f a x = f nest -> (x(a nest))  in\nlet base = f x -> x in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "message": ["Error: Syntax error\n", "Error: Unbound value pipe\n", "Error: Unbound value pipe\n", "Error: Unbound value pipe\n", "Error: Syntax error\n", "Error: Unbound value pipe\n", "Error: Unbound value pipe\n", "Error: Unbound value pipe\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = \"[\"^(sepConcat \";\" List.map(f l))^\"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"], "bad": ["let stringOfList f l = \"[\"^sepConcat \";\" [List.map(f l)]^\"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let stringOfList f l = \"[\"^sepConcat \";\"^[List.map(f l)]^\"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let stringOfList f l = \"[\"^sepConcat \";\" [List.map(f l)]^\"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let stringOfList f l = \"[\"^sepConcat \";\" [List.map(f l)]^\"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let stringOfList f l = \"[\"^sepConcat \";\" List.map(f l)^\"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"], "message": ["Error: This expression has type 'a list -> 'b list\n       but an expression was expected of type string\n", "Error: Unbound value stringOfList\n", "Error: Unbound value stringOfList\n", "Error: Unbound value stringOfList\n", "Error: This expression has type string list -> string\n       but an expression was expected of type string\n", "Error: Unbound value stringOfList\n", "Error: Unbound value stringOfList\n", "Error: Unbound value stringOfList\n", "Error: This expression has type 'a list -> 'b list\n       but an expression was expected of type string\n", "Error: Unbound value stringOfList\n", "Error: Unbound value stringOfList\n", "Error: Unbound value stringOfList\n", "Error: This expression has type 'a list -> 'b list\n       but an expression was expected of type string\n", "Error: Unbound value stringOfList\n", "Error: Unbound value stringOfList\n", "Error: Unbound value stringOfList\n", "Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value stringOfList\n", "Error: Unbound value stringOfList\n", "Error: Unbound value stringOfList\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = \"[\"^(sepConcat \";\" (List.map f l))^\"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"], "bad": ["let stringOfList f l = \"[\"^sepConcat \";\" List.map(f l)^\"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let stringOfList f l = \"[\"^sepConcat(\";\" List.map(f l))^\"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"], "message": ["Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value stringOfList\n", "Error: Unbound value stringOfList\n", "Error: Unbound value stringOfList\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: Unbound value stringOfList\n", "Error: Unbound value stringOfList\n", "Error: Unbound value stringOfList\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y = clone (List.hd l1) (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone (List.hd l2) (List.length l2 - List.length l1) in\n(z, l1)"], "bad": ["let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen l1, l2\nelse if List.length l1 > List.length l2", "let y =clone List.hd l1 (List.length l1 - List.length l2)\ny, l2", "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen l1, l2\nelse if (List.length l1 > List.length l2)", "let y =clone List.hd l1 (List.length l1 - List.length l2)\ny, l2", "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen l1, l2\nelse if (List.length l1) > (List.length l2)", "let y =clone List.hd l1 (List.length l1 - List.length l2)\ny, l2", "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y =clone List.hd l1 (List.length l1 - List.length l2)\n(y, l2)", "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y =clone List.hd l1 (List.length l1 - List.length l2) then(y, l2)", "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y =clone List.hd l1 (List.length l1 - List.length l2) -> (y, l2)", "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y =clone List.hd l1 (List.length l1 - List.length l2) (y, l2)", "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y =clone l1 (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone l2 (List.length l2 - List.length l1) in\n(z, l1)", "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y =clone List.hd l1 (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone List.hd l2 (List.length l2 - List.length l1) in\n(z, l1)", "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y = clone List.hd l1 (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone List.hd l2 (List.length l2 - List.length l1) in\n(z, l1)"], "message": ["Error: Syntax error\n", "Error: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Syntax error\n", "Error: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Syntax error\n", "Error: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type 'a list list\n       but an expression was expected of type 'a list\n       The type variable 'a occurs inside 'a list\n", "Error: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let rec removeZero l = \nmatch l with \n| x::xs -> if x = 0 then removeZero(xs) else l"], "bad": ["let rec removeZero l = \nmatch l with \nx::xs -> if x = 0 then removeZero(xs)\n| [] -> xs"], "message": ["Error: Unbound value xs\n"], "problem": "removeZero"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = fun nest -> (x(a nest))  in\nlet base = fun x -> x in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = \"[\"^(sepConcat \";\" (List.map f l))^\"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n = \nif n <= 0 then []\nelse x::clone x(n-1)", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y = clone 0 (List.length l1 - List.length l2) @ l2 in\n(l1, y)\nelse let z = clone 0 (List.length l2 - List.length l1) @ l1 in\n(z,l2)", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let rec removeZero l = failwith \"to be implemented\"", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> match a with\n| (carry,[result]) -> if carry = 1 then \n\nmatch \nlet base = (0,[]) in\n\nif d1 + d2 > 9 then let carry = 1\nelse let carry = 0", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nif d1 + d2 > 9 then let carry = 1\nelse let carry = 0\nmatch a with \n| (c,result) -> (carry, d1+d2+c)", "let base = (0,[]) in\nlet args = List.combine(List.rev l1 List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  in\nlet base = [] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  failwith \"tba\" in\nlet base = [] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let rec removeZero l = failwith \"to be implemented\"", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nif d1 + d2 > 9 then let carry = 1\nelse let carry = 0\nmatch a with \n| (c,result) -> (carry, d1+d2+c)", "let base = (0,[]) in\nlet args = List.combine(List.rev l1 List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nif d1 + d2 > 9 then let carry = 1\nelse then let carry = 0\nmatch a with \n| (c,result) -> (carry, d1+d2+c)", "let base = (0,[]) in\nlet args = List.combine(List.rev l1 List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> match a with\n| (carry,[result]) -> if carry = 1 then \n\nmatch \nlet base = (0,[]) in\n\nif d1 + d2 > 9 then let carry = 1\nelse let carry = 0", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nif d1 + d2 > 9 then let carry = 1\nelse let carry = 0\nmatch a with \n| (c,result) -> (carry, d1+d2+c)", "let base = (0,[]) in\nlet args = List.combine(List.rev l1 List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)\nelse (0,(d1+d2)::result) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nif (d1 + d2 > 9) then let carry = 1\nelse let carry = 0\nmatch a with \n| (c,result) -> (carry, d1+d2+c)", "let base = (0,[]) in\nlet args = List.combine(List.rev l1 List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nif (d1 + d2 > 9) then let carry = 1\nelse carry = 0\nmatch a with \n| (c,result) -> (carry, d1+d2+c)", "let base = (0,[]) in\nlet args = List.combine(List.rev l1 List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nif (d1 + d2 > 9) then let carry = 1\nelse let carry = 0\nmatch a with \n| (c,result) -> (carry, d1+d2+c)", "let base = (0,[]) in\nlet args = List.combine(List.rev l1 List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)\nelse (0,(d1+d2)::result)", "let base = (0,[]) in\nlet args = List.combine(List.rev l1 List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)\nelse (0,(d1+d2)::result) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev l1 List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)\nelse (0,(d1+d2)::result) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev l1, List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2+carry)::result) in\nlet base = (0,[]) in\nlet args = [(0,0)]@List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2+carry)::result) in\nlet base = (0,[]) in\nlet args = [0]@[List.combine(List.rev l1)(List.rev l2)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2+carry)::result) in\nlet base = (0,[]) in\nlet args = [0]@List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type ('a * 'b) list\n       but an expression was expected of type int\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type int list\n       Type 'a * 'b is not compatible with type int \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nmatch l2 with\n| x::xs -> xs", "let f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 =  \nlet f a x =  match x with \n| (_,n) -> \nmatch a with\n| (numzero,result) ->\n(i + 1, bigAdd(mulByDigit n l1 @ clone 0 i) result)", "let base = (0,[]) in\nlet args = List.combine (List.rev l1)(List.rev l2)", ")", "let (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 =  \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd(mulByDigit x l1 @ clone 0 numzero) result)", "let base = (0,[]) in\nlet args = List.rev l2", "let (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 =  \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd(mulByDigit * l1 @ clone 0 numzero) result)", "let base = (0,[]) in\nlet args = List.rev l2", "let (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 =  \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd(mulByDigit * l1 :: clone 0 numzero) result)", "let base = (0,[]) in\nlet args = List.rev l2", "let (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 =  \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd(mulByDigit * l1 :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2", "let (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 =  \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd(mulByDigit * l1 :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 =  \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd(mulByDigit l1 x :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 =  \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd(mulByDigit x l1 :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 =  \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value f\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value f\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value f\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value f\n", "Error: Syntax error\n", "Error: Unbound value f\n", "Error: This expression has type int -> int list -> int list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int -> int list -> int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, (bigAdd((mulByDigit x l1) @ clone 0 numzero)) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nmatch l2 with\n| x::xs -> xs in\nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nmatch l2 with\n| x::xs -> t in\nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, (bigAdd((mulByDigit x l1) :: clone 0 numzero)) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: Unbound value l1\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value l1\n", "Error: Unbound value t\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value t\n", "Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "bigMul"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n <= 0\nthen []\nelse n - (n/10) * 10 :: digitsOfInt (n/10)"], "bad": ["let rec digitsOfInt n = \nif n <= 0\nthen []\nelse n - (n/10) * 10 :: digitsOfInt n/10"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = additivePersistence (-1)"], "bad": ["let _ = additivePersistence -1"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> append (listReverse tl) [hd]", "let _ = listReverse [1; 2; 3; 4]"], "bad": ["let _ = listReverse [1; 2; 3; 4]", "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]", "let _ = listReverse [1; 2; 3; 4]", "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let palindrome w = match (explode w) with\n| [] -> true\n| head::[] -> true\n| head::tail -> \nif head = List.hd (listReverse tail)\nthen palindrome (List.tl (listReverse tail))\nelse false", "let _ = palindrome \"malayalam\""], "bad": ["let palindrome w = match (explode w) with\n| [] -> true\n| head::[] -> true\n| head::tail -> \nif head = hd (listReverse w)\nthen palindrome (tl (listReverse tail))\nelse false", "let palindrome w = match (explode w) with\n| [] -> true\n| head::[] -> true\n| head::tail -> \nif head = List.hd (listReverse w)\nthen palindrome (List.tl (listReverse tail))\nelse false", "let palindrome w = match (explode w) with\n| [] -> true\n| head::[] -> true\n| head::tail -> \nif head = List.hd (listReverse [w])\nthen palindrome (List.tl (listReverse [tail]))\nelse false"], "message": ["Error: Unbound value hd\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n", "Error: This expression has type string but an expression was expected of type\n         char\n"], "problem": "palindrome"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (di,ki) ->\nif ki = k\nthen di\nelse assoc (d,k,t)"], "bad": ["let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (di * ki) ->\nif ki = k\nthen di\nelse assoc (d,k,t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| di * ki ->\nif ki = k\nthen di\nelse assoc (d,k,t)", "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (di * ki) ->\nif ki = k\nthen di\nelse assoc (d,k,t)", "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (di*ki) ->\nif ki = k\nthen di\nelse assoc (d,k,t)"], "message": ["Characters 72-73:\n  | (di * ki) ->\n    ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Unbound value assoc\n", "Error: Syntax error\n", "Characters 72-73:\n  | (di * ki) ->\n    ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Characters 72-73:\n  | (di*ki) ->\n    ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (ki,di) ->\nif ki = k\nthen di\nelse assoc (d,k,t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "bad": ["let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "message": ["Error: This expression has type string but an expression was expected of type\n         int\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen\nthen seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem (h, seen)\nthen seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem h\nthen seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "message": ["Error: This expression has type ('a * 'b) list -> bool\n       but an expression was expected of type bool\n", "Error: This expression has type 'a list -> bool\n       but an expression was expected of type bool\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile (\nlet g a = \nf a, f a != a\nin \ng, b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "bad": [" g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Syntax error\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((fun a -> f a, f a != a), b)"], "bad": ["let fixpoint (f,b) = wwhile (\nfun a ->\nf a, f a != a\nin \ng, b", "let fixpoint (f,b) = wwhile (\nfun a ->\nf a, f a != a, b)", "let fixpoint (f,b) = wwhile (\nfun a ->\nf a, f a != a\n, b)", "let fixpoint (f,b) = wwhile (\nfun a ->\nf a, f a != a\n, b)", "let fixpoint (f,b) = wwhile (fun a -> f a, f a != a, b)"], "message": ["Characters 28-29:\n  let fixpoint (f,b) = wwhile (\n                              ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> String.concat \"pi* \" ^ exprToString s", "let sampleExpr2 = Sine(VarX)", "let _ = exprToString sampleExpr2"], "bad": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> String.concat sep [\"pi* \"; exprToString s]"], "message": ["Error: Unbound value sep\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi *. eval e)", "let _ = VarX, 0.5, 0.6"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi * eval e)"], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) =\nif \n(depth = 0)\nthen\nmatch rand(0,2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \nmatch rand (0,100) with\n| i when (i<5) -> \nbuildSine (build (rand, depth-1))\n| i when (i<10) -> \nbuildCosine (build (rand, depth-1))\n| i when (i<20) -> \nbuildAverage (build (rand, depth-1), build (rand, depth-1))\n| i when (i<80) -> \nbuildTimes (build (rand, depth-1), build (rand, depth-1))\n| i when (i<100) ->\nbuildThresh (build (rand, depth-1), build (rand, depth-1), \nbuild (rand, depth-1), build (rand, depth-1))"], "bad": ["let rec build (rand, depth) =\nif \n(depth = 0)\nthen\nmatch rand(0,2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \nmatch rand (0,100) with\n| i if (i<5) -> \nbuildSine (build (rand, depth-1))\n| i if (i<10) -> \nbuildCosine (build (rand, depth-1))\n| i if (i<20) -> \nbuildAverage (build (rand, depth-1), build (rand, depth-1))\n| i if (i<80) -> \nbuildTimes (build (rand, depth-1), build (rand, depth-1))\n| i if (i<100) ->\nbuildThresh (build (rand, depth-1), build (rand, depth-1), \nbuild (rand, depth-1), build (rand, depth-1))"], "message": ["Error: Syntax error\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\n| VarX -> \nx\n| VarY -> \ny\n| Sine e1 -> \nsin(pi *. eval (e1,x,y))\n| Cosine e1 -> \ncos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> \n(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0\n| Times (e1,e2) -> \neval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif (eval(e1,x,y)<eval(e2,x,y))\nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Log e1 ->\nlet b = eval (e1,x,y)\nin\nif (b > 1.0)\nthen log(b)\nelse 0.0"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> \nx\n| VarY -> \ny\n| Sine e1 -> \nsin(pi *. eval (e1,x,y))\n| Cosine e1 -> \ncos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> \n(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0\n| Times (e1,e2) -> \neval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif (eval(e1,x,y)<eval(e2,x,y))\nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Log e1 ->\nlet b = eval (e1,x,y)\nin\nif (b > 1.0)\nthen log(b)\nelse 0"], "message": ["Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\n| VarX -> \nx\n| VarY -> \ny\n| Sine e1 -> \nsin(pi *. eval (e1,x,y))\n| Cosine e1 -> \ncos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> \n(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0\n| Times (e1,e2) -> \neval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif (eval(e1,x,y)<eval(e2,x,y))\nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Log e1 ->\nlet b = eval (e1,x,y)\nin\nif (b > 1.0)\nthen log(b)\nelse 0.0\n| SumOfSquares (e1,e2,e3) ->\n(eval(e1,x,y) ** 2.0) +. (eval(e2,x,y) ** 2.0) +. (eval(e3,x,y) ** 2.0)"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> \nx\n| VarY -> \ny\n| Sine e1 -> \nsin(pi *. eval (e1,x,y))\n| Cosine e1 -> \ncos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> \n(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0\n| Times (e1,e2) -> \neval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif (eval(e1,x,y)<eval(e2,x,y))\nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Log e1 ->\nlet b = eval (e1,x,y)\nin\nif (b > 1.0)\nthen log(b)\nelse 0.0\n| SumOfSquares (e1,e2,e3) ->\n(eval(e1,x,y) ** 2.0) + (eval(e2,x,y) ** 2.0) + (eval(e3,x,y) ** 2.0)", "let rec eval (e,x,y) = match e with\n| VarX -> \nx\n| VarY -> \ny\n| Sine e1 -> \nsin(pi *. eval (e1,x,y))\n| Cosine e1 -> \ncos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> \n(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0\n| Times (e1,e2) -> \neval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif (eval(e1,x,y)<eval(e2,x,y))\nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Log e1 ->\nlet b = eval (e1,x,y)\nin\nif (b > 1.0)\nthen log(b)\nelse 0.0\n| SumOfSquares (e1,e2,e3) ->\n(eval(e1,x,y) **. 2.0) + (eval(e2,x,y) **. 2.0) + (eval(e3,x,y) **. 2.0)"], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: Unbound value **.\nHint: Did you mean *. or **?\n"], "problem": "eval"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = x**2.0 in\nlet base = 0.0 in\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = x**2 in\nlet base = 0 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = x**2.0 in\nlet base = 0 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = x**.2.0 in\nlet base = 0 in\nList.fold_left f base xs"], "message": ["Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: Unbound value **.\nHint: Did you mean *. or **?\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = x*x in\nlet base = 0 in\nList.fold_left f base xs"], "bad": ["let _ = sqsum [1;2;3;4]", "let sqsum xs = \nlet f a x = x*xin", "let base = 0 in\nList.fold_left f base xs"], "message": ["Error: This expression has type int but an expression was expected of type\n         float\n", "Error: Syntax error\n", "Error: Unbound value f\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = x*x in\nlet base = 0 in\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = base + x in\nlet base = x*x in\nList.fold_left f base xs"], "message": ["Error: Unbound value base\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = z in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs"], "message": ["Error: Unbound value a\n", "Error: Unbound value z\n", "Error: Unbound value x\n", "Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun a->a in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = 'a->'a in\nList.fold_left f base fs"], "message": ["Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value x\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x  in\nlet base = fun b->b in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let pipe fs = \nlet f a x = x (a->a) in\nlet base = fun a->a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a->a in\nlet base = fun a->a in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Characters 29-30:\n  let f a x = x (a->a) in\n                ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun c->x c in\nlet base = fun b->b in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun x-> x a in\nlet base = fun b->b in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let stringOfList f l = sepConcat \"; \" (List.map f l)"], "bad": ["let stringOfList f l = List.map sepConcat \";\" l"], "message": ["Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif (length1 > length2)\nthen List.append (clone 0 (length1 - length2)), length2\nelse List.append (clone 0 (length2 - length1)), length1"], "bad": ["let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif (lenth1 > length2)\nthen List.append (clone 0 (length1 - length2)), length2\nelse List.append (clone 0 (length2 - length1)), length1"], "message": ["Error: Unbound value lenth1\nHint: Did you mean length1?\n"], "problem": "padZero"}
{"hw": "hw1", "fix": ["let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t"], "bad": ["let rec sumList xs = match xs with\n| [] -> []\n| h::t -> h+sumList t"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let h::t = [1;0]"], "bad": ["h::t = [1;0]"], "message": ["Error: Unbound value h\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let _ = 4::[]"], "bad": ["let h::t = 1232", "let h+t = 1232", "let [] = 1232", "let [] = 1232"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "???"}
{"hw": "hw1", "fix": ["5 mod 5"], "bad": ["5%5"], "message": ["Error: Unbound value %\n"], "problem": "???"}
{"hw": "hw1", "fix": ["5::[1]"], "bad": ["[5]::1", "[5]::[1]"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n < 0\nthen true\nelse false"], "bad": ["let rec digitsOfInt n = \nif n < 0\nthen []", "let rec digitsOfInt n = \nif n < 0\nthen -> []", "let rec digitsOfInt n = \nif n < 0\nthen true"], "message": ["Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "Error: Syntax error\n", "Error: This variant expression is expected to have type unit\n       The constructor true does not belong to type unit\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n < 0\nthen []\nelse []"], "bad": ["let rec digitsOfInt n = \nif n < 0\nthen []\nelse"], "message": ["Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n < 0\nthen []\nelse \nlet (x,y) = (n mod 10, n / 10) in\nn::(digitsOfInt n)"], "bad": ["let rec digitsOfInt n = \n| n < 0 -> true", "let rec digitsOfInt n =", "with\n| n < 0 -> true"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n > 0\nthen []\nelse if (n mod 10) < 10\nthen []\nelse (n mod 10)::(digitsOfInt (n / 10))"], "bad": ["let rec digitsOfInt n = \nif n > 0\nthen []\nelse \nif (n mod 10) < 10\nthen [x]\nelse x::(digitsOfInt (n / 10))", "let rec digitsOfInt n = \nif n > 0\nthen []\nelse if (n mod 10) < 10\nthen []\nelse x::(digitsOfInt (n / 10))"], "message": ["Error: Unbound value x\n", "Error: Unbound value x\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let append x y= \nx::y", "append 1 [2]"], "bad": ["append 1 2"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let append x y = match y with\n| [] -> [x]\n| h::t -> h::(append x t)"], "bad": ["let append x y = match y with\n| [] -> x\n| h::t -> h::(append x t)"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a list list\n       The type variable 'a occurs inside 'a list\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let append x y = x+y"], "bad": ["let append x y = match y with\n| [] -> []\n| h::t -> h::(append x t)", "let append (x, y) = match y with\n| [] -> []\n| h::t -> h::(append x t)"], "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nlet x = sumList n in\nif x < 10\nthen countlist n\nelse additivePersistence [x]"], "bad": ["let rec additivePersistence n = \nlet x = sumList n in\nif x < 10\nthen countlist n\nelse additivePersistence x"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec sumdigits x = \nlet y = digits x in\nmatch y with\n| [] -> 0\n| h::t -> 1 + sumdigits x"], "bad": ["let rec sumdigits x = \nlet y = digits x in\nmatch y with\n| [] -> 0\n| h::t -> 1 + sumdigits"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nif sumList (digits n) < 10\nthen numdigits (digits n)\nelse additivePersistence (sumList (digits n))"], "bad": ["let rec additivePersistence n = \nif sumList (digits n) < 10\nthen numdigits n\nelse additivePersistence sumList n", "let rec additivePersistence n = \nif sumList (digits n) < 10\nthen numdigits (digits n)\nelse additivePersistence sumList n", "let rec additivePersistence n = \nif sumList (digits n) < 10\nthen numdigits (digits n)\nelse additivePersistence (sumList n)"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt (-3124)"], "bad": ["let _ = digitsOfInt -3124"], "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt (-3124)"], "bad": ["let _ = digitsOfInt -3124"], "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) =\nlet (b',c') = f b in\nif c'\nthen wwhile (f, b')\nelse\nb'"], "bad": ["let rec wwhile (f,b) =\nlet (b',c') = f b in\nif c'\nthen f b'\nelse\nb'"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((fun x -> if (x=b) then (b,false) else (f x,true)),b)"], "bad": ["let fixpoint (f,b) = wwhile (fun x -> if(f x)=x then (b,false) else (f x,true),b)", "let fixpoint (f,b) = wwhile (fun x -> if (x=b) then (b,false) else (f x,true),b)"], "message": ["Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with \nVarX -> 1\n| VarY-> 1\n| Sine x -> 1\n| Cosine  x -> 1\n| Average (x,y) -> 1\n| Times  (x,y)  -> 1\n| Thresh  (x,y,z,w) -> 1"], "bad": ["let rec exprToString e = match e with \nVarX -> printf \"A\"\n| VarY-> printf \"A\"\n| Sine x -> printf \"A\"\n| Cosine  x -> printf \"A\"\n| Average x y -> printf \"A\"\n| Times  x y  -> printf \"A\"\n| Thresh  x y z w -> printf \"A\"", "let rec exprToString e = match e with \nVarX -> printf \"A\"\n| VarY-> printf \"A\"\n| Sine x -> printf \"A\"\n| Cosine  x -> printf \"A\"\n| Average (x,y) -> printf \"A\"\n| Times  (x,y)  -> printf \"A\"\n| Thresh  (x,y,z,w) -> printf \"A\"", "let rec exprToString e = match e with \nVarX -> Printf.printf \"A\"\n| VarY-> printf \"A\"\n| Sine x -> printf \"A\"\n| Cosine  x -> printf \"A\"\n| Average (x,y) -> printf \"A\"\n| Times  (x,y)  -> printf \"A\"\n| Thresh  (x,y,z,w) -> printf \"A\""], "message": ["Error: Syntax error\n", "Error: Unbound value printf\n", "Error: Unbound value printf\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with \nVarX -> Printf.sprintf \"x\"\n| VarY-> Printf.sprintf \"y\"\n| Sine x ->Printf.sprintf \"\"\n| Cosine  x -> Printf.sprintf \"\"\n| Average (x,y) -> Printf.sprintf \"\"\n| Times  (x,y)  -> Printf.sprintf \"\"\n| Thresh  (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" (exprToString x) (exprToString y) (exprToString z)"], "bad": ["let rec exprToString e = match e with \nlet sprintf=Printf.sprintf in\nVarX -> sprintf(\"x\")\n| VarY-> sprintf(\"x\")\n| Sine x ->3\n| Cosine  x -> 4\n| Average (x,y) -> 5\n| Times  (x,y)  -> 6\n| Thresh  (x,y,z,w) -> sprintf(\"%s<%s?%s:\") x,y,z", "let rec exprToString e = match e with \nVarX -> Printf.sprintf(\"x\")\n| VarY-> sprintf(\"x\")\n| Sine x ->3\n| Cosine  x -> 4\n| Average (x,y) -> 5\n| Times  (x,y)  -> 6\n| Thresh  (x,y,z,w) -> sprintf(\"%s<%s?%s:\") x,y,z", "let rec exprToString e = match e with \nVarX -> Printf.sprintf(\"x\")\n| VarY-> Printf.sprintf(\"x\")\n| Sine x ->Printf.sprintf (\"\")\n| Cosine  x -> Printf.sprintf (\"\")\n| Average (x,y) -> Printf.sprintf (\"\")\n| Times  (x,y)  -> Printf.sprintf (\"\")\n| Thresh  (x,y,z,w) -> Printf.sprintf(\"%s<%s?%s:\") x,y,z", "let rec exprToString e = match e with \nVarX -> Printf.sprintf \"x\"\n| VarY-> Printf.sprintf \"x\"\n| Sine x ->Printf.sprintf \"\"\n| Cosine  x -> Printf.sprintf \"\"\n| Average (x,y) -> Printf.sprintf \"\"\n| Times  (x,y)  -> Printf.sprintf \"\"\n| Thresh  (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" x,y,z", "let rec exprToString e = match e with \nVarX -> Printf.sprintf \"x\"\n| VarY-> Printf.sprintf \"x\"\n| Sine x ->Printf.sprintf \"\"\n| Cosine  x -> Printf.sprintf \"\"\n| Average (x,y) -> Printf.sprintf \"\"\n| Times  (x,y)  -> Printf.sprintf \"\"\n| Thresh  (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" x y z", "let rec exprToString e = match e with \nVarX -> Printf.sprintf \"x\"\n| VarY-> Printf.sprintf \"y\"\n| Sine x ->Printf.sprintf \"\"\n| Cosine  x -> Printf.sprintf \"\"\n| Average (x,y) -> Printf.sprintf \"\"\n| Times  (x,y)  -> Printf.sprintf \"\"\n| Thresh  (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" exprToString x exprToString y exprToStringz"], "message": ["Error: Syntax error\n", "Error: Unbound value sprintf\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type string\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type string\n", "Error: This expression has type expr but an expression was expected of type\n         string\n", "Error: This expression has type\n         ('a -> 'b -> 'c, unit, string, string, string, 'a -> 'b -> 'c)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b -> 'c, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b -> 'c is not compatible with type string \n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["sin(2.)"], "bad": ["sin(2)"], "message": ["Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "???"}
{"hw": "hw2", "fix": ["eval(Sine(VarX),0.,0.)"], "bad": ["eval(Sine(0))", "eval(Sine(VarX),0,0)"], "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y))\n| Cosine a -> x\n| Average (a,b) -> x\n| Times (a,b) -> x\n| Thresh (a,b,c,d) -> x", "eval(Sine(VarX),1.,0.)"], "bad": ["let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(pi*eval(a,x,y))\n| Cosine a -> x\n| Average (a,b) -> x\n| Times (a,b) -> x\n| Thresh (a,b,c,d) -> x"], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let pi = 4.0 *. atan 1.0", "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin((eval(a,x,y)*2.))\n| Cosine a -> x\n| Average (a,b) -> x\n| Times (a,b) -> x\n| Thresh (a,b,c,d) -> x", "eval(Sine(VarX),1.,0.)"], "bad": ["eval(a,x,y)*2."], "message": ["Error: This expression has type int * int\n       but an expression was expected of type expr\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y)*.pi)\n| Cosine a -> cos(eval(a,x,y)*.pi)\n| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y) /. 2.)\n| Times (a,b) -> x\n| Thresh (a,b,c,d) -> x"], "bad": ["let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y)*.pi)\n| Cosine a -> cos(eval(a,x,y)*.pi)\n| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y) /. 2)\n| Times (a,b) -> x\n| Thresh (a,b,c,d) -> x"], "message": ["Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> x", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr1,0.5,0.2)"], "bad": ["let _ = eval (sampleExpr,0.5,0.2)"], "message": ["Error: This expression has type expr/1210\n       but an expression was expected of type expr/1410\nError: This expression has type expr/2898\n       but an expression was expected of type expr/2918\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type expr/1210\n       but an expression was expected of type expr/1410\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["sampleExpr2"], "bad": ["sampleExp"], "message": ["Error: Unbound value sampleExp\nHint: Did you mean sampleExpr?\nError: Unbound value sampleExp\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sampleExp\nHint: Did you mean sampleExpr?\n"], "problem": "???"}
{"hw": "hw2", "fix": ["sampleExpr1"], "bad": ["sampleExpr3"], "message": ["Error: Unbound value sampleExpr3\nHint: Did you mean sampleExpr1, sampleExpr2 or sampleExpr?\nError: Unbound value sampleExpr3\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sampleExpr3\nHint: Did you mean sampleExpr1, sampleExpr2 or sampleExpr?\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let _ = eval (sampleExpr1,0.5,0.2)"], "bad": ["let _ = eval (sampleExpr,0.5,0.2)"], "message": ["Error: This expression has type expr/1210\n       but an expression was expected of type expr/1410\nError: This expression has type expr/3092\n       but an expression was expected of type expr/3112\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type expr/1210\n       but an expression was expected of type expr/1410\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let g1 () = failwith \"to be implemented\"", "let g2 () = failwith \"to be implemented\"", "let g3 () = failwith \"to be implemented\"", "let c1 () = failwith \"to be implemented\"", "let c2 () = failwith \"to be implemented\"", "let c3 () = failwith \"to be implemented\"", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type test = unit -> string", "let key = \"\"", "let prefix130 = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")", "let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0", "let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)", "let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))", "let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p", "let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max"], "bad": ["build(rand,1)"], "message": ["Error: Unbound value rand\nHint: Did you mean land?\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) =", "let g1 () = failwith \"to be implemented\"", "let g2 () = failwith \"to be implemented\"", "let g3 () = failwith \"to be implemented\"", "let c1 () = failwith \"to be implemented\"", "let c2 () = failwith \"to be implemented\"", "let c3 () = failwith \"to be implemented\"", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type test = unit -> string", "let key = \"\"", "let prefix130 = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")", "let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0", "let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)", "let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))", "let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p", "let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max"], "bad": ["let rec build (rand, depth) ="], "message": ["Error: Syntax error\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nif depth<2\nthen let x=rand(0,2) in\nmatch x with\n|0 -> buildX()\n|1 -> buildY()\nelse\nlet x=rand(0,5) in\nmatch x with\n|0 -> buildSine(build(rand,depth))\n|1 -> buildCosine(build(rand,depth))"], "bad": ["let rec build (rand, depth) = \nif depth<2\nthen let x=rand(0,2) in\nmatch x with\n|0 -> buildX()\n|1 -> buildY()\nelse\nlet x=rand(0,5) in\nmatch x with\n|0 -> buildSin(build(rand,depth))\n|1 -> buildCosin(build(rand,depth))"], "message": ["Error: Unbound value buildSin\nHint: Did you mean buildSine?\nError: Unbound value buildSin\nHint: Did you mean build, buildY or buildX?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value buildSin\nHint: Did you mean buildSine?\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let g1 () = doRandomGray(2,1,1)", "let g2 () = failwith \"to be implemented\"", "let g3 () = failwith \"to be implemented\"", "let c1 () = failwith \"to be implemented\"", "let c2 () = failwith \"to be implemented\"", "let c3 () = failwith \"to be implemented\"", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))"], "bad": ["build(rand,1)"], "message": ["Error: Unbound value rand\nHint: Did you mean land?\n"], "problem": "build"}
{"hw": "hw2", "fix": ["makeRand(0,1)"], "bad": ["makeRandom(0,1)\ndoRandomGray(1,1,1)", "makeRand(0,1)\ndoRandomGray(1,1,1)"], "message": ["Error: Unbound value makeRandom\nHint: Did you mean makeRand?\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value makeRandom\nHint: Did you mean makeRand?\n", "Error: This function has type int * int -> int * int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type int * int -> int * int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)"], "bad": ["let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (.9*eval(a,x,y)) else (.1*eval(a,x,y))\n| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)", "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (.9*.eval(a,x,y)) else (.1*.eval(a,x,y)\n| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)", "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y)\n| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)", "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)", "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y)  eval(a,x,y)"], "message": ["Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Characters 392-393:\n  | Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y)\n                                                                             ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "eval"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = x*x\nin\nlet base = 0 in\nList.fold_left f base xs"], "bad": ["let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let _ = pipe [] 3"], "message": ["Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x(a) in\nlet base = 0 in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x(a) in\nlet base = f 0 in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3"], "message": ["Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = f 0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x(a) in\nlet base = a in\nList.fold_left f base fs"], "message": ["Error: Unbound value a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun a -> 0 in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         int -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun a->a in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = fun a' in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = fun a'->_ in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = fun 'a->'a in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = 'a in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = a in\nlet base = fun a -> a in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a x in\nlet base = fun a -> a in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun z -> a (x z) in\nlet base = fun a-> f a in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a x in\nlet base = fun a-> f a in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base =  sepConcat sep t in\nlet l =  h in\nList.fold_left f base l"], "bad": ["let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base =  sepConcat sep t in\nlet l =  f in\nList.fold_left f base l"], "message": ["Error: This expression has type string but an expression was expected of type\n         string list\n", "Error: This expression has type string -> string -> string\n       but an expression was expected of type string list\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \"\" in\nlet base =  sepConcat sep t in\nlet l =  h in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base =  sepConcat sep t in\nlet l =  \"\" in\nList.fold_left f base l"], "message": ["Error: This expression has type string but an expression was expected of type\n         string list\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base =  sepConcat sep t in\nlet l =  t in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \"\" in\nlet base =  sepConcat sep t in\nlet l =  \"\" in\nList.fold_left f base l", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \"\" in\nlet base =  sepConcat sep {} in\nlet l =  \"\" in\nList.fold_left f base l", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \"\" in\nlet base =  sepConcat sep [] in\nlet l =  \"\" in\nList.fold_left f base l", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \"\" in\nlet base =  \"\" in\nlet l =  \"\" in\nList.fold_left f base l"], "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n", "Error: Syntax error\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  if t=[] then \"A\" else h in\nlet l =  sl in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  if t=[] then \"A\" else t in\nlet l =  sl in\nList.fold_left f base l"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base =  if t=[] then sep else h in\nlet l =  sl in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base =  if t=\"\" then sep else h in\nlet l =  sl in\nList.fold_left f base l"], "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["fun x -> x"], "bad": ["fun x -> 'b", "fun x -> y"], "message": ["Error: Syntax error\n", "Error: Unbound value y\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = failwith List.map (fun x-> x) l"], "bad": ["let _ = sepConcat \"X\" [\"hello\"]\n\nfun x -> x", "let stringOfList f l = failwith List.map (fun x-> \"\") l", "let _ = sepConcat \"X\" [\"hello\"]\n\nfun x -> x", "let stringOfList f l = failwith List.map (fun x-> \"\") l"], "message": ["Error: Syntax error\n", "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "Error: Syntax error\n", "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let asd_ x = x", "let stringOfList f l = failwith List.map asd l"], "bad": ["let stringOfList f l = failwith List.map (fun x-> x) (l)"], "message": ["Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = List.map (sepConcat \"\") l"], "bad": ["let stringOfList f l = List.map asd l"], "message": ["Error: Unbound value asd\nHint: Did you mean asd_ or asr?\nError: Unbound value asd\nHint: Did you mean asr?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value asd\nHint: Did you mean asd_ or asr?\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = List.map (sepConcat \" \") l", "let _ = stringOfList string_of_int [1;2;3;4;5;6]"], "bad": ["let _ = stringOfList string_of_int [1;2;3;4;5;6]"], "message": ["Error: This expression has type int but an expression was expected of type\n         string list\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = List.map (sepConcat \"\") l"], "bad": ["let stringOfList f l = List.map (sepConcat \" \") l.string"], "message": ["Error: Unbound record field string\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = List.map (fun x->x) l", "let _ = stringOfList string_of_int [1;2;3;4;5;6]"], "bad": ["let _ = stringOfList string_of_int [1;2;3;4;5;6]"], "message": ["Error: This expression has type int but an expression was expected of type\n         string\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = List.map (fun x-> Printf.sprintf \"%d\" x) l"], "bad": ["let _ = stringOfList string_of_int [1;2;3;4;5;6]"], "message": ["Error: This expression has type int but an expression was expected of type\n         string\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = List.map (sepConcat f) l"], "bad": ["let _ = stringOfList (fun x -> x) [\"foo\"]"], "message": ["Error: This expression has type string but an expression was expected of type\n         int\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = List.map (f) l"], "bad": ["let _ = stringOfList string_of_int [1;2;3;4;5;6]"], "message": ["Error: This expression has type int -> string\n       but an expression was expected of type string\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = fun z -> x (a z) in\nlet base = fun a -> a in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  h in\nlet l =  t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = List.map (f) l", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone x::accum n-1"], "bad": ["let rec clone x n =\nlet acc = [] in\nif x=0\nthen acc\nelse acc::clone x n-1", "let rec clone x n =\nlet acc = [] in\nif n=0\nthen acc\nelse clone x::acc n-1", "let rec clone x n =\nlet acc = [] in\nif n=0\nthen acc\nelse clone x::acc n-1"], "message": ["Error: This expression has type 'a list list\n       but an expression was expected of type int\n", "Error: This expression has type int -> 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside int -> 'a list\n", "Error: This expression has type int -> 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside int -> 'a list\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone x n"], "bad": ["let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone x n-1", "let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone x ne"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: Unbound value ne\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone x (n-1)"], "bad": ["let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone x n-1"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let h::t = [1;1]"], "bad": ["h::t = [1]"], "message": ["Error: Unbound value h\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let _ = clone 3 5"], "bad": ["let _ = clone 3 -1"], "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = ((clone (clone 0 1)::l1 2),l2)"], "bad": ["let _ = padZero [9;9] [1;0;0;2]"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = ((clone 0::l1 2),l2)"], "bad": ["let _ = padZero [9;9] [1;0;0;2]"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type\n         int -> (int -> int list list) list\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = fun z -> x (a z) in\nlet base = fun a -> a in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  h in\nlet l =  t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = List.map (f) l", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n =\nlet accum=[] in\nlet rec helper accum n=\nif n<1\nthen accum\nelse helper (x::accum)(n-1) in\nhelper accum n", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nList.concat (clone 0 (b-a)) l1"], "bad": ["let _ = padZero [9;9] [1;0;0;2]"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int -> (int -> int list) list\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 (b-a)) l1\nelse []"], "bad": ["let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nList.append (clone 0 (b-a)) l1", "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nList.append (clone 0 (b-a)) l1", "let _ = padZero [9;9] [1;0;0;2]", "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nList.append l2 l1", "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nList.append (clone 0 (b-a)) l1\nelse []"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type 'a list\n       but an expression was expected of type int -> (int -> int list) list\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\na"], "bad": ["let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen (List.append (clone 0 (b-a)) l1)\nelse if(b<a)\nthen (List.append (clone 0 (a-b)) l2)", "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen (List.append (clone 0 (b-a)) l1)\nelse if(b<a)\nthen (List.append (clone 0 (a-b)) l2)", "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen (List.append (clone 0 (b-a)) l1)\nelse if(b<a)\nthen List.append (clone 0 (a-b)) l2", "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen (List.append (clone 0 (b-a)) l1)", "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 (b-a)) l1", "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 b-a) l1", "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 1) l1", "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(1)\nthen List.append (clone 0 1) l1", "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(true)\nthen List.append (clone 0 1) l1", "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(true)\nthen List.append l1 l1"], "message": ["Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int but an expression was expected of type\n         bool\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = List.length l1"], "bad": ["let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen a", "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen 1", "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen 1", "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen \"\""], "message": ["Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type string but an expression was expected of type\n         unit\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = let a = List.length l1 in\na"], "bad": ["let padZero l1 l2 = let a = List.length l1"], "message": ["Error: Syntax error\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = let a = List.length l1 in\nlet b= List.length l2 in\nif (1<2)\nthen 1\nelse 2"], "bad": ["let padZero l1 l2 = let a = List.length l1 in\nlet b= List.length l2 in\nif (a<b)\nthen a", "let padZero l1 l2 = let a = List.length l1 in\nlet b= List.length l2 in\nif (1<2)\nthen 1", "let padZero l1 l2 = let a = List.length l1 in\nlet b= List.length l2 in\nif (1<2)\nthen clone 0 1"], "message": ["Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let stringOfList f l = sepConcat \",\" (List.map (f) l)"], "bad": ["let stringOfList f l = sepConcat(\" \" (List.map (f) l))"], "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = (sepConcat \";\" (List.map (f) l))", "let _ = stringOfList string_of_int [1;2;3;4;5;6]"], "bad": ["let stringOfList f l = \"[\"::(sepConcat \";\" (List.map (f) l))"], "message": ["Error: This expression has type string but an expression was expected of type\n         string list\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = fun z -> x (a z) in\nlet base = fun a -> a in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  h in\nlet l =  t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = Printf.sprintf\"[%s]\" (sepConcat \";\" (List.map (f) l))"], "bad": ["let stringOfList f l = (sepConcat \";\" (List.map (f) l)).\"]\""], "message": ["Error: Syntax error\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = fun z -> x (a z) in\nlet base = fun a -> a in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  h in\nlet l =  t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = Printf.sprintf\"[%s]\" (sepConcat \"; \" (List.map (f) l))", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n =\nlet accum=[] in\nlet rec helper accum n=\nif n<1\nthen accum\nelse helper (x::accum)(n-1) in\nhelper accum n", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen ((List.append (clone 0 (b-a)) l1),l2)\nelse if(b<a)\nthen (l1,(List.append (clone 0 (a-b)) l2))\nelse \n(l1,l2)", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h=0 then removeZero t else l", "let _ = removeZero [0;0;0;1;0;0;2]", "let _ = removeZero [9;9]", "let _ = removeZero [0;0;0;0]", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  base  in\nlet base = [] in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x+1::a in\nlet base = [] in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x+1::a in\nlet base = [] in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a  in\nlet base = ([],[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a  in\nlet base = [] in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\na=(t,(h+x))::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\na=(_,(h+x))\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\na=(l1,(h+x))\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\nx+h\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n(x+h,_)\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n(x+h,[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'b list * 'c\n", "Error: Syntax error: operator expected.\n", "Error: This expression has type int list * int -> int -> bool\n       but an expression was expected of type\n         int list * int -> int -> int list * int\n       Type bool is not compatible with type int list * int \n", "Error: This expression has type int list * 'a -> int -> int\n       but an expression was expected of type\n         int list * 'a -> int -> int list * 'a\n       Type int is not compatible with type int list * 'a \n", "Error: Syntax error: operator expected.\n", "Error: This expression has type int list * 'a -> int -> int * 'b list\n       but an expression was expected of type\n         int list * 'a -> int -> int list * 'a\n       Type int is not compatible with type int list \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n(0,0)::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n0::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n[0;0]::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n[[0];[0]]::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],0)::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n[([],0)]::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n[],0::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n[]::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\na=(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\na=(t,b)\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\na=([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\na=([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a list * 'b\n       but an expression was expected of type (int * int) list\n", "Error: This expression has type 'a list * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type 'a list * 'b\n       but an expression was expected of type int list list\n", "Error: This expression has type 'a list * 'b\n       but an expression was expected of type int list list list\n", "Error: This expression has type 'a list * 'b\n       but an expression was expected of type ('c list * 'd list) list\n", "Error: This expression has type 'a list * 'b\n       but an expression was expected of type ('c list * int) list\n", "Error: This expression has type 'a list * 'b\n       but an expression was expected of type ('c list * int) list list\n", "Error: This expression has type 'a list * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type 'a list * 'b\n       but an expression was expected of type 'c list list\n", "Error: This expression has type int list * int list -> int -> bool\n       but an expression was expected of type\n         int list * int list -> int -> int list * int list\n       Type bool is not compatible with type int list * int list \n", "Error: This expression has type 'a list * 'b -> 'c -> bool\n       but an expression was expected of type\n         'a list * 'b -> 'c -> 'a list * 'b\n       Type bool is not compatible with type 'a list * 'b \n", "Error: This expression has type 'a list * 'b list -> 'c -> bool\n       but an expression was expected of type\n         'a list * 'b list -> 'c -> 'a list * 'b list\n       Type bool is not compatible with type 'a list * 'b list \n", "Error: This expression has type 'a list * 'b list -> 'c -> bool\n       but an expression was expected of type\n         'a list * 'b list -> 'c -> 'a list * 'b list\n       Type bool is not compatible with type 'a list * 'b list \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\na=(l1,[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a list * 'b list -> 'c -> bool\n       but an expression was expected of type\n         'a list * 'b list -> 'c -> 'a list * 'b list\n       Type bool is not compatible with type 'a list * 'b list \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\nlet (_,asd4)=padZero asd3 (asd2::b) in\n(asd3,asd4)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h::t in\n(asd,padZero(asd,x+h::b))\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h::t in\n(asd,padZero(asd,(x+h::b)))\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero(asd3,asd2))\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero(asd3 asd2))\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero asd3 asd2)\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero asd3 asd2::b)\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero asd3 (asd2::b))\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero asd3 (asd2::b))\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int list * int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int list * int list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let _= (1,3)>(1,2)"], "bad": ["let _ (_,3)>(1,2)", "let _= (_,3)>(1,2)"], "message": ["Error: Syntax error\n", "Error: Syntax error: operator expected.\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[] & (x+h)>9)\nthen\nlet asd2=x+h-10 in\nlet asd3=asd2::b in\n([],1::asd3)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[])\nthen\nlet asd2=x+h-10 in\nlet asd3=t in\nlet asd3=h2+1::t2 in\n(_,asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[])\nthen\nlet asd2=x+h-10 in\nlet asd3=t in\nlet asd3=h2+1::t2 in\n([],asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error: operator expected.\n", "Error: Unbound value h2\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nif(t=[])\nthen\n([],1::(x+h-10)::b)\nelse\nlet h2::t2=t in\n((h2+1::t2),(x+h-10)::b)\n\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nif((t=[])\nthen\n([],1::(x+h-10)::b)\nelse\nlet h2::t2=t in\n((h2+1::t2),(x+h-10)::b)\n\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Characters 95-96:\n  if((t=[])\n    ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper (x-1) l (bigAdd l accum)\nelse accum\nin\nmulByDigit i (helper i l accum)"], "bad": ["let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper i l accum = \nif(i ~=0)\nthen\nmatch l with\n| h::t -> list.concat (helper i-1 t (bigAdd h h)) accum\nelse accum\nin\nhelper", "let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper i l accum = \nif(i != 0)\nthen\nmatch l with\n| h::t -> list.concat (helper i-1 t (bigAdd h h)) accum\nelse accum\nin\nhelper", "let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper x-1 l (bigAdd l accum)\nelse accum\nin\nmulByDigit (helper i l accum)", "let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper (x-1) l (bigAdd l accum)\nelse accum\nin\nmulByDigit (helper i l accum)"], "message": ["Error: Unbound value ~=\n", "Error: Unbound value list\n", "Error: This expression has type 'a -> 'b -> 'c\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(mulByDigit x q,[]) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\nmulByDigit x q in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(mulByDigit x q)", "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(mulByDigit x q) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type int list * 'a -> int -> int list\n       but an expression was expected of type\n         int list * 'a -> int -> int list * 'a\n       Type int list is not compatible with type int list * 'a \n", "Error: Syntax error\n", "Error: This expression has type int list * 'a -> int -> int list\n       but an expression was expected of type\n         int list * 'a -> int -> int list * 'a\n       Type int list is not compatible with type int list * 'a \n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(q+1,mulByDigit x l1) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n((+)1,mulByDigit x q) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(q+1,mulByDigit x q) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type\n         int list * 'a -> int -> (int -> int) * int list\n       but an expression was expected of type\n         int list * 'a -> int -> int list * 'a\n       Type int -> int is not compatible with type int list \n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "bigMul"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) =   \nlet (b', c') = f b in \nif c' then \nwwhile (f,b') \nelse \nb'"], "bad": ["let rec wwhile (f,b) =   \nlet (b', c') = f b in \nif c' then \nwwhile (f,b') \nelse \nb'"], "message": ["Error: Unbound value return\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let fixpoint (f,b) = wwhile (let f b =  let fb  = f b in\n(fb,fb=b) ,b)", "let fixpoint (f,b) = wwhile (let f b in  let fb  = f b in\n(fb,fb=b) ,b)", "let fixpoint (f,b) = wwhile ((  let fb  = f b in\n(fb,fb=b)) ,b)", "let fixpoint (f,b) = wwhile ((  let w b = let fb  = f b in\n(fb,fb=b)) ,b)", "let fixpoint (f,b) = wwhile ((  let w b = let fb  = f b in \n(fb,fb=b) in f b) ,b)", "let fixpoint (f,b) = wwhile ((  let w b' = let fb  = f b' in \n(fb,fb=b') in f b) ,b)", "let fixpoint (f,b) = wwhile ((  let w b' = let fb  = f b' in \n(fb,fb=b') in f b') ,b)", "let fixpoint (f,b) = wwhile ((  let w b' = let fb  = f b' in \n(fb,fb=b') in f b) ,b)", "let fixpoint (f,b) = let w b' = let fb  = f b' in \n(fb,fb=b') in  wwhile ( w ,b)", "let fixpoint (f,b) =  wwhile (let w b' = let fb  = f b' in \n(fb,fb=b') in  w ,b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value fixpoint\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Unbound value wwhile\n", "Error: Syntax error: operator expected.\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let _ = exprToString build (makeRand,5)"], "bad": ["let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand 1 2 in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand 1 5 with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"], "message": ["Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (1,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(1,5) with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "let _ = exprToString (build (makeRand,5))"], "bad": ["let _ = exprToString (build (makeRand,5))"], "message": ["Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let _ = let rand=makeRand(10,10) in exprToString (build (rand,5))"], "bad": ["let _ = let rand=makeRand(10,39) in exprToString (build (rand,5))"], "message": ["Error: This expression has type int * int -> int * int -> int\n       but an expression was expected of type int * int -> int\n       Type int * int -> int is not compatible with type int \n"], "problem": "build"}
{"hw": "hw2", "fix": ["let _ = tanh (( -0.5+.0.9)/.0.4)"], "bad": ["let _ = tanh (pi*. -0.5+.0.9)"], "message": ["Error: This expression has type float -> float\n       but an expression was expected of type int\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = (a*a)+ x  in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]"], "bad": ["let sqsum xs = \nlet f a x = a^2::x  in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let sqsum xs = \nlet f a x = (a^2)::x  in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let sqsum xs = \nlet f a x = (a^2.)::x  in\nlet base = 0 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = (a*a)::x  in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: Unbound value sqsum\n", "Error: Unbound value sqsum\n", "Error: Unbound value sqsum\n", "Error: This expression has type int but an expression was expected of type\n         string\n", "Error: Unbound value sqsum\n", "Error: Unbound value sqsum\n", "Error: Unbound value sqsum\n", "Error: This expression has type float but an expression was expected of type\n         string\n", "Error: This expression has type int -> int list -> int list\n       but an expression was expected of type int -> int list -> int\n       Type int list is not compatible with type int \n", "Error: Unbound value sqsum\n", "Error: Unbound value sqsum\n", "Error: Unbound value sqsum\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let pipe fs n= \nlet f a x = x a  in\nlet base = n in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3"], "message": ["Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a  in\nlet base = f   in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a  in\nlet base = f a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a  in\nlet base = f _ in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a  in\nlet base = f fs in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a  in\nlet base = _  in\nList.fold_left f base fs"], "message": ["Error: Unbound value a\n", "Error: Syntax error\n", "Error: This expression has type 'a but an expression was expected of type\n         ((('a -> 'b) -> 'b) -> ('a -> 'b) -> 'b) list\n       The type variable 'a occurs inside\n       ((('a -> 'b) -> 'b) -> ('a -> 'b) -> 'b) list\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x   in\nlet base = f   in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a  in\nlet base = f fs  in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         ((('a -> 'b) -> 'b) -> ('a -> 'b) -> 'b) list\n       The type variable 'a occurs inside\n       ((('a -> 'b) -> 'b) -> ('a -> 'b) -> 'b) list\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs  = \nlet f a x = x   in\nlet base = 0   in\nList.fold_left f base fs"], "bad": ["let pipe fs  = \nlet f a x = x   in\nlet base =   in\nList.fold_left f base fs", "let pipe fs  = \nlet f a x = x   in\nlet base =   in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs  = \nlet f a x = x a  in\nlet base = function y ->y  in\nList.fold_left f base fs"], "bad": ["let pipe fs  = \nlet f a x = x a  in\nlet base = function y   in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = function y -> y  in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let pipe fs = \nlet f a x = x a in\nlet base = fun y  in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = function y -> y  in\nList.fold_left f base", "let _ = pipe [] 3"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = function y -> y  in\nList.fold_left f base fs", "let _ = pipe [] 3"], "bad": ["let _ = pipe [] 3", "let pipe fs = \nlet f a x = x a in\nlet base = function y -> y  in\nList.fold_left f base xs", "let _ = pipe [] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         (('a -> 'a) -> 'a -> 'a) list\n", "Error: Unbound value xs\n", "Error: This expression has type int but an expression was expected of type\n         (('a -> 'a) -> 'a -> 'a) list\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"], "bad": ["let stringOfList f l = \"[\" ^ (sepConcat \"; \" (map f l)) ^ \"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"], "message": ["Error: Unbound value map\nHint: Did you mean max?\n", "Error: Unbound value stringOfList\n", "Error: Unbound value stringOfList\n", "Error: Unbound value stringOfList\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let rec clone x n = \nlet rec helper x n acc =\nif n<= 0 then\nacc\nelse\nhelper x (n-1) (x::acc) \nin\nhelper x n []"], "bad": ["let rec clone x n = \nlet rec helper x n acc \nif n<= 0 then\nacc\nelse\nhelper x (n-1) (x::acc) \nin\nhelper x n []"], "message": ["Error: Syntax error\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\nl1\nelse\nl2"], "bad": ["let padZero l1 l2 = \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\n((clone 0 (len1-len2)) @ len2),len1", ")\nelse\n((clone 0 (len2-len1)) @ len1),len2", ")", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value padZero\n", "Error: Unbound value padZero\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\n(clone 0 (len1-len2)) \nelse\n(clone 0 (len2-len1))"], "bad": ["let padZero l1 l2 = \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\n(clone 0 (len1-len2)) \nelse\n((clone 0 (len2-len1)) @ l1),l2", ")"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: Syntax error\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = \nlet (v,l)=x in\nlet (ac,la)=a in\nlet mul= mulByDigit v l in\nlet shift= mulByDigit ac mul in \n(ac*10,bigAdd shift la)\nin\nlet base = (1,[]) in\nlet args = List.map (fun x -> (x,(List.rev l2))) l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = \nlet (v,l)=x in\nlet (ac,la)=a in\nlet mul= mulByDigit v l in\nlet shift= mulByDigit ac a in \n(ac*10,bigAdd mul shift)\nin\nlet base = (1,[]) in\nlet args = List.map (fun x -> (x,l2)) l1 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = \nlet (v,l)=x in\nlet (ac,la)=a in\nlet mul= mulByDigit v l in\nlet shift= mulByDigit mul ac in \n(ac*10,bigAdd shift la)\nin\nlet base = (1,[]) in\nlet args = List.map (fun x -> (x,(List.rev l2))) l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type int * 'a\n       but an expression was expected of type int list\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x(a) in\nlet base = function y ->y in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x(a) in\nlet base = function  in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x(a) in\nlet base = function x in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =  x(a) in\nlet base = function y ->y in\nList.fold_left f base fs", "let _ = pipe [] 3"], "bad": ["let pipe fs = \nlet f a x = function x(a) in\nlet base = 0 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = function _ ->x(a) in\nlet base = 0 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x =  x(a) in\nlet base = function in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = function v ->  x (a v) in\nlet base = function y ->y in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = function f' -> f' x(a) in\nlet base = function y ->y in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = function f'->  x(f' a) in\nlet base = function y ->y in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b -> ('b -> 'a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('b -> 'a -> 'c) -> 'c\n", "Error: This expression has type 'a -> ('b -> 'c) -> ('a -> 'b) -> 'c\n       but an expression was expected of type 'a -> ('b -> 'c) -> 'a\n       The type variable 'a occurs inside ('a -> 'b) -> 'c\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let rec multByDigit i l =\nlet rec helper i l2 acc s =\nmatch l2 with\n| []   -> \ns::acc\n| h::t -> \nlet n = i*h + s in\nif n>9 then\nhelper i t ((n mod 10)::acc) (n/10) \nelse\nhelper i t (n::acc) 0\nin \nremoveZero (helper i (List.rev l) [] 0)"], "bad": ["let rec multByDigit i l =\nrec helper i l2 acc s =\nmatch l2 with\n| []   -> \ns::acc\n| h::t -> \nlet n = i*h + s in\nif n>9 then\nhelper i t ((n mod 10)::acc) (n/10) \nelse\nhelper i t (n::acc) 0\nin \nremoveZero (helper i (List.rev l) [] 0)"], "message": ["Error: Syntax error\n"], "problem": "removeZero"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) :: (helper (n / 10)) in\nhelper n"], "bad": ["let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) @ (helper (n / 10)) in\nhelper n"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  helper (n / 10) @ [(n mod 10)] in\nhelper n"], "bad": ["let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) :: (helper (n / 10)) in\n(helper n).reverse", "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) :: (helper (n / 10)) in\nlet rec reverse xs =\nmatch xs with\n| [] -> xs\n| hd :: tl -> (reverse tl) :: hd in\nreverse (helper n)", "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) :: (helper (n / 10)) in\nlet rec reverse xs =\nmatch xs with\n| [] -> []\n| hd :: tl -> (reverse tl) :: hd in\nreverse (helper n)", "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  append (helper (n / 10)) (n mod 10) in\nhelper n", "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  append [helper (n / 10)] [(n mod 10)] in\nhelper n", "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  append [helper (n / 10)] [n mod 10] in\nhelper n", "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  append [helper (n / 10)] [(n mod 10)] in\nhelper n", "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append [helper (n / 10)] [(n mod 10)]) in\nhelper n", "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  helper (n / 10) @ [(n mod 10)]", ") in\nhelper n", "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  helper (n / 10) @ [(n mod 10)]"], "message": ["Error: Unbound record field reverse\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append (helper (n / 10)) [(n mod 10)]) in\nhelper n"], "bad": ["let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append helper (n / 10) [(n mod 10)]) in\nhelper n"], "message": ["Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n"], "bad": ["let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  helper (append [(m / 10)] [(m mod 10)]) in\nhelper n"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> hd :: append tl xs2 in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n"], "bad": ["let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs2 with \n| [] -> xs1\n| hd :: tl -> (append (xs1 :: hd) tl) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 352663"], "bad": ["let _ = digitsOfInt 3124"], "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nlet rec helper count x =\nif (x < 10) then count else  (helper (count + 1) (sumList (digits n)))\nin (helper 0 n)"], "bad": ["let _ = additivePersistence 9876"], "message": ["Error: Unbound value sumList\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nlet rec helper count x =\nif (count = 1) then count else  (helper (count + 1) (sumList (digits n)))\nin (helper 0 n)"], "bad": ["let _ = additivePersistence 9876"], "message": ["Error: Unbound value sumList\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n"], "bad": ["let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "let rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> hd :: (append tl xs2)"], "message": ["Error: Unbound value digitalRoot\n", "Error: Unbound value append\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4]"], "bad": ["let rec listReverse l = \nlet rec helper xs result =\nmatch xs with\n| [] -> result\n| hd :: tl ->  helper tl  (hd :: result) in\nhelper xs []", "let rec listReverse l = \nlet rec helper xs result =\nmatch xs with\n| [] -> result\n| hd :: tl ->  helper tl  (hd :: result) in\nhelper xs []", "let rec listReverse l = \nlet rec helper xs result =\nmatch xs with\n| [] -> result\n| hd :: tl ->  helper tl  (hd :: result) in\nhelper l []"], "message": ["Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: Unbound value xs\n", "Error: Unbound value xs\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec append xs1 xs2 = \nlet rec helper xs1 xs2 result = \nmatch xs1 with \n| [] -> result\n| hd :: tl -> (helper tl xs2  (hd :: result)) in\n(helper xs1 xs2 [])\n\nappend [1] [2]"], "bad": ["let rec append xs1 xs2 = \nlet rec helper xs1 xs2 result = \nmatch xs1 with \n| [] -> result\n| hd :: tl -> (helper tl xs2  hd :: result) in\n(helper xs1 xs2 [])", "let rec append xs1 xs2 = \nlet rec helper xs1 xs2 result = \nmatch xs1 with \n| [] -> result\n| hd :: tl -> (helper tl xs2  (hd :: result)) in\n(helper xs1 xs2 [])"], "message": ["Error: Syntax error\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> hd :: (append tl xs2)"], "bad": ["let rec append xs1 xs2 = \nlet rec helper xs1 xs2 result = \nmatch xs1 with \n| [] -> result\n| hd :: tl -> (helper tl xs2  (hd :: result)) in\n(helper xs1 xs2 [])\n\n\nappend [1] [2]", "let rec append l1 l2 = \nlet rec helper xs1 xs2 result = \nmatch xs1 with \n| [] -> result\n| hd :: tl -> (helper tl xs2  (hd :: result)) in\n(helper xs1 xs2 [])\n\n\nappend [1] [2]", "let rec append l1 l2 = \nlet rec helper xs1 xs2 result = \nmatch xs1 with \n| [] -> result\n| hd :: tl -> (helper tl xs2  (hd :: result)) in\n(helper l1 l2 [])\n\n\nappend [1] [2]", "let rec append l1 l2 = \nlet rec helper xs1 xs2 result = \nmatch xs1 with \n| [] -> result\n| hd :: tl -> (helper tl xs2  (hd :: result)) in\nhelper l1 l2 []\n\n\nappend [1] [2]", "let rec append l1 l2 = \nlet rec helper xs1 xs2 result = \nmatch xs1 with \n| [] -> result\n| hd :: tl -> (helper tl [] (hd :: result)) in\nhelper l1 l2 []\n\n\nappend [1] [2]", "let rec append l1 l2 = \nlet rec helper xs1 xs2 result = \nmatch xs1 with \n| [] -> result\n| hd :: tl -> (helper tl [] (hd :: result)) in\nhelper l1 l2 []\n\n\nappend [1] [2]", "let rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> hd :: (append tl xs2)\n\nappend [1] [2]", "let rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> hd :: (append tl xs2) \n\nappend [1] [2]", "let rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> hd :: (append tl xs2) \n\nappend [1] [2]", "let rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> hd :: (append tl xs2)"], "message": ["Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: Unbound value xs1\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This function has type 'a list -> 'b -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> 'b list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> 'b list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let _ = List.mem 3 [1;2;3]"], "bad": ["let _ = List.mem [1;2;3] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list list\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then h :: seen else seen  in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "l"], "bad": ["et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"], "message": ["Error: Syntax error\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then h :: seen else seen  in\nlet rest' = t in helper (seen',rest') \nin\nList.rev (helper ([],l))"], "bad": ["et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"], "message": ["Error: Syntax error\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)"], "bad": ["let fixpoint (f,b) = wwhile (let xx = f xx in (xx, (f xx) = xx),b)", "let fixpoint (f,b) = wwhile (let xx = in (xx, (f xx) = xx),b)", "let fixpoint (f,b) = wwhile (fun xx ((xx, (f xx) = xx)),b)", "let fixpoint (f,b) = wwhile (fun xx ((xx, f xx = xx)),b)", "let fixpoint (f,b) = wwhile (fun xx -> ((xx, f xx = xx)),b)", "let fixpoint (f,b) = wwhile (fun xx -> (xx, f xx = xx),b)", "let fixpoint (f,b) = wwhile ((fun xx -> (xx, f xx = xx)),b)"], "message": ["Error: Unbound value x\n", "Error: Unbound value xx\n", "Error: Syntax error: operator expected.\n", "Characters 42-43:\n  let fixpoint (f,b) = wwhile (fun xx ((xx, (f xx) = xx)),b);;\n                                            ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error: pattern expected.\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "bad": ["let rec wwhile (f,b) =\nlet rec acc result =\nlet res = (f result) in\nmatch res with\n(b', c') -> if c' then acc b' else b'\nin\nacc b"], "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((fun xx -> (f xx, (f xx) != xx)),b)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 100)", "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) != xx)),b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 739085 )", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 739080 )"], "message": ["Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let _ = pi / sqrt(2.0)"], "bad": ["let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1"], "message": ["Error: Unbound value fixpoint\n"], "problem": "???"}
{"hw": "hw2", "fix": ["exprToString VarX"], "bad": ["let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX x -> sprintf \"%s\" x\n| VarY y -> sprintf \"%s\" y in\nacc e\n\nexprToString VarX", "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX x -> sprintf \"%s\" x\n| VarY y -> sprintf \"%s\" y in\nacc e \"\"\n\nexprToString VarX", "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX-> sprintf \"x\" \n| VarY y -> sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX-> sprintf \"x\" \n| VarY y -> sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX-> sprintf \"x\" \n| VarY -> sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX-> sprintf \"x\" \n| VarY -> sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX-> printf \"x\" \n| VarY -> printf \"y\" in\nacc e \"\"\n\nexprToString VarX", "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "let rec exprToString e = \nlet rec acc curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "let rec exprToString e = \nlet rec acc curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "let rec exprToString e = \nlet rec accu curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\" in\naccu e \"\"\n\nexprToString VarX", "let rec exprToString e = \nlet rec accu curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\" in\naccu e \"\""], "message": ["Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: The constructor VarY expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: The constructor VarY expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: Unbound value sprintf\n", "Error: Unbound value sprintf\n", "Error: Unbound value printf\n", "Error: Unbound value sprintf\n", "Error: This function has type expr -> 'a -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type expr -> 'a -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type expr -> 'a -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type expr -> 'a -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["exprToString VarX"], "bad": ["let rec exprToString e = \nmatch e with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\"  \n| Sine x   -> Printf.sprintf \"Sine(%s)\" exprToString x", "let rec exprToString e = \nmatch e with \n| VarX -> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\"  \n| Sine x -> Printf.sprintf \"Sine\\(%s\\)\" exprToString x", "let rec exprToString e = \nmatch e with \n| VarX -> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\"  \n| Sine x -> Printf.sprintf \"Sine(%s)\" exprToString x", "let rec exprToString e = \nmatch e with \n| VarX -> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\"  \n| Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x)"], "message": ["Error: Unbound value Printf.srprintf\nHint: Did you mean sprintf?\n", "Error: This expression has type\n         ('a -> 'b, unit, string, string, string, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type string \n", "Error: This expression has type\n         ('a -> 'b, unit, string, string, string, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type string \n", "Error: This expression has type\n         ('a -> 'b, unit, string, string, string, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type string \n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = \nlet rec acc xs = \nmatch xs with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nacc tl\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\"\nin\nacc l", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen else h :: seen  in\nlet rest' = t in helper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) =\nlet rec acc result =\nlet res = (f result) in\nmatch res with\n(b', c') -> if c' then acc b' else b'\nin\nacc b", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) = wwhile ((fun xx -> (f xx, (f xx) != xx)),b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0 )", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)", "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"Sine(%s)\" exprToString x"], "bad": ["exprToString Sine(VarX)", "exprToString Sine(VarX)", "| failwith \"Why don't you just make me write a lisp compiler\"\n\n\nexprToString Sine(VarX)"], "message": ["Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"Sine(%s)\" (exprToString x)\n\nexprToString Sine(VarX)"], "bad": ["let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"Sine(%s)\" (exprToString x)"], "message": ["Error: This expression has type\n         ('a -> 'b, unit, string, string, string, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type string \n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["exprToString Sine(VarX)"], "bad": ["let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"Sine(%s)\" (exprToString x)"], "message": ["Error: This expression has type\n         ('a -> 'b -> 'c -> 'd, unit, string, string, string,\n          'a -> 'b -> 'c -> 'd)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b -> 'c -> 'd, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b -> 'c -> 'd is not compatible with type string \n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["exprToString Sine(VarX)"], "bad": ["exprToString Sine(VarX)", "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"Sine(%s)\" (exprToString x)\n| _ -> failwith \"are we writing a lisp compiler now\""], "message": ["Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"Sine(pi*%s)\" (exprToString x)\n| \n| _ -> failwith \"are we writing a lisp compiler now\""], "bad": ["let _ = exprToString (Sine(VarX))"], "message": ["Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let _ = exprToString (Sine(VarX))"], "bad": ["let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"Sine(pi*%s)\" (exprToString x)\n| _ -> failwith \"are we writing a lisp compiler now\""], "message": ["Error: Syntax error\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let _ = exprToString (Sine(Average(VarX, VarY)))"], "bad": ["let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\nexprToString e1\nexprToString e2\n| _ -> failwith \"are we writing a lisp compiler now\"", "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| _ -> failwith \"are we writing a lisp compiler now\""], "message": ["Error: The constructor Times expects 2 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: This expression has type\n         ('a -> 'b -> 'c, unit, string, string, string, 'a -> 'b -> 'c)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b -> 'c, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b -> 'c is not compatible with type string \n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr,0.5,0.2)"], "bad": ["let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(eval(e', x, y))\n| Cosine(e') -> cos(eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) + eval(e2, x, y))/2\n| Times (e1, e2) -> (eval(e1, x, y) * eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(eval(e', x, y))\n| Cosine(e') -> cos(eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/2\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(eval(e', x, y))\n| Cosine(e') -> cos(eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\""], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)"], "bad": ["let _ = eval (sampleExpr1,0.5,0.2)"], "message": ["Error: This expression has type expr/1070\n       but an expression was expected of type expr/1675\nError: This expression has type expr/2036\n       but an expression was expected of type expr/2056\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type expr/1070\n       but an expression was expected of type expr/1675\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)"], "bad": ["let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\""], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "bad": ["let rec assoc (d,k,l) = \nmatch l with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nassoc (d, k, tl)\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\""], "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a * 'b * ('b * ('c -> 'd -> 'e)) list\n       The type variable 'a occurs inside\n       'a * 'b * ('b * ('c -> 'd -> 'e)) list\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "bad": ["let rec wwhile (f,b) =\nlet res = (f b) in\nmatch res with\n(b', c') -> if c' then wwhile (f, b') else b'"], "message": ["Error: Unbound value result\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr,0.5,0.2)", "let _ = eval (Average(Sqrt (VarX), Sqrt(VarY)), 0.3, -0.3)"], "bad": ["let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs (eval e))\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs (eval (e, x, y)))\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (absF (eval (e, x, y)))\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\""], "message": ["Error: Unbound value ^.\n", "Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: Unbound value absF\nHint: Did you mean abs?\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Sqrt(VarX)),Cosine(Average(VarX,VarY)))))"], "bad": ["let _ = sqrt (abs_foat (-0.3))", "let _ = sqrt (abs_float (-0.3))"], "message": ["Error: Unbound value abs_foat\nHint: Did you mean abs_float?\n", "Error: Unbound value abs_foat\nHint: Did you mean abs_float?\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let _  = eval (Quad (VarX, VarY, VarX), 0.5, 0.5)"], "bad": ["let _  = eval (Quad (VarX, VarY, VarX), 0.5, -0.5)"], "message": ["Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "let g1 () = failwith \"to be implemented\"", "let g2 () = failwith \"to be implemented\"", "let g3 () = failwith \"to be implemented\"", "let c1 () = failwith \"to be implemented\"", "let c2 () = failwith \"to be implemented\"", "let c3 () = failwith \"to be implemented\"", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type test = unit -> string", "let key = \"\"", "let prefix130 = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")", "let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0", "let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)", "let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))", "let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p", "let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max"], "bad": ["let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next next)\n| 4 -> buildTimes next next\n| 5 -> buildThresh next next next next\n| 6 -> buildSqrt next\n| 7 -> buildGauss next next next", "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes next next\n| 5 -> buildThresh next next next next\n| 6 -> buildSqrt next\n| 7 -> buildGauss next next next", "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)"], "message": ["Error: This function has type expr * expr -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type expr\n       This is not a function; it cannot be applied.\n", "Error: This function has type expr * expr -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "build"}
{"hw": "hw2", "fix": [")\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)"], "bad": ["let rec build (rand, depth) = match depth with\n(| 0 -> match rand (1, 2) with\n1 -> buildX\n| 2 -> buildY)\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "let rec build (rand, depth) = match depth with\n( 0 -> match rand (1, 2) with\n1 -> buildX\n| 2 -> buildY)\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "let rec build (rand, depth) = match depth with\n0 -> match rand (1, 2) with\n1 -> buildX\n| 2 -> buildY"], "message": ["Error: Syntax error\n", "Error: Syntax error: operator expected.\n", "Characters 47-48:\n  ( 0 -> match rand (1, 2) with\n  ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let _ = abs_float (x)"], "bad": ["let _ = abs_float -.40", "let _ = abs_float (-.40)", "let _ = abs_float (-0.40)"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type float\n", "Error: This expression has type float -> float\n       but an expression was expected of type float\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let buildAbs(e)\t\t\t   = Abs(e)"], "bad": ["let buildSqrt(e)                   = Sqrt(e)"], "message": ["Error: Unbound value x\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let _ = makeRand (1, 2)"], "bad": ["let _ = makeRand (1, 2)"], "message": ["Error: Unbound value rand\nHint: Did you mean land?\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let _ = makeRand (1, 2) (1, 2)"], "bad": ["let _ = makeRand (1, 2) (1, 2)"], "message": ["Error: This expression has type int but an expression was expected of type\n         int * int\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let _ = makeRand (2, 2) (1,2)"], "bad": ["let _ = makeRand (2, (1, 2))", "let _ = makeRand (2, 2) (1,2)"], "message": ["Error: Syntax error: ')' expected\nError: This '(' might be unmatched\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = match depth with\n| 0 -> (match rand (1, 3) with\n1-> VarX\n| 2 -> VarY )\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 8) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))"], "bad": ["let rec build (rand, depth) = match depth with\n| 0 -> (match rand (1, 3) with\n1-> VarX\n| 2 -> VarY )\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let g1 () = failwith \"to be implemented\"", "let g2 () = failwith \"to be implemented\"", "let g3 () = failwith \"to be implemented\"", "let c1 () = failwith \"to be implemented\"", "let c2 () = failwith \"to be implemented\"", "let c3 () = failwith \"to be implemented\"", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")"], "bad": ["let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 8) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| _ -> buildAbs next)"], "message": ["Error: This expression has type expr but an expression was expected of type\n         int\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Logistic (e1, e2, e3) -> \n(2.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y) *. eval(e3, x, y )))\n-. 1.0))\n| _ -> failwith \"error\""], "bad": ["let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Logistic (e1, e2, e3) -> \n(2.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y)))\n-. 1.0) ** eval (e3, x, y))\n| _ -> failwith \"error\""], "message": ["Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let g1 () = failwith \"to be implemented\"", "let g2 () = failwith \"to be implemented\"", "let g3 () = failwith \"to be implemented\"", "let c1 () = failwith \"to be implemented\"", "let c2 () = failwith \"to be implemented\"", "let c3 () = failwith \"to be implemented\"", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "let _ = doRandomGray (5, 7, 180)"], "bad": ["let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 1) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 6) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next)"], "message": ["Error: Syntax error: ')' expected\nError: This '(' might be unmatched\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 6) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildLogistic (next,\nbuild (rand, depth - 1), \nbuild (rand, depth - 1)))", "let g1 () = (8, 7, 180)", "let g2 () = (8, 52, 13)", "let g3 () = (8, 13, 10)", "let c1 () = (8, 2, 17)", "let c2 () = (8, 5, 43)", "let c3 () = (8, 83, 4)", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type test = unit -> string", "let key = \"\"", "let prefix130 = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")", "let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0", "let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)", "let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))", "let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p", "let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max"], "bad": ["let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 6) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildLogistic (next,\nbuild (rand, depth - 1), \nbuild (rand, depth - 1)))"], "message": ["Error: Syntax error: ')' expected\nError: This '(' might be unmatched\n"], "problem": "build"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = a + x^2 in\nlet base = 0 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = a +. x ** 2in\nlet base = 0 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = a +. x ** 2.0 in\nlet base = 0 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = a + x*xin"], "message": ["Error: This expression has type int but an expression was expected of type\n         string\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: Syntax error\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let _ = List.fold_right (+) [1;2;3] 0"], "bad": ["[1,2,3].fold_right (+) 0", "let _ = [1,2,3].fold_right (+) 0", "let _ = List.fold_right (+) 0 [1,2,3]", "let _ = List.fold_right (+) [1,2,3] 0"], "message": ["Error: Unbound record field fold_right\n", "Error: Unbound record field fold_right\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type int\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let _ = List.fold_left(+) 0 [1;2;3]"], "bad": ["let _ = List.fold_left(+) [1;2;3] 0"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (h acc) tl in\niter (fun y-> y) fs"], "bad": ["let pipe fs = \nlet f a x = a x in\nlet base = x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fs (a x) in\nlet base = x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fs (a x) in\nlet base = fun y -> y in\nList.fold_left f base fs", "let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (h curr) tl in\niter (fun y-> y) fs"], "message": ["Error: Unbound value x\n", "Error: Unbound value x\n", "Error: This expression has type 'a -> 'a -> 'a\n       but an expression was expected of type 'a list\n", "Error: This expression has type ('a -> 'b) list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b) list\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let _ = pipe [] 3"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (h (acc)) tl in\niter (fun y-> y) fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)]"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let _ = compose (fun x -> x + 1) (fun x -> x* 2) 1"], "bad": ["let _ = compose ((+) 1) (", "let _ = compose (((+) 1)) (", "let _ = compose (+) 1", ") ( * 2) 1", "let _ = compose (+ 1) ( * 2) 1"], "message": ["Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: This expression has type int but an expression was expected of type\n         'a -> int\n", "Error: Syntax error\n", "Characters 22-23:\n  let _ = compose (+ 1) ( * 2) 1;;\n                        ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (fun x -> (h (acc x))) tl in\niter id fs"], "bad": ["let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (fun x -> (h (acc x)) tl in\niter id fs"], "message": ["Characters 83-84:\n  | h::tl -> iter (fun x -> (h (acc x)) tl in\n                  ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =  fun y -> (a (x y))   in\nlet base = fun y -> y in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x =  fun y -> ((a (x y))   in\nlet base = fun y -> y in\nList.fold_left f base fs *", "let pipe fs = \nlet f a x =  fun y -> ((a (x y))   in\nlet base = fun y -> y in\nList.fold_left f base fs *", ")", "let pipe fs = \nlet f a x =  fun y -> (a (x y))   in\nlet base = fun y -> y in\nList.fold_left f base fs *"], "message": ["Characters 37-38:\n  let f a x =  fun y -> ((a (x y))   in\n                        ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Characters 37-38:\n  let f a x =  fun y -> ((a (x y))   in\n                        ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let stringOfList f l = \n\"[\" ^ List.fold_left (^) \n\"\"\n(List.map f l) ^ \"]\""], "bad": ["let stringOfList f l = \n\"[\" ^ List.map f l ^ \"]\""], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = \n\"[\" ^\nList.fold_left (fun x acc -> x ^ \"; \" ^ acc) \n\"\"\n(List.map f l) ^ \"]\""], "bad": ["let stringOfList f l = \n\"[\" (fun x acc -> x ^ \"; \" ^ acc) \nList.fold_left (^) \n\"\"\n(List.map f l) ^ \"]\""], "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = \n\"[\" ^\n(List.fold_right (fun x acc -> x ^ \"; \" ^ acc) \n(List.map f l) \n\"\")\n^ \"]\""], "bad": ["let stringOfList f l = \n\"[\" ^\nList.fold_right (fun x acc -> x ^ \"; \" ^ acc) \n\"\"\n(List.map f l) ^ \"]\""], "message": ["Error: This expression has type string but an expression was expected of type\n         string list\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\n( clone 0 (len2 - len1) @ l1,\nclone 0 (len1 - len2)@  l2)"], "bad": ["let padZero l1 l2 = \nlet len1 = List.len l1 in\nlet len2 = List.len l2 in\n( clone 0 (len2 - len1) @ l1,\nclone 0 (len1 - len2)@  l2)"], "message": ["Error: Unbound value List.len\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nlet diff = (List.length l2) - (List.length l1) in\n( clone 0 diff @ l1,\nclone 0 (-diff) @  l2)"], "bad": ["let padZero l1 l2 = \nlet diff = (List.length l2) - (List.length l1) in\n( clone 0 diff @ l1,\nclone 0 -diff @  l2)"], "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let rec removeZero l = match l with\n| [] -> l\n| h :: t -> if (h = 0) then removeZero t \nelse l"], "bad": ["let rec removeZero l = match l with\n| [] -> l\n| h :: t -> if (h = 0) then removeZer t \nelse l"], "message": ["Error: Unbound value removeZer\nHint: Did you mean removeZero?\n"], "problem": "removeZero"}
{"hw": "hw3", "fix": ["let _ = List.combine [1;2;3] [4;5;6]"], "bad": ["let _ = list.Combine = [1;2;3] [4;5;6]", "let _ = list.Combine  [1;2;3] [4;5;6]", "let _ = list.Combine [1;2;3] [4;5;6]", "let _ = list.combine [1;2;3] [4;5;6]"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value list\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let _ = List.hd [1;2;3] + List.hd [4;5]"], "bad": ["let _ = [1;2;3].hd + [4;5].hd", "let _ = [1;2;3].headd + [4;5].hd", "let _ = [1;2;3].head + [4;5].hd", "let _ = List.hd [1;2;3] + [4;5].hd"], "message": ["Error: Unbound record field hd\n", "Error: Unbound record field headd\n", "Error: Unbound record field head\n", "Error: Unbound record field hd\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let _ = bigAdd [1] [2]"], "bad": ["let _ = bigAdd [1] [2];\n\n\nlet _ = bigAdd [9;9] [1;0;0;2]"], "message": ["Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n((if (addit > 10) then (addit / 10) else 0), \n( addit mod 10 :: num)\t)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n((if (addit > 10) then (addit / 10) else 0), \n( addit mod 10 :: num)\t  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Characters 132-133:\n  ((if (addit > 10) then (addit / 10) else 0), \n  ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f x a = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n((if (addit > 10) then 1 else 0), \n( addit mod 10 :: num))  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_right f args base in res\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n((if (addit > 10) then 1 else 0), \n( addit mod 10 :: num))  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_right f args base in res\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int * int list -> int * int -> int * int list\n       but an expression was expected of type\n         int * int list -> int * int -> int * int\n       Type int list is not compatible with type int \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, ((addit mod 10) :: num)) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry \nprint_int l1' in\n(addit / 10, ( addit mod 10 :: num)) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type\n         ((int -> unit) -> int -> int) * int list ->\n         int * int -> int * int list\n       but an expression was expected of type\n         ((int -> unit) -> int -> int) * int list ->\n         int * int -> ((int -> unit) -> int -> int) * int list\n       Type int is not compatible with type (int -> unit) -> int -> int \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, ((addit mod 10) :: num)) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [1; 9] [0; 1]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nif (x = [] && carry > 0) then carry :: num else num"], "message": ["Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, ((addit mod 10) :: num)) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = x in\nlet (l1', l2') = a in \nlet addit = l1' + l2' + carry in\n(addit / 10, ((addit mod 10) :: num)) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int * int -> int * int list -> int * int list\n       but an expression was expected of type\n         int * int -> int * int list -> int * int\n       Type int list is not compatible with type int \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  \nlet (carry, num) = a in \nlet (l1, l2) = x in\n(0, l1 :: num)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \n(0, x :: a)", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  (0, x :: a) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  (0, x :: a) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  let (l1, l2) = x in\n(0, l2 :: a)", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  let (l1, l2) = x in\n(0, l2 :: a)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  let (l1, l2) = x in\n(0, l2 :: a)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  let (l1, l2) = x in\n(0, l1 :: a)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  \nlet (carry, nume ) = a in \nlet (l1, l2) = x in\n(0, l1 :: num)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  \nlet (carry, nume ) = a in \nlet (l1, l2) = x in\n(0, l1 :: num)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n", "Error: This expression has type 'a list -> 'a -> int * 'a list\n       but an expression was expected of type 'a list -> 'a -> 'a list\n       Type int * 'a list is not compatible with type 'a list \n", "Error: This expression has type 'a list -> 'a -> int * 'a list\n       but an expression was expected of type 'a list -> 'a -> 'a list\n       Type int * 'a list is not compatible with type 'a list \n", "Error: Syntax error\n", "Error: This expression has type 'a list -> 'b * 'a -> int * 'a list\n       but an expression was expected of type 'a list -> 'b * 'a -> 'a list\n       Type int * 'a list is not compatible with type 'a list \n", "Error: This expression has type 'a list -> 'b * 'a -> int * 'a list\n       but an expression was expected of type 'a list -> 'b * 'a -> 'a list\n       Type int * 'a list is not compatible with type 'a list \n", "Error: This expression has type 'a list -> 'a * 'b -> int * 'a list\n       but an expression was expected of type 'a list -> 'a * 'b -> 'a list\n       Type int * 'a list is not compatible with type 'a list \n", "Error: Unbound value num\nHint: Did you mean nume?\n", "Error: Unbound value num\nHint: Did you mean nume?\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ ((addit mod 10) )) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ (addit mod 10) )", ") in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ (addit mod 10) ) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ (addit mod 10) ) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in car\nin \n(add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in _\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZeros (add (padZero l1 l2))"], "message": ["Error: Unbound value removeZeros\nHint: Did you mean removeZero?\nError: Unbound value removeZeros\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value removeZeros\nHint: Did you mean removeZero?\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(if addit >= 10 then 1 else 0, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(if addit >= 10 then 1 else 0, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine [0; l1] [0; l2] in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2)"], "message": ["Error: This expression has type int list * int list\n       but an expression was expected of type int * int\n       Type int list is not compatible with type int \n", "Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nfailwith (Printf.sprintf \"hi %d\" addit)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nfailwith printf.sprintf \"hi %d\" addit\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nfailwith Printf.sprintf \"hi %d\" addit\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Unbound value printf\n", "Error: This expression has type ('a, unit, string) format -> 'a\n       but an expression was expected of type string\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf \"hi %d\" car \n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" car )\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" car );\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" car; )\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry; )\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (\"hi %d\") carry; )\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (\"hi %d\") carry", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf (\"hi %d\") carry", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (\"hi %d\") carry)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (\"hi %d\") carry)", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.kprintf (\"hi %d\") carry)", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.kprintf (\"hi %d\") carry)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (\"hi %d\") carry)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (\"hi %d\" carry)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (\"hi %d\" carry))\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type\n         ('a -> 'b, out_channel, unit, unit, unit, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, out_channel, unit, unit, unit, unit)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type unit \n", "Error: Unbound value car\n", "Error: Unbound value car\n", "Error: Unbound value car\n", "Error: This expression has type unit\n       This is not a function; it cannot be applied.\n", "Error: This expression has type unit\n       This is not a function; it cannot be applied.\n", "Characters 134-135:\n  (Printf.printf (\"hi %d\") carry;;\n  ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Error: This expression has type unit\n       This is not a function; it cannot be applied.\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type string but an expression was expected of type\n         string -> 'a\n", "Error: This expression has type unit\n       This is not a function; it cannot be applied.\n", "Error: This expression has type unit\n       This is not a function; it cannot be applied.\n", "Characters 134-135:\n  (Printf.printf (\"hi %d\" carry)\n  ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type unit\n       This is not a function; it cannot be applied.\n", "Characters 134-135:\n  (Printf.printf \"hi %d\" carry;\n  ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit; in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %s\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit; in\n(if addit >= 10 then 1 else 0), num @ [addit mod 10]", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit; in\n(if addit >= 10 then 1 else 0), num @ [addit mod 10]", ") in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit in\n(if addit >= 10 then 1 else 0), num @ [addit mod 10]", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit; in\n(if addit >= 10 then 1 else 0), num @ [addit mod 10]"], "message": ["Error: This expression has type int but an expression was expected of type\n         string\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let _ = bigAdd [1; 9] [2]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\"; in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int -> unit\n       but an expression was expected of type unit\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf \"%d\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf (\"%d\\n\" addit);\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf (\"%d\\n\", addit);\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type\n         ('c, out_channel, unit) format =\n           ('c, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%8d%8d%8d\\n\" l1' l2' carry; (if addit >= 10 then 1 else 0), num @ [addit mod 10])"], "message": ["Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%8d%8d%8d\\n\"; l1'; l2'; carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%8d%8d%8d\\n\"; l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf; Printf.sprintf \"%8d%8d%8d\\n\"; l1'; l2'; carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf Printf.sprintf \"%8d%8d%8d\\n\"; l1'; l2'; carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type ('a, unit, string) format -> 'a\n       but an expression was expected of type\n         ('b -> 'c, out_channel, unit) format =\n           ('b -> 'c, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry); ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type ('a, unit, string) format -> 'a\n       but an expression was expected of type\n         ('b -> 'c -> 'd -> 'e -> 'f, out_channel, unit) format =\n           ('b -> 'c -> 'd -> 'e -> 'f, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n", "Error: This expression has type string but an expression was expected of type\n         ('a, out_channel, unit) format =\n           ('a, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\"; Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s \"Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\" Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type\n         ('a -> 'b -> 'c -> 'd -> 'e, out_channel, unit, unit, unit,\n          'a -> 'b -> 'c -> 'd -> 'e)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b -> 'c -> 'd -> 'e, out_channel, unit, unit, unit, unit)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b -> 'c -> 'd -> 'e is not compatible with type unit \n", "Error: This expression has type\n         ('a -> 'b -> 'c -> 'd -> 'e, out_channel, unit, unit, unit,\n          'a -> 'b -> 'c -> 'd -> 'e)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b -> 'c -> 'd -> 'e, out_channel, unit, unit, unit, unit)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b -> 'c -> 'd -> 'e is not compatible with type unit \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf \"%d\\n\" addit in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((Printf.printf \"%s\\n\" addit);\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(let _ = Printf.printf \"%s\\n\" addit);\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf \"%s\\n\" addit in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf \"%d\\n\" addit in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])"], "message": ["Error: This expression has type\n         ('a -> 'b, out_channel, unit, unit, unit, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, out_channel, unit, unit, unit, unit)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type unit \n", "Error: This expression has type int but an expression was expected of type\n         string\n", "Error: This expression has type int but an expression was expected of type\n         string\n", "Error: This expression has type int but an expression was expected of type\n         string\n", "Error: This expression has type int but an expression was expected of type\n         string\n", "Error: This expression has type int but an expression was expected of type\n         string\n", "Error: This expression has type int but an expression was expected of type\n         string\n", "Error: This expression has type int but an expression was expected of type\n         string\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let _ = Printf.printf \"%s\" \"moo\""], "bad": ["let _ = Printf.printf string_of_int 1", "let _ = Printf.printf (string_of_int 1)", "let _ = Printf.printf \"%*s\"( string_of_int 1)"], "message": ["Error: This expression has type int -> string\n       but an expression was expected of type\n         ('a -> 'b, out_channel, unit) format =\n           ('a -> 'b, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n", "Error: This expression has type string but an expression was expected of type\n         ('a, out_channel, unit) format =\n           ('a, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n", "Error: This expression has type string but an expression was expected of type\n         int\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf (string_of_int addit) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type string but an expression was expected of type\n         ('a, out_channel, unit) format =\n           ('a, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10), num @ [addit mod 10]"], "message": ["Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let _ = List.fold_left (fun a x -> x /. a) 1.0 [1.0;4.0]"], "bad": ["let _ = List.fold_left fun a x -> x / a 1 [1.0;4.0]", "let _ = List.fold_left (fun a x -> x / a) 1 [1.0;4.0]", "let _ = List.fold_left (fun a x -> x / a) 1.0 [1.0;4.0]"], "message": ["Error: Syntax error\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine (List.rev ([0] @ l1)) (List.rev ([0]@ l2)) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine (List.reverse ([0] @ l1)) (List.Reverse ([0]@ l2)) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Unbound value List.reverse\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine (List.rev ([0] @ l1)) (List.rev ([0]@ l2)) in\nlet (car, res) = List.fold_left f base args in \nList.rev res\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine (List.rev ([0] @ l1)) (List.rev ([0]@ l2)) in\nlet (car, res) = List.fold_left f base args in \nList.reve res\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Unbound value List.reve\nHint: Did you mean rev?\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = if i = 0 then 0\nelse if i = 1 then l \nelse (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\nelse bigAdd l (mulByDibit (i - 1) l)"], "bad": ["let _ = mulByDigit 9 [9;9;9;9]", "let rec mulByDigit i l = if i = 1 then l \nelse mulByDigit (i - 1) (bigAdd l l)", "let _ = mulByDigit 9 [9;9;9;9]", "let rec mulByDigit i l = if i = 0 then 0\nelse if i = 1 then l \nelse l"], "message": ["Error: Unbound value bigAdd\n", "Error: Unbound value mulByDigit\n", "Error: Unbound value bigAdd\n", "Error: Unbound value mulByDigit\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(place + 1 ,bigAdd num (mulByDigit (x * placement) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement =  10 ** place  in\n(addit / 10, (addit mod 10) :: num) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(addit / 10, (addit mod 10) :: num) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(bigAdd a mulByDigit (x * place) l1) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(bigAdd a mulByDigit ((x * place) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(bigAdd a (mulByDigit (x * place) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(place + 1 , bigAdd num (mulByDigit (x * place) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(place + 1 ,bigAdd num (mulByDigit (x * place) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let _ = bigMul [9;9;9;9] [9;9;9;9]"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: Unbound value addit\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n"], "problem": "bigMul"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 1"], "bad": ["let _ = digitsOfInt -1", "let _ = digitsOfInt -1.5", "let _ = digitsOfInt -1"], "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n", "Error: This expression has type int -> int list\n       but an expression was expected of type int\n", "Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]", "let rec digithelper n l=\nlet x = n/10 in\nlet y = n mod 10 in\nif x <= 0\nthen y :: l\nelse digithelper x (y :: l)", "let digitsOfInt n =\nif n =< 0 \nthen []\nelse \ndigithelper n []", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let _ = digitsOfInt 0", "let _ = digitsOfInt 1", "let _ = digitsOfInt -12"], "bad": ["let _ = digitsOfInt -12"], "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec addPHelper n pos =\nlet sum = sumList pos in \nif sum < 10\nthen sum\nelse addPHelper sum pos", "let additivePersistence n = \nlet pos = digits n in\naddPHelper n pos", "let _ = additivePersistence 9876"], "bad": ["let rec addPHelper n pos =\nlet sum = sumList pos in \nif sum < 10\nthen sum\nelse addPHelper sum", "let additivePersistence n = \nlet pos = digits n in\naddPHelper n pos", "let _ = additivePersistence 9876"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list -> int\n       but an expression was expected of type int\n", "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let _ = additivePersistence 1"], "bad": ["let _ = additivePersistence 1"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "problem": "additivePersistence"}
{"hw": "hw2", "fix": ["let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "let rec build (rand, depth) = failwith \"TBD\"", "let g1 () = doRandomGray (3, 1, 5)", "let g2 () = failwith \"to be implemented\"", "let g3 () = failwith \"to be implemented\"", "let c1 () = doRandomColor (3, 1, 5)", "let c2 () = failwith \"to be implemented\"", "let c3 () = failwith \"to be implemented\"", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type test = unit -> string", "let key = \"\"", "let prefix130 = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")", "let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0", "let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)", "let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))", "let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p", "let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max"], "bad": ["let rec build (rand, depth) = match depth with\n| 0 -> buildX \n| 1 -> (build (rand, depth-(depth -1)))\n| 2 -> buildTimes(build (rand, depth-(depth -2)), build(rand, depth-(depth -2)))", "let rec build (rand, depth) = match depth with\n| 0 -> buildX \n| 1 -> (build (rand, depth-(depth -1)))\n| 2 -> buildTimes(build (rand, depth-(depth -2)), build(rand, depth-(depth -2)))"], "message": ["Error: Unbound value buildX\nHint: Did you mean build?\n", "Error: Unbound value buildX\nHint: Did you mean build?\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with \n| VarX              -> x\n| VarY              -> y\n| Sine(e)          -> sin(pi *. eval(e,x,y))\n| Cosine(e)        -> cos(pi *. eval(e,x,y))\n| Average(e1,e2)   -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.\n| Times(e1,e2)     -> eval(e1,x,y) *. eval(e2,x,y)\n(* | PowerUp(e1,e2)   -> (abs(eval(e1,x,y))) ** (abs(eval(e2,x,y))) *)\n| Square2(e1,e2,e3)-> sqrt((eval(e1,x,y))**2. +. (eval(e2,x,y))**2. +. (eval(e3,x,y))**2.)/. 2.     (* New Operator *)\n| Thresh(a,b,a_less,b_less) -> \nif eval(a,x,y) < eval(b,x,y)\nthen eval(a_less, x, y)\nelse eval(b_less, x, y)", "eval (Times(VarX,VarY), 0.5, -0.5)", "eval (Cosine(Times(VarX,VarY)), 0.5,-0.5)", "eval (Sine(Average(VarX,VarY)), 0.5, -0.5)", "eval (Sine(Average(VarX,VarY)), 0.3 ,0.3)", "eval (sampleExpr1,0.5,0.2)"], "bad": ["let rec eval (e,x,y) = match e with \n| BuildX()              -> x\n| VarY              -> y\n| Sine(e)          -> sin(pi *. eval(e,x,y))\n| Cosine(e)        -> cos(pi *. eval(e,x,y))\n| Average(e1,e2)   -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.\n| Times(e1,e2)     -> eval(e1,x,y) *. eval(e2,x,y)\n(* | PowerUp(e1,e2)   -> (abs(eval(e1,x,y))) ** (abs(eval(e2,x,y))) *)\n| Square2(e1,e2,e3)-> sqrt((eval(e1,x,y))**2. +. (eval(e2,x,y))**2. +. (eval(e3,x,y))**2.)/. 2.     (* New Operator *)\n| Thresh(a,b,a_less,b_less) -> \nif eval(a,x,y) < eval(b,x,y)\nthen eval(a_less, x, y)\nelse eval(b_less, x, y)", "eval (Times(VarX,VarY), 0.5, -0.5)", "eval (Cosine(Times(VarX,VarY)), 0.5,-0.5)", "eval (Sine(Average(VarX,VarY)), 0.5, -0.5)", "eval (Sine(Average(VarX,VarY)), 0.3 ,0.3)", "eval (sampleExpr1,0.5,0.2)"], "message": ["Error: Syntax error\n", "Error: Unbound constructor BuildX\n", "Error: Unbound value eval\n", "Error: Unbound value eval\n", "Error: Unbound value eval\n", "Error: Unbound value eval\n"], "problem": "eval"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x (a+1) in\nlet base = 0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = [fs a] in\nlet base = 0 in\nList.fold_left f base fs"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "pipe"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = \nlet ( a , b ) = (f b) in\n5"], "bad": ["let rec wwhile (f,b) = \nlet ( a , b ) = f b in\nif b then wwhile f a else a", "let rec wwhile (f,b) = \nlet ( a , b ) = (f b) in\nif b then wwhile f a else a", "let rec wwhile (f,b) = \nlet ( a , b ) = (f b) in\nif b then wwhile (f a) else a"], "message": ["Error: This expression has type 'a -> 'b * bool\n       but an expression was expected of type ('a -> 'b * bool) * 'a\n", "Error: This expression has type 'a -> 'b * bool\n       but an expression was expected of type ('a -> 'b * bool) * 'a\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type ('a -> 'a * bool) * 'a\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = \nlet ( b' , c' ) = f b in\nif c' then wwhile ( f, b' ) else b'"], "bad": ["let rec wwhile (f,b) = \nlet ( b' , c' ) = (f b) in\nif c' then f b' else b'", "let rec wwhile (f,b) = \nlet ( b' , c' ) = (f b) in\nif c' then wwhile (f b') else b'", "let rec wwhile (f,b) = \nlet ( b' , c' ) = f b in\nif c' then wwhile f b' else b'"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type ('a -> 'a * bool) * 'a\n", "Error: This expression has type 'a -> 'b * bool\n       but an expression was expected of type ('a -> 'b * bool) * 'a\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = \nlet rec helper (f, b) =\nlet b' = f b in\nif b' = b then b' else helper (f, b')\nin helper (f, b)"], "bad": ["let fixpoint (f,b) = \nlet rec helper (f, b) =\nlet b' = f b in\nif b' = b then b' else helper (f, b')"], "message": ["Error: Syntax error\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let _ = fixpoint (collatz, 9349802374897001)"], "bad": ["let _ = fixpoint (collatz, 93rew001)"], "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let pi = 4.0 *. atan 1.0", "sin ( pi )"], "bad": ["let pi = 4.0 *. atan 1.0\nsin ( pi )"], "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr,0.5,0.2)"], "bad": ["let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e' x y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval e' x y ) )\n| Average ( e1, e2 )\n-> (( eval e1 x y ) +. ( eval e2 x y )) /. 2\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )", "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) )\n| Cosine e'\n-> cos ( pi *. ( eval e' x y ) )\n| Average ( e1, e2 )\n-> (( eval e1 x y ) +. ( eval e2 x y )) /. 2\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )", "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval e' x y ) )\n| Average ( e1, e2 )\n-> (( eval e1 x y ) +. ( eval e2 x y )) /. 2\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )", "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )", "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )", "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )", "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )", "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )"], "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)\n", "Error: This expression has type expr\n       This is not a function; it cannot be applied.\n", "Characters 79-80:\n  -> sin ( pi *. ( eval (e', x, y ) )\n         ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: This function has type expr * float * float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This function has type expr * float * float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type expr\n       This is not a function; it cannot be applied.\n", "Error: This expression has type expr\n       This is not a function; it cannot be applied.\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval (Average(VarX,VarY)), 5.0, 10.0", ")"], "bad": ["let _ = eval (sampleExpr1,0.5,0.2)"], "message": ["Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"], "bad": ["let _ = eval ((Average(VarX,VarY)), 5.0, 10.0 )"], "message": ["Error: Syntax error\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")"], "bad": ["let _ = eval sampleExpr 0.5 0.2", "let _ = eval( sampleExpr, 0.5, 0.2 )"], "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * float * float\nError: Unbound constructor Average\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "Error: This function has type expr * float * float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound constructor Average\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type expr * float * float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let q = g1", "let _ = doRandomGray( q )"], "bad": ["let _ = doRandomGray( (g1) )"], "message": ["Error: This expression has type unit -> int * int * int\n       but an expression was expected of type int * int * int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type unit -> int * int * int\n       but an expression was expected of type int * int * int\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let _ = doRandomGray( 12, 9239, 32432 )"], "bad": ["let _ = doRandomGray( 76, 9239, 32432 )"], "message": ["Error: This expression has type unit -> int * int * int\n       but an expression was expected of type int * int * int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type unit -> int * int * int\n       but an expression was expected of type int * int * int\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let _ = doRandomColor( 200000000, 3032, 1056 )"], "bad": ["let _ = doRandomColor( 2000000000, 3032, 1056 )"], "message": ["Error: Integer literal exceeds the range of representable integers of type int\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )\n| Factorial e'\n-> factorial( eval( e', x, y ), 1 )\n| Sum3( e1, e2, e3 )\n-> eval( e1, x, y ) +. eval( e2, x, y ) +. eval( e3, x, y )"], "bad": ["let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )\n| Factorial e'\n-> factorial( eval( e' ), 1 )\n| Sum3( e1, e2, e3 )\n-> eval( e1 ) +. eval( e2 ) +. eval( e3 )", "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )"], "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval ((Average(VarX,VarY)), 5.0, 10.0 )", "let _ = eval (Factorial(VarX), 5, 0 )"], "bad": ["let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )\n| Factorial e'\n-> factorial (eval( e', x, y )) 1.0 \n| Sum3( e1, e2, e3 )\n-> eval( e1, x, y ) +. eval( e2, x, y ) +. eval( e3, x, y )"], "message": ["Error: This function has type float -> float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval (Factorial(VarX), 5.0, 4.0 )"], "bad": ["let _ = eval (Factorial(VarX), 5.0, 0.0 )"], "message": ["Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x))", "let _ = fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let fixpoint (f,b) = wwhile ( (f, ( b, ( f b ) = b ))), b", "let fixpoint (f,b) = wwhile ( f b, b )"], "message": ["Error: Syntax error\n", "Error: This expression has type 'a but an expression was expected of type\n         'a * 'b\n       The type variable 'a occurs inside 'a * 'b\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ( (f b) = b , b )"], "bad": ["let fixpoint (f,b) = wwhile ( (f b), b )"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if ( List.mem h seen ) then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev(helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) = \nlet ( b' , c' ) = f b in\nif c' then wwhile ( f, b' ) else b'", "let f x = let xx = x*x*x in (xx, xx < 512) in wwhile (f,2)", "let fixpoint (f,b) = wwhile ( \nlet f' b' = f b in ( f, b' = b )\n, b )"], "bad": ["let fixpoint (f,b) = wwhile ( f, (f b) = b , b )", "let fixpoint (f,b) = wwhile ( \nlet f' b' = let xx = f b in ( b' = b ) \n, b )", "let fixpoint (f,b) = wwhile ( \nlet f' b' = f b in ( b' = b ) \n, b )", "let fixpoint (f,b) = wwhile ( \nlet b' = f b in ( b' = b ) \n, b )", "let fixpoint (f,b) = wwhile ( \nlet f x = let xx = x*x*x in (xx, xx < 512) in wwhile (f,2)\n, b )", "let fixpoint (f,b) = wwhile ( \nlet f x = let xx = x*x*x in (xx, xx < 512)\n, b )", "let fixpoint (f,b) = wwhile ( \nlet f x = let xx = x*x*x in (xx, xx < 512)\n, b )", "let fixpoint (f,b) = wwhile ( \nlet f x = x*x*x in (xx, xx < 512)\n, b )", "let fixpoint (f,b) = wwhile ( \nlet f x = let xx = x*x*x in (xx, xx < 512)\n, b )", "let fixpoint (f,b) = wwhile ( \nlet f' x = let xx = x*x*x in (xx, xx < 512)\n, b )", "let fixpoint (f,b) = wwhile ( \nlet b' = f b in ( f, b' = b)\n, b )", "let fixpoint (f,b) =  \nlet b' = f b in wwhile( ( f, b' = b)\n, b )", "let fixpoint (f,b) =  \nlet b' = f b in wwhile( ( f , b' = b)\n, b )", "let fixpoint (f,b) =  \nlet b' = f b in wwhile( f , b' = b\n, b )"], "message": ["Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type ('d -> 'd * bool) * 'd\n", "Error: Syntax error: operator expected.\n", "Error: Unbound value b'\n", "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'a * bool\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ( \nlet f' b' = ( f, b = b' ) in f b\n, b )"], "bad": ["let fixpoint (f,b) = wwhile ( \nlet f' b' = f b in ( f', b' = b )\n, b )", "let fixpoint (f,b) = wwhile ( \nlet b' = f b in ( f, b' = b )\n, b )", "let fixpoint (f,b) = wwhile ( \nlet b' = f b in ( f, (b' = b) )\n, b )", "let fixpoint (f,b) = wwhile ( \nlet f' b' = ( f b, b = b' )\n, b )", "let fixpoint (f,b) = wwhile ( \nlet f' b' = ( f b, b = b' ) in f b\n, b )"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: Syntax error: operator expected.\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ( \nlet f' = ( f, b = f b ) in f b\n, b )"], "bad": ["let fixpoint (f,b) = wwhile ( \nlet f' b' = ( f, b = b' ) in f b\n, b )"], "message": ["Error: Unbound value b'\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let f x = let xx = x*x*x in (xx, xx < 512)", "wwhile (f,2)"], "bad": ["let f x = let xx = x*x*x in (xx, xx < 512) in wwhile (f,2)"], "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "problem": "wwhile"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = a x in\nlet base = 0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fs a in\nlet base = fs x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fs a in\nlet base = fs in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fs a x in\nlet base = fs a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fs a x in\nlet base = 0 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fs a in\nlet base = 0 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fs x in\nlet base = 0 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base = 0 in\nList.fold_left f base fs"], "message": ["Error: Unbound value x\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a\n", "Error: Unbound value a\n", "Error: This expression has type int -> 'a -> int\n       but an expression was expected of type 'a list\n", "Error: This expression has type int -> int\n       but an expression was expected of type 'a list\n", "Error: This expression has type 'a -> int\n       but an expression was expected of type 'a list\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = 'a in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let _ = pipe [] 3"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs y = \nlet f a x = x a in\nlet base = y in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs"], "message": ["Error: Unbound value a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x  in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a x  in\nlet base = fun x -> x  in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a + x a in\nlet base = fun x -> x  in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x + x a in\nlet base = fun x -> x  in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type ('a -> 'b) -> int\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b) -> int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs y = \nlet f a x = x a in\nlet base = y  in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let pipe fs = \nlet f a x = a -> x in\nlet base = fun x -> x  in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x', y -> x a + a", "let base = fun x -> x  in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x' y -> x a + a", "let base = fun x -> x  in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x' y -> x a + a", "let base = fun x -> x  in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value f\n", "Error: Syntax error\n", "Error: Unbound value f\n", "Error: Syntax error\n", "Error: Unbound value f\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun a -> x a  in\nlet base = fun x -> x  in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x y -> y+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x y -> y+x); (fun x y -> x + y)] 3", "let pipe fs = \nlet f a x = fun x' y -> x a + a in\nlet base = fun x -> x  in\nList.fold_left f base fs"], "message": ["Error: This expression has type int -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type int -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type int -> (int -> int) -> 'a -> 'b -> int\n       but an expression was expected of type int -> (int -> int) -> int\n       Type 'a -> 'b -> int is not compatible with type int \n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let _ = pipe [(fun x -> x ^ \", \" ^ x); (fun x -> x ^ \", \" ^ x ^ \"!\")] \"corn\""], "bad": ["let _ = pipe [(fun x -> x ^ \", \" ^ x); (fun x -> x ^ \", \" ^ x ^ \"!\")] corn"], "message": ["Error: Unbound value corn\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let cat = pipe []"], "bad": ["let _ = pipe [(fun x -> x ^ \", \" ^ x); (fun x -> x ^ \", \" ^ x ^ \"!\")] \"corn\"", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type string\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep ^ a in\nlet base = sepConcat sep t in\nlet l = t in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep ^ a in\nlet base = \"\" in\nlet l = sepConcat sep t in\nList.fold_left f base l"], "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let stringOfList f l = match l with\n[] -> \"\"\n| h::t -> \nlet f' a x = x ^ a in\nlet base = f h in\nlet l = t in\nList.fold_left f' base l"], "bad": ["let stringOfList f l = match l with\n[] -> \"\"\n| h::t -> f h ^ stringOfList f t"], "message": ["Error: Unbound value stringOfList\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x =  in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fs a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'a) -> 'a -> 'a\n       but an expression was expected of type 'b list\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = fun x in\nList.fold_left f base fs"], "message": ["Error: Unbound value a\n", "Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let crack a x = x a", "let base = fun x -> x", "List.fild_left crack base []"], "bad": ["List.fold_left ( fun a x -> x a , fun x -> x, []  ) 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a * ('b -> 'b * 'c list)\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let crack a x = x a", "let base = fun x -> x", "List.fold_left crack base [fun x -> x * x] 3"], "bad": ["List.fold_left crack base [fun x -> x * x] 3", "List.fold_left crack base [fun x -> (x * x)] 3"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun y -> y in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a -> x in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a + x in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x + x in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x -> a -> x in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun y -> a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type (int -> int) -> int -> int\n       but an expression was expected of type\n         (int -> int) -> int -> int -> int\n       Type int is not compatible with type int -> int \n", "Error: Syntax error\n", "Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n", "Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun y-> y in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun -> a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun y -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = (a,x) in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun y -> fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b -> 'a * 'b\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'a * 'b\n", "Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let _ = pipe [(fun x -> x ^ \", \" ^ x); (fun x -> x ^ \", \" ^ x ^ \"!\")] \"corn\""], "bad": ["let cat = pipe [(fun x -> x + x )] 3"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["List.append [1;2;3] [4;5;6]"], "bad": ["List.append( [1;2;3], [4;5;6] )", "List.append( [1;2;3], [4;5;6] )"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let a = [1;2;3]", "let b = [4;5;6]"], "bad": ["a = [1;2;3]", "b = [4;5;6]", "List.append a b"], "message": ["Error: Unbound value a\n", "Error: Unbound value b\n", "Error: Unbound value a\n"], "problem": "???"}
{"hw": "hw3", "fix": ["clone 0 5"], "bad": ["List.append clone 0 5 a", "List.append clone( 0 5 ) a"], "message": ["Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let rec padZero l1 l2 = \nlet diffsize = List.length l1 - List.length l2 in\nif diffsize > 0 then\n( l1, List.append (clone 0 diffsize) l2 )\nelse\n( (List.append (clone 0 ((List.length l1) - (List.length l2))) l1),  l2 )"], "bad": ["let rec padZero l1 l2 = \nif List.length l1 > List.length l2 then\n( l1, List.append (clone 0 ((List.length l1) - (List.length l2))), l2 )\nelse if List.length l1 < List.length l2 then\n( (List.append (clone 0 ((List.length l1) - (List.length l2))) l1),  l2 )\nelse\n( l1, l2 )"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type\n         'c list * (int list -> int list) * 'd list\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let rec padZero l1 l2 = \nlet diffsize = List.length l1 - List.length l2 in\nif diffsize > 0 then\n( l1, List.append (clone 0 diffsize) l2 )\nelse\n( List.append (clone 0 ( -1 * diffsize )) l1,  l2 )"], "bad": ["let rec padZero l1 l2 = \nlet diffsize = List.length l1 - List.length l2 in\nif diffsize > 0 then\n( l1, List.append (clone 0 diffsize) l2 )\nelse\n( List.append clone 0 ( -1 * diffsize ) l1,  l2 )"], "message": ["Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1::t1, h2::t2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [0] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1::t1, h2::t2) -> ( [], ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a )\n| _ -> ( [], a )\nin\nlet base = [0] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1::t1, h2::t2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [0] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1::t1, h2::t2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [0] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = ([],[]) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = ([],[]) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type\n         int list -> int list * int list -> 'a list * int list\n       but an expression was expected of type\n         int list -> int list * int list -> int list\n       Type 'a list * int list is not compatible with type int list \n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type int list * int list\n       but an expression was expected of type int list list * int list list\n       Type int is not compatible with type int list \n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type int list\n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type int list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> (removeZero (((h1 + h2) / 10 )::(( h1 + h2) mod 10 ))) :: a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> (removeZero (((h1 + h2) / 10 )::[(( h1 + h2) mod 10 )])) :: a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int list list\n       but an expression was expected of type int list\n       Type int list is not compatible with type int \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (x1, x2) -> match a with\n(h1, h2::t2) -> let sum = x1 + x2 + h2 in\n( ( sum / 10 ) , sum::( sum mod 10 )::t2)\nin\nlet base = (0,[0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (x1, x2) -> match a with\n(_, h2::t2) ->\n( ((x1 + x2 + h2) / 10 ) , (x1 + x2 + h2) / 10 )::(( x1 + x2 + h2 ) mod 10 )::t2", ")\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = match x with\n| (x1, x2) -> match a with\n( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in\n( ( h1 + 1 ) , (mul / 10)::( mul mod 10 )::t2)\n| (_,_) -> (0,[0]) in\nlet base = (1,[0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = match x with\n| (x1, x2) -> match a with\n( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in\n( ( h1 + 1 , (mul / 10)::( mul mod 10 )::t2)\n| (_,_) -> (0,[0]) in\nlet base = (1,[0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = match x with\n| (x1, x2) -> match a with\n( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in\n( ( h1 + 1 , (mul / 10))::( mul mod 10 )::t2)\n| (_,_) -> (0,[0]) in\nlet base = (1,[0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = match x with\n| (x1, x2) -> match a with\n( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in\n( ( h1 + 1 , (mul / 10))::(( mul mod 10 )::t2))\n| (_,_) -> (0,[0]) in\nlet base = (1,[0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Characters 120-121:\n  ( ( h1 + 1 , (mul / 10)::( mul mod 10 )::t2)\n  ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: This expression has type int but an expression was expected of type\n         int * int\n", "Error: This expression has type int but an expression was expected of type\n         int * int\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = \nlet ( pos, total ) = a in\n( pos + 1, mulByDigit (int_of_float (10.0 ** float_of_int pos)) l2 ) in \nlet base = (0,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = \nlet ( pos, total ) = a in\n( pos + 1, mulByDigit ( 10 ** pos) l2 ) in \nlet base = (0,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = \nlet ( pos, total ) = a in\n( pos + 1, mulByDigit ( 10.0 ** pos) l2 ) in \nlet base = (0,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = \nlet ( pos, total ) = a in\n( pos + 1, mulByDigit ( 10.0 ** float_of_int pos) l2 ) in \nlet base = (0,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "bigMul"}
{"hw": "hw1", "fix": ["let rec sumList xs = \nif xs = [] then 0\nelse let h::t = xs in\nh + (sumList t)"], "bad": ["let rec sumList xs = \nif (hd xs) = [] then 0\nelse let h::t = xs in\nh + (sumList t)", "let rec sumList xs = \nif (xs hd xs) = [] then 0\nelse let h::t = xs in\nh + (sumList t)", "let rec sumList xs = \nif (List.hd xs) = [] then 0\nelse let h::t = xs in\nh + (sumList t)"], "message": ["Error: Unbound value hd\n", "Error: Unbound value hd\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif (n mod 2 = 0) & (n > 0) then\nlet rec loop input =\nif input = 0 then []\nelse (loop (input / 10))@[(input mod 10)]\nin (loop n)\nelse []"], "bad": ["let rec digitsOfInt n = \nif (n mod 2 = 0) and (n > 0) then\nlet rec loop input =\nif input = 0 then []\nelse (loop (input / 10))@[(input mod 10)]\nin (loop n)\nelse []"], "message": ["Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nif (n / 10) = 0 then n\nelse additivePersistence (sumList (digits n))"], "bad": ["let rec additivePersistence n = \nif (n / 10) = 0 then n\nelse additivePersistence (sumList digits n)"], "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if ((List.tl lst) = lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false"], "bad": ["let palindrome w = \nif (List.hd w) = (List.tl w) then\nlet b::rest = w in\nlet c @ (x::[]) = rest in\npalindrome x", "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.size lst) < 2 then []\nelse if (List.hd lst) = (List.tl lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.size (palHelper wEx)) = 0 then true\nelse false", "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if (List.hd lst) = (List.tl lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false", "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if (List.hd lst) = (List.tl lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false", "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if (List.tl lst) = (List.hd lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false", "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if (List.tl lst) == (List.hd lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false", "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if ((List.tl lst) = (List.hd lst)) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false"], "message": ["Error: Syntax error\n", "Error: Unbound value List.size\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "problem": "palindrome"}
{"hw": "hw1", "fix": ["let rec sizeLst lst =\nif lst = [] then 0\nelse let h::t = lst in\n(sizeLst t) + 1"], "bad": ["let rec sizeLst lst =\nif lst = [] then 0\nelse let h::t = lst in\n(sizeList t) + 1"], "message": ["Error: Unbound value sizeList\nHint: Did you mean sizeLst?\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif (n mod 2 = 0) && (n > 0) then\nlet rec loop input =\nif input < 10 then [input]\nelse let [y] = (loop (input / 10)) in\ny::[(input mod 10)]\nin loop n\nelse []"], "bad": ["let rec digitsOfInt n = \nif (n mod 2 = 0) && (n > 0) then\nlet rec loop input =\nif input < 10 then input\nelse (loop (input / 10))::[(input mod 10)]\nin (loop n)\nelse []"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = \nlet y = (f b) in match y with\n| (aPrime, _) -> \nif b = aPrime then b\nelse fixpoint (f, aPrime)"], "bad": ["let fixpoint (f,b) = \nif b = (f b) then b\nelse fixpoint (f, f b)", "let fixpoint (f,b) = \nlet y = f b in\nif b = y then b\nelse fixpoint (f, y)", "let fixpoint (f,b) = \nlet y = f b in\nif b = y then b\nelse fixpoint (f, y)", "let fixpoint (f,b) = \nlet y = (f b) in\nif b = y then b\nelse fixpoint (f, y)", "let fixpoint (f,b) = \nlet y = (f b) in match y with\n| aPrime -> \nif b = aPrime then b\nelse fixpoint (f, aPrime)"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\n| Thresh (e1,e2,e3,e4) ->\nif (eval (e1,x,y)) < (eval (e2,x,y))\nthen (eval (e3,x,y))\nelse (eval (e4,x,y))\n| Times (e1,e2) -> (eval (e1,x,y)) *. (eval (e2,x,y))\n| Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) /. 2.0\n| Cosine (e1) -> cos ( 3.142 *. (eval (e1,x,y)) )\n| Sine (e1) -> sin ( 3.142 *. (eval (e1,x,y)) )\n| VarY -> y\n| VarX -> x"], "bad": ["let rec eval (e,x,y) = match e with\n| Thresh (e1,e2,e3,e4) ->\nif (eval (e1,x,y)) < (eval (e2,x,y))\nthen (eval (e3,x,y))\nelse (eval (e4,x,y))\n| Times (e1,e2) -> (eval (e1,x,y)) *. (eval (e2,x,y))\n| Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) / 2.0\n| Cosine (e1) -> cos ( 3.142 *. (eval (e1,x,y)) )\n| Sine (e1) -> sin ( 3.142 *. (eval (e1,x,y)) )\n| VarY -> y\n| VarX -> x"], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen) then seen\nelse (h::seen) \nin\nlet rest' = t \nin \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) = \nlet y = f b in match y with\n| (b', c')   -> \nif c' then wwhile (f,b')\nelse b'", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) = \nlet f' b = (f b, b != f b) in\nwwhile(f',b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)", "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "let rec exprToString e = match e with\n| Thresh (e1,e2,e3,e4)  ->\n\"(\" ^ exprToString e1 ^\n\"<\" ^ exprToString e2 ^\n\"?\" ^ exprToString e3 ^\n\":\" ^ exprToString e4 ^ \")\"\n| Times (e1,e2) ->\nexprToString e1 ^\n\"*\" ^ exprToString e2\n| Average (e1,e2) ->\n\"((\" ^ exprToString e1 ^\n\"+\" ^ exprToString e2 ^ \")/2)\"\n| Cosine (e1) ->\n\"cos(pi*\" ^ exprToString e1 ^ \")\"\n| Sine (e1) ->\n\"sin(pi*\" ^ exprToString e1 ^ \")\"\n| VarY -> \"y\"\n| VarX -> \"x\"", "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "let _ = exprToString sampleExpr1", "let buildX()                       = VarX", "let buildY()                       = VarY", "let buildSine(e)                   = Sine(e)", "let buildCosine(e)                 = Cosine(e)", "let buildAverage(e1,e2)            = Average(e1,e2)", "let buildTimes(e1,e2)              = Times(e1,e2)", "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "let pi = 4.0 *. atan 1.0", "let rec eval (e,x,y) = match e with\n| Thresh (e1,e2,e3,e4) ->\nif (eval (e1,x,y)) < (eval (e2,x,y))\nthen (eval (e3,x,y))\nelse (eval (e4,x,y))\n| Times (e1,e2) -> (eval (e1,x,y)) *. (eval (e2,x,y))\n| Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) /. 2.0\n| Cosine (e1) -> cos ( pi *. (eval (e1,x,y)) )\n| Sine (e1) -> sin ( pi *. (eval (e1,x,y)) )\n| VarY -> y\n| VarX -> x", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr1 ,0.5,0.2)", "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "let _ = eval_fn sampleExpr (0.5,0.2)", "let _ = eval_fn sampleExpr2 (0.5,0.2)", "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )", "let g1 () = failwith \"to be implemented\"", "let g2 () = failwith \"to be implemented\"", "let g3 () = failwith \"to be implemented\"", "let c1 () = failwith \"to be implemented\"", "let c2 () = failwith \"to be implemented\"", "let c3 () = failwith \"to be implemented\"", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type test = unit -> string", "let key = \"\"", "let prefix130 = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")", "let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0", "let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)", "let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))", "let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p", "let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max"], "bad": ["let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )", "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )", "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),build(rand, depth-1), build(rand, depth-1) )", "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )"], "message": ["Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rand (a, b) = if a < b then a else b"], "bad": ["rand(0,4)", "rand"], "message": ["Error: Unbound value rand\nHint: Did you mean land?\n", "Error: Unbound value rand\nHint: Did you mean land?\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen) then seen\nelse (h::seen) \nin\nlet rest' = t \nin \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) = \nlet y = f b in match y with\n| (b', c')   -> \nif c' then wwhile (f,b')\nelse b'", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) = \nlet f' b = (f b, b != f b) in\nwwhile(f',b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)", "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "let rec exprToString e = match e with\n| Thresh (e1,e2,e3,e4)  ->\n\"(\" ^ exprToString e1 ^\n\"<\" ^ exprToString e2 ^\n\"?\" ^ exprToString e3 ^\n\":\" ^ exprToString e4 ^ \")\"\n| Times (e1,e2) ->\nexprToString e1 ^\n\"*\" ^ exprToString e2\n| Average (e1,e2) ->\n\"((\" ^ exprToString e1 ^\n\"+\" ^ exprToString e2 ^ \")/2)\"\n| Cosine (e1) ->\n\"cos(pi*\" ^ exprToString e1 ^ \")\"\n| Sine (e1) ->\n\"sin(pi*\" ^ exprToString e1 ^ \")\"\n| VarY -> \"y\"\n| VarX -> \"x\"", "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "let _ = exprToString sampleExpr1", "let buildX()                       = VarX", "let buildY()                       = VarY", "let buildSine(e)                   = Sine(e)", "let buildCosine(e)                 = Cosine(e)", "let buildAverage(e1,e2)            = Average(e1,e2)", "let buildTimes(e1,e2)              = Times(e1,e2)", "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "let pi = 4.0 *. atan 1.0", "let rec eval (e,x,y) = match e with\n| Thresh (e1,e2,e3,e4) ->\nif (eval (e1,x,y)) < (eval (e2,x,y))\nthen (eval (e3,x,y))\nelse (eval (e4,x,y))\n| Times (e1,e2) -> (eval (e1,x,y)) *. (eval (e2,x,y))\n| Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) /. 2.0\n| Cosine (e1) -> cos ( pi *. (eval (e1,x,y)) )\n| Sine (e1) -> sin ( pi *. (eval (e1,x,y)) )\n| VarY -> y\n| VarX -> x", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr1 ,0.5,0.2)", "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "let _ = eval_fn sampleExpr (0.5,0.2)", "let _ = eval_fn sampleExpr2 (0.5,0.2)", "let rand (a, b) = if a < b then a else b", "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )", "let g1 () = failwith \"to be implemented\"", "let g2 () = failwith \"to be implemented\"", "let g3 () = failwith \"to be implemented\"", "let c1 () = failwith \"to be implemented\"", "let c2 () = failwith \"to be implemented\"", "let c3 () = failwith \"to be implemented\"", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type test = unit -> string", "let key = \"\"", "let prefix130 = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")", "let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0", "let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)", "let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))", "let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p", "let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max"], "bad": ["let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )"], "message": ["Error: This expression has type expr but an expression was expected of type\n         unit\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in build(rand , y-1)"], "bad": ["let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )", "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif (y = 2) then buildSine( build(rand, depth-1) )"], "message": ["Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen) then seen\nelse (h::seen) \nin\nlet rest' = t \nin \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) = \nlet y = f b in match y with\n| (b', c')   -> \nif c' then wwhile (f,b')\nelse b'", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) = \nlet f' b = (f b, b != f b) in\nwwhile(f',b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)", "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "let rec exprToString e = match e with\n| Thresh (e1,e2,e3,e4)  ->\n\"(\" ^ exprToString e1 ^\n\"<\" ^ exprToString e2 ^\n\"?\" ^ exprToString e3 ^\n\":\" ^ exprToString e4 ^ \")\"\n| Times (e1,e2) ->\nexprToString e1 ^\n\"*\" ^ exprToString e2\n| Average (e1,e2) ->\n\"((\" ^ exprToString e1 ^\n\"+\" ^ exprToString e2 ^ \")/2)\"\n| Cosine (e1) ->\n\"cos(pi*\" ^ exprToString e1 ^ \")\"\n| Sine (e1) ->\n\"sin(pi*\" ^ exprToString e1 ^ \")\"\n| VarY -> \"y\"\n| VarX -> \"x\"", "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "let _ = exprToString sampleExpr1", "let buildX()                       = VarX", "let buildY()                       = VarY", "let buildSine(e)                   = Sine(e)", "let buildCosine(e)                 = Cosine(e)", "let buildAverage(e1,e2)            = Average(e1,e2)", "let buildTimes(e1,e2)              = Times(e1,e2)", "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "let pi = 4.0 *. atan 1.0", "let rec eval (e,x,y) = match e with\n| Thresh (e1,e2,e3,e4) ->\nif (eval (e1,x,y)) < (eval (e2,x,y))\nthen (eval (e3,x,y))\nelse (eval (e4,x,y))\n| Times (e1,e2) -> (eval (e1,x,y)) *. (eval (e2,x,y))\n| Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) /. 2.0\n| Cosine (e1) -> cos ( pi *. (eval (e1,x,y)) )\n| Sine (e1) -> sin ( pi *. (eval (e1,x,y)) )\n| VarY -> y\n| VarX -> x", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr1 ,0.5,0.2)", "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "let _ = eval_fn sampleExpr (0.5,0.2)", "let _ = eval_fn sampleExpr2 (0.5,0.2)", "let rand (a, b) = if a < b then a else b", "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildX()", "let g1 () = failwith \"to be implemented\"", "let g2 () = failwith \"to be implemented\"", "let g3 () = failwith \"to be implemented\"", "let c1 () = failwith \"to be implemented\"", "let c2 () = failwith \"to be implemented\"", "let c3 () = failwith \"to be implemented\"", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type test = unit -> string", "let key = \"\"", "let prefix130 = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")", "let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0", "let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)", "let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))", "let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p", "let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max"], "bad": ["let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in build(rand , y-1) \nif (y = 2) then buildSine( build(rand, depth-1) ) \nelse \nif y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )", "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif (y = 2) then buildSine( build(rand, depth-1) ) \nelse \nif y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )", "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildX()"], "message": ["Error: Syntax error\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nbuildX()"], "bad": ["let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildX()", "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y == 2 then buildX()", "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then 5", "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\ny", "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif (y = 2) then y", "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nif (y = 2) then y"], "message": ["Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type int but an expression was expected of type\n         expr\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen) then seen\nelse (h::seen) \nin\nlet rest' = t \nin \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) = \nlet y = f b in match y with\n| (b', c')   -> \nif c' then wwhile (f,b')\nelse b'", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) = \nlet f' b = (f b, b != f b) in\nwwhile(f',b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)", "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "let rec exprToString e = match e with\n| Thresh (e1,e2,e3,e4)  ->\n\"(\" ^ exprToString e1 ^\n\"<\" ^ exprToString e2 ^\n\"?\" ^ exprToString e3 ^\n\":\" ^ exprToString e4 ^ \")\"\n| Times (e1,e2) ->\nexprToString e1 ^\n\"*\" ^ exprToString e2\n| Average (e1,e2) ->\n\"((\" ^ exprToString e1 ^\n\"+\" ^ exprToString e2 ^ \")/2)\"\n| Cosine (e1) ->\n\"cos(pi*\" ^ exprToString e1 ^ \")\"\n| Sine (e1) ->\n\"sin(pi*\" ^ exprToString e1 ^ \")\"\n| VarY -> \"y\"\n| VarX -> \"x\"", "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "let _ = exprToString sampleExpr1", "let buildX()                       = VarX", "let buildY()                       = VarY", "let buildSine(e)                   = Sine(e)", "let buildCosine(e)                 = Cosine(e)", "let buildAverage(e1,e2)            = Average(e1,e2)", "let buildTimes(e1,e2)              = Times(e1,e2)", "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "let pi = 4.0 *. atan 1.0", "let rec eval (e,x,y) = match e with\n| Thresh (e1,e2,e3,e4) ->\nif (eval (e1,x,y)) < (eval (e2,x,y))\nthen (eval (e3,x,y))\nelse (eval (e4,x,y))\n| Times (e1,e2) -> (eval (e1,x,y)) *. (eval (e2,x,y))\n| Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) /. 2.0\n| Cosine (e1) -> cos ( pi *. (eval (e1,x,y)) )\n| Sine (e1) -> sin ( pi *. (eval (e1,x,y)) )\n| VarY -> y\n| VarX -> x", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr1 ,0.5,0.2)", "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "let _ = eval_fn sampleExpr (0.5,0.2)", "let _ = eval_fn sampleExpr2 (0.5,0.2)", "let rand (a, b) = if a < b then a else b", "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nif y = 2 then buildX()"], "bad": ["let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nif y = 2 then buildX()"], "message": ["Error: This expression has type expr but an expression was expected of type\n         unit\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let y = rand(2,6)"], "bad": ["et y = rand(2,6)"], "message": ["Error: Unbound value et\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen) then seen\nelse (h::seen) \nin\nlet rest' = t \nin \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) = \nlet y = f b in match y with\n| (b', c')   -> \nif c' then wwhile (f,b')\nelse b'", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) = \nlet f' b = (f b, b != f b) in\nwwhile(f',b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)", "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "let rec exprToString e = match e with\n| Thresh (e1,e2,e3,e4)  ->\n\"(\" ^ exprToString e1 ^\n\"<\" ^ exprToString e2 ^\n\"?\" ^ exprToString e3 ^\n\":\" ^ exprToString e4 ^ \")\"\n| Times (e1,e2) ->\nexprToString e1 ^\n\"*\" ^ exprToString e2\n| Average (e1,e2) ->\n\"((\" ^ exprToString e1 ^\n\"+\" ^ exprToString e2 ^ \")/2)\"\n| Cosine (e1) ->\n\"cos(pi*\" ^ exprToString e1 ^ \")\"\n| Sine (e1) ->\n\"sin(pi*\" ^ exprToString e1 ^ \")\"\n| VarY -> \"y\"\n| VarX -> \"x\"", "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "let _ = exprToString sampleExpr1", "let buildX()                       = VarX", "let buildY()                       = VarY", "let buildSine(e)                   = Sine(e)", "let buildCosine(e)                 = Cosine(e)", "let buildAverage(e1,e2)            = Average(e1,e2)", "let buildTimes(e1,e2)              = Times(e1,e2)", "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "let pi = 4.0 *. atan 1.0", "let rec eval (e,x,y) = match e with\n| Thresh (e1,e2,e3,e4) ->\nif (eval (e1,x,y)) < (eval (e2,x,y))\nthen (eval (e3,x,y))\nelse (eval (e4,x,y))\n| Times (e1,e2) -> (eval (e1,x,y)) *. (eval (e2,x,y))\n| Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) /. 2.0\n| Cosine (e1) -> cos ( pi *. (eval (e1,x,y)) )\n| Sine (e1) -> sin ( pi *. (eval (e1,x,y)) )\n| VarY -> y\n| VarX -> x", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr1 ,0.5,0.2)", "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "let _ = eval_fn sampleExpr (0.5,0.2)", "let _ = eval_fn sampleExpr2 (0.5,0.2)"], "bad": ["let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nif y = 2 then y"], "message": ["Error: This expression has type int but an expression was expected of type\n         unit\n"], "problem": "build"}
{"hw": "hw2", "fix": ["buildX()"], "bad": ["let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then VarX else VarY\nelse\nlet y = rand(2,6) in\nif y = 2 then y", "let rec build (rand, depth) = \nif depth = 0 then\nif rand (0,1) = 0 then VarX else VarY\nelse\nlet y = rand (2,6) in\nif y = 2 then y", "let rec build (rand, depth) = \nif depth = 0 then\nif rand (0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand (2,6) in\nif y = 2 then y"], "message": ["Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in\nbuildX()"], "bad": ["if depth = 0 then\nif rand (0,1) = 0 then buildX() else buildY()", "let rec build (rand, depth) = \nif depth = 0 then\nif rand (0,1) = 0 then buildX() else buildY()", "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in\nif y = 2 then y", "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()"], "message": ["Error: Unbound value depth\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in\nbuildX()"], "bad": ["let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()"], "message": ["Error: This expression has type expr but an expression was expected of type\n         unit\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in match y with\n| 2 -> buildSine( build(rand, depth-1) ) \n| 3 -> buildCosine( build(rand, depth-1) )\n| 4 -> buildAverage( build(rand, depth-1), build(rand, depth-1) )\n| 5 -> buildTimes( build(rand, depth-1), build(rand, depth-1) )\n| 6 -> buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )"], "bad": ["let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in match y with\n| 2 -> buildSine( build(rand, depth-1) ) \n| 3 -> buildCosine( build(rand, depth-1) )\n| 4 -> buildAverage( build(rand, depth-1), build(rand, depth-1) )\n| 5 -> buildTimes( build(rand, depth-1), build(rand, depth-1) )\n| 6 -> buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )  *"], "message": ["Error: Syntax error\n"], "problem": "build"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = a (x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a (x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> (('a -> 'b) -> 'a) -> 'b\n       but an expression was expected of type\n         ('a -> 'b) -> (('a -> 'b) -> 'a) -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a x in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = h::t in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x =  in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l"], "message": ["Error: Syntax error\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let _ = sepConcat \"X\" [\"hello\"]"], "bad": ["let _ = sepConcat \"X\" [\"hello\"]\n\nstring_of_int 5", "let _ = sepConcat \"X\" [\"hello\"]\n\nstring_of_int 5"], "message": ["Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let _ = sepConcat \"X\" [\"hello\"]", "let _ = string_of_int 5"], "bad": ["let _ = sepConcat \"X\" [\"hello\"]\n\nstring_of_int [1]"], "message": ["Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let stringOfList f l = sepConcat \"; \" (List.append (\"[\"::List.map f l) [\"]\"])"], "bad": ["let stringOfList f l = sepConcat \"; \" [\"[\"; List.map f l;\"]\"]", "let stringOfList f l = sepConcat \"; \" [[\"[\"]; List.map f l;[\"]\"]]", "let stringOfList f l = sepConcat \"; \" (List.append (\"[\"::List.map f l) \"]\")"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: This expression has type string but an expression was expected of type\n         string list\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\""], "bad": ["let stringOfList f l = \"[\" ^ (sepConcat \"; \" List.map f l) ^ \"]\""], "message": ["Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([],r) , acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> (([],0), r::acc)\n| ((h::t,r) , acc) -> \nlet sum = h+x+r in\n((t,sum/10), (sum mod 10)::acc)\nin\nlet (pad1, pad2) = padZero l1 l2 in\nlet base = ((List.rev pad1,0) , []) in\nlet args = (List.rev pad2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1+h2+r) in\nhelper ((sum%10)::acc2) (sum/10) t1 t2)\nin\n(0, helper [] 0 padded1 padded2)\nin\nlet base = [] in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1+h2+r) in\nhelper ((sum % 10)::acc2) (sum/10) t1 t2)\nin\n(0, helper [] 0 padded1 padded2)\nin\nlet base = [] in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1 + h2 + r) in\nhelper ((sum % 10)::acc2) (sum/10) t1 t2)\nin\n(0, helper [] 0 padded1 padded2)\nin\nlet base = [] in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1 + h2 + r) in\nhelper ((sum mod 10)::acc2) (sum/10) t1 t2)\nin\n(0, helper [] 0 padded1 padded2)\nin\nlet base = [] in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1 + h2 + r) in\nhelper ((sum mod 10)::acc2) (sum/10) t1 t2)\nin\n(0, helper [] 0 padded1 padded2)\nin\nlet base = (0 , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1 + h2 + r) in\nhelper ((sum mod 10)::acc2) (sum/10) t1 t2)\nin\n(0, helper [] 0 padded1 padded2)\nin\nlet base = (0 , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1 + h2 + r) in\nhelper ((sum mod 10)::acc2) (sum/10) t1 t2)\nin\n(0, helper [] 0 padded1 padded2)\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1 + h2 + r) in\nhelper ((sum mod 10)::acc2) (sum/10) t1 t2)\nin\n([], helper [] 0 padded1 padded2)\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1 + h2 + r) in\nhelper ((sum mod 10)::acc2) (sum/10) t1 t2)\nin\n([], helper [] 0 (List.rev padded1) (List.rev padded2))\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet g = \n(fun (c,d) -> (List.rev c; List.rev d) (padZero ((fun (a,b) -> b) a) x) in\nlet rec helper acc r (lst1, lst2) = \nif lst1 = [] then acc\nelse\nlet h1::t1 = lst1 in\nlet h2::t2 = lst2 in\nlet sum = h1+h2+r in\nhelper (sum mod 10)::acc (sum/10) (t1, t2)\nin\nhelper [] 0 g\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet g = \n(fun (c,d) -> (List.rev c; List.rev d)) (padZero ((fun (a,b) -> b) a) x) in\nlet rec helper acc r (lst1, lst2) = \nif lst1 = [] then acc\nelse\nlet h1::t1 = lst1 in\nlet h2::t2 = lst2 in\nlet sum = h1+h2+r in\nhelper (sum mod 10)::acc (sum/10) (t1, t2)\nin\nhelper [] 0 g\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet g = \n(fun (c,d) -> (List.rev c; List.rev d)) (padZero ((fun (a,b) -> b) a) x) in\nlet rec helper acc r (lst1, lst2) = \nif lst1 = [] then acc\nelse\nlet h1::t1 = lst1 in\nlet h2::t2 = lst2 in\nlet sum = h1+h2+r in\nhelper ((sum mod 10)::acc) (sum/10) (t1, t2)\nin\nhelper [] 0 g\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet g = \n(fun (c,d) -> (List.rev c, List.rev d)) (padZero ((fun (a,b) -> b) a) x) in\nlet rec helper acc r (lst1, lst2) = \nif lst1 = [] then acc\nelse\nlet h1::t1 = lst1 in\nlet h2::t2 = lst2 in\nlet sum = h1+h2+r in\nhelper ((sum mod 10)::acc) (sum/10) (t1, t2)\nin\nhelper [] 0 g\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet g = \n(fun (c,d) -> (List.rev c, List.rev d)) (padZero ((fun (a,b) -> b) a) x) in\nlet rec helper acc r (lst1, lst2) = \nif lst1 = [] then acc\nelse\nlet h1::t1 = lst1 in\nlet h2::t2 = lst2 in\nlet sum = h1+h2+r in\nhelper ((sum mod 10)::acc) (sum/10) (t1, t2)\nin\n([], helper [] 0 g)\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet g = \n(fun (c,d) -> (List.rev c, List.rev d)) (padZero ((fun (q,r) -> r) a) x) in\nlet rec helper acc r (lst1, lst2) = \nif lst1 = [] then acc\nelse\nlet h1::t1 = lst1 in\nlet h2::t2 = lst2 in\nlet sum = h1+h2+r in\nhelper ((sum mod 10)::acc) (sum/10) (t1, t2)\nin\n([], helper [] 0 g)\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([],r) , acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> (([],0), r::acc)\n| ((h::t,r) , acc) -> \nlet sum = h+x+r in\n((t,sum/10), (sum mod 10)::acc)\nin\nlet (pad1, pad2) = padZero l1 l2 in\nlet base = (List.rev pad1 , []) in\nlet args = (List.rev pad2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Unbound value %\n", "Error: Unbound value %\n", "Error: Unbound value %\n", "Error: This expression has type 'a list\n       but an expression was expected of type int * int list\n", "Error: This expression has type int list * int list\n       but an expression was expected of type int * int\n       Type int list is not compatible with type int \n", "Error: This expression has type int list * int list\n       but an expression was expected of type int * int\n       Type int list is not compatible with type int \n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type int * int list\n       Type 'a list is not compatible with type int \n", "Error: This expression has type int list * int list\n       but an expression was expected of type int * int\n       Type int list is not compatible with type int \n", "Error: This expression has type int list * int list\n       but an expression was expected of type int * int\n       Type int list is not compatible with type int \n", "Characters 62-63:\n  (fun (c,d) -> (List.rev c; List.rev d) (padZero ((fun (a,b) -> b) a) x) in\n  ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int list\n       but an expression was expected of type int list * int list\n", "Error: This expression has type 'a * int list -> int list -> int list\n       but an expression was expected of type\n         'a * int list -> int list -> 'a * int list\n       Type int list is not compatible with type 'a * int list \n", "Error: This expression has type int list * int list\n       but an expression was expected of type int * int\n       Type int list is not compatible with type int \n", "Error: This expression has type int list * int list\n       but an expression was expected of type int * int\n       Type int list is not compatible with type int \n", "Error: This expression has type int list * 'a list\n       but an expression was expected of type (int list * int) * int list\n       Type int list is not compatible with type int list * int \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nif (l1 = [] || l2 = []) then []\nelse\nlet f a x = match a with\n| ((lst,decPlace), acc) ->\n((lst,decPlace+1), bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in\nlet base = ((l1,0), []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nif (l1 = [] || l2 = []) then []\nelse\nlet f a x = match a with\n| ((lst,decPlace), acc) ->\n((lst,decPlace+1) bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace)) in\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nif (l1 = [] || l2 = []) then []\nelse\nlet f a x = match a with\n| ((lst,decPlace), acc) ->\n((lst,decPlace+1) bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nif (l1 = [] || l2 = []) then []\nelse\nlet f a x = match a with\n| ((lst,decPlace), acc) ->\n((lst,decPlace+1) bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in\nlet base = ((l1,0), []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Characters 109-110:\n  ((lst,decPlace+1) bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace)) in\n  ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: This expression has type 'a * int\n       This is not a function; it cannot be applied.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a * int\n       This is not a function; it cannot be applied.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * int\n       This is not a function; it cannot be applied.\n"], "problem": "bigMul"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt (n/10)"], "bad": ["let rec digitsOfInt n = if n <= 0 -> []\nelse n mod 10 :: digitofInt n/10", "let rec digitsOfInt n = if n <= 0 then -> []\nelse n mod 10 :: digitofInt n/10", "let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsofInt n/10s", "let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt n/10s", "let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt n/10"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value digitsofInt\nHint: Did you mean digitsOfInt?\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = if n <= 0 then [] else n mod 10 @ digitsOfInt (n/10)", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663"], "bad": ["let rec digitsOfInt n = if n <= 0 then [] else digitsOfInt (n/10):: n mod 10"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let digitsOfInt n = \nlet rec digitsHelper n l = if n = 0 then l else digitsHelper (n/10) (n mod 10::l)\nin\nif n<=0 then [] else digitsHelper n []"], "bad": ["let rec digitsOfInt n = if n <= 0 then [] else digitsHelper n []", "let rec digitsHelper n l = if n = 0 then l else (n/10) n mod 10::l", "let digitsOfInt n = \nlet rec digitsHelper n l = if n = 0 then l else (n/10) n mod 10::l\nin\nif n<=0 then [] else digitsHelper n []", "let digitsOfInt n = \nlet rec digitsHelper n l = if n = 0 then l else (n/10) (n mod 10::l)\nin\nif n<=0 then [] else digitsHelper n []"], "message": ["Error: Unbound value digitsHelper\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitalRoot n = \nlet rec digHelper n = if n < 10 then n else digHelper (sumList (digitsOfInt n))\nin\ndigHelper n"], "bad": ["let rec digitalRoot n = \nlet rec digHelper n = if n < 10 then n else digHelper (sumList n)\nin\ndigHelper n", "let _ = digitalRoot 9876"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: Unbound value digitalRoot\n"], "problem": "digitalRoot"}
{"hw": "hw1", "fix": ["let rec listReverse l = \nlet rec listHelper l l2 = match l with\n| [] -> l2 \n| h::t -> listHelper t (h::l2)\nin\nlistHelper l []"], "bad": ["let rec listReverse l = \nlet rec listHelper l l2 = match l with\n| [] -> l2 \n| h::t -> listHelper t h::l2\nin\nlistHelper l []", "let _ = listReverse [1; 2; 3; 4]", "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: Unbound value listReverse\n", "Error: Unbound value listReverse\n"], "problem": "listReverse"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> if fst h = k then snd h else assoc (d, k, t)"], "bad": ["let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then true else assoc d k t", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then true else assoc (d k t)", "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d k t)", "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i) as h::t -> if s = k then i else assoc (d k t)", "let rec assoc (d,k,l) = match l with\n| [] -> d\n| ((s,i) as h)::t -> if s = k then i else assoc (d k t)", "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> if fst h = k then snd h else assoc (d k t)"], "message": ["Error: This function has type bool * 'a * ('a * 'b) list -> bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value assoc\n", "Error: Unbound value assoc\n", "Error: This expression has type bool\n       This is not a function; it cannot be applied.\n", "Error: This expression has type ('a * ('a -> 'b -> 'c)) list\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside ('a * ('a -> 'b -> 'c)) list\n", "Error: This expression has type ('a * ('a -> 'b -> 'c)) list\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside ('a * ('a -> 'b -> 'c)) list\n", "Error: This expression has type ('a * ('a -> 'b -> 'c)) list\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside ('a * ('a -> 'b -> 'c)) list\n", "Error: This expression has type ('a * ('a -> 'b -> 'c)) list\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside ('a * ('a -> 'b -> 'c)) list\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = if snd (f b) then wwhile (f, fst (f b)) else fst (f b)"], "bad": ["let rec wwhile (f,b) = let snd (f b) then wwhile f fst (f b) else fst (f b)", "let rec wwhile (f,b) = let snd f b then wwhile f fst f b else fst f b", "let rec wwhile (f,b) = if snd f b then wwhile f fst f b else fst f b"], "message": ["Characters 31-32:\n  let rec wwhile (f,b) = let snd (f b) then wwhile f fst (f b) else fst (f b);;\n                                 ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Error: This expression has type 'a * ('b -> bool)\n       but an expression was expected of type ('a * ('b -> bool)) * 'b\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = let fx b' = (f b', f b' = b') in\nwwhile(fx,b)"], "bad": ["let fixpoint (f,b) = wwhile ((if f b = b then (true,b) else (false,b)),b)", "let fixpoint (f,b) = wwhile (((f b) = b, (f b)),b)", "let fixpoint (f,b) = wwhile (f b, f b = b,b)", "let fixpoint (f,b) = \nwwhile(if f b = b then (f b, true) else (f b, false),b)", "let fixpoint (f,b) = \nwwhile((if f b = b then (f b, true) else (f b, false)),b)", "let fixpoint (f,b) = \nwwhile(let fx = if f b = b then (b,true) else (b,false),b)", "let fixpoint (f,b) = \nwwhile((let fx = if f b = b then (b,true) else (b,false)),b)"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type ('d -> 'd * bool) * 'd\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type bool -> bool * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)"], "bad": ["let fixpoint (f,b) = let fx b= (f b, f b = b) in\nwwhile(fx,b)", ")", "let _ = fixpoint (collatz, 3)"], "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Syntax error\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)"], "bad": ["let fixpoint (f,b) = \nlet fx b = (f b, not (f b = b)) in\nwwhile(fx,b)"], "message": ["Error: This function has type bool -> bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let fixpoint (f,b) = \nwwhile(fun x = f x , not (f x = x),b)", "let fixpoint (f,b) = \nwwhile(fun x = f x , not (f x = x),b)", "let fixpoint (f,b) = \nwwhile(fun x -> f x , not (f x = x),b)", "let fixpoint (f,b) = \nwwhile(fun x -> (f x , not (f x = x)),b)", "let fixpoint (f,b) = \nwwhile((fun x -> f x , not (f x = x)),b)"], "message": ["Error: Unbound value fixpoint\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let fixpoint (f,b) = \nwwhile(fun x -> f x  not (f x = x),b)", "let fixpoint (f,b) = \nwwhile((fun x -> f x  not (f x = x)),b)", "let fixpoint (f,b) = \nwwhile((fun x -> f x , not (f x = x)),b)"], "message": ["Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "let _ = exprToString sampleExpr1"], "bad": ["let rec exprToString e = match e with \n| VarX -> \"VarX\"\n| VarY -> \"VarY\"\n| Sine e1 -> \"Sine(\"^ exprToString e1 ^ \")\"\n| Cosine e1 -> \"Cosine(\" ^ exprToString e1 ^ \")\"\n| Average e1 e11 -> \"Average(\" ^ exprToString e1 ^ \",\" ^ exprToString e2 ^ \")\"\n| Times e1 e2 -> \"Times(\" ^ exprToString e1 ^ \",\" ^ exprToString e2 ^ \")\"\n| Thresh e1 e2 e3 e4 -> \"Thresh(\" ^  exprToString e1 ^ \",\" ^ exprToString e2 ^\",\" ^ exprToString e3 ^ \",\" ^ exprToString e4 ^ \")\"", "let rec exprToString e = match e with \n| VarX -> \"VarX\"\n| VarY -> \"VarY\"\n| Sine e1 -> \"Sine(\"^ exprToString e1 ^ \")\"\n| Cosine e1 -> \"Cosine(\" ^ exprToString e1 ^ \")\"\n| Average (e1,e2) -> \"Average(\" ^ exprToString e1 ^ \",\" ^ exprToString e2 ^ \")\"\n| Times e1 e2 -> \"Times(\" ^ exprToString e1 ^ \",\" ^ exprToString e2 ^ \")\"\n| Thresh e1 e2 e3 e4 -> \"Thresh(\" ^  exprToString e1 ^ \",\" ^ exprToString e2 ^\",\" ^ exprToString e3 ^ \",\" ^ exprToString e4 ^ \")\"", "let rec exprToString e = match e with \n| VarX -> \"VarX\"\n| VarY -> \"VarY\"\n| Sine e1 -> \"Sine(\"^ exprToString e1 ^ \")\"\n| Cosine e1 -> \"Cosine(\" ^ exprToString e1 ^ \")\"\n| Average (e1,e2) -> \"Average(\" ^ exprToString e1 ^ \",\" ^ exprToString e2 ^ \")\"\n| Times e1 e2 -> \"Times(\" ^ exprToString e1 ^ \",\" ^ exprToString e2 ^ \")\"\n| Thresh e1 e2 e3 e4 -> \"Thresh(\" ^  exprToString e1 ^ \",\" ^ exprToString e2 ^\",\" ^ exprToString e3 ^ \",\" ^ exprToString e4 ^ \")\"", "let rec exprToString e = match e with \n| VarX -> \"VarX\"\n| VarY -> \"VarY\"\n| Sine e1 -> \"Sine(\"^ exprToString e1 ^ \")\"\n| Cosine e1 -> \"Cosine(\" ^ exprToString e1 ^ \")\"\n| Average (e1,e2) -> \"Average(\" ^ exprToString e1 ^ \",\" ^ exprToString e2 ^ \")\"\n| Times (e1,e2) -> \"Times(\" ^ exprToString e1 ^ \",\" ^ exprToString e2 ^ \")\"\n| Thresh (e1,e2,e3,e4) -> \"Thresh(\" ^  exprToString e1 ^ \",\" ^ exprToString e2 ^\",\" ^ exprToString e3 ^ \",\" ^ exprToString e4 ^ \")\""], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi .* exprToString e1)\n| Cosine e1 -> cos(pi .* exprToString e1)\n| Average (e1,e2) -> ((exprToString e1 .+ exprToString e2 )./2)\n| Times (e1,e2) -> exprToString e1 .* exprToString e2 \n| Thresh (e1,e2,e3,e4) -> (exprToString e1 < exprToString e2 ? exprToString e3 : exprToString e4)", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. exprToString e1)\n| Cosine e1 -> cos(pi *. exprToString e1)\n| Average (e1,e2) -> ((exprToString e1 +. exprToString e2 )/.2)\n| Times (e1,e2) -> exprToString e1 *. exprToString e2 \n| Thresh (e1,e2,e3,e4) -> (exprToString e1 < exprToString e2 ? exprToString e3 : exprToString e4)", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y) : eval (e4,x,y))", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y) : eval (e4,x,y))", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y) : eval (e4,x,y))", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y):eval (e4,x,y))", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y) : eval(e4,x,y))", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? (eval (e3,x,y)) : eval(e4,x,y))", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? (eval (e3,x,y)) : (eval(e4,x,y)))", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> ((eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y)))", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))", "eval"], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: Syntax error: operator expected.\n", "Error: This expression has type string but an expression was expected of type\n         float\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr,0.5,0.2)"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))"], "message": ["Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))"], "bad": ["let rec build (rand, depth) =\nlet expChooser (r,d) =  match r with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,d-1))\n| 3\n-> buildCosine(build (rand,d-1))\n| 4\n-> buildAverage(build (rand,d-1), build (rand,d-1))\n| 5\n-> buildTimes(build (rand,d-1), build (rand,d-1))\n| 6\n-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))\nin  if (depth < 1) then expChooser rand (0,2) else expChooser rand (2,7)", "let rec build (rand, depth) =\nlet expChooser (r,d) =  match r with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,d-1))\n| 3\n-> buildCosine(build (rand,d-1))\n| 4\n-> buildAverage(build (rand,d-1), build (rand,d-1))\n| 5\n-> buildTimes(build (rand,d-1), build (rand,d-1))\n| 6\n-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))\nin  if (depth < 1) then expChooser rand (0,2) depth else expChooser rand (2,7) depth", "let rec build (rand, depth) =\nlet expChooser (r,d) =  match r with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,d-1))\n| 3\n-> buildCosine(build (rand,d-1))\n| 4\n-> buildAverage(build (rand,d-1), build (rand,d-1))\n| 5\n-> buildTimes(build (rand,d-1), build (rand,d-1))\n| 6\n-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))\nin  if (depth < 1) then (expChooser (rand (0,2), depth) else (expChooser (rand (2,7)), depth)", "let rec build (rand, depth) =\nlet expChooser (r,d) =  match r with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,d-1))\n| 3\n-> buildCosine(build (rand,d-1))\n| 4\n-> buildAverage(build (rand,d-1), build (rand,d-1))\n| 5\n-> buildTimes(build (rand,d-1), build (rand,d-1))\n| 6\n-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))\nin  if (depth < 1) then (expChooser (rand (0,2)), depth) else (expChooser (rand (2,7)), depth)", "let rec build (rand, depth) =\nlet expChooser (r,d) =  match r with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,d-1))\n| 3\n-> buildCosine(build (rand,d-1))\n| 4\n-> buildAverage(build (rand,d-1), build (rand,d-1))\n| 5\n-> buildTimes(build (rand,d-1), build (rand,d-1))\n| 6\n-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))\nin  if (depth < 1) then (expChooser (rand (0,2)), depth) else (expChooser (rand (2,7)), depth)", "let rec build (rand, depth) = let n = \nif (depth < 1) then rand (0,2) else rand(2,7)", "match n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "let rec build (rand, depth) = let n = \nif (depth < 1) then rand (0,2) else rand(2,7)\nmatch n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "let rec build (rand, depth) = let n = \nmatch n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))\nin if (depth < 1) then rand (0,2) else rand(2,7)", "let rec build (rand, depth) = \nlet n = \nmatch n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))\nin n = if (depth < 1) then rand (0,2) else rand(2,7)", "let rec build (rand, depth) = \nlet n = if (depth < 1) then rand (0,2) else rand(2,7)\nmatch n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "let rec build (rand, depth) = \nlet n = if (depth < 1) then match rand(0,2) with else match rand(2,7) with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "let rec build (rand, depth) = \nlet n = if (depth < 1) then (match rand(0,2) with) else (match rand(2,7) with)\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "let rec build (rand, depth) = \nif (depth < 1) then (match rand(0,2) with) else (match rand(2,7) with)\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "let rec build (rand, depth) = \nlet num = if (depth < 1) rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))"], "message": ["Error: Syntax error\n", "Error: This function has type int * int -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int * int -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Characters 397-398:\n  in  if (depth < 1) then (expChooser (rand (0,2), depth) else (expChooser (rand (2,7)), depth);;\n                          ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "Error: Syntax error\n", "Error: Unbound value n\n", "Error: Syntax error\n", "Error: Unbound value n\n", "Error: Unbound value n\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))\n| Power (e1,e2) -> eval (e1,x,y) ** abs_float (eval (e2,x,y))\n| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))\n| Power (e1,e2) -> eval (e1,x,y) ** abs_float eval (e2,x,y)\n| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))\n| Power (e1,e2) -> eval (e1,x,y) ** abs_float (eval (e2,x,y))\n| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)"], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This function has type float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "eval"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base =  1 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a + f x in\nlet base = 0 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a + f x in\nlet base = x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a + x a in\nlet base = x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base =  _ in\nList.fold_left f base fs"], "message": ["Error: Unbound value f\n", "Error: Unbound value f\n", "Error: Unbound value x\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base =  (fun x -> x) in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "message": ["Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in \nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a = x a in\nlet base = fun x -> x in \nList.fold_left f base fs", "let pipe fs = \nlet f a x = a = x a in\nlet base = 0 in \nList.fold_left f base fs", "let pipe fs = \nlet f a x = a = f (a y) in\nlet base = fun x -> x in \nList.fold_left f base fs", "let pipe fs = \nlet f a x = a = x (a y) in\nlet base = fun x -> x in \nList.fold_left f base fs", "let pipe fs = \nlet f a x = a = x a in\nlet base = fun x -> x in \nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type bool\n", "Error: This expression has type int but an expression was expected of type\n         bool\n", "Error: Unbound value f\n", "Error: Unbound value y\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type bool\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =  x a in \nlet base = fun x -> x in \nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let pipe fs = \nlet f a x = a = fun x a -> x a in \nlet base = fun x -> x in \nList.fold_left f base fs", "let pipe fs = \nlet f a x = a = fun x a t-> x (a t) in \nlet base = fun x -> x in \nList.fold_left f base fs", "let pipe fs = \nlet f a x = a = (fun x y -> x (a y)) in \nlet base = fun x -> x in \nList.fold_left f base fs", "let pipe fs = \nlet f a x = a = fun y ->  x (a y) in \nlet base = fun x -> x in \nList.fold_left f base fs", "let pipe fs = \nlet f a x = let a = fun y ->  x (a y) in \nlet base = fun x -> x in \nList.fold_left f base fs", "let pipe fs = \nlet f a x =  x a", "let base = fun x -> x in \nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type (('a -> 'b) -> 'a -> 'b) -> 'c -> bool\n       but an expression was expected of type\n         (('a -> 'b) -> 'a -> 'b) -> 'c -> ('a -> 'b) -> 'a -> 'b\n       Type bool is not compatible with type ('a -> 'b) -> 'a -> 'b \n", "Error: This expression has type\n         (('a -> 'b) -> ('c -> 'a) -> 'c -> 'b) -> 'd -> bool\n       but an expression was expected of type\n         (('a -> 'b) -> ('c -> 'a) -> 'c -> 'b) ->\n         'd -> ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b\n       Type bool is not compatible with type\n         ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b \n", "Error: This expression has type ('a -> 'b) -> 'c\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b) -> 'c\n", "Error: This expression has type ('a -> 'b) -> ('b -> 'b) -> bool\n       but an expression was expected of type\n         ('a -> 'b) -> ('b -> 'b) -> 'a -> 'b\n       Type bool is not compatible with type 'a -> 'b \n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value f\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =  fun y -> x (a y) in \nlet base = fun x -> x in \nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let pipe fs = \nlet f a x =  let a = x a in \nlet base = fun x -> x in \nList.fold_left f base fs", "let pipe fs = \nlet f a x =  a x in \nlet base = fun x -> x in \nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: Syntax error\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let stringOfList f l = \"[\" ^ (sepConcat \";\" (List.map f l)) ^ \"]\""], "bad": ["let stringOfList f l = \"[\" ^ List.map sepConcat \";\" l ^ \"]\"", "let stringOfList f l = \"[\" ^ sepConcat \";\" List.map f l ^ \"]\""], "message": ["Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let rec clone x n = \nlet rec cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper(x,n-1,x::acc) in\ncloneHelper(x,n,[])"], "bad": ["let rec clone x n = \nlet rec cloneHelper x n acc = if n < 0 then acc else cloneHelper x n-1 x::acc in\ncloneHelper x n []", "let rec clone x n = \nlet rec cloneHelper x n acc = if n < 0 then acc else cloneHelper (x,n-1,x::acc) in\ncloneHelper x n []", "let rec clone x n = \nlet rec cloneHelper x n acc = if n < 0 then acc else cloneHelper (x,n-1,x::acc) in\ncloneHelper x n []", "let rec clone x n = \nlet rec cloneHelper x n acc = if n < 0 then acc else cloneHelper (x,n-1,x::acc) in\ncloneHelper (x ,n,[])", "let rec clone x n = \nlet rec cloneHelper x n acc = if n < 0 then acc else cloneHelper (x,n-1,x::acc) in\ncloneHelper (x,n,[])", "let rec clone x n = if n < 0 then [] else clone x n-1", "let rec clone x n = if n < 0 then [] else clone (x,n-1)", "let rec clone x n = \nlet cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper(x,n-1,x::acc) in\ncloneHelper(x,n,[])"], "message": ["Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b * 'c\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b * 'c\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b * 'c\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b * 'c\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b\n", "Error: Unbound value cloneHelper\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1 else l2"], "bad": ["let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1\nelse if (diff > 0) then List.append (clone 0 diff) l2", "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append ((clone 0 (abs diff)) l1)\nelse if (diff > 0) then List.append ((clone 0 diff) l2)", "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append ((clone 0 (abs diff)),l1)\nelse if (diff > 0) then List.append ((clone 0 diff),l2)", "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then (List.append ((clone 0 (abs diff)),l1),l2)\nelse if (diff > 0) then (l1,List.append ((clone 0 diff),l2))", "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then (List.combine ((clone 0 (abs diff)),l1),l2)\nelse if (diff > 0) then (l1,List.combine ((clone 0 diff),l2))", "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1\nelse if (diff > 0) then List.append (clone 0 diff) l2", "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1\nelse if (diff > 0) then List.append (clone 0 diff) l2", "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1"], "message": ["Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1 else if (diff > 0) then l1 else l1"], "bad": ["let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1 else if l2 else l1"], "message": ["Error: Syntax error\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) mod 10 in\n(sum/10, sum mod 10) in\nlet base = (0,0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres::[] \nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + (fst x + snd x) mod 10 in\nlet base = 0 in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) mod 10 in\n(sum/10, sum mod 10) in\nlet base = (0,0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nList.rev res\nin \nremoveZero (add (padZero 0::l1 0::l2))", "let _ = bigAdd [5;1] [5;4]", "let _ = bigAdd [9;9] [1;0;0;2]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.reverse l1) (List.reverse l2) in\nlet (_, res) = List.fold_left f base args in\nList.reverse res\nin \nremoveZero (add (padZero 0::l1 0::l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nList.reverse res\nin \nremoveZero (add (padZero 0::l1 0::l2))"], "message": ["Error: Unbound value List.reverse\n", "Error: Unbound value List.reverse\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nList.rev res\nin \nremoveZero (add (padZero (0::l1) (0::l2)))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nList.rev res\nin \nremoveZero (add (padZero (0::l1) (0::l2))\n\nlet _ = bigAdd [5;1] [5;4]"], "message": ["Characters 271-272:\n  removeZero (add (padZero (0::l1) (0::l2))\n             ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero (0::l1) (0::l2)))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero (0:l1) (0:l2)))"], "message": ["Error: Unbound type constructor l1\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = (fst a + 1, bigAdd (snd a) (List.append l1 (clone 0 (fst a)))) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = (fst a + 1, bigAdd snd a (List.append l1 (clone 0 (fst a)))) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This function has type int list -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type int list -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "bigMul"}
{"hw": "hw1", "fix": ["51/10"], "bad": ["51 mod 10\n51/10"], "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n < 1 then []\nelse n mod 10 :: digitsOfInt(n/10)"], "bad": ["let rec digitsOfInt n = match n with\n| n < 1 -> []\n| n mod 10 :: digitsofInt(n/10)", "let rec digitsOfInt n = match n with\nif n < 1 then []\nelse n mod 10 :: digitsofInt(n/10)", "let rec digitsOfInt n = \nif n < 1 then []\nelse n mod 10 :: digitsofInt(n/10)"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value digitsofInt\nHint: Did you mean digitsOfInt?\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsOfInt(n)))"], "bad": ["let rec additivePersistence n = \nlet count = 0 in\nif digitsOfInt(n).length = 1 then \ncount\nelse\nadditivePersistence(addList(digitsofInt(n)))", "let rec additivePersistence n = \nlet count = 0 in\nif List.length digitsOfInt(n) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsofInt(n)))", "let rec additivePersistence n = \nlet count = 0 in\nif (List.length digitsOfInt(n)) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsofInt(n)))", "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsofInt(n)))", "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsofInt(n)))"], "message": ["Error: Unbound record field length\n", "Error: This function has type 'a list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value digitsofInt\nHint: Did you mean digitsOfInt?\n", "Error: Unbound value digitsofInt\nHint: Did you mean digitsOfInt?\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["addList[1;2;3;4]", "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount + 1\nelse \nlet count = count + 1\nadditivePersistence(addList(digitsOfInt(n)))"], "bad": ["let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\ninc count\nadditivePersistence(addList(digitsOfInt(n)))", "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nincr count\nadditivePersistence(addList(digitsOfInt(n)))", "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nincr(count)\nadditivePersistence(addList(digitsOfInt(n)))", "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse (\nincr(count)\nadditivePersistence(addList(digitsOfInt(n)))\n)", "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse (\nincr(count)", "additivePersistence(addList(digitsOfInt(n)))\n)", "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse \nincr(count)", "additivePersistence(addList(digitsOfInt(n)))", "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse \ncount = count + 1\nadditivePersistence(addList(digitsOfInt(n)))", "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse \nlet count = count + 1\nadditivePersistence(addList(digitsOfInt(n)))"], "message": ["Error: Unbound value inc\nHint: Did you mean incr?\n", "Error: This function has type int ref -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int ref -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int ref -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Characters 104-105:\n  else (\n       ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         int ref\n", "Error: Unbound value n\nError: Unbound value digitsOfInt\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value n\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec addList (f,xs) = match xs with\n| [] -> 0\n| h::t -> h+ addList(f,t)", "addList (digitsOfInt,5)"], "bad": ["addList digitsOfInt 5"], "message": ["Error: This function has type 'a * int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec addList xs = match xs with\n| [] -> 0\n| h::t -> h + addList t"], "bad": ["let rec addHelp(count, n) = \nif n < 10 then\ncount + 1\nelse\naddHelp(count+1, addNum(n))"], "message": ["Error: Unbound value addNum\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec addNum n = \nif n < 10 then n\nelse \naddList(digitsOfInt(n))"], "bad": ["let rec addNum = match n with\nif n < 10 then n\nelse \naddList(digitsOfInt(n))", "let rec addNum = \nif n < 10 then n\nelse \naddList(digitsOfInt(n))"], "message": ["Error: Syntax error\n", "Error: Unbound value n\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec addList xs = match xs with\n| [] -> 0\n| h::t -> h + addList t", "let rec addNum n = \nif n < 10 then n\nelse \naddList(digitsOfInt(n))", "let rec additivePersistence n = \naddHelp(0, n)", "let rec addHelp(count, n) = \nif n < 10 then\ncount + 1\nelse\naddHelp(count+1, addNum(n))"], "bad": ["let rec additivePersistence n = \nlet count = 0 in \nif n < 10 then\ncount + 1\nelse \nlet count = count + 1"], "message": ["Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let palindrome w = \nlet l = explode w in\nif listReverse(l) = l then\ntrue\nelse\nfalse"], "bad": ["let palindrome w = \nlet l = explode s in\nif listReverse(l) = l then\ntrue\nelse\nfalse"], "message": ["Error: Unbound value s\n"], "problem": "palindrome"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =\nif List.mem h seen\nthen\nseen\nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =\nif List.mem h seen\nthen\nseem\nelse\nh::seem\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "message": ["Error: Unbound value seem\nHint: Did you mean seen?\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = \nlet a', b' = f b in  \nif b' = true \nthen wwhile (f, b')\nelse a'"], "bad": [" rec wwhile (f,b) = \nlet f b = x, y in \nif y = true \nthen wwhile (f, x)\nelse x", " rec wwhile (f,b) = \nlet f b = (x, y) in \nif y = true \nthen wwhile (f, x)\nelse x", "let rec wwhile (f,b) = \nlet f(b) = (x, y) in \nif y = true \nthen wwhile (f, x)\nelse x", "let rec wwhile (f,b) = \nlet f(b) = (x, y) in \nif x = true \nthen wwhile (f, x)\nelse x", "let rec wwhile (f,b) = \nlet f(b) = (b', c') in \nif c' = true \nthen wwhile (f, b')\nelse x", "let rec wwhile (f,b) = \nlet f(b) = b', c' in \nif c' = true \nthen wwhile (f, b')\nelse x", "let rec wwhile (f,b) = \nlet f b = b', c' in \nif c' = true \nthen wwhile (f, b')\nelse x", "let rec wwhile (f,b) = \nlet f b = q, x in \nif c' = true \nthen wwhile (f, b')\nelse x", "let rec wwhile (f,b) = \nlet f b = q, x \nif c' = true \nthen wwhile (f, b')\nelse x", "let rec wwhile (f,b) = \nlet f b = q, x in  \nif c' = true \nthen wwhile (f, b')\nelse x", "let rec wwhile (f,b) = \nlet f b = w in  \nif c' = true \nthen wwhile (f, b')\nelse x"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type bool but an expression was expected of type\n         int\n", "Error: This expression has type bool but an expression was expected of type\n         string\n", "Error: Unbound value b'\n", "Error: Unbound value b'\n", "Error: Unbound value b'\n", "Error: Unbound value q\n", "Error: Syntax error\n", "Error: Unbound value q\n", "Error: Unbound value w\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = \nlet b', c' = f b in  \nif c' = true \nthen wwhile (f, b')\nelse b'"], "bad": ["let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "message": ["Error: This expression has type int -> int * bool\n       but an expression was expected of type bool -> 'a * bool\n       Type int is not compatible with type bool \n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = \nlet f' b' = \nif f(b') = b'\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)"], "bad": ["let fixpoint (f,b) = \nlet f' = fun b'\nif(f(b') = b')\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)", "let fixpoint (f,b) = \nlet f' = fun b' = \nif(f(b') = b')\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)", "let fixpoint (f,b) = \nlet fun f' b' =  \nif(f(b') = b')\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)", "let fixpoint (f,b) = \nlet f' b' =  fun\nif(f(b') = b')\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)", "let fixpoint (f,b) = \nlet f' b' =  fun\nif(f(b') = b')\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)", "let fixpoint (f,b) = \nlet f' b' =  fun\nif(f(b') = b')\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)", "let fixpoint (f,b) = \nlet f' b' =  fun\nif(f(b') = b')\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)", "let fixpoint (f,b) = \nlet f' b' =  fun\nif(f(b') = b')\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)", "let fixpoint (f,b) = \nlet f' b' =  function\nif(f(b') = b')\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with\n| VarX\t\t  -> \"x\"\n| VarY\t\t  -> \"y\"\n| Sine e1\t  -> \"(sin\"^ exprToString e1 ^\")\"\n| Cosine e1\t  -> \"(cos\"^exprToString e1 ^ \")\"\n| Average (e1, e2)-> \"(\"^ exprToString e1 ^\"+\" ^ exprToString e2 ^ \")/2\"\n| Times (e1, e2)  -> \"(\"^ exprToString e1 ^\"*\"^exprToString e2 ^\")\"\n| Thresh (e1, e2, e3, e4) -> \"(\"^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \")?(\"^ exprToString e3 ^ \"):(\"^exprToString e4 ^ \")\""], "bad": ["exprToString (Sine(VarX))"], "message": ["Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)"], "bad": ["let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval(e))", "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval(e1))", "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval e1)", "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval e1)", "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval e1, x, y)", "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))"], "message": ["Error: Unbound constructor BuildSine\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let pi = 4.0 *. atan 1.0", "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)/. 2.0)\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif \n(eval(e1, x, y) < eval(e2, x, y) \nthen\neval(e3, x, y)\nelse\neval(e4, x, y)"], "bad": ["let pi = 4.0 *. atan 1.0\n\n(* eval : expr -> float * float -> float \nEvaluator for expressions in x and y *)\n1<2?3:4"], "message": ["Error: Syntax error\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)/. 2.0)\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif \neval(e1, x, y) < eval(e2, x, y)\nthen\neval(e3, x, y)\nelse\neval(e4, x, y)"], "bad": ["let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)/. 2.0)\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif \n(eval(e1, x, y) < eval(e2, x, y) )\nthen\neval(e3, x, y)\nelse\neval(e4, x, y)"], "message": ["Characters 283-284:\n  (eval(e1, x, y) < eval(e2, x, y) \n  ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "eval"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (x a) in\nlet base = 0 in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "message": ["Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (x a) in\nlet base = [] in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3"], "message": ["Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (x a) in\nlet base = fun g x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = (x a) in\nlet base = x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (x a) in\nlet base = a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (x a) in\nlet base = g x->x in\nList.fold_left f base fs"], "message": ["Error: Unbound value x\n", "Error: Unbound value a\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (x a) in\nlet base = fun g x -> x in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "message": ["Error: This expression has type 'a -> 'b -> 'b\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'b -> 'b\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let y = fun x -> x + 1", "let x = fun z -> z*z"], "bad": ["y = fun x -> x + 1"], "message": ["Error: Unbound value y\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let q x = y (x)"], "bad": ["let z = (y x)", "let q = (y x)", "let q = (y(x))", "let q = fun adf -> fun x -> fun y", "let q = (fun x -> fun z)"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n", "Error: This expression has type int -> int\n       but an expression was expected of type int\n", "Error: This expression has type int -> int\n       but an expression was expected of type int\n", "Error: Syntax error\n", "Error: Syntax error: operator expected.\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun q -> x(a(q)) in\nlet base = fun g q -> q in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         int -> int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let rec clone x n = match n with\n| 0 -> []\n| _ -> x::(clone x (n-1))"], "bad": ["let rec clone x n =  \n| 0 -> []\n| _ -> x::clone n-1", "let rec clone x n = match n with\n| 0 -> []\n| _ -> x::clone n-1", "let rec clone x n = match n with\n| 0 -> []\n| _ -> x::clone (x n-1)", "let rec clone x n = match n with\n| 0 -> []\n| _ -> x::(clone x n-1)"], "message": ["Error: Syntax error\n", "Error: This expression has type int -> int list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         int -> int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let padZero l1 l2 =\nlet lenl1 = List.length l1 in\nlet lenl2 = List.length l2 in\nif lenl1 > lenl2\nthen (l1, (clone 0 (lenl1-lenl2))@l2)\nelse ((clone 0 (lenl2-lenl1))@l1, l2)"], "bad": ["let padZero l1 l2 =\nlet lenl1 = List.length l1 in\nlet lenl2 = List.length l2 in\nif lenl1 > lenl2\nthen (l1, (clone 0 lenl1-lenl2)@l2)\nelse ((clone 0 lenl2-lenl1)@l1, l2)"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let _ = removeZero [0;0;0;0]"], "bad": ["let _ = removeZero [0;0;0;0]\n\n*"], "message": ["Error: Syntax error\n"], "problem": "removeZero"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rem = match a with\n| (x, y) -> x in\nmatch x with \n| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in\nlet digit = (rem + add_a + add_b) mod 10 in\nmatch a with\n| (x, y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rem = match a in\n| (x, y) -> x in\nmatch x with \n| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in\nlet digit = (rem + add_a + add_b) mod 10 in\nmatch a with\n| (x, y) -> new_carry, digit::y", ") in\n\nlet base = (0, []) in\nlet args = List.rev(List.combine(l1, l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rem = match a with\n| (x, y) -> x in\nmatch x with \n| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in\nlet digit = (rem + add_a + add_b) mod 10 in\nmatch a with\n| (x, y) -> new_carry, digit::y", ") in\n\nlet base = (0, []) in\nlet args = List.rev(List.combine(l1, l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rem = match a with\n| (x, y) -> x in\nmatch x with \n| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in\nlet digit = (rem + add_a + add_b) mod 10 in\nmatch a with\n| (x, y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine(l1, l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, _) = a in\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, (norm_sum::y)) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, _) = a in\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, norm_sum::y)", "let base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, _) = a in\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, norm_sum::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type int -> int\n       but an expression was expected of type int list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let rec removeZero l = match l with\n| []      -> []\n| h::t    -> \nif h = 0 \nthen removeZero(t)\nelse h::t", "List.combine([1;2] [3;4])"], "bad": ["let rec removeZero l = match l with\n| []      -> []\n| h::t    -> \nif h = 0 \nthen removeZero(t)\nelse h::t\n\nList.combine([1;2] [3;4])"], "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "problem": "removeZero"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\nif ((List.length acc) = (List.length l1)) || (List.length acc = List.length l2)\nthen if rem = 1\nthen (0, 1::acc) \nelse (0, acc)\nelse\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\nif (acc.length = l1.length) || (acc.length = l2.length)\nthen if rem = 1\nthen (0, 1::acc) \nelse (0, acc)\nelse\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Unbound record field length\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\n\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \nlet larger = if List.length l1 > List.length l2 then l1 else l2 in\nif ((List.length acc) = (List.length larger)-1)\nthen if rem = 1\nthen (0, [1;norm_sum]@acc) \nelse (0, acc)\nelse\n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [0;9;9;9]", "let _ = bigAdd [0;9;9;9] [9;9;9;9]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\n\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \nlet larger = if List.length l1 > List.length l2 then l1 else l2 in\nif ((List.length acc) = (List.length larger)-1)\nthen if rem = 1\nthen (0, [1;norm_sum]@acc) \nelse (0, acc)\nelse\n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZ"], "message": ["Characters 580-581:\n  removeZero (add (padZ;;\n                  ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\n\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \nlet larger = if List.length l1 > List.length l2 then l1 else l2 in\nif ((List.length acc) = (List.length larger)-1)\nthen if rem = 1\nthen (0, [1;norm_sum]@acc) \nelse (0, norm_sum::acc)\nelse\n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [0;9;9;9]", "let _ = bigAdd [0;9;9;9] [9;9;9;9]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\n\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \nlet larger = if List.length l1 > List.length l2 then l1 else l2 in\nif ((List.length acc) = (List.length larger)-1)\nthen if rem = 1\nthen (0, [1;norm_sum]@acc) \nelse (0, norm_sum@acc)\nelse\n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = match i with\n| 1 -> l\n| _ -> bigAdd (mulByDigit (i-1) l) l"], "bad": ["let rec mulByDigit i l = match i with\n| 0 -> l\n| _ -> bigAdd (mulByDigit i-1) l", "let rec mulByDigit i l = match i with\n| 1 -> l\n| _ -> bigAdd (mulByDigit i-1) l"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = \nlet (place, acc) = a in\n(place+1, bigAdd ((mulByDigit x l1)@(clone 0 place)) acc) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = (bigAdd (mulByDigit x l1) a in\nlet base = [] in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = (bigAdd (mulByDigit x l1) a) in\nlet base = [] in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = \nlet (place, acc) = a in\n(place+1, (bigAdd(mulByDigit x l1)@clone 0 place) acc) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = \nlet (place, acc) = a in\n(place+1, (bigAdd(mulByDigit x l1)@clone (0 place)) acc) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = \nlet (place, acc) = a in\n(place+1, bigAdd(mulByDigit x l1)@clone (0 place) acc) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Characters 32-33:\n  let f a x = (bigAdd (mulByDigit x l1) a in\n              ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type 'a list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list -> int list\n       but an expression was expected of type 'a list\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type 'a list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list -> int list\n       but an expression was expected of type 'a list\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type 'a list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list -> int list\n       but an expression was expected of type 'a list\n"], "problem": "bigMul"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digits n digitList = \nif n = 0 then digitList\nelse digits (n/10) ((n mod 10)::digitList)", ") in\nmatch n with\n| 0 -> [0]\n| _ -> digits n []", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663"], "bad": ["let rec digitsOfInt n = \nif n <= 0 then []\nelse if n mod 10 = 0 then 0::digitsOfInt (n/10)\nelse if ((n-1) mod 10) = 0 then (1::digitsOfInt ((n-1)/10))", "let rec digitsOfInt n = \nif n <= 0 then []\nelse if n mod 10 = 0 then 0::digitsOfInt (n/10)\nelse if ((n-1) mod 10) = 0 then (1::(digitsOfInt ((n-1)/10)))"], "message": ["Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digits n digitList = \nif n = 0 then digitList\nelse digits (n/10) ((n mod 10)::digitList) in\nmatch n with\n| 0 -> [0]\n| _ -> digits n []"], "bad": ["let rec digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digits n digitList = \nif n = 0 then digitList\nelse digits (n/10) ((n mod 10)::digitList)", ") in\nmatch n with\n| 0 -> [0]\n| _ -> digits n []", "let rec digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digits n digitList = \nif n = 0 then digitList\nelse digits (n/10) ((n mod 10)::digitList)", "let rec digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digits n digitList = \nif n = 0 then digitList\nelse digits (n/10) ((n mod 10)::digitList)", ") in\nmatch n with\n| 0 -> [0]\n| _ -> digits n []"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "bad": ["let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| (h::t) -> if h = (k,'a) then 'a else assoc (d,k,t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| (h::t) -> if h = (k * 'a) then 'a else assoc (d,k,t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| (h::t) -> if h = [k,'a] then 'a else assoc (d,k,t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| (('a,'b)::t) -> if 'a = k then 'b else assoc (d,k,t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "message": ["Error: Syntax error: operator expected.\n", "Error: Unbound value assoc\n", "Error: Unbound value assoc\n", "Error: Syntax error: operator expected.\n", "Error: Unbound value assoc\n", "Error: Unbound value assoc\n", "Error: Syntax error\n", "Error: Unbound value assoc\n", "Error: Unbound value assoc\n", "Error: Syntax error: operator expected.\n", "Error: Unbound value assoc\n", "Error: Unbound value assoc\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif List.mem h seen \nthen helper (seen, t) \nelse helper (h::seen, t)\nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) = \nmatch f b with\n| (x, false) -> x\n| (x, true)  -> wwhile (f, x)", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) = wwhile (let g x = let bb = f b in (bb, bb = b) in f, b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "bad": ["let fixpoint (f,b) = wwhile (let a = (f b, b = f b),b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let fixpoint (f,b) = wwhile ((f b, b = f b),b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Syntax error: operator expected.\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile (let g x = let bb = f x in (bb, bb = x) in g, b)"], "bad": ["let fixpoint (f,b) = wwhile (let g = let bb = f b in (bb, bb = b) in g, b)"], "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with\n| VarX -> x", "let sampleExpr1 = VarX", "let _ = exprToString sampleExpr1"], "bad": ["let rec exprToString e = match e with\n| VarX x -> Printf.printf \"%s\" x"], "message": ["Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nif depth = 0 then \nmatch rand mod 2 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand mod 5 with\n| 2 -> buildSine(build (rand, depth-1))\n| 3 -> buildCosine(build (rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"], "bad": ["let rec build (rand, depth) = \nif depth = 0 then \nmatch rand (i,j) mod 2 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand (i,j) mod 5 with\n| 2 -> buildSine(build (rand, depth-1))\n| 3 -> buildCosine(build (rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "let rec build (rand, depth) = \nif depth = 0 then \nmatch rand mod 2 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand mod 5 with\n| 2 -> buildSine(build (rand, depth-1))\n| 3 -> buildCosine(build (rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"], "message": ["Error: Unbound value i\n", "Error: Unbound value i\n"], "problem": "build"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet rec f a x = match x with\n| []     -> a\n| (h::t) -> f (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = match x with\n| [] -> a\n| (h::t) -> f (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let sqsum xs = \nlet f a x = match x with\n| []     -> a\n| (h::t) -> sqsum (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = match x with\n| []     -> a\n| (h::t) -> f (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = match x with\n| []     -> a\n| (h::t) -> f a+(h*h) t in\nlet base = 0 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = match x with\n| []     -> a\n| (h::t) -> f (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs"], "message": ["Error: Unbound value f\n", "Error: Unbound value sqsum\n", "Error: Unbound value sqsum\n", "Error: Unbound value sqsum\n", "Error: Unbound value sqsum\n", "Error: Unbound value f\n", "Error: Unbound value f\n", "Error: Unbound value f\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = (a + (x*x)) in\nlet base = 0 in\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = a + x*x", "let base = 0 in\nList.fold_left f base xs"], "message": ["Error: Syntax error\n", "Error: Unbound value f\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x 'a in\nlet base = fs in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs"], "message": ["Error: Unbound value x\n", "Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n", "Error: Syntax error\n", "Error: Unbound value a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs", "let _ = pipe []"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let pipe fs = \nlet f a x = x 'a in\nlet base = 'a in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let pipe fs = \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "let _ = pipe [] 3", "let pipe fs = \nlet f a x = x a in\nlet base = 'a in\nList.fold_left f base fs"], "message": ["Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Syntax error\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value a\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs num = \nlet f a x = x a in\nlet base = num in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = b in\nList.fold_left f base fs"], "message": ["Error: Unbound value b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = fun 'a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = fun 'a -> fs 'a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = fun a -> fs a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = base in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = fs 'a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = List.hd fs in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type (('a -> 'b) -> 'a -> 'b) list\n", "Error: Syntax error\n", "Error: Unbound value base\n", "Error: Syntax error\n", "Error: This expression has type 'a list\n       but an expression was expected of type ('a -> 'a) list\n       The type variable 'a occurs inside 'a -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe = fun x -> fun2 (fun1 x)"], "bad": ["let pipe = fun x -> fun (fun y)"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = _ in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = 'a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = 'b in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = int in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3"], "message": ["Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe = fun x -> fun2 (fun1 x)", "let _ = pipe 3", "let pipe fs = \nlet f a x = x a in\nlet base = fun p = p in\nList.fold_left f base fs"], "bad": ["let pipe = let base = x in fun x -> fun2 (fun1 base)", "let _ = pipe 3", "let pipe = let base = fun x in fun x -> fun2 (fun1 base)", "let _ = pipe 3", "let pipe = let base =  in fun x -> fun2 (fun1 base)", "let _ = pipe 3", "let pipe fs = \nlet f a x = x a in\nlet base = fun p = p in\nList.fold_left f base fs", "let pipe = fun x -> fun2 (fun1 base)", "let _ = pipe 3", "let pipe fs = \nlet f a x = x a in\nlet base = fun p = p in\nList.fold_left f base fs"], "message": ["Error: Unbound value x\n", "Error: This expression has type int but an expression was expected of type\n         ('a list -> 'a list) list\n", "Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         ('a list -> 'a list) list\n", "Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         ('a list -> 'a list) list\n", "Error: Syntax error\n", "Error: Unbound value base\n", "Error: This expression has type int but an expression was expected of type\n         ('a list -> 'a list) list\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun p -> p in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let pipe fs = \nlet f a x = x a in\nlet base = p -> p in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let _ = pipe fun1 fun2 3", "let pipe fs = \nlet f a x = x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "let _ = pipe [] 3"], "bad": ["let _ = pipe fun1 fun2", "let _ = pipe fun1 fun2 3"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type (int -> int) -> 'a\n       Type int is not compatible with type int -> int \n", "Error: This expression has type int -> int\n       but an expression was expected of type (int -> int) -> 'a -> 'b\n       Type int is not compatible with type int -> int \n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe = fun x -> fun2 (fun1 x)"], "bad": ["let pipe = fun2 fun1", "let pipe = fun x -> fun2 fun1", "let pipe = fun x -> fun2 fun1 x"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n", "Error: This expression has type int -> int\n       but an expression was expected of type int\n", "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe = fun x -> fun2 (fun1 x)"], "bad": ["let pipe = fun x -> fun2 x -> (fun1 x)", "let pipe = fun x -> fun2 x (fun1 x)"], "message": ["Error: Syntax error\n", "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun p -> p in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let rec pipe fs = \nmatch fs with\n| [] -> 0\n| (h::t) -> h (pipe t)"], "bad": ["let rec pipe fs = \nlet fsrev = List.rev fs in\nmatch fsrev with\n| [] -> x -> x\n| (h::t) -> h (pipe t)", "let rec pipe fs = \nlet fsrev = List.rev fs in\nmatch fsrev with\n| [x] -> x \n| (h::t) -> h (pipe t)", "let rec pipe fs = \nmatch fs with\n| [x] -> x \n| (h::t) -> h (pipe t)", "let rec pipe fs = \nmatch fs with\n| [x] -> x \n| (h::t) -> h (pipe t)", "let rec pipe fs = \nmatch fs with\n| [] -> x \n| (h::t) -> h (pipe t)"], "message": ["Error: Syntax error\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n", "Error: Unbound value x\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let rec pipe fs = \nmatch fs with\n| [] -> fun x -> x\n| (h::t) -> h (pipe t)"], "bad": ["let rec pipe fs = \nmatch fs with\n| [] -> fun\n| (h::t) -> h (pipe t)"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x (a _) in\nlet base = fun y -> y in\nList.fold_left f base fs"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let stringOfList f l = sepConcat \"; \" (List.map f l)", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"], "bad": ["let stringOfList f l = List.map f sepConcat l", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let stringOfList f l = sepConcat (List.map f)", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let stringOfList f l = sepConcat \"; \" (List.map f)", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"], "message": ["Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value stringOfList\n", "Error: Unbound value stringOfList\n", "Error: Unbound value stringOfList\n", "Error: This expression has type 'a list -> 'b list\n       but an expression was expected of type string\n", "Error: Unbound value stringOfList\n", "Error: Unbound value stringOfList\n", "Error: Unbound value stringOfList\n", "Error: This expression has type 'a list -> 'b list\n       but an expression was expected of type string list\n", "Error: Unbound value stringOfList\n", "Error: Unbound value stringOfList\n", "Error: Unbound value stringOfList\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let _ = padZero [9;9] [1;2]"], "bad": ["let _ padZero [9;9] [1;2]"], "message": ["Error: Syntax error\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let pipe fs p = \nlet f a x = x a in\nlet base = p in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = let p = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = let p = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let x = 2", "let (_, test) = x + 1 in test"], "bad": ["let (_, test) = x + 1 in test"], "message": ["Error: Unbound value x\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet prevN (n1, n2) = n1 in\nlet prev = prevN a in\nlet sumlist (p1, p2) = p2 in\nlet sum = sumlist a in\nlet add (m,n) = m + n in\nlet digit = (add x) + prev in\nif digit > 10 then (1, (digit-10)::sum) else (0, (digit)::sum) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet prevN (n1, n2) in\nlet prev = prevN a in\nlet sumlist (p1, p2) = p2 in\nlet sum = sumlist a in\nlet add (m,n) = m + n in\nlet digit = (add x) + prev in\nif digit > 10 then (1, (digit-10)::sum) else (0, (digit)::sum) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let getTail l = match l with \n| [] -> []\n| (h::t) -> if t = [] then [h] else t", "let _ = getTail [0]"], "bad": ["let getTail l = match l with \n| [] -> []\n| (h::t) -> if t = [] then [h] else t in\n\nlet _ = getTail [0]"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let _ = bigMul [1] [0]"], "bad": ["let _ bigMul [1] [0]"], "message": ["Error: Syntax error\n"], "problem": "bigMul"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\nif n < 0 then []\nelse n :: digitsOfInt n"], "bad": ["let rec digitsOfInt n =\nif n < 0 then []\nelse a :: [] -> digitsOfInt n :: []", "let rec digitsOfInt n =\nif n < 0 then []\nelse a :: [] -> digitsOfInt n :: []", "let rec digitsOfInt n =\nif n < 0 then []\nelse a :: [] -> digitsOfInt n :: []", "let rec digitsOfInt n =\nif n < 0 then []\nelse a :: [] -> a :: digitsOfInt n", "let rec digitsOfInt n =\nif n < 0 then []\nelse a :: digitsOfInt n"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value a\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10)"], "bad": ["let rec digitsOfInt n =\nif n < 0 then []\nelse n%10", "let rec digitsOfInt n =\nif n < 0 then []\nelse n mod 10", "let rec digitsOfInt n =\nif n < 0 then []\nelse h:: digitsOfInt n mod 10", "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt n mod 10", "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10) mod 10 :: []"], "message": ["Error: Unbound value %\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: Unbound value h\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 98*-1"], "bad": ["let _ = digitsOfInt 98"], "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit n acc =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n"], "bad": ["let _ = digitsOfInt -9", "let _ = digitsOfInt ~-9"], "message": ["Error: Unbound value *-\n", "Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []"], "bad": ["let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \ndigit [] n", "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nn [] digit", "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \ndigit [] digit", "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []"], "message": ["Error: Syntax error\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = additivePersistence 9876"], "bad": ["let additivePersistence n =\nif n < 10 then 0  \nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then 1 + addTimes x\nelse 1", "let additivePersistence n =\nif n < 10 then 0  \nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then 1 + addTimes x\nelse 1 in\naddTimes n"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec digitalRoot n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10)"], "bad": ["let rec digitalRoot n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10)"], "message": ["Error: Unbound value n\n"], "problem": "digitalRoot"}
{"hw": "hw1", "fix": ["let _ = digitalRoot 9876"], "bad": ["let digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digits(n/10)", "let digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot (n/10)", "let digitalRoot n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot (n/10)"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "digitalRoot"}
{"hw": "hw1", "fix": ["let digitalRoot n =\nif n < 10 then 0\nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then 1 + addTimes x\nelse 1 in\naddTimes n"], "bad": ["let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digits (n/10) in\nlet x = digits n in \nif x > 9 then digitalRoot x\nelse x in digitalRoot n", "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in \nif x > 9 then digitalRoot x\nelse x in digitalRoot n", "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in \nif x > 9 then digitalRoot x\nelse 1 in digitalRoot x", "let digitalRoot n =\nif n < 10 then 0\nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then 1 + addTimes x\nelse 1 in\naddTimes n"], "message": ["Error: Syntax error\n", "Error: Unbound value n\n", "Error: Unbound value n\n", "Error: Unbound value x\n"], "problem": "digitalRoot"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4]"], "bad": ["let rec listReverse l = match l with\n| [] -> []\n| hd::l' -> 1 + listReverse l'", "let rec listReverse l = match l with\n| [] -> 0\n| hd::l' -> 1 + listReverse l'"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4; 9]"], "bad": ["let rec listReverse l = match l with\n| [] -> 0\n| _::tl -> 1 + listReverse tl"], "message": ["Error: Syntax error\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4; 9]"], "bad": ["let rec listReverse l = match l with\n| [] -> []\n| _::tl -> listReverse _ + tl", "let rec listReverse l = match l with\n| [] -> []\n| _::tl -> listReverse tl + tl", "let rec listReverse l = match l with\n| 0 -> []\n| _::tl -> listReverse tl + tl", "let rec listReverse l = match l with\n| [] -> []\n| _::tl -> listReverse tl + tl", "let rec listReverse l = match l with\n| [] -> []\n| _::tl -> listReverse tl"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4; 9]"], "bad": ["let listReverse l = \nlet rec reverseHelper tl l = match l with\n| [] -> []\n| _::tl -> reverseHelper tl l", "let listReverse l = \nlet rec reverseHelper l tl = match l with\n| [] -> []\n| _::t -> reverseHelper t l", "let rec listReverse l =\nmatch l with\n| [] -> []\n| hd::l -> listReverse l"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4; 9]", "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]"], "bad": ["let listReverse l = \nlet rec reverseHelper acc = \nif [] then acc\nelse reverseHelper (h::acc) t in\nreverseHelper [] l", "let listReverse l = \nlet rec reverseHelper acc = \n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l", "let listReverse l = \nlet rec reverseHelper acc = match acc with \n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l", "let listReverse l = \nlet rec reverseHelper acc = function\n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l"], "message": ["Error: Syntax error\n", "Error: This variant expression is expected to have type bool\n       The constructor [] does not belong to type bool\n", "Error: Syntax error\n", "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = palindrome \"malayalam\""], "bad": ["let palindrome w = \nif explode w = listReverse w then true\nelse false", "let palindrome w = \nif explode w = listReverse (explode w) then true\nelse false"], "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n"], "problem": "palindrome"}
{"hw": "hw1", "fix": ["let _ = palindrome \"_\""], "bad": ["let _ = palindrome \"\""], "message": ["Error: Syntax error\n"], "problem": "palindrome"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4; 9]"], "bad": ["let listReverse l = \nlet rec reverseHelper acc = function \n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l"], "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4; 9]"], "bad": ["let listReverse l = \n(*let rec reverseHelper acc = function \n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l *)\nlet rec reverseHelper ln lo =\nmatch ln with\n| [] -> lo\n| h::t -> reverseHelper t (h::lo) in\nreverseHelper l []"], "message": ["Error: Unbound value acc\n"], "problem": "listReverse"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = a*a + x in\nlet base = [] in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = a*a + x in\nlet base = a in\nList.fold_left f base xs"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: Unbound value a\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun y -> y |> a |> x in\nlet base = fun y -> y in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun inner -> y |> a |> x in\nlet base = fun y -> y in\nList.fold_left f base fs"], "message": ["Error: Unbound value y\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep^a in\nlet base = h in\nlet l = t in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep^a t in\nlet base = h in\nlet l = sl in\nList.fold_left f base l"], "message": ["Error: This expression has type (string list -> string) -> 'a -> string\n       but an expression was expected of type\n         (string list -> string) -> 'a -> string list -> string\n       Type string is not compatible with type string list -> string \n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let stringOfList f l = List.map f l"], "bad": ["let stringOfList f l = in List.map f sepConcat \" \" l"], "message": ["Error: Syntax error\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = sepConcat \"[\" (List.map f l)"], "bad": ["let stringOfList f l = sepConcat \"[\" List.map f l"], "message": ["Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = sepConcat \"; \" (List.map f l)"], "bad": ["let stringOfList f l = sepConcat \"; \" List.map f l"], "message": ["Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 then true\nelse false"], "bad": ["let padZero l1 l2 = \nlet f a l = a+1 l in \nlet base = a\nin List.fold_left f base", "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) acc l1", "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) acc l1", "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) acc l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) acc l2 in\nif length1 < length2 then true\nelse false"], "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value acc\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 = length2 \nthen (l1,l2)\nelse \nif length1 < length2\nthen (List.append (clone 0 (length2 - length1)) l1, l2)\nelse (l1, (List.append (clone 0 (length1 - length2)) l2))"], "bad": ["let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen clone (length2-length1) 0 \nelse if length2 < length1\nthen clone (length1-length2) 0", "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen clone (length2 - length1) 0 \nelse if length2 < length1\nthen clone (length1-length2) 0", "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen clone (length2 - length1) 0 \nelse if length2 < length1\nthen clone (length1 - length2) 0", "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen clone 0 (length2 - length1) \nelse if length2 < length1\nthen clone 0 (length1 - length2)", "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen let pad1 = clone 0 (length2 - length1) in\nelse if length2 < length1\nthen let pad2 = clone 0 (length1 - length2) in\nList.append pad1 l1", "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen let pad1 = clone 0 (length2 - length1) in\nelse if length2 < length1\nthen let pad2 = clone 0 (length1 - length2) in\nList.append pad1 l1", "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen let pad1 = clone 0 (length2 - length1)\nelse if length2 < length1\nthen let pad2 = clone 0 (length1 - length2) in\nList.append pad1 l1", "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen let pad1 = clone 0 (length2 - length1)\nelse if length2 < length1\nthen let pad2 = clone 0 (length1 - length2) in\nList.append pad1 l1"], "message": ["Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let rec removeZero l = match l with\n| [] -> l\n| x::l' -> \nif x=0 \nthen removeZero l'\nelse l"], "bad": ["let rec removeZero l = match l with\n| [] -> 0\n| x::l' -> if x = 0\nthen List.fold_left (fun acc x -> acc+1) 0 l"], "message": ["Error: This expression has type int but an expression was expected of type\n         unit\n"], "problem": "removeZero"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = \nlet (carry, acc) = a in\nlet (fact, dig)  = x in\nlet prod = mulByDigit dig l1 @ clone 0 carry in\nlet result = bigAdd prod acc in\n(carry+1, result) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = \nlet (carry, acc) = a in\nlet (fact, dig)  = x in\nlet prod = mulByDigit dig l1 @ clone 0 carry in\nlet result = bigAdd prod acc in\n(i+1, result) in\nlet base =  in\nlet args = in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = \nlet (carry, acc) = a in\nlet (fact, dig)  = x in\nlet prod = mulByDigit dig l1 @ clone 0 carry in\nlet result = bigAdd prod acc in\n(i+1, result) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: Syntax error\n", "Error: Unbound value i\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value i\n"], "problem": "bigMul"}
{"hw": "hw1", "fix": ["List.tl [1;2;3]"], "bad": ["tl [1;2;3]"], "message": ["Error: Unbound value tl\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs)"], "bad": ["let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList List.tl xs"], "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt n)"], "bad": ["let rec digitsOfInt n = if n<0 [] else match n with f::b -> f", "let rec digitsOfInt n = if n<0 then [] else match n with f::b -> f", "let rec digitsOfInt n = if n<0 then [] else (n mod 10)::digitsOfInt n*10", "let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt n*10)"], "message": ["Error: Syntax error\n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x))"], "bad": ["let rec persistenceHelper q = let x = sumList q in"], "message": ["Error: Syntax error\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let _ = additivePersistence 9876"], "bad": ["let _ = additivePersistence -9876"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let _ = additivePersistence 9"], "bad": ["let _ = additivePersistence -9876"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let _ = digitalRoot (-45)"], "bad": ["let _ = digitalRoot -4", "let _ = digitalRoot -434"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\nError: Unbound value digits\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int -> int\n       but an expression was expected of type int\n", "Error: This expression has type int -> int\n       but an expression was expected of type int\nError: Unbound value digits\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int -> int\n       but an expression was expected of type int\n"], "problem": "digitalRoot"}
{"hw": "hw1", "fix": ["let _ = digitalRoot 459"], "bad": ["let _ = digitalRoot -459"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\nError: Unbound value digits\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int -> int\n       but an expression was expected of type int\n"], "problem": "digitalRoot"}
{"hw": "hw1", "fix": ["let poop = [1; 2; 3; 4]", "match poop with h::t"], "bad": ["let poop = [1; 2; 3; 4]\nmatch poop with h::t"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true else false"], "bad": ["let palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true esle false"], "message": ["Error: Syntax error\n"], "problem": "palindrome"}
{"hw": "hw1", "fix": ["let rec append list1 list2 = match list1 with [] -> list2 | a::b -> a::(append b list2)"], "bad": ["let rec @ list1 list2 = match list1 with [] -> list2 | a::b -> a::(@ b list2)", "let rec append list1 list2 = match list1 with [] -> list2 | a::b -> a::(@ b list2)"], "message": ["Error: Syntax error\n", "Characters 71-72:\n  let rec append list1 list2 = match list1 with [] -> list2 | a::b -> a::(@ b list2);;\n                                                                         ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen' then seen' else h::seen' in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "message": ["Error: Unbound value seen'\nHint: Did you mean seen?\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let fixpoint (f,b) = wwhile ((let func x = if (f x)= x then (x,false) else (f x,true) ),b)", "let fixpoint (f,b) = wwhile ((let func x = if (f x)= x then (x,false) else (f x,true)),b)", "let fixpoint (f,b) = wwhile ((let func x = (if (f x)= x then (x,false) else (f x,true))),b)", "let fixpoint (f,b) = wwhile ((let func x = (if (f x)= x then (x,false) else ((f x),true))),b)", "let fixpoint (f,b) = wwhile ((let func x = (if ((f x)= x) then (x,false) else (f x,true))),b)", "let fixpoint (f,b) = wwhile (((if ((f x)= x) then (x,false) else (f x,true))),b)", "let fixpoint (f,b) = wwhile ((let func x = (if ((f x)= x) then (x,false) else (f x,true)) in func x),b)", "let fixpoint (f,b) = wwhile ((let func x = (if ((f x)= x) then (x,false) else (f x,true)) in func),b)"], "message": ["Error: Unbound value wwhile\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "let _ = exprToString sampleExpr1"], "bad": ["let rec exprToString e = match e with VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin(pi*\"^ exprToString ex ^\")\"\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times ex1 ex2 -> ex1^\"*\"^ex2\n| Thresh ex1 ex2 ex3 ex4 -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "let rec exprToString e = match e with VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin(pi*\"^ exprToString ex ^\")\"\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> ex1^\"*\"^ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "let rec exprToString e = match e with VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin(pi*\"^ exprToString ex ^\")\"\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type expr but an expression was expected of type\n         string\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""], "bad": ["let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*. exprToString ex )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*. eval ex )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*. eval ex x y )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval ex x y )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval ex x y )", "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval ex x y )", "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval ex x y )", "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex x y) )", "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )"], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type string but an expression was expected of type\n         float\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "Error: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)\n", "Error: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)\n", "Error: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)\n", "Error: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)\n", "Error: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)\n", "Error: This expression has type expr\n       This is not a function; it cannot be applied.\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)", ")"], "bad": ["let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((exprToString (ex1,x,y)+.exprToString (ex2,x,y))/.2)\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2)\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/2)\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) -> (eval (ex1,x,y)<eval (ex2,x,y) ? eval (ex3,x,y): eval (ex4,x,y))", "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) -> (eval (ex1,x,y)<eval (ex2,x,y)? eval (ex3,x,y): eval (ex4,x,y))", "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) -> (eval (ex1,x,y)<eval (ex2,x,y)?eval (ex3,x,y): eval (ex4,x,y))", "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) -> (eval(ex1,x,y)<eval(ex2,x,y) ? eval(ex3,x,y):eval(ex4,x,y))", "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y) then eval(ex3,x,y) else eval(ex4,x,y)", ")", "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  (eval(ex1,x,y)<eval(ex2,x,y)) ? eval(ex3,x,y):eval(ex4,x,y)", ")", "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  (eval(ex1,x,y)<eval(ex2,x,y)) ? eval(ex3,x,y) : eval(ex4,x,y)", ")"], "message": ["Error: This expression has type string but an expression was expected of type\n         float\n", "Error: This expression has type string but an expression was expected of type\n         float\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type string but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type string but an expression was expected of type\n         float\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Characters 283-284:\n  | Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y) then eval(ex3,x,y) else eval(ex4,x,y);;\n                                    ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr,0.5,0.2)"], "bad": ["let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)"], "message": ["Error: Syntax error\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval (sampleExpr,0.5,0.2)"], "bad": ["let _ = eval (sampleExpr1,0.5,0.2)"], "message": ["Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n"], "problem": "eval"}
{"hw": "hw2", "fix": [" rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)"], "bad": ["let _ = eval (sampleExpr,0.5,0.2)"], "message": ["Error: Unbound value l\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) = match f b with (num,boo)-> \nif boo then wwhile (f,num)\nelse num", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) = wwhile ((let func x = (if ((f x)= x) then (x,false) else (f x,true)) in func),b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)", "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "let rec exprToString e = match e with VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin(pi*\"^ exprToString ex ^\")\"\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "let _ = exprToString sampleExpr1", "let buildX()                       = VarX", "let buildY()                       = VarY", "let buildSine(e)                   = Sine(e)", "let buildCosine(e)                 = Cosine(e)", "let buildAverage(e1,e2)            = Average(e1,e2)", "let buildTimes(e1,e2)              = Times(e1,e2)", "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "let pi = 4.0 *. atan 1.0", "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)", "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr,0.5,0.2)", "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"], "bad": ["let rec build (rand, depth) = if depth= 0 then (let case = rand(0,1)) \nelse let case = rand(0,6)in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "let rec build (rand, depth) = if depth= 0 then (let case = rand(0,1)) else let case = rand(0,6)in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "let rec build (rand, depth) = (if depth= 0 then (let case = rand(0,1)) else let case = rand(0,6)) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "let rec build (rand, depth) = if depth= 0 then let case = rand(0,1) in  else let case = rand(0,6) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "let rec build (rand, depth) = if depth= 0 then (let case = rand(0,1) in)  else let case = rand(0,6) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "let rec build (rand, depth) = let case = 0 in if depth= 0 then ( case = rand(0,1) in", ")  else let case = rand(0,6) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "let rec build (rand, depth) = let case = 0 in if depth= 0 then case = rand(0,1) in  else let case = rand(0,6) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "let rec build (rand, depth) = let case = 0 in if depth= 0 then case = rand(0,1)  else let case = rand(0,6) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "let rec build (rand, depth) = let case = 0 in if depth= 0 then case = rand(0,1)  else let case = rand(0,6) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "let rec build (rand, depth) = if depth= 0 then let case = rand(0,1) else let case = rand(0,6) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"], "message": ["Error: Syntax error\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error\n", "Error: Syntax error: operator expected.\n", "Characters 63-64:\n  let rec build (rand, depth) = let case = 0 in if depth= 0 then ( case = rand(0,1) in;;\n                                                                 ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type unit -> expr\n       but an expression was expected of type bool\n", "Error: This expression has type expr but an expression was expected of type\n         bool\n", "Error: Syntax error\n", "Error: This expression has type unit -> expr\n       but an expression was expected of type unit\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = let case = rand(0,6)", "let if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"], "bad": ["let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> VarX\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "let rec build (rand, depth) = let case = rand(0,6) in \nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"], "message": ["Error: This expression has type unit -> expr\n       but an expression was expected of type unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This variant expression is expected to have type unit\n       The constructor VarX does not belong to type unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = if depth=0 then(\nmatch rand(0,5) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,0) with\n| 0 -> buildX()\n| 1 -> buildY()"], "bad": ["let rec build (rand, depth) = let case = rand(0,6)", "let if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "let rec build (rand, depth) = if depth=0 then(\nmatch rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)\n| FiboPlus (ex1,ex2,ex3,ex4,ex5) -> ((eval (ex1,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)+.eval (ex4,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)+.eval (ex4,x,y)+.eval (ex5,x,y)))\n| TheThing (ex1,ex2,ex3) -> ((eval (ex1,x,y)*.sin(pi*. eval (ex2,x,y))*.cos(pi*. eval (ex3,x,y)))/.2.)"], "bad": ["let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)\n| FiboPlus (ex1,ex2,ex3,ex4,ex5) -> ((eval (ex1,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)+.eval (ex4,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)+.eval (ex4,x,y)+.eval (ex5,x,y)))\n| TheThing (ex1,ex2,ex3) -> ((eval (ex1,x,y)*.sin(pi*. eval (ex2,x,y))*.cos(pi*. eval (ex3,x,y)))/.2.)"], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = if depth>0 then(\nmatch rand(0,8) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))\n| 7 -> buildSixtyNine(build (rand,depth-1))\n| 8 -> buildTheThing(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"], "bad": ["let rec build (rand, depth) = if depth>0 then(\nmatch rand(0,8) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))\n| 7 -> buildSixtyNine(build (rand,depth-1))\n| 8 -> buildTheThing(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"], "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * expr\n"], "problem": "build"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x(a) in\nlet base = 0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x(a) in\nlet base = 'a in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = x(a) in\nlet base = fun fs->fs in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x(fs) in\nlet base = a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x(fs) in\nlet base = _ in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x(fs) in\nlet base = 'a->'a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x(fs) in\nlet base = 0 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x(fs) in\nlet base = fs in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x(fs) in\nlet base = a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a+x(fs) in\nlet base = a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x(a) in\nlet base =  in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x(a) in\nlet base =  a'-> fs in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x(a) in\nlet base =  'a-> fs in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x(a) in\nlet base =  'a-> fs in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x(a) in\nlet base =  'a -> fs in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x(a) in\nlet base = fs in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x(a) in\nlet base = fs->fs in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x(a) in\nlet base = fs(fs) in\nList.fold_left f base fs"], "message": ["Error: Unbound value a\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type 'a but an expression was expected of type\n         ('a -> int) list\n       The type variable 'a occurs inside ('a -> int) list\n", "Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n", "Error: Unbound value a\n", "Error: Unbound value a\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n", "Error: Syntax error\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =  x in\nlet base = fun q->q in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x =  in\nlet base = fun q->q in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =  x(a) in\nlet base = (fun q->q) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x =  a(x) in\nlet base = (fun q->q) in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =  x(a) in\nlet base = (fun q->q) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x =  a(x) in\nlet base = (fun q->q) in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x(a) in\nlet base = (fun q->q) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x =  f x(a) in\nlet base = (fun q->q) in\nList.fold_left f base fs"], "message": ["Error: Unbound value f\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun w -> x(a) in\nlet base = (fun q->q) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun x -> a in\nlet base = (fun q->q) in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun w -> x(a) in\nlet base = (fun a->a) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun w -> x(a) in\nlet base = (fun a->q) in\nList.fold_left f base fs"], "message": ["Error: Unbound value q\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a  in\nlet base = fun a -> a in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a x in\nlet base = (fun a->a) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun a -> a x in\nlet base = (fun a->a) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun a -> a x in\nlet base = (fun 'a->'a) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x =  match x with x:xs in\nlet base = (fun a->a) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x =  match x with x:fs in\nlet base = (fun a->a) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x =  match fs with x::xs in\nlet base = (fun a->a) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a  in\nlet base = a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a  in\nlet base = fun s -> a s in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error: pattern expected.\n", "Error: Unbound value a\n", "Error: Unbound value a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun w -> x(a(w))   in\nlet base = fun a -> a in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a(x)   in\nlet base = fun a -> a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x   in\nlet base = fun a -> a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x   in\nlet base =  a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x   in\nlet base =  x in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: Unbound value a\n", "Error: Unbound value x\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let stringOfList f l = \"[\"^(sepConcat \"; \" (List.map f l))^\"]\""], "bad": ["let stringOfList f l = \"[\"^(sepConcat \"; \"(List.map f \"\" l))^\"]\"", "let stringOfList f l = \"[\"^(sepConcat \"; \" (List.map f \"\" l))^\"]\""], "message": ["Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let rec clone x n = if n<1 then [] \nelse \nlet rec helper acc f x = match x with \n| 0 -> acc\n| _ -> helper (f::acc) f (x-1)\nin helper [] x n"], "bad": ["let rec clone x n = if n<1 then return [] \nelse \nlet rec helper acc f x = match x with \n| 0 -> acc\n| _ -> helper (f::acc) f x-1\nin helper [] x n", "let rec clone x n = if n<1 then [] \nelse \nlet rec helper acc f x = match x with \n| 0 -> acc\n| _ -> helper (f::acc) f x-1\nin helper [] x n"], "message": ["Error: Unbound value return\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = let x = (List.length l1 - List.length l2) in \nif x!=0 then\nif x<0 then\n(((clone 0 (abs x))@l1),l2)\nelse \n(l1,((clone 0 (abs x))@l2))\nelse \n(l1,l2)"], "bad": ["let padZero l1 l2 = let x = (List.length l1 - List.length l2) in \nif x then\nif x<0 then\n(((clone 0 (abs x))@l1),l2)\nelse \n(l1,((clone 0 (abs x))@l2))\nelse \n(l1,l2)"], "message": ["Error: This expression has type int but an expression was expected of type\n         bool\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let rec removeZero l = match l with\n| x::xs -> if x=0 then removeZero xs\nelse xs\n| _ -> l"], "bad": ["let rec removeZero l = match l with\n| x:xs -> if x=0 then removeZero xs\nelse xs\n| _ -> l"], "message": ["Error: Syntax error\n"], "problem": "removeZero"}
{"hw": "hw3", "fix": ["let _ =  18 mod 10"], "bad": ["let _ = mod 18 10"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let _ =List.combine (clone 7 7)(List.combine [0;0;0;1;0;0;2][0;0;0;1;0;0;2])"], "bad": ["let _ =List.combine ((clone 7 7)(List.combine [0;0;0;1;0;0;2][0;0;0;1;0;0;2]) )"], "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = fun w -> x(a(w))   in\nlet base = fun a -> a in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = \"[\"^(sepConcat \"; \" (List.map f l))^\"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n = if n<1 then [] \nelse \nlet rec helper acc f x = match x with \n| 0 -> acc\n| _ -> helper (f::acc) f (x-1)\nin helper [] x n", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let padZero l1 l2 = let x = (List.length l1 - List.length l2) in \nif x!=0 then\nif x<0 then\n(((clone 0 (abs x))@l1),l2)\nelse \n(l1,((clone 0 (abs x))@l2))\nelse \n(l1,l2)", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let rec removeZero l = match l with\n| x::xs -> if x=0 then removeZero xs\nelse l\n| _ -> l", "let _ = removeZero [0;0;0;1;0;0;2]", "let _ = removeZero [9;9]", "let _ = removeZero [0;0;0;0]", "let _ =List.combine (clone 7 7)(List.combine [0;0;0;1;0;0;2][0;0;0;1;0;0;2])", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d,(b,c)) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| [] -> sum::a\n| x'::xs' -> \nif (x'=(-1)) then\nif (sum=9) then\n-1::0::xs'\nelse\n(sum+1)::xs'\nelse \nsum::a\nelse\nmatch a with \n| [] -> -1::(sum mod 10)::a\n| x'::xs' -> \nif (x'=(-1)) then\n-1::(sum mod 10)::a\nelse \n-1::(sum mod 10)::a\n\nin\nlet base = [] in\nlet args = List.combine (clone (List.length l1) (List.length l1)) (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d,(b,c)) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| [] -> sum::a\n| x'::xs' -> \nif (x'=(-1)) then\nif (sum=9) then\n-1::0::xs'\nelse\n(sum+1)::xs'\nelse \nsum::a\nelse\nmatch a with \n| [] -> -1::(sum mod 10)::a\n| x'::xs' -> \nif (x'=(-1)) then\n-1::(sum mod 10)::a\nelse \n-1::(sum mod 10)::a\n\nin\nlet base = [] in\nlet args = List.combine (clone (List.length l1) (List.length l1)) (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d,(b,c)) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| [] -> sum::a\n| x'::xs' -> \nif (x'=(-1)) then\nif (sum=9) then\n-1::0::xs'\nelse\n(sum+1)::xs'\nelse \nsum::a\nelse\nmatch a with \n| [] -> -1::(sum mod 10)::a\n| x'::xs' -> \nif (x'=(-1)) then\n-1::(sum mod 10)::a\nelse \n-1::(sum mod 10)::a\n\nin\nlet base = [] in\nlet args = List.combine (clone (List.length l1) (List.length l1)) (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (b,c) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| (len,[]) -> (len,[sum])\n| (len,x'::xs') -> \nif (x'=(-1)) then\nif (sum=9) then\n(len,-1::0::xs')\nelse\n(len,(sum+1)::xs')\nelse \n(len,sum::x'::xs')\nelse\nmatch a with \n| (len,[]) -> (len,-1::[(sum mod 10)])\n| (len,x'::xs') -> \nif (x'=(-1)) then\n(len,-1::((sum mod 10)+1)::xs')\nelse \n(len,-1::(sum mod 10)::x'::xs')\n\nin\nlet base = (List.length l1,[]) in\nlet args = (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d,(b,c)) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| [] -> sum::a\n| x'::xs' -> \nif (x'=(-1)) then\nif (sum=9) then\n-1::0::xs'\nelse\n(sum+1)::xs'\nelse \nsum::a\nelse\nmatch a with \n| [] -> -1::(sum mod 10)::a\n| x'::xs' -> \nif (x'=(-1)) then\n-1::(sum mod 10)::a\nelse \n-1::(sum mod 10)::a\n\nin\nlet base = (List.length l1,[]) in\nlet args = List.combine (clone (List.length l1) (List.length l1)) (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (b,c) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| (len,[]) -> (len,[sum])\n| (len,x'::xs') -> \nif (x'=(-1)) then\nif (sum=9) then\n(len,-1::0::xs')\nelse\n(len,(sum+1)::xs')\nelse \n(len,sum::a)\nelse\nmatch a with \n| (len,[]) -> (len,-1::[(sum mod 10)])\n| (len,x'::xs') -> \nif (x'=(-1)) then\n-1::((sum mod 10)+1)::a\nelse \n(len,-1::(sum mod 10)::x'::xs')\n\nin\nlet base = (List.length l1,[]) in\nlet args = (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (b,c) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| (len,[]) -> (len,[sum])\n| (len,x'::xs') -> \nif (x'=(-1)) then\nif (sum=9) then\n(len,-1::0::xs')\nelse\n(len,(sum+1)::xs')\nelse \n(len,sum::x'::xs')\nelse\nmatch a with \n| (len,[]) -> (len,-1::[(sum mod 10)])\n| (len,x'::xs') -> \nif (x'=(-1)) then\n-1::((sum mod 10)+1)::a\nelse \n(len,-1::(sum mod 10)::x'::xs')\n\nin\nlet base = (List.length l1,[]) in\nlet args = (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int * 'a list\n       but an expression was expected of type int list\n", "Error: This expression has type 'a * int list\n       but an expression was expected of type int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * int list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = let lre = List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 (num::xs') xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::xs') xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 (num::accum) xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::accum) xs\nin helper 0 [] lre"], "bad": ["let rec mulByDigit i l = let lrev = List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 num::xs' xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::xs' xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 num::accum xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::accum::xs", "let rec mulByDigit i l = let lre = List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 num::xs' xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::xs' xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 num::accum xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::accum xs\nin helper 0 [] lre", "let rec mulByDigit i l = let lre = List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 num::xs' xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::xs' xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 num::accum xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::accum xs\nin helper 0 [] lre", "let rec mulByDigit i l = let lre = List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 (num::xs') xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::xs' xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 num::accum xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::accum xs\nin helper 0 [] lre"], "message": ["Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "mulByDigit"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 0"], "bad": ["let_ = digitsOfInt 0"], "message": ["Error: Unbound value let_\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nlet newList = digitsOfInt n in 1 + 2"], "bad": ["let rec additivePersistence n = \nlet newList = digitsOfInt n"], "message": ["Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let _ = digitalRoot 9876"], "bad": ["let _ = digitalRoot2 9876"], "message": ["Error: Unbound value digitalRoot2\nHint: Did you mean digitalRoot?\nError: Unbound value digitalRoot2\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value digitalRoot2\nHint: Did you mean digitalRoot?\n"], "problem": "digitalRoot"}
{"hw": "hw1", "fix": ["let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nlet count = 2 in\nif(sum < 10) then count\nelse 1 + additivePersistence2 sum"], "bad": ["let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nlet count 2 in = \nif(sum < 10) then count\nelse 1 + additivePersistence2 sum"], "message": ["Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = failwith \"to be written\"", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if(List.mem h seen = false) then h::seen \nelse seen in  (* any way to not use else statement? *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true then wwhile (f b')\nelse c'"], "bad": ["let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true then wwhile (f b')\nelse c'"], "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type ('a -> 'a * bool) * 'a\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((f b),b)"], "bad": ["(\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Characters 0-1:\n  (\n  ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true then wwhile (f,b')\nelse b'", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) = wwhile ((f b),b)"], "bad": ["let fixpoint (f,b) = wwhile ((f (neg b)),b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value neg\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ( (f b),b)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type bool -> bool -> bool * bool\n       Type int is not compatible with type bool \n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let f x = let xx = x*x*x in (xx, xx < 100)"], "bad": ["(xx, xx < 100)", "let xx = x*x*x in (xx, xx < 100)"], "message": ["Error: Unbound value xx\n", "Error: Unbound value x\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(eval(e1,x,y))", "eval(Sine(VarY), 11.0 ,0)"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi * eval(e1,x,y))", "eval(Sine(VarY), 11.0 ,0)"], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval (Times(Sine(VarX),Cosine(Average(VarX,VarY))), 0.5, 0.2)"], "bad": ["let _ = eval ((Times(Sine(VarX),Cosine(Average(VarX,VarY))))), 0.5, 0.2", ")", ")"], "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> begin let ans = sin(pi *. eval(e1,x,y)); Printf.printf \"sine is \"; end\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.printf \"sine is \"\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.sprintf \"sine is \"\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.printf \"sine is \"\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend"], "message": ["Error: This expression has type unit but an expression was expected of type\n         float\n", "Error: This expression has type string but an expression was expected of type\n         float\n", "Error: This expression has type unit but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr1,0.5,0.2)", "let _ = eval ( Thresh(  VarX,  VarY,  VarX,  (Times(Sine(VarX),Cosine(Average(VarX,VarY))))), 0.5, 0.2)", "let _ = eval (Times( Sine(VarX),Cosine(Average(VarX,VarY)) ), 0.5, 0.2)", "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)); Printf.printf \"sine is \"; \n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> if(1) then begin let ans = sin(pi *. eval(e1,x,y)); Printf.printf \"sine is \"; end\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> if(1) then begin sin(pi *. eval(e1,x,y)); Printf.printf \"sine is \"; end\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> if(true) then begin let ans = sin(pi *. eval(e1,x,y)); Printf.printf \"sine is \"; end\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> if(true) then let ans = sin(pi *. eval(e1,x,y)); Printf.printf \"sine is \";\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> if(true) then begin let ans = sin(pi *. eval(e1,x,y)); Printf.printf \"sine is \"; end else 1.0\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         bool\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = build(makeRand(2,3), 2)"], "bad": ["let _ = build(rand(2,3), 2)"], "message": ["Error: Unbound value rand\nHint: Did you mean land?\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n|[] -> seen\n| h::t -> \nlet seen' = if(List.mem h seen = false) then h::seen \nelse seen in  (* any way to not use else statement? *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true then wwhile (f,b')\nelse b'", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)", "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY ->  \"y\"\n| Sine (e1) -> \"sin(pi*\" ^ exprToString e1 ^ \")\"\n| Cosine (e1) -> \"cos(pi*\" ^ exprToString e1 ^ \")\"\n| Average (e1, e2) -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1, e2) -> exprToString e1 ^ \"*\" ^exprToString e2\n|Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 \n^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"", "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "let _ = exprToString sampleExpr1", "let buildX()                       = VarX", "let buildY()                       = VarY", "let buildSine(e)                   = Sine(e)", "let buildCosine(e)                 = Cosine(e)", "let buildAverage(e1,e2)            = Average(e1,e2)", "let buildTimes(e1,e2)              = Times(e1,e2)", "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "let pi = 4.0 *. atan 1.0", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then eval(a_less, x, y)\nelse eval(b_less, x, y)", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "let _ = eval (sampleExpr,0.5,0.2)", "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "let rec build (rand, depth) = match rand(1,3) with\n|1 -> 1\n|2 -> 2\n|3->3\n|_ -> 4", "let g1 () = failwith \"to be implemented\"", "let g2 () = failwith \"to be implemented\"", "let g3 () = failwith \"to be implemented\"", "let c1 () = failwith \"to be implemented\"", "let c2 () = failwith \"to be implemented\"", "let c3 () = failwith \"to be implemented\"", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let _ = let rand = makeRand(1,3) in \nlet x = rand(1,3) in build(rand, 1)"], "bad": ["let _ = let rand = makeRand(1,3) in \nlet x = rand(1,3) in build(rand 1)", "let _ = let rand = makeRand(1,3) in \nlet x = rand(1,3) in build(rand, 1)"], "message": ["Error: This expression has type int but an expression was expected of type\n         int * int\n", "Error: This expression has type int * int -> int\n       but an expression was expected of type int\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = match (rand,depth)  with\n|(_,0) -> if((rand mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()"], "bad": ["let rec build (rand, depth) = match (r,d)  with\n|(_,0) -> if((r mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()", "let rec build (rand, depth) = match (rand,depth)  with\n|(_,0) -> if((r mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()"], "message": ["Error: Unbound value r\n", "Error: Unbound value r\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )"], "bad": ["let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( (build(rand*3), depth - 1), build((rand +1), depth - 1) )\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))\nelse if (rand mod 5 == 0) then\nbuild(rand + 3 ,depth -1)\nelse \nbuild(rand + 1, depth - 1)", "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( (build(rand), depth - 1), build((rand +1), depth - 1) )\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))\nelse if (rand mod 5 == 0) then\nbuild(rand + 3 ,depth -1)\nelse \nbuild(rand + 1, depth - 1)", "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n(*| (_, 2) -> buildTimes( (build(rand), depth - 1), build((rand +1), depth - 1) )*)\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))\nelse if (rand mod 5 == 0) then\nbuild(rand + 3 ,depth -1)\nelse \nbuild(rand + 1, depth - 1)", "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( (build(rand), depth - 1), build((rand +1), depth - 1) )"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "Error: This expression has type expr but an expression was expected of type\n         expr * expr\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), build(rand, depth - 1))\nelse \nbuild(rand + 1, depth - 1)"], "bad": ["let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))\nelse if (rand mod 5 == 0) then\nbuild(rand + 3 ,depth -1)\nelse \nbuild(rand + 1, depth - 1)", "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), \nbuild(rand, depth - 1);\nelse if (rand mod 5 == 0) then\nbuild(rand + 3 ,depth -1)\nelse \nbuild(rand + 1, depth - 1)", "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), build(rand, depth - 1)); \nelse \nbuild(rand + 1, depth - 1)"], "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * expr\n", "Characters 380-381:\n  buildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), \n            ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let g = makeRand(1, 3)"], "bad": ["let g = makeRand(seed1, seed2)"], "message": ["Error: Unbound value seed1\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = match depth with \n| 0 -> buildX() \n| 1 ->  let x = rand(1, 2) in \nif (x > 1) then buildCosine( build(rand, depth - 1) )\nelse buildSine( build(rand, depth - 1))\n| _ -> buildCosine( build(rand, depth - 1) )"], "bad": ["let rec build (rand, depth) = match depth with \n| 0 -> buildX() \n| 1 ->  let x = rand(_, _) in \nif (x > 1) then buildCosine( build(rand, depth - 1) )\nelse buildSine( build(rand, depth - 1))\n| _ -> buildCosine( build(rand, depth - 1) )"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = match depth with\n| 0 -> let z = 2 in rand(1,z)"], "bad": ["let rec build (rand, depth) = match rand with\n| (x* y-> z) -> buildX()", "let rec build (rand, depth) = match depth with |\n| 0 -> let z = 2 in rand", "let rec build (rand, depth) = match depth with |\n| 0 -> let z = 2 in rand(1,z)"], "message": ["Characters 48-49:\n  | (x* y-> z) -> buildX();;\n    ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = match depth with\n| 0 -> let z = rand in\nif( z > 1) then buildX()\nelse buildY()"], "bad": ["let rec build (rand, depth) = match depth with\n| 0 -> let z = rand in rand in \nif( z > 1) then buildX()\nelse buildY()"], "message": ["Error: Unbound value z\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildSine( build( rand, depth - 1))\nelse buildCosine( build(rand, depth - 1))\n| _ -> buildX()"], "bad": ["let rec build (rand, depth) = match depth with |\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildSine( build( rand, depth - 1))\nelse buildCosine( build(rand, depth - 1))"], "message": ["Error: Syntax error\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 3) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuild(rand, depth - 1))"], "bad": ["let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 3) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)))"], "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * expr\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n\n| _ -> let num = rand(1, 3) in build(rand, depth - num )"], "bad": ["let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n\n| _ -> let num = rand(1, 3) in build(rand, depth num )"], "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let g1 () = failwith \"to be implemented\"", "let g2 () = failwith \"to be implemented\"", "let g3 () = failwith \"to be implemented\"", "let c1 () = failwith \"to be implemented\"", "let c2 () = failwith \"to be implemented\"", "let c3 () = failwith \"to be implemented\"", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = doRandomGray(8, 72, 2140)", "let _ = doRandomGray(9, 72, 2140)", "let _ = doRandomGray(10, 72, 2140)"], "bad": ["let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 | 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)"], "message": ["Error: Syntax error\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "bad": ["let fixpoint (f,b) = wwhile (let g x = let xx = f x in (xx, xx != b) in g,b)"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "fixpoint"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = x * x in\nlet base = 0 in\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = match x with\n| [] -> a\n| h:: t -> (h*h) + sqsum t in\nlet base = 0 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = match x with\n| [] -> a\n| h:: t -> (h*h) + f base t", "let base = 0 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = match x with\n| [] -> a\n| h:: t -> (h*h) + f base t in \nlet base = 0 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = match x with\n| [] -> a\n| h:: t -> (h*h) + List.fold_left f base t in \nlet base = 0 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = fun x -> x * x in\nlet base = 0 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = fun _ x -> x * x in\nlet base = 0 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = fun a x -> x * x in\nlet base = 0 in\nList.fold_left f base xs"], "message": ["Error: This expression has type int list\n       but an expression was expected of type 'a list list\n       Type int is not compatible with type 'a list \n", "Error: Syntax error\n", "Error: Unbound value f\n", "Error: Unbound value f\n", "Error: Unbound value f\n", "Error: This expression has type int but an expression was expected of type\n         int -> int\n", "Error: This expression has type int but an expression was expected of type\n         'a -> int -> int\n", "Error: This expression has type int but an expression was expected of type\n         'a -> int -> int\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = g a x = x * x + a in\nlet base = 0 in\nList.fold_left g base xs"], "message": ["Error: Unbound value g\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsumL xs = \nlet rec helper acc rest = match rest with\n| [] -> acc * acc\n| h :: t -> h + helper (acc + h) t\nin helper 0 xs"], "bad": ["let sqsumL xs = \nlet rec helper acc rest = match xs with\n| [] -> []\n| h :: t -> h", "let sqsumL xs = \nlet rec helper acc xs = match xs with\n| [] -> acc * acc\n| h :: t -> h + helper (acc + h) t"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let rec fold_l f base xs = match xs with \n| [] -> base \n| h :: t ->  fold_l (f) base t"], "bad": ["let rec fold_l base xs = match xs with \n| [] -> base \n| h :: t ->  fold_l base t f h", "let rec fold_l f base xs = match xs with \n| [] -> base \n| h :: t ->  fold_l f base t f h", "let rec fold_l f base xs = match xs with \n| [] -> base \n| h :: t ->  fold_l (f h) base t"], "message": ["Error: Unbound value f\n", "Error: This expression has type 'a but an expression was expected of type\n         'b -> 'c -> 'a\n       The type variable 'a occurs inside 'b -> 'c -> 'a\n", "Error: This expression has type 'a but an expression was expected of type\n         'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let rec fold_l f base xs = match xs with \n| [] -> base \n| h :: t ->  let temp = fold_l f base t \nin f h temp"], "bad": ["let rec fold_l f base xs = match xs with \n| [] -> base \n| h :: t ->  f h fold_l f base t", "let rec fold_l f base xs = match xs with \n| [] -> base \n| h :: t ->  (f h) fold_l f base t"], "message": ["Error: This expression has type\n         ('a -> 'b -> 'c -> 'd -> 'e -> 'f) -> 'g -> 'a list -> 'g\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside\n       ('a -> 'b -> 'c -> 'd -> 'e -> 'f) -> 'g -> 'a list -> 'g\n", "Error: This expression has type\n         ('a -> 'b -> 'c -> 'd -> 'e -> 'f) -> 'g -> 'a list -> 'g\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside\n       ('a -> 'b -> 'c -> 'd -> 'e -> 'f) -> 'g -> 'a list -> 'g\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let rec fold_l f base xs = match xs with \n| [] -> base \n| h :: t ->  (f h) (fold_l f base t)"], "bad": ["let rec fold_l f base xs = match xs with \n| [] -> base \n| h :: t ->  f h fold_l f base t"], "message": ["Error: This expression has type\n         ('a -> 'b -> 'c -> 'd -> 'e -> 'f) -> 'g -> 'a list -> 'g\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside\n       ('a -> 'b -> 'c -> 'd -> 'e -> 'f) -> 'g -> 'a list -> 'g\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let rec fold_l f base xs = match xs with \n| [] -> base \n| h :: t -> let temp = fold_l f base t \nin f h temp"], "bad": ["let rec fold_l f base xs = match xs with \n| [] -> base \n| h :: t -> (fold_l f base t) (f h)", "let rec fold_l f base xs = match xs with \n| [] -> base \n| h :: t -> let temp = fold_l f base t \nin temp f h", "let rec fold_l f base xs = match xs with \n| [] -> base \n| h :: t -> let temp = fold_l f base t \nin temp (f h)"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n", "Error: This expression has type 'a but an expression was expected of type\n         'b -> 'c -> 'a\n       The type variable 'a occurs inside 'b -> 'c -> 'a\n", "Error: This expression has type 'a but an expression was expected of type\n         'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let rec fold_l f base xs = match xs with \n| [] -> base \n| h :: t -> f h (fold_l f base t)"], "bad": ["let rec fold_l f base xs = match xs with \n| [] -> base \n| h :: t -> f h fold_l f base t"], "message": ["Error: This expression has type\n         ('a -> 'b -> 'c -> 'd -> 'e -> 'f) -> 'g -> 'a list -> 'g\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside\n       ('a -> 'b -> 'c -> 'd -> 'e -> 'f) -> 'g -> 'a list -> 'g\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let list =  [\"hi\" ; \"iris\" ; \"elephant\"]", "let list2 = sumListL []", "let _ =  [1;2;3;4]", "let _ =  [(-1); (-2); (-3); (-4)]", "let _ =  [1]", "let _ =  [0;0;0;0]", "let sumListL = fold_l (fun h temp -> temp ^ h) \"\" list", "let concatL = fold_l (fun h temp -> temp + h*h) 0 list2"], "bad": ["let _ = concatL [\"hi\" ; \"iris\" ; \"elephant\"]", "let _ = sumListL []", "let _ = sumListL [1;2;3;4]", "let _ = sumListL [(-1); (-2); (-3); (-4)]", "let _ = sumListL [1]", "let _ = sumListL [0;0;0;0]", "let sumListL = fold_l (fun h temp -> temp ^ h) \"\" list", "let concatL = fold_l (fun h temp -> temp + h*h) 0 list2"], "message": ["Error: Unbound value concatL\nHint: Did you mean concat?\nError: Unbound value concatL\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value concatL\nHint: Did you mean concat?\n", "Error: Unbound value sumListL\n", "Error: Unbound value sumListL\n", "Error: Unbound value sumListL\n", "Error: Unbound value sumListL\n", "Error: Unbound value sumListL\n", "Error: Unbound value list\n", "Error: Unbound value list2\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let test = fun x -> x * x", "test 3"], "bad": ["let fun x -> x * x", "fun 3"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let hi = fun x -> x + x in\nlet g = fun x -> x + 3 in\nhi 3"], "bad": ["let fun x -> x + x in\nlet fun x -> x + 3 in\nfun 3", "let hi = fun x -> x + x in\nlet fun x -> x + 3 in\nhi 3", "let hi = fun x -> x + x in\nfun x -> x + 3 in\nhi 3"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let hi = fun x -> x + x in\nlet temp = fun x -> x + 3 in\ntemp 3"], "bad": ["let hi = fun x -> x + x in\nx + 3 in\nhi 3", "let hi = fun x -> x + x in\nx -> x + 3 in\nhi 3", "let hi = fun x -> x + x in\nfun x -> x + 3 in\nhi 3"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let hi = fun x -> x + x in\nlet temp = fun x -> hi 3 in\ntemp 3"], "bad": ["let hi = fun x -> x + x in\nlet temp = fun x -> hi + 3 in\ntemp 3"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let hi = fun x -> x + x in\nlet temp = fun x -> x + 3 in\nhi (temp 3)"], "bad": ["let hi = fun x -> x + x in\nlet temp = fun x -> x + 3 in\nhi temp 3"], "message": ["Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let hi = fun x -> x + 3 in\nlet temp = fun x -> x + x in\nhi (temp 3)"], "bad": ["let hi = fun x -> x + x in\nlet temp = fun x -> x + 3 in\nhi temp 3"], "message": ["Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let _ = sqsum [0;0;0]", "let pipe fs = \nlet f a x =  failwith \"TBD\" in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x =  failwith \"TBD\"", "let base = a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x =  failwith \"TBD\" in\nlet base = a in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: Unbound value a\n", "Error: Unbound value a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let _ = sqsum [0;0;0]", "let pipe fs = \nlet f a x =  failwith \"TBD\" in\nlet base = fun x -> x\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x =  failwith \"TBD\" in\nlet base = a in\nList.fold_left f base fs"], "message": ["Error: Unbound value a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let firstF = fun x -> x + x in\nlet secondF = fun x' -> x' + 3 in\nsecondF(firstF 3)"], "bad": ["let fun x -> x + x in\nlet secondF = fun x' -> x' + 3 in\nsecondF 3", "fun x -> x + x in\nlet secondF = fun x' -> x' + 3 in\nsecondF 3"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "???"}
{"hw": "hw3", "fix": ["fun x -> x + x =\nlet g = fun y -> y + y\nin g 2"], "bad": ["fun x -> x + x in\nfun y -> y + 3 in 3", "fun x -> x + x =\nlet g = a + b \nin g 2 2", "fun x -> x + x =\nlet g = 2 + 2\nin g 2"], "message": ["Error: Syntax error\n", "Error: Unbound value a\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let plus x y = x + y", "let plus1 = plus1", "plus1 1"], "bad": ["plus1 1"], "message": ["Error: Unbound value plus1\nHint: Did you mean plus?\nError: Unbound value plus1\nHint: Did you mean flush?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value plus1\nHint: Did you mean plus?\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let plus x y = x + y", "let plus1 = plus1", "plus1 1"], "bad": ["plus1 1"], "message": ["Error: Unbound value plus1\nHint: Did you mean plus?\nError: Unbound value plus1\nHint: Did you mean flush?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value plus1\nHint: Did you mean plus?\n"], "problem": "???"}
{"hw": "hw3", "fix": ["plus1 (plus1 2)"], "bad": ["plus1 plus1 2"], "message": ["Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =  a x in\nlet base = fun x -> x in \nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let test = fun x -> x * x \nin test 3", "let firstF = fun x -> x + x in\nlet secondF = fun x' -> x' + 3 in", "secondF(firstF 3)"], "bad": ["let pipe fs = \nlet f a x =  a (f x) in\nlet base = fun x -> x in \nList.fold_left f base fs", "let pipe fs = \nlet f a x =  a (x) in\nlet base = fun x -> x in \nList.fold_left f base fs", "let pipe fs = \nlet f a x =  a x in\nlet base = fun x -> x in \nList.fold_left f base fs"], "message": ["Error: Unbound value f\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =  fun x' = a x in\nlet base = fun x -> x in \nList.fold_left f base fs", "let _ = pipe [] 3"], "bad": ["let pipe fs = \nlet f a x =  let existing = a in \nlet next x in \nexisting(next) in\nlet base = fun x -> x in \nList.fold_left f base fs", "let pipe fs = \nlet f a x =  let existing = a in \nlet next = x in \nexisting(next) in\nlet base = fun x -> x in \nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =  fun x' -> a x in\nlet base = fun x -> x in \nList.fold_left f base fs", "let _ = pipe [] 3"], "bad": ["let pipe fs = \nlet f a x =  fun x' = a x in\nlet base = fun x -> x in \nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =  fun x' -> a x in\nlet base = fun x -> x in \nList.fold_left f base fs", "let _ = pipe [] 3"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x+x)] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         int -> int\n", "Error: This expression has type int but an expression was expected of type\n         int -> int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =  fun x' -> (a x) in\nlet base = fun x -> x in \nList.fold_left f base fs", "let _ = pipe [] 3"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         int -> int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =  a (f x) in\nlet base = fun x -> x in \nList.fold_left f base fs", "let _ = pipe [] 3"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         int -> int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =  failwith \"hi\" in\nlet base = fun x -> x in \nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x =  fun y -> fun x -> a in\nlet base = fun x -> x in \nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =  let g x = a x in\nlet base = fun x -> x in \nList.fold_left f base fs", "let _ = pipe [] 3"], "bad": ["let pipe fs = \nlet f a x =  let g a = let xx = f x in g in\nlet base = fun x -> x in \nList.fold_left f base fs", "let pipe fs = \nlet f a x =  let g x = a x in\nlet base = fun x -> x in \nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =  fun a -> fun x ->  a x in\nlet base = fun x -> x in \nList.fold_left f base fs", "let _ = pipe [] 3"], "bad": ["let _ = pipe [] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =  fun g -> a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "let _ = pipe [] 3"], "bad": ["let pipe fs = \nlet f a x =  let f g = fun x -> f (a x) in\nlet base = fun x -> x in\nList.fold_left f base fs", "let _ = pipe [] 3", "let pipe fs = \nlet f a x =  let g y = a (g x) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let f y z = x a", "a"], "bad": ["let f y z = x a"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let f y z = fun x -> x + x in fun x' -> x' + 3"], "bad": ["let f y z = fun x -> x + x -> fun x' -> x' + 3"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let f y z = fun x -> x + x in fun x' -> x' + 3", "f a x"], "bad": ["let f y z = y in z"], "message": ["Error: Unbound value z\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let f y z = fun x -> (y z)", "f a x"], "bad": ["f a x"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let f y z = fun x -> x + x in fun x' -> x' + 3", "f a x"], "bad": ["f a x"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let test = fun x -> x * x \nin test 3", "let firstF = fun x -> x + x in\nlet secondF = fun x' -> x' + 3 in\nsecondF(firstF 3)", "let t = fun x -> x + 1"], "bad": ["test a x"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let _ = t \"hi\"", "let a = fun x -> x + x", "let x = fun x' -> x' + 3", "x(a 3)", "let test f g = fun x -> f (f g)"], "bad": ["let _ = t \"hi\""], "message": ["Error: This expression has type string but an expression was expected of type\n         int\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let pick_one n =\nif n > 0 then (fun x -> x + 1) \nelse (fun x -> x - 1)", "(pick_one -5 6)"], "bad": ["let test f g = fun x -> fun -> y", "test a x"], "message": ["Error: Syntax error\n", "Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let _ = sepConcat \"hi\" []"], "bad": ["let _ = sepConcat sep []"], "message": ["Error: Unbound value sep\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base = sep in\nlet l = t in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = if x = \"a\" then x :: a in\nlet base = sep in\nlet l = t in\nList.fold_left f base l", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = if x = \"a\" then x :: a \nelse a in\nlet base = sep in\nlet l = t in\nList.fold_left f base l", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = if x = \"a\" then a ^ x in\nlet base = sep in\nlet l = t in\nList.fold_left f base l"], "message": ["Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This expression has type string list\n       but an expression was expected of type string\n", "Error: This expression has type string but an expression was expected of type\n         unit\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec fold_l f acc xs = match xs with \n| [] -> acc \n| h :: t -> fold_l f (f acc h) t", "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let _ = sqsum [0;0;0]", "let pipe fs = \nlet f a x = let g n = x(a n) in g in\nlet base = fun x -> x in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x  ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = if a = \"a\" then a ^ x  ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"], "message": ["Error: This expression has type string but an expression was expected of type\n         unit\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let stringOfList f l = List.map (sepConcat f) l"], "bad": ["let stringOfList f l = List.map sepConcat f l"], "message": ["Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = List.map (f sepConcat ) l"], "bad": ["let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"], "message": ["Error: This expression has type int -> string\n       but an expression was expected of type string\n", "Error: This expression should not be a function, the expected type is\nstring\n", "Error: This expression has type int -> string\n       but an expression was expected of type string\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nlet carry = \nmatch a with\n| (x,y) -> x in\nmatch x with \n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = padZero l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int list * int list\n       but an expression was expected of type 'a list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args =  in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]", "let rec mulByDigit i l = failwith \"to be implemented\"", "let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres", "let key = \"\"", "let prefix130 = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")", "let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0", "let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)", "let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))", "let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p", "let wrap_curried_2 f (a,b) = f a b"], "bad": ["let bigMul l1 l2 = \nlet f a x = \nlet (index, result) = a in\nlet (list1,list2) = x in\nmatch list2 with\n| [] -> []\n| h::t ->\nlet resList = mulByDigit h list1 in\nlet newIndex = (index + 1) in \nlet newRes = bigAdd result (mulByDigit (int_of_float (10.0 ** (float (newIndex -1)))) resList) in\n(newIndex, newRes)\nin\nlet base = (0, []) in\nlet args = ((List.rev l1),(List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"hi\" in\nlet base = failwith \"to be implemented\" in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = x in carry in\nlet base = failwith \"to be implemented\" in\nlet args =  List.rev List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = x in carry in\nlet base = failwith \"to be implemented\" in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \n1", "let base = failwith \"to be implemented\" in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nx", "let base = failwith \"to be implemented\" in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x", "let base = failwith \"to be implemented\" in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = failwith \"to be implemented\" in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nlet carry = \nmatch a with\n| (x,y) -> x in\nmatch x with \n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n|(x, y) -> x in\nlet base = (0, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n|(x, y) -> x in\nlet base = (0, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n|(x, y) -> x in carry in\nlet base = (0, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = [] in\nlet base = (0, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a * 'b -> 'c -> 'a\n       but an expression was expected of type 'a * 'b -> 'c -> 'a * 'b\n       The type variable 'a occurs inside 'a * 'b\n", "Error: Syntax error\n", "Error: This expression has type 'a * 'b -> 'c -> 'a\n       but an expression was expected of type 'a * 'b -> 'c -> 'a * 'b\n       The type variable 'a occurs inside 'a * 'b\n", "Error: This expression has type int * 'a list\n       but an expression was expected of type 'b list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let x = let y = 10 in x"], "bad": ["let x = let y = 10"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (x,y) -> x in\nmatch x with\n|(add1, add2) -> let newCarry = (carry + add1 + add2) mod 10 in\nlet num = (carry + add1 + add2) / 10 in\nmatch a with \n|(x,y) -> (newCarry, num :: y) in\nlet base = (0, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nlet carry = match a with\n| (x,y) -> x in\nmatch x with \n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in carry in \nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (x,y) -> x in\nmatch x with\n|(add1, add2) -> let newCarry = (carry + add1 + add2) mod 10 in\nlet num = (carry + add1 + add2) / 10 in\nmatch a with \n|(x,y) -> (newCarry, num :: y in\nlet base = (0, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Unbound value carry\n", "Characters 235-236:\n  |(x,y) -> (newCarry, num :: y in\n            ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (c,_) -> c in\nmatch x with\n|(add1, add2) -> let newCarry = (carry + add1 + add2) / 10 in\nlet num = (carry + add1 + add2) mod 10 in\nmatch a with \n|(x,y) -> (newCarry, num :: y) in\nlet base = (0, []) in\nlet args =  List.rev (List.combine (0::l1) (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (c,_) -> c in\nmatch x with\n|(add1, add2) -> let newCarry = (carry + add1 + add2) / 10 in\nlet num = (carry + add1 + add2) mod 10 in\nmatch a with \n|(x,y) -> (newCarry, num :: y) in\nlet base = (newCarry, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Unbound value newCarry\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"tbd\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 =\nlet g =\nlet f b x = ((mulByDigit x l1)@(clone 0 (List.length b)))::b in\nlet base = [] in\nlet args = List.rev l2 in\nlet (_,res) = (List.fold_left f base args) in\nres\nin\nList.fold_left bigAdd [] g", "let bigMul l1 l2 = \nlet f a x = \nlet (index, result) = a in\nlet (list1,list2) = x in\nmatch list2 with\n| [] -> []\n| h::t ->\nlet resList = mulByDigit h list1 in\nlet newIndex = (index + 1) in \nlet newRes = bigAdd result (mulByDigit (int_of_float (10.0 ** (float (newIndex -1)))) resList) in\n(newIndex, newRes)\nin\nlet base = (0, []) in\nlet args = ((List.rev l1),(List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type int list list\n       but an expression was expected of type 'a * 'b\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = match a with\n|(num, prod) -> (num + 1, bigAdd ((mulByDigit x (List.rev l1)) @ clone 0 num) prod) in\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = match a with\n|(num, prod) -> (num + 1, bigAdd ((mulByDigit x List.rev l1) @ clone 0 num) prod) in\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This function has type int -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type int -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let _ = padZero [1;2;3] []"], "bad": ["let _ padZero [1;2;3] []"], "message": ["Error: Syntax error\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let _ = pipe [(fun x -> x + 3);(fun x-> x + x); (fun x -> x + 1)] 3"], "bad": ["let _ = pipe [(fun x -> x + 3);(fun x-> x + x); (fun y -> x = 2); fun x -> x + 1] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x); (fun y -> x = 2); (fun x -> x + 1)] 3"], "message": ["Error: This expression has type bool but an expression was expected of type\n         int\n", "Error: This expression has type bool but an expression was expected of type\n         int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base =  fun y ->  y in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base =  fun y ->  in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\""], "bad": ["let stringOfList f l = \"[\" ^ sepConcat \";\" List.map f l ^ \"]\""], "message": ["Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let rec clone x n = \nlet rec helper a x n =\nif x <= 0 then []\nelse \nlet a' = x::a in\nhelper a' x (n-1)\nin helper [] x n"], "bad": ["let rec clone x n = \nlet helper a x n =\nif x <= 0 then []\nelse \nlet a' = x::a in\nhelper a' x (n-1)\nin helper [] x n"], "message": ["Error: Unbound value helper\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]"], "bad": ["let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif length1 > length2 then \n(l1, List.append (clone 0 (length1 - length2)) l2)\nelse if length2 > length1 then \n(List.append (clone 0 (length1 - length2)) l1, l2)\nelse (l1,l2)"], "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = 0 in\nlet args = \nlet rec pair list1 list2 = match (list1, list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| ([], []) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = 0 in\nlet args = \nlet rec pair list1 list2 = match (list1, list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z)if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair list1 list2 = \nmatch (List.rev list1, List.rev list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair list1 list2 = \nmatch (List.rev list1, List.rev list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let _ = mulByDigit 9 [9;9;9;9]"], "bad": ["let rec mulByDigit i l =\nlet rec helper a i l = match l with\n| [] -> a\n| h::t -> let a' = h*i::a in\nhelper a' i t\nin helper [] i l"], "message": ["Error: Unbound value helper\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let _ = mulByDigit 9 [9;9;9;9]"], "bad": ["let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> acc\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x - 10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin helper [] 0 i (List.rev l)"], "message": ["Error: Unbound value a\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair acc list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> pair ((h1,h2)::acc) t1 t2\n| (_ , _) -> acc\nin pair [(0,0)] (List.rev l1) (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a list -> 'b list -> 'c list\n       but an expression was expected of type 'c\n       The type variable 'c occurs inside 'a list -> 'b list -> 'c list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x =  bigAdd a x in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \n(let placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1)) in\nbuildZeros [] place in \nlet acc' = List.append (mulByDigit h l2) placeHolders) in\ndigitProducts acc' (place+1) t l2", ") in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \n(let placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in\nbuildZeros [] place) in \nlet acc' = List.append (mulByDigit h l2) placeHolders) in\ndigitProducts acc' (place+1) t l2) in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \n(let placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in\nbuildZeros [] place) in \nlet acc' = List.append (mulByDigit h l2) placeHolders in\ndigitProducts acc' (place+1) t l2)) in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \n(let placeHolders = \n(let rec buildZeros a places = if places = 0 then a else buildZeros (0::a) (places-1) in buildZeros [] place) in \nlet acc' = List.append (mulByDigit h l2) placeHolders in\ndigitProducts acc' (place+1) t l2)) in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet acc' = List.append (mulByDigit h l2) placeHolders in\ndigitProducts acc' (place+1) t l2) in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = List.append (mulByDigit h l2) placeHolders in\ndigitProducts a::acc (place+1) t l2) in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = List.append (mulByDigit h l2) placeHolders in\ndigitProducts a::acc (place+1) t l2+) in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = List.append (mulByDigit h l2) placeHolders in\ndigitProducts a::acc (place+1) t l2) \nin\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = List.append (mulByDigit h l2) placeHolders in\ndigitProducts a::acc (place+1) t l2", ") \nin\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = List.append (mulByDigit h l2) placeHolders in\ndigitProducts a::acc (place+1) t) \nin\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts a::acc (place+1) t l2) \nin\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts a::acc (place+1) t l2 in\ndigitsProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitsProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: This expression has type int -> int list -> int list -> int list\n       but an expression was expected of type int\n", "Error: Unbound value digitsProducts\nHint: Did you mean digitProducts?\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x) in\nlet base = (0, []) in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x)\n| _ -> (0, 0) in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x)\n| _ -> (0, []) in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x)\n| _ -> (0, []) in\nlet base = (0, []) in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int * int list\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = let ass y -> y in\nass y in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = function y -> y in\nList.fold_left f base fs"], "message": ["Error: Unbound value y\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "bad": ["let pipe fs = \nlet f a x =  fun b -> x (a b) in\nlet base = fun b -> b in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw1", "fix": ["let digitsOfInt n = \nlet explodeNum n =\nif (n > 0)\nthen (n mod 10) :: (digitsOfInt (n/10))\nelse []\nin listReverse (explodeNum n)"], "bad": ["let digitsOfInt n = \nlet explodeNum =\nif (n > 0)\nthen (n mod 10) :: (digitsOfInt (n/10))\nelse []\nin listReverse explodeNum n", "let digitsOfInt n = \nlet explodeNum =\nif (n > 0)\nthen (n mod 10) :: (digitsOfInt (n/10))\nelse []\nin listReverse (explodeNum n)"], "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let listReverse l = \nlet rec r e a =\nmatch a with\n| [] -> []\n| (x::l') -> x :: e :: r e l'\nin r [] l"], "bad": ["let rec listReverse l = \nmatch l with\n| [] -> []\n| (x::l') -> (listReverse l') :: x :: []"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let listReverse l = \nlet rec rev o = function\n| [] -> o\n| h::t -> rev (h::o) t\nin rev [] l"], "bad": ["let listReverse l = \nlet rec rev [] o = o\n| (hd::tl) -> rev tl (hd::o)\nin rev l []", "let listReverse l = \nlet rec rev o = \n| [] -> o\n| h::t -> rev (h::o) t\nin rev [] l"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let listReverse l = \nlet rec rev o = function\n| [] -> o\n| h::t -> rev (h::o) t\nin rev [] l"], "bad": ["let listReverse l = \nlet rec rev o = fun\n| [] -> o\n| h::t -> rev (h::o) t\nin rev [] l"], "message": ["Error: Syntax error\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let digitsOfInt n =\nlet rec digits o a = \nif (a > 0)\nthen digitsOfInt ((a mod 10)::o) (a/10)\nelse []\nin digits [] n", "let _ = digitsOfInt 3124"], "bad": ["let digitsOfInt n =\nlet rec digits o a = \nif (a > 0)\nthen (digitsOfInt ((a mod 10)::o) (a/10))\nelse []\nin digits [] n;\n\nlet _ = digitsOfInt 3124"], "message": ["Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)"], "bad": ["let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k i else assoc (d,k,t)"], "message": ["Error: Syntax error\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile (f,b)"], "bad": ["let fixpoint (f,b) = wwhile (fixpoint(f,b),b)"], "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = let helper x = \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)"], "bad": ["let fixpoint (f,b) = wwhile (if b = f b then b else f(b),b)", "let fixpoint (f,b) = wwhile (if b = f b then b else f b,b)", "let fixpoint (f,b) = wwhile (if b = (f b) then b else (f b),b)", "let fixpoint (f,b) = wwhile (if b = (f b) then (b,false) else ((f b),true),b)", "let fixpoint (f,b) = wwhile (if x = f x then (b, false) else (b, true),b)", "let fixpoint (f,b) = wwhile (if x = f x then (x, false) else (x, true),b)", "let fixpoint (f,b) = wwhile (if b = f b then (b, false) else (b, true),b)", "let fixpoint (f,b) = wwhile ((if b = f b then (b, false) else (b, true)),b)", "let fixpoint (f,b) = let helper x = \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper b,b)"], "message": ["Error: This expression has type ('a -> 'a * bool) * 'a\n       but an expression was expected of type 'a -> 'a * bool\n", "Error: This expression has type ('a -> 'a * bool) * 'a\n       but an expression was expected of type 'a -> 'a * bool\n", "Error: This expression has type ('a -> 'a * bool) * 'a\n       but an expression was expected of type 'a -> 'a * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type bool -> bool * bool\n", "Error: Unbound value x\n", "Error: Unbound value x\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type bool -> bool * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = let helper x = \nif b = (f b) then (b, false) else (f b, true) in\nwwhile (helper,b)", "l"], "bad": ["et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value l\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((if b = (f b) then (b, false) else (f b, true)),b)", "l"], "bad": ["et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value l\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with \n| 1 -> 1 \n| _ when n mod 2 = 0 -> n/2 \n| _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let fixpoint (f,b) = wwhile ((if x = (f x) then (x, false) else (f x, true)),b)", "l", "let fixpoint (f,b) = wwhile (x->(if x = (f x) then (x, false) else (f x, true)),b)", "l", "let fixpoint (f,b) = let helper x = \nif x = (f x) then (x, false) else (f x, true) in\nwwhile (helper,b)", "l"], "message": ["Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value l\n", "Characters 28-29:\n  let fixpoint (f,b) = wwhile (x->(if x = (f x) then (x, false) else (f x, true)),b);;\n                              ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Unbound value l\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e    -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e  -> \"cos (pi*\" ^ exprToString e ^ \")\"\n| Average e1 e2 -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\""], "bad": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin (pi*\" + exprToString e", "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin (pi*\" ^ exprToString e"], "message": ["Error: Unbound constructor Varx\nHint: Did you mean VarX or VarY?\n", "Error: This expression has type string but an expression was expected of type\n         int\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e    -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e  -> \"cos (pi*\" ^ exprToString e ^ \")\"\n| Average (e1,e2) -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1,e2) -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\""], "bad": ["let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e    -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e  -> \"cos (pi*\" ^ exprToString e ^ \")\"\n| Average (e1,e2) -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\""], "message": ["Error: Syntax error\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (\"not found\",3,[(1,\"found 1\");(2,\"found 2\");(3,\"found 3\")])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9;1;2;3;4;2;4;45]", "let _ = removeDuplicates [\"james\";\"james\";\"ding\";\"guan\";\"ding\"]", "let rec wwhile (f,b) = match f b with\n| (i,true) -> wwhile(f,i)\n| (i, false) -> i", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let f x = let xx = x*x*x in (xx, xx < 28) in\nwwhile (f, 3)", "let fixpoint (f,b) = let helper x = \nif x = (f x) then (x, false) else (f x, true) in\nwwhile (helper,b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with \n| 1 -> 1 \n| _ when n mod 2 = 0 -> n/2 \n| _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)", "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "let rec exprToString e = match e with\n| VarX\t\t        -> \"x\"\n| VarY\t\t        -> \"y\"\n| Sine e\t        -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e\t\t-> \"cos (pi*\" ^ exprToString e ^ \")\"\n| Average (e1,e2)       -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1,e2)\t        -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1,e2,e3,e4)  -> \"(\" ^ exprToString e1 \n^ \"<\" ^ exprToString e2 \n^ \"?\" ^ exprToString e3 \n^ \":\" ^ exprToString e4 ^ \")\"", "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "let _ = exprToString sampleExpr1", "let buildX()                       = VarX", "let buildY()                       = VarY", "let buildSine(e)                   = Sine(e)", "let buildCosine(e)                 = Cosine(e)", "let buildAverage(e1,e2)            = Average(e1,e2)", "let buildTimes(e1,e2)              = Times(e1,e2)", "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "let pi = 4.0 *. atan 1.0", "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)\n| Times (e1,e2)\t        -> eval (e1,x,y) * eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", ") else (eval(e4,x,y))"], "bad": ["let rec eval (e,x,y) = match e with\n| buildX()\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)\n| Times (e1,e2)\t        -> eval (e1,x,y) * eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", ") e", "let rec eval (e,x,y) = match e with\n| buildX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)\n| Times (e1,e2)\t        -> eval (e1,x,y) * eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", ") e", "let rec eval (e,x,y) = match e with\n| buildX\t                -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)\n| Times (e1,e2)\t        -> eval (e1,x,y) * eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", ") e", "let rec eval (e,x,y) = match e with\n| buildX                -> x\n| buildY\t        -> y \n| Sine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)\n| Times (e1,e2)\t        -> eval (e1,x,y) * eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", ") e", "let rec eval (e,x,y) = match e with\n| buildX                -> x\n| buildY\t        -> y \n| buildSine(e1)\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)\n| Times (e1,e2)\t        -> eval (e1,x,y) * eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", ") e", "let rec eval (e,x,y) = match e with\n| buildX                -> x\n| buildY\t        -> y \n| buildSine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)\n| Times (e1,e2)\t        -> eval (e1,x,y) * eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", ") e"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: Syntax error\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: Syntax error\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)", ")"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)", "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)", "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)", "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> eval (e1,x,y)<eval (e2,x,y)?eval (e3,x,y)", "):(eval(e4,x,y))", "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> eval (e1,x,y)<eval (e2,x,y)?(eval (e3,x,y)):(eval(e4,x,y))", "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> (eval (e1,x,y)<eval (e2,x,y))?(eval (e3,x,y)):(eval(e4,x,y))", "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)", "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)"], "message": ["Error: Syntax error\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: Unbound value <.\n", "Error: This expression has type float but an expression was expected of type\n         unit\n", "Error: This function has type expr * float * float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value <.\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)>=eval (e2,x,y)->  eval (e4,x,y)"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)"], "message": ["Error: Syntax error\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nlet e = build(rand,depth') in\nif depth > 0 then match rand 0 4 with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildTimes(e,e,e,e)\nelse match rand 0 1 with\n| 0 -> buildX()\n| 1 -> buildY()"], "bad": ["let rec build (rand, depth) = match rand (depth>0?(rand 0 1):(rand 2 6)) with\n| 0 -> buildX()", "let rec build (rand, depth) = match (depth>0?(rand 0 1):(rand 2 6)) with\n| 0 -> buildX()", "let rec build (rand, depth) = match rand (depth>0?0:2) (depth>0?1:6) with\n| 0 -> buildX()", "let rec build (rand, depth) = if depth > 0 then match rand 0 4 with\n| 0 -> buildX()\nelse match rand 0 1 with\n| 0 -> buildX()"], "message": ["Error: Syntax error\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand 0 4 with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand 0 1 with\n| 0 -> buildX()\n| 1 -> buildY()"], "bad": ["let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 0 then match rand 0 4 with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildTimes(e,e,e,e)\nelse match rand 0 1 with\n| 0 -> buildX()\n| 1 -> buildY()", "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 0 then match rand 0 4 with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand 0 1 with\n| 0 -> buildX()\n| 1 -> buildY()"], "message": ["Error: Unbound value depth'\nHint: Did you mean depth?\n", "Error: This expression has type 'a * 'b * 'c * 'd\n       but an expression was expected of type expr * expr\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "let g1 () = failwith \"to be implemented\"", "let g2 () = failwith \"to be implemented\"", "let g3 () = failwith \"to be implemented\"", "let c1 () = failwith \"to be implemented\"", "let c2 () = failwith \"to be implemented\"", "let c3 () = failwith \"to be implemented\"", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type test = unit -> string", "let key = \"\"", "let prefix130 = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")", "let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0", "let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)", "let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))", "let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p", "let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max"], "bad": ["let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match (rand (0 4)) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0 1) with\n| 0 -> buildX()\n| 1 -> buildY()", "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match (rand(0 4)) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0 1) with\n| 0 -> buildX()\n| 1 -> buildY()", "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"], "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "let g1 () = (8,8,8)", "let g2 () = (8,8,8)", "let g3 () = (8,8,8)", "let c1 () = (12,12,12)", "let c2 () = (12,12,12)", "let c3 () = (12,12,12)", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")"], "bad": ["let _ = build(rand,2)", "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"], "message": ["Error: This expression has type int * int -> int * int -> int\n       but an expression was expected of type int * int -> int\n       Type int * int -> int is not compatible with type int \n", "Error: Unbound value rand\nHint: Did you mean land?\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let _ = doRandomGray (g2())"], "bad": ["let _ = doRandomGray g1()", "let _ = doRandomGray g1()", "let _ = doRandomGray g1", "let _ = doRandomGray (g1())"], "message": ["Error: Unbound value doRandomGrayscale\n", "Error: This function has type int * int * int -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type int * int * int -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int * int * int -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type int * int * int -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type unit -> int * int * int\n       but an expression was expected of type int * int * int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type unit -> int * int * int\n       but an expression was expected of type int * int * int\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rand = makeRand(10,39)", "let _ = build (rand, 8)"], "bad": ["let rand = makeRand(10,39) in \nbuild (rand, 8);\n\n(* g1,g2,g3,c1,c2,c3 : unit -> int * int * int\n* these functions should return the parameters needed to create your \n* top three color / grayscale pictures.\n* they should return (depth,seed1,seed2)\n*)\n\nlet g1 () = (8,54765,10000)", "let rand = makeRand(10,39) in \nlet _ = build (rand, 8);\n\n(* g1,g2,g3,c1,c2,c3 : unit -> int * int * int\n* these functions should return the parameters needed to create your \n* top three color / grayscale pictures.\n* they should return (depth,seed1,seed2)\n*)\n\nlet g1 () = (8,54765,10000)"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec recu r = if rand(0,4) != 4 then recu else r"], "bad": ["let yes = rand(0,4) in\nlet rec recu = if yes != 4 then recu else true", "let yes = rand(0,4) in\nlet rec recu = if yes != 4 then recu", "let yes = rand(0,4) in\nlet rec recu = if yes != 4 then recu else true", "let yes = rand(0,4) in\nlet rec recu = if yes != 4 then recu else 1", "let rec recu = if rand(0,4) != 4 then recu else 1"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let _ = recu 5"], "bad": ["let rec recu r = if rand(0,4) != 4 then recu r else r"], "message": ["Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let g1 () = (10,39,12)", "let g2 () = (10,123213,567567)", "let g3 () = (12,20,50000)", "let c1 () = (12,12,12)", "let c2 () = (12,12,12)", "let c3 () = (12,12,12)", "let _ = doRandomGray (12,40,312)"], "bad": ["let _ = doRandomGray (8,10,12)", "let _ = doRandomGray (8,39,12)", "let _ = doRandomGray (9,39,12)", "let _ = doRandomGray (10,39,12)"], "message": ["Error: Unbound value doRandomGray\n", "Error: Unbound value doRandomGray\n", "Error: Unbound value doRandomGray\n", "Error: Unbound value doRandomGray\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rand = makeRand(10,12)", "let _ = build(rand,12)", "let rec recu r = if rand(0,4) != 3 then recu r else r", "let _ = recu 5", "let g1 () = (10,39,12)", "let g2 () = (12,40,312)", "let g3 () = (11,21,76)", "let c1 () = (12,12,12)", "let c2 () = (9,34,927)", "let c3 () = (8,98,42)", "let _ = doRandomGrey (g1())"], "bad": ["let rec build (rand, depth) = \nif depth > 1 then match rand (0,16) with\n| 0        ->  buildX()\n| 1\t   -> buildY()\n| 3|4      -> buildSine(build(rand,depth-1))\n| 5|6      -> buildCosine(build(rand,depth-1))\n| 7|8|9    -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 13|14|15 -> buildThresh(build(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1))\n| 16|17    -> buildDivide(build(rand,depth-1),build(rand,depth-1))\n| _        -> buildMultDiv(build(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1))\n\nelse match rand (0,2) with\n| 0 -> buildX()\n| _ -> buildY()"], "message": ["Error: Unbound value doRandomGrey\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let _ = eval_fn (Square VarX) (2.,2.)"], "bad": ["let _ = eval_fn (Square 5) (1,1)", "let _ = eval_fn (Square VarX) (1,1)", "let _ = eval_fn (Square VarX) (1.,1.)"], "message": ["Error: This function has type expr -> float * float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type expr -> float * float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int but an expression was expected of type\n         expr\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         expr\n", "Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval (Square VarX,0.9,0.9)"], "bad": ["let _ = eval (Square VarX,0.5,0.25)"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval_fn (Square VarX) (2.,1.)"], "bad": ["let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nFormat.sprintf(\"%d\" !rv)", "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nFormat.sprintf \"%d\" !rv", "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nFormat.sprintf \"%f\" !rv", "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\n\nlet _ = eval_fn (Square VarX) (2.,1.)", "let eval_fn e (x,y) = \nlet rv = eval (e,x,y)", "let eval_fn e (x,y) = \nlet _ = eval (e,x,y)", "let eval_fn e (x,y) =  eval (e,x,y)"], "message": ["Error: This expression has type float but an expression was expected of type\n         ('a, unit, string) format =\n           ('a, unit, string, string, string, string)\n           CamlinternalFormatBasics.format6\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type float but an expression was expected of type\n         'a ref\n", "Error: This expression has type float but an expression was expected of type\n         'a ref\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "eval"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a**2. +. x in\nlet base = 0. in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]"], "bad": ["let sqsum xs = \nlet f a x = a**2 + x in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let sqsum xs = \nlet f a x = a**2. + x in\nlet base = 0 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = a**2. +. x in\nlet base = 0 in\nList.fold_left f base xs"], "message": ["Error: This expression has type int but an expression was expected of type\n         float\n", "Error: Unbound value sqsum\n", "Error: Unbound value sqsum\n", "Error: Unbound value sqsum\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a x in\nlet base = in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base = x' in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base = (f s = s) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a (x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (a x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a -> x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: Unbound value x'\n", "Error: Unbound value s\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: Syntax error\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (x) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun x in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x in\nlet base = () in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x in\nlet base = x in\nList.fold_left f base fs"], "message": ["Error: Unbound value x\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x in\nlet base = base in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: Unbound value base\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x in\nlet base = fun x y -> x y in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a x in\nlet base = fun x y -> x y in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun y -> a (x y) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a x in\nlet base = fun x y -> x y in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun y -> a (x y) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun y -> a (x y) in\nlet base = fun x -> y in\nList.fold_left f base fs"], "message": ["Error: Unbound value y\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = \"\" in\nlet l = l in\nList.fold_left f base l"], "message": ["Error: Unbound value l\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = if a != \"\" then a ^ sep ^ x else x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = (fun x -> match x with\n| sep ^ y -> y\n| _ -> x) in\nlet l = sl in\nList.fold_left f base l"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = (^) h in\nlet l = t in\nList.fold_left f base l", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sep ^ x in\nlet base = (^) h in\nlet l = t in\nList.fold_left f base l", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sep ^ x in\nlet base = fun x-> h ^ x in\nlet l = t in\nList.fold_left f base l"], "message": ["Error: This expression has type string -> string\n       but an expression was expected of type string\n", "Error: This expression has type string -> string\n       but an expression was expected of type string\n", "Error: This expression has type string -> string\n       but an expression was expected of type string\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec clone x n =\nif n > 0 then\nx :: clone x (n-1)\nelse\n[]"], "bad": ["let rec clone x n =\nif n > 0 then\nx :: clone x n-1\nelse\n[]"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = if (List.length l1) > (List.length l2) then\n(l1,(clone 0 ((List.length l1) - (List.length l2)))::l2)\nelse\n((clone 0 ((List.length l2) - (List.length l1)))::l1,l2)"], "bad": ["let _ = padZero [9;9] [1;0;0;2]"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let rec combine x1 x2 = match (x1,x2) with\n| (h1::t1,h2::t2) -> (h1,h2)::combine t1 t2\n| _ -> []\nin combine [0;0;9;9] [1;0;0;2]"], "bad": ["let _ = []::3", "let combine x1 x2 match (x1,x2) with\n| (h1::t1,h2::t2) -> (h1,h2)::combine t1 t2\n| _ -> []\nin combine [0;0;9;9] [1;0;0;2]", "let combine x1 x2 = match (x1,x2) with\n| (h1::t1,h2::t2) -> (h1,h2)::combine t1 t2\n| _ -> []\nin combine [0;0;9;9] [1;0;0;2]"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list list\n", "Error: Syntax error\n", "Error: Unbound value combine\nHint: Did you mean compare?\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let _ = List.rev (List.combine [0;0;9;9] [1;0;0;2])"], "bad": ["let _ = List.rev List.combine [0;0;9;9] [1;0;0;2]"], "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> (b,(d+e)::c) \nin\nlet base = ([], [0]) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> (b,((d+e)::c) \nin\nlet base = ([], [0]) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Characters 88-89:\n  | ((b,c),(d,e)) -> (b,((d+e)::c) \n                     ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e)/10,(d+e+h) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Unbound value h\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine (0::l1) (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine (0::l1) 0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = if i > 0\nthen\nmulByDigit (i-1) (bigAdd l l)\nelse\n0"], "bad": ["let rec mulByDigit i l = mulByDigit i-1 bigAdd l l", "let rec mulByDigit i l = mulByDigit (i-1) bigAdd l l", "let rec mulByDigit i l = if i > 0\nthen\nmulByDigit (i-1) bigAdd l l\nelse\n0"], "message": ["Error: This expression has type 'a -> 'b\n       but an expression was expected of type int\n", "Error: This expression has type 'a but an expression was expected of type\n         (int list -> int list -> int list) ->\n         (int list -> int list -> int list) -> 'a\n       The type variable 'a occurs inside\n       (int list -> int list -> int list) ->\n       (int list -> int list -> int list) -> 'a\n", "Error: This expression has type 'a but an expression was expected of type\n         (int list -> int list -> int list) ->\n         (int list -> int list -> int list) -> 'a\n       The type variable 'a occurs inside\n       (int list -> int list -> int list) ->\n       (int list -> int list -> int list) -> 'a\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = match (a,x) with\n| ((b,c),d) -> (b+1,(mulByDigit d l1)::(clone 0 b))\nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = match (a,x) with\n| ((b,c),d) -> d \nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: Unbound value mulByDigit\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]", "let key = \"\"", "let prefix130 = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")", "let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0", "let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)", "let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))", "let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p", "let wrap_curried_2 f (a,b) = f a b"], "bad": ["let bigMul l1 l2 = \nlet f a x = match (a,x) with\n| ((b,c),d) -> (b+1,List.append (mulByDigit d l1) (clone 0 b))\nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let _ = bigMul [9;9;9;9] [9;9;9;9]", "let _ = bigMul [4;0] [1;0]", "let _ = bigMul [4;0] [1;1]", "let bigMul l1 l2 = \nlet f a x = match (a,x) with\n| ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)\nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let _ = bigMul [4;0] [1;1]", "let _ = bigMul [9;9;9;9] [9;9;9;9]", "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"], "message": ["Error: Unbound value mulByDigit\n", "Error: Unbound value mulByDigit\n", "Error: This expression has type int but an expression was expected of type\n         int * 'a list\n", "Error: This expression has type int but an expression was expected of type\n         int * 'a list\n", "Error: This expression has type int but an expression was expected of type\n         int * 'a list\n", "Error: Unbound value bigAdd\n", "Error: This expression has type int but an expression was expected of type\n         int * 'a list\n", "Error: This expression has type int but an expression was expected of type\n         int * 'a list\n"], "problem": "bigMul"}
{"hw": "hw1", "fix": ["let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs"], "bad": ["let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + sumList List.tl", "let rec sumList xs = \nmatch xs with\n| _ -> List.hd xs + sumList List.tl\n| [] -> []", "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + List.tl sumList"], "message": ["Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type int list\n", "Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type int list\n", "Error: This expression has type int list -> 'a list\n       but an expression was expected of type 'b list\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let rec sumList xs = \nmatch xs with\n| [] -> []\n| (x::xs') -> x"], "bad": ["let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + 2", "let rec sumList xs = \nmatch xs with\n| _ -> List.hd xs + 2\n| [] -> []", "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + (sumList List.tl xs)", "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + sumList List.tl xs"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This function has type int list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let _ = sumList []"], "bad": ["let _ = sumList [1; 2; 3; 4]"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))"], "bad": ["let rec sumList xs = \nmatch xs with\n| [] -> []\n| List.hd xs -> x", "let rec sumList xs = \nmatch xs with\n| [] -> []\n| List.hd xs -> 1", "let rec sumList xs = \nmatch xs with\n| [] -> []\n| List.hd xs -> 1", "let rec sumList xs = \nmatch xs with\n| [] -> []\n| xs -> List.hd xs + sumList List.tl xs", "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> List.hd xs + sumList List.tl xs", "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs))"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This function has type int list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Characters 54-55:\n  | xs -> (List.hd xs + (sumList (List.tl xs));;\n          ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let _ = sumList [1; 3; 5; 7; 9; 11]"], "bad": ["let _ = sumList [1; 3; 5; 7; 9; 11]\n(* uncomment and run AFTER you have implemented sumList\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n*)\nList.hd 55"], "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["55 mod 10"], "bad": ["55 % 10"], "message": ["Error: Unbound value %\n"], "problem": "???"}
{"hw": "hw1", "fix": ["3124 - 4"], "bad": ["3124 - mod 10"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nmatch n with\n| n -> 5"], "bad": ["let rec digitsOfInt n = \nmatch n with\n| n <= 0 -> []", "let rec digitsOfInt n = \nmatch n with\n| n (<=) 0 -> []", "let rec digitsOfInt n = \nmatch n with\n| n < 0 -> []", "let rec digitsOfInt n = \nmatch n with\n| (n < 0) -> []", "let rec digitsOfInt n = \nmatch n with\n| (n < 0) -> []\n| n -> 5"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Characters 40-41:\n  | (n < 0) -> [];;\n    ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Characters 40-41:\n  | (n < 0) -> []\n    ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nmatch n with\n| n -> n :: []"], "bad": ["let rec digitsOfInt n = \nmatch n with\n| n -> 5\n| (n < 0) -> []", "let rec digitsOfInt n = \nmatch n with\n| n -> 5\n| n < 0 -> []", "let rec digitsOfInt n = \nmatch n with\n| n -> 5\n| 0 -> []"], "message": ["Characters 49-50:\n  | (n < 0) -> [];;\n    ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nmatch n with\n| (n::ns) -> n :: ns"], "bad": ["let rec digitsOfInt n = \nmatch n with\n| 0 -> [] :: ns\n| n -> n :: ns", "let rec digitsOfInt n = \nmatch n with\n| n -> n :: ns"], "message": ["Error: Unbound value ns\n", "Error: Unbound value ns\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nmatch n with\n| n::ns -> (n::ns)"], "bad": ["let rec digitsOfInt n = \nmatch n with\n| n -> (n::ns)"], "message": ["Error: Unbound value ns\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let ns = []", "let rec digitsOfInt n = \nmatch n with\n| n -> (n::ns)"], "bad": ["let _ = digitsOfInt 3124"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> List.hd ((n mod 10)::ns)"], "bad": ["let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> List.hd (n mod 10)::ns"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 3124"], "bad": ["let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))", "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))::ns", "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))"], "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 3124"], "bad": ["let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((digitsOfInt (n / 10))::((n mod 10)::ns))", "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> (digitsOfInt (n / 10))::((n mod 10)::ns)", ")", "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> (digitsOfInt (n / 10))::((n mod 10)::ns)", "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: Syntax error\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 3124"], "bad": ["let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> (digitsOfInt (n / 10))::(n mod 10)", "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> (digitsOfInt (n / 10))::(n mod 10)", "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["digitsOfInt (-1)"], "bad": ["digitsOfInt -5", "digitsOfInt (-5)"], "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n", "Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec additivePersistence n =", "let rec digitalRoot n = sumList (digitsOfInt n)"], "bad": ["let rec additivePersistence n =", "let rec digitalRoot n = \nsumList digitsOfInt n", "let rec additivePersistence n =", "let rec digitalRoot n = \nsumList (digitsOfInt n)"], "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Syntax error\n", "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Syntax error\n"], "problem": "digitalRoot"}
{"hw": "hw1", "fix": ["digitalRoot 9876"], "bad": ["let rec digitalRoot n = \nsumList (digitsOfInt n)"], "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "digitalRoot"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4]"], "bad": ["let rec listReverse l = \nlet l' = [] in\nmatch l with\n| [] -> l'\n| h::t -> (List.hd l)::(listReverse (List.tl l))"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4]", "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]"], "bad": ["let rec listReverse l = \nlet rec lr l' =\nmatch l with\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] listReverse", "let rec listReverse l = \nlet rec lr l' = function\nmatch l with\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] listReverse", "let rec listReverse l = \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] listReverse", "let listReverse l = \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] listReverse", "let listReverse l = \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] l"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b -> 'c\n", "Error: Syntax error\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'b list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let palindrome w = \nexplode w = listReverse (explode w )"], "bad": ["palindrome \"hello\""], "message": ["Error: Unbound value hello\n"], "problem": "palindrome"}
{"hw": "hw1", "fix": ["additivePersistence 98765"], "bad": ["additivePersistence 1111"], "message": ["Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: (listReverse ( digitsOfInt (n / 10))) )"], "bad": ["let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: listReverse ((( digitsOfInt (n / 10) ) )", "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: listReverse ( digitsOfInt (n / 10) )", "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: listReverse ( digitsOfInt (n / 10) )", "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: listReverse ( digitsOfInt (n / 10) ) )"], "message": ["Characters 94-95:\n  else ((n mod 10) :: listReverse (( digitsOfInt (n / 10) ) );;\n       ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Characters 121-122:\n  else ((n mod 10) :: listReverse ((( digitsOfInt (n / 10) ) );;\n                                  ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Characters 94-95:\n  else ((n mod 10) :: listReverse ( digitsOfInt (n / 10) );;\n       ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Characters 94-95:\n  else ((n mod 10) :: listReverse ( digitsOfInt (n / 10) );;\n       ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 3124"], "bad": ["let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10) :: []) )", "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)) ) :: []", "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)) )"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list list\n       but an expression was expected of type int list\n       Type int list is not compatible with type int \n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse let rev = listReverse ns' in\n((n mod 10) ::  ( digitsOfInt (n / 10)) )"], "bad": ["let listReverse l = \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] l"], "message": ["Error: Unbound value ns'\nHint: Did you mean ns?\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse let listReverse ns in\n((n mod 10) ::  ( digitsOfInt (n / 10)) )"], "bad": ["let rec digitsOfInt n =\nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse let rev = listReverse ns in\n((n mod 10) ::  ( digitsOfInt (n / 10)) )"], "message": ["Error: Unbound value ns'\nHint: Did you mean ns?\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "let digitsOfInt n = \nlet xxx = function \nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))\nin listReverse (xxx n)"], "bad": ["let rec digitsOfInt n = \nlet this = function\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))\nin this listReverse n", "let rec digitsOfInt n = \nlet this = function\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))\nin this listReverse n", "let rec digitsOfInt n = \nlet this = \nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))\nin this listReverse n"], "message": ["Error: This pattern matches values of type int\n       but a pattern was expected which matches values of type 'a list\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nlet xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( digitsOfInt (n / 10)))\nin listReverse (xxx n)"], "bad": ["let digitsOfInt n = \nlet xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))\nin listReverse (xxx n)", "let digitsOfInt n = \nlet xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( xxx (n / 10)))\nin listReverse (xxx n)", "let digitsOfInt n = \nlet rec xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( xxx (n / 10)))\nin listReverse (xxx n)", "let rec digitsOfInt n = \nlet xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( digitsOfInt (n / 10)))\nin listReverse (xxx n)", "let listReverse l = \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] l"], "message": ["Error: Syntax error\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: Unbound value xxx\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "problem": "listReverse"}
{"hw": "hw2", "fix": ["let rec bssoc (d,k,l) = \nmatch d with\nd -> d"], "bad": ["let rec bssoc (d,k,l) = \nmatch d with\nd -> v"], "message": ["Error: Unbound value v\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rec bssoc (d,k,l) = \nmatch d with\n| h :: t -> l\n| _ -> d"], "bad": ["let rec bssoc (d,k,l) = \nmatch d with\nh :: t -> l\n_ -> d"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rec bssoc (d,k,l) = \nmatch d with\n| h :: t -> if h = k\nthen h"], "bad": ["let rec bssoc (d,k,l) = \nmatch d with\n| h :: t -> if h = k\nthen h\n| _ -> d"], "message": ["Error: This expression has type unit list\n       but an expression was expected of type unit\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rec bssoc (d,k,l) = \nmatch l with \n| [] -> d\n| h :: t ->\nmatch h with\n| (k', d') -> d'"], "bad": ["let rec bssoc (d,k,l) = \nmatch l with \n| [] -> v\n| h :: t ->\nmatch h with\n| (k, d) -> d"], "message": ["Error: Unbound value v\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))\n\nremoveDuplicates [1;6;2;4;12;2;13;6;9]"], "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["List.mem 1 seal = true"], "bad": ["if List.mem 1 seal\nthen 4 :: seal", "if List.mem 1 seal\nthen 3", "if (List.mem 1 seal)\nthen 3", "if (List.mem 1 seal)\nthen (3)", "if List.mem 1 seal = true\nthen 12", "if List.mem 1 seal = true\nthen false", "if List.mem 1 seal = true"], "message": ["Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This variant expression is expected to have type unit\n       The constructor false does not belong to type unit\n", "Error: Syntax error\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nif List.mem seen' seen = false\nthen seen' :: seen", "let rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nif List.mem seen' seen = false\nthen seen' :: seen", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nif List.mem seen' seen = false\nthen seen' :: seen", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nif (List.mem seen' seen = false)\nthen seen' :: seen", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nif (List.mem seen' seen = false)\nthen seen' :: seen", "let rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nif (List.mem seen' seen = false)\nthen (seen' :: seen)", "if 1 < 2\nthen 12", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen", "let rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen"], "message": ["Error: Syntax error\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = t\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = t\nhelper (seen',rest'); \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = t\nhelper (seen',rest')"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) =\nlet f' = f b in \nmatch f' with\n| (b', false) -> b'\n| (b', true) -> wwhile (f, b')"], "bad": ["let rec wwhile (f,b) =\nlet b' =\nmatch x' with\n| (b', false) -> b'\n| (b', true) -> wwhile (f, b')\nin f b", "let rec wwhile (f,b) =\nlet b' =\nmatch b' with\n| (b', false) -> b'\n| (b', true) -> wwhile (f, b')\nin f b"], "message": ["Error: Unbound value x'\n", "Error: Unbound value b'\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) =\nlet f' = f b in \nmatch f' with\n| (b', false) -> b'\n| (b', true) -> wwhile (f, b')", "let fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)", "let fixpoint (f,b) = wwhile ((let f x = let xx = x*x*x in (xx, xx < 100)),b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x))", "let collatz n = \nmatch n with \n1 -> 1 \n| _ when \nn mod 2 = 0 -> n/2 | _ -> 3*n + 1", "collatz 3", "let f x = let xx = x*x*x in (xx,xx<100)"], "bad": ["let fixpoint (f,b) = wwhile ((let f x = let xx = x*x*x in (xx, xx < 100),b)", "let fixpoint (f,b) = wwhile ((let f x = let xx = x*x*x in (xx, xx < 100)),b)"], "message": ["Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile (\n(let f' f b = let g f b =  g(b) in (b , b = g'),b))", "let g x = truncate (1e6 *. cos (1e-6 *. float x))", "let collatz n = \nmatch n with \n1 -> 1 \n| _ when \nn mod 2 = 0 -> n/2 | _ -> 3*n + 1", "collatz 3", "let f x = let xx = x*x*x in (xx,xx<100)", "let f b = let g' = g(b) in (b, b = g')", "f collatz"], "bad": ["let fixpoint (f,b) = wwhile (\n(let f' f b =\nlet f b = let g' = g(b) in (b , b = g')\n),b)", "let fixpoint (f,b) = wwhile (\n(let f' f b =\nlet f b = let g' = g(b) in (b , b = g')", "let fixpoint (f,b) = wwhile (\n(let f' f b = let f b = let g' = g(b) in (b , b = g')),b)", "let fixpoint (f,b) = wwhile (\n(let f' f b = let g f b =  g(b) in (b , b = g')),b)", "let fixpoint (f,b) = wwhile (\n(let f' f b = let g f b =  g(b) in (b , b = g'),b)"], "message": ["Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile (let whilesFun f' b' = let fOfB = f(b) in (b , b = fOfB) in whilesFun (f, b), b)"], "bad": ["let fixpoint (f,b) = wwhile (\n(let whilesFun = let fOfB = f(b) in (b , b = fOfB),b))", "let fixpoint (f,b) = wwhile ((let whilesFun = let fOfB = f(b) in (b , b = fOfB)), b)", "let fixpoint (f,b) = wwhile (let whilesFun = let fOfB = f(b) in (b , b = fOfB), b)", "let fixpoint (f,b) = wwhile (let whilesFun = let fOfB = f(b) in (b , b = fOfB)), b", "let fixpoint (f,b) = wwhile ((let whilesFun = let fOfB = f(b) in (b , b = fOfB)), b)"], "message": ["Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| (k', d') :: t ->\nif k = k'\nthen d'\nelse assoc (d, k, t)", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nmatch List.mem h seen with\ntrue -> seen\n| false -> h :: seen\nin\n\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let rec wwhile (f,b) =\nlet f' = f b in \nmatch f' with\n| (b', false) -> b'\n| (b', true) -> wwhile (f, b')", "let fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)", "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f'(b') in (b' , b' = fOfB) in whilesFun (f, b)), b)"], "bad": ["let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b' , b' = fOfB) in whilesFun (f, b)), b)", "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f'(b') in (b' , b' = fOfB) in whilesFun (f, b)), b)"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b' , b' = fOfB) in whilesFun f), b)"], "bad": ["let fixpoint (f,b) = wwhile ((let whilesFun f' = let fOfB = f'(b') in (b' , b' = fOfB) in whilesFun f), b)"], "message": ["Error: Unbound value b'\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x))", "let whilesFun f' b' = let fOfB = f' (b') in (b' , b' = fOfB) in whilesFun g", ")"], "bad": ["let whilesFun f' b' = let fOfB = f' (b') in (b' , b' = fOfB) in whilesFun f", ")"], "message": ["Error: This expression has type int -> int * bool\n       but an expression was expected of type int -> int\n       Type int * bool is not compatible with type int \n", "Error: Syntax error\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let whilesFun f' b' = let fOfB = f' (b') in (b' , b' = fOfB) in whilesFun g"], "bad": ["let whilesFun f' = let fOfB = f' (b') in (b' , b' = fOfB) in whilesFun g"], "message": ["Error: Unbound value b'\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let whilesFun f' b' = let fOfB = f' (b') in (b' , b' = fOfB)"], "bad": ["let fOfB = f' (b') in (b' , b' = fOfB)", "let fOfB = g (b') in (b' , b' = fOfB)", "let fOfB b' = g (b') in (b' , b' = fOfB)", "let fOfB b' = g (b') in (b', b' = fOfB)", "let fOfB b' = g (b') in (x, b' = fOfB)", "let fOfB b' = let b' = g (b') in (b', b' = fOfB)"], "message": ["Error: Unbound value f'\n", "Error: Unbound value b'\n", "Error: Unbound value b'\n", "Error: Unbound value b'\n", "Error: Unbound value b'\nError: Unbound value h\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value b'\n", "Error: Unbound value fOfB\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun (f)), b)"], "bad": ["let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun f), b)"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x))", "fixpoint (g,0)"], "bad": ["let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB b' = f' (b') in (b', fOfB = b') in whilesFun (f)), b)"], "message": ["Error: Unbound value b'\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((let whilesFun f' b' = (b', f' (b') = b') in whilesFun (f)), b)"], "bad": ["let fixpoint (f,b) = wwhile ((let whilesFun f' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun (f)), b)", "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun (f)), b)"], "message": ["Error: This expression has type int but an expression was expected of type\n         int -> int\n", "Error: Unbound value b'\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x))", "fixpoint (g,0)"], "bad": ["let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' b in (fOfB, fOfB = b') in whilesFun (f)), b)"], "message": ["Error: Unbound value fixpoint\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x))", "fixpoint (g,0)"], "bad": ["let fixpoint (f,b) = wwhile ((let whilesFun f' = let fOfB = f' b in (fOfB, fOfB = b) in whilesFun (f)), b)", "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' b') in (fOfB, fOfB = b') in whilesFun (f)", "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (fOfB, fOfB = b') in whilesFun (f)), b)"], "message": ["Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Syntax error: operator expected.\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["VarX"], "bad": ["VarX"], "message": ["Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let VarX = 2"], "bad": ["Sine VarX"], "message": ["Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"], "problem": "???"}
{"hw": "hw2", "fix": ["VarX"], "bad": ["int", "int 2", "2"], "message": ["Error: Unbound value expr\nHint: Did you mean exp?\n", "Error: Unbound value int\n", "Error: Unbound value int\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let mars k = match k with\n| Sine x -> x\nin mars (Sine VarX)", "type tree = \n| Leaf of int\n| Node of tree * tree"], "bad": ["Sine Cosine VarX", "Sine (Cosine VarX)"], "message": ["Error: The constructor Cosine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "Error: Syntax error\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with\n| VarX -> e", "exprToString 2"], "bad": ["let rec exprToString e = match e with\n| VarX -> x", "let rec exprToString e = match e with\n| VarX -> e"], "message": ["Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: Unbound value x\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with\n| VarX -> \"x\""], "bad": ["exprToString VarX"], "message": ["Error: This expression has type int but an expression was expected of type\n         expr\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["exprToString VarX"], "bad": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"Sin(\" ^ (exprToString e1) ^ \")\""], "message": ["Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["exprToString (VarX, VarY)"], "bad": ["exprToString (Sine VarX)"], "message": ["Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["exprToString (Sine VarX)"], "bad": ["exprToString (Sine (Sine VarX))"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine e1 -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"\n| Average (e1, e2) -> \"((\" ^ (exprToString e1) ^ \"+\" ^ (exprToString e2) ^ \")\" ^ \"/2)\""], "bad": ["exprToString (Average(VarX,VarY))"], "message": ["Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["exprToString (Sine (Cosine VarX))", "exprToString (Sine VarX)", "exprToString (Average(VarX,VarY))", "exprToString (Times(VarX,VarY))"], "bad": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine e1 -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"\n| Average (e1, e2) -> \"((\" ^ (exprToString e1) ^ \"+\" ^ (exprToString e2) ^ \")\" ^ \"/2)\"\n| Times (e1, e2) -> (exprToString e1) ^ \"*\" ^ (exprToString e2)"], "message": ["Error: This variant pattern is expected to have type expr\n       The constructor Time does not belong to type expr\nHint: Did you mean Times?\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x"], "message": ["Error: Syntax error\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["eval ((VarX * VarY), 1, 2)"], "bad": ["eval"], "message": ["Error: This expression has type expr but an expression was expected of type\n         int\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["eval (Times (VarX,VarY), 1, 2)"], "bad": ["eval (Times(VarX,VarY), 1, 2)"], "message": ["Error: This expression has type expr but an expression was expected of type\n         int\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["eval ((Sine (VarY)), 0.2, 0.3)"], "bad": ["eval (Sine (VarX,VarY), 0.2, 0.3)", "eval ((Sine (VarX,VarY)), 0.2, 0.3)", "eval ((Sine (VarX, VarY)), 0.2, 0.3)", "eval ((Sine (VarX)), 0.2, 0.3)"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1, x, y))\n| Cosine e1 -> cos(pi *. eval (e1, x, y))\n| Average (e1, e2) -> (eval (e1, x, y) +. eval (e2, x, y)) /. 2.0\n| Times (e1, e2) -> (eval (e1, x, y) *. eval (e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif ((eval (e1, x, y)) < (eval (e1, x, y))\nthen x\nelse y"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1, x, y))\n| Cosine e1 -> cos(pi *. eval (e1, x, y))\n| Average (e1, e2) -> (eval (e1, x, y) +. eval (e2, x, y)) /. 2.0\n| Times (e1, e2) -> (eval (e1, x, y) *. eval (e2, x, y))"], "message": ["Error: Syntax error\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["eval ((Sine (VarX)), 1.0, 0.3)"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1, x, y))\n| Cosine e1 -> cos(pi *. eval (e1, x, y))\n| Average (e1, e2) -> (eval (e1, x, y) +. eval (e2, x, y)) /. 2.0\n| Times (e1, e2) -> (eval (e1, x, y) *. eval (e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif (eval (e1, x, y)) < (eval (e1, x, y))\nthen x\nelse y"], "message": ["Characters 298-299:\n  if ((eval (e1, x, y)) < (eval (e1, x, y))\n     ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "eval"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = x * x in\nlet base = 0 in\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = x * x +  in\nlet base = a in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = x * x in\nlet base = a in\nList.fold_left f base xs"], "message": ["Error: Syntax error\n", "Error: Unbound value a\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = base + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = f base (x * x) in\nlet base = 0 in\nList.fold_left f base xs"], "message": ["Error: Unbound value base\n", "Error: Unbound value f\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = a in\nList.fold_left f base xs"], "message": ["Error: Unbound value a\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\n(* Should this be able to hand strings or other types? *)\nlet base = 0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\n(* Should this be able to hand strings or other types? *)\nlet base = 0\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\n(* Should this be able to hand strings or other types? *)\nlet base = 0\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\n(* Should this be able to hand strings or other types? *)\nlet base = 0 in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let _ = pipe [] 3", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let pipe fs = \nlet f a x = x f in\n(* Should this be able to hand strings or other types? *)\nlet base = 0 in\nList.fold_left f base fs"], "message": ["Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value f\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let hi = fun x -> x + x", "(hi)"], "bad": ["(_)"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = pipe in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\n(* Should this be able to hand strings or other types? *)\nlet base = x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = base in\nList.fold_left f base fs"], "message": ["Error: Unbound value x\n", "Error: Unbound value x\n", "Error: Unbound value x\n", "Error: Unbound value base\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         (int -> int) list\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = [] in\nlet l = sl in\nList.fold_left f base l"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = \"\" in\nlet l = h :: t in\nList.fold_left f base l"], "bad": ["let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]"], "message": ["Error: This expression has type string but an expression was expected of type\n         string list\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let _ = sepConcat \"X\" [\"hello\"]"], "bad": ["let _ = sepConcat \"X\" [\"hello\"]\n\n*"], "message": ["Error: Syntax error\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let stringOfList f l = \nList.map (sepConcat \"; \") l"], "bad": ["let stringOfList f l = \nList.map sepConcat (\"; \")", "let stringOfList f l = \nList.map sepConcat (\"; \" l)", "let stringOfList f l = \nList.map sepConcat \"; \" l"], "message": ["Error: This expression has type string but an expression was expected of type\n         string list\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = \nsepConcat \"; \" (List.map f l)"], "bad": ["let stringOfList f l = \nList.map (sepConcat \"; \") l l", "let stringOfList f l = \nList.map (sepConcat \"; \" l) l", "let stringOfList f l = \nList.map (sepConcat (\"; \" l)) l", "let stringOfList f l = \nList.map (sepConcat (\"; \" l))", "let stringOfList f l = \nList.map (sepConcat \"; \" l)", "let stringOfList f l = \nsepConcat \"; \" List.map f l"], "message": ["Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n", "Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = \n\"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\""], "bad": ["let stringOfList f l = \n\"[\" ^ sepConcat \"; \" (List.map f l) \"]\""], "message": ["Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs"], "message": ["Error: Unbound value x\n", "Error: Unbound value a\n", "Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = () in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = _ in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs\n\npipe [] 3", "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs\n\npipe [] 3"], "message": ["Error: This expression has type\n         (((((int -> int) -> int -> int) list -> int -> int) ->\n           ((int -> int) -> int -> int) list -> int -> int) ->\n          (((int -> int) -> int -> int) list -> int -> int) ->\n          ((int -> int) -> int -> int) list -> int -> int)\n         list -> int\n       but an expression was expected of type\n         (((((int -> int) -> int -> int) list -> int -> int) ->\n           ((int -> int) -> int -> int) list -> int -> int) ->\n          (((int -> int) -> int -> int) list -> int -> int) ->\n          ((int -> int) -> int -> int) list -> int -> int)\n         list -> 'a -> 'b\n       Type int is not compatible with type 'a -> 'b \n", "Error: This expression has type\n         (((((int -> int) -> int -> int) list -> int -> int) ->\n           ((int -> int) -> int -> int) list -> int -> int) ->\n          (((int -> int) -> int -> int) list -> int -> int) ->\n          ((int -> int) -> int -> int) list -> int -> int)\n         list -> int\n       but an expression was expected of type\n         (((((int -> int) -> int -> int) list -> int -> int) ->\n           ((int -> int) -> int -> int) list -> int -> int) ->\n          (((int -> int) -> int -> int) list -> int -> int) ->\n          ((int -> int) -> int -> int) list -> int -> int)\n         list -> 'a -> 'b\n       Type int is not compatible with type 'a -> 'b \n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = function e -> e in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = fun ee in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = fun e in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = fun in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = function e in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x (a) in\nlet base = [] in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a x in\nlet base = [] in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = base in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = base' in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n", "Error: Unbound value base\n", "Error: Unbound value base'\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base =  Nil in\nList.fold_left f base fs"], "message": ["Error: Unbound constructor Nil\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun a -> a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = let x a = a in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: Syntax error\n", "Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n", "Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun a -> a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun a -> a in\nlet base = fun x -> a in\nList.fold_left f base fs"], "message": ["Error: Unbound value a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         int -> int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun x -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun x -> fun a -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun x -> x x in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun a -> x x in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun x -> fun a -> a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun x -> fun a -> x (a) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun x -> fun a -> x in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun x a -> a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun a -> fun x -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun a -> a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun x a -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun (x a) -> a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Characters 31-32:\n  let f a x = fun (x a) -> a in\n                  ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun x -> x in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = let x a = a in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun a in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x a"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x(a) in\nlet base = 0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun a x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun a x -> a in\nlet base =  in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun a x -> a in\nlet base = 0 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x a -> a in\nlet base = 0 in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n", "Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'b -> 'a\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'b -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x(a) in\nlet base = let f x = x in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x(a) in\nlet base = fun x -> b in\nList.fold_left f base fs"], "message": ["Error: Unbound value b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = let a = x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = let a = x in x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = let a = x in a(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = let a = x in a(x) in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = let a = x in x(x) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun x -> fun a -> x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun x -> fun a in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x -> x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n", "Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n", "Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun a -> fun a -> x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun a -> fun a -> a(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun a -> fun a -> x(x) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun a -> fun x -> f x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun a -> fun x -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun a -> fun x -> x (a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x -> (x a)  in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x -> (x a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x -> (x (a)) in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x - in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x  in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: Unbound value f\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n", "Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n", "Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n", "Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x in\nlet base = a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x in\nlet base = f x\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x in\nlet base = f x in \nList.fold_left f base fs"], "message": ["Error: Unbound value a\n", "Error: Syntax error\n", "Error: Unbound value x\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x in\nlet base = fun x -> fun a -> a in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x in\nlet base = fun x -> fun a in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x(x) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a(x) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let rec padZero l1 l2 = \n(clone 0 (List.length l1 - List.length l2)) @ l2"], "bad": ["let rec padZero l1 l2 = \n(clone 0 List.len l1 - l2)", "let rec padZero l1 l2 = \n(clone 0 (List.len l1 - l2)) @ smaller", "let rec padZero l1 l2 = \n(clone 0 (List.length l1 - l2)) @ smaller", "let rec padZero l1 l2 = \n(clone 0 (List.length l1 - l2)) @ l2"], "message": ["Error: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value List.len\n", "Error: Unbound value smaller\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = let x' = x' x a in \nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = let a = x(a) in \nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = let a = x a in \nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun x' -> a x in \nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = let x' = x' (x a) in \nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = let x' = x' (x a) in x' x a in \nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: Unbound value x'\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun x' -> x (a x') in \nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let pipe fs = \nlet f a x = fun x' -> x' (a x) in \nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x' -> x' (x a) in \nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type int but an expression was expected of type\n         int -> int\n", "Error: This expression has type ('a -> 'a) -> 'a -> 'a\n       but an expression was expected of type ('a -> 'a) -> 'a\n       The type variable 'a occurs inside 'a -> 'a\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let rec padZero l1 l2 = \nif List.length l1 > List.length l2\nthen (l1, (clone 0 (List.length l1 - List.length l2)) @ l2)\nelse (clone 0 (List.length l2 - List.length l1) @ l1, l2)", "let _ = padZero [9;9] [1;0;0;2]"], "bad": ["let rec padZero l1 l2 = \nif List.length l1 > List.length l2\nthen (l1, (clone 0 (List.length l1 - List.length l2)) @ l2)\nelse (clone 0 (List.length l2 - List.length l1) @ l1, l2)\n\npadZero [9;9] [8;8;8]"], "message": ["Error: This expression has type int list * int list\n       This is not a function; it cannot be applied.\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = (l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int list * int list\n       but an expression was expected of type ('a -> 'b list) * 'a\n       Type int list is not compatible with type 'a -> 'b list \n", "Error: This expression has type int list * int list\n       but an expression was expected of type ('a -> 'b list) * 'a\n       Type int list is not compatible with type 'a -> 'b list \n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  [0], [0]in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = (0, 0) in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [0] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [a] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [0, 0] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [_, _] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [,] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [(), ()] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  res in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: Unbound value a\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type (int * int) list\n       but an expression was expected of type 'a * 'b\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type (unit * unit) list\n       but an expression was expected of type 'a * 'b\n", "Error: Unbound value res\nHint: Did you mean ref?\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun x'-> x (a x') in \nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun x' x a -> x (a x') in \nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type\n         'a -> ('b -> 'c) -> ('a -> 'b) -> 'c\n       The type variable 'a occurs inside ('b -> 'c) -> ('a -> 'b) -> 'c\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun x'-> x (a x') in \nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun x' a-> x (a x') in \nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'c\n       The type variable 'a occurs inside ('a -> 'b) -> 'c\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let c = 3"], "bad": ["let c = 3\nz + c"], "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let (x, y) = z"], "bad": ["z + c"], "message": ["Error: This expression has type int * int\n       but an expression was expected of type int\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let z = (1, 2)", "let c = 3", "let (x, y) = z in\nx + y", "let pipe fs = \nlet f a x = fun x' -> x (a x') in \nlet base = fun x -> x in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = \n\"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n = match n with\n| n when n <= 0 -> []\n| _ -> x :: (clone x (n-1))", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let rec padZero l1 l2 = \nif List.length l1 > List.length l2\nthen (l1, (clone 0 (List.length l1 - List.length l2)) @ l2)\nelse (clone 0 (List.length l2 - List.length l1) @ l1, l2)", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let rec removeZero l = match l with\n[] -> []\n| h::t ->\nif h = 0\nthen removeZero t\nelse l", "let _ = removeZero [0;0;0;1;0;0;2]", "let _ = removeZero [9;9]", "let _ = removeZero [0;0;0;0]", "let ee = [1;2]", "let zz = [3;4]", "List.combine ee zz", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\nx (sum / 10) :: (sum mod 10) :: a"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, (sum mod 10) :: a)\nin\nlet base =  0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, (sum mod 10) :: a)\nin\nlet base =  0 [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, (sum mod 10) :: a)\nin\nlet base =  0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, (sum mod 10) :: a)\nin\nlet base =  (0, [0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, (sum mod 10) :: a)\nin\nlet base = [0], [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, ((sum mod 10) :: a))\nin\nlet base = 0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, (sum mod 10) :: a)\nin\nlet base = 0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type\n         int list -> int * int -> int -> int * int list\n       but an expression was expected of type\n         int list -> int * int -> int list\n       Type int -> int * int list is not compatible with type int list \n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type\n         int list -> int * int -> int -> int * int list\n       but an expression was expected of type\n         int list -> int * int -> int list\n       Type int -> int * int list is not compatible with type int list \n", "Error: This expression has type\n         int list -> int * int -> int -> int * int list\n       but an expression was expected of type\n         int list -> int * int -> int list\n       Type int -> int * int list is not compatible with type int list \n", "Error: This expression has type\n         int list -> int * int -> int -> int * int list\n       but an expression was expected of type\n         int list -> int * int -> int list\n       Type int -> int * int list is not compatible with type int list \n", "Error: This expression has type\n         int list -> int * int -> int -> int * int list\n       but an expression was expected of type\n         int list -> int * int -> int list\n       Type int -> int * int list is not compatible with type int list \n", "Error: This expression has type\n         int list -> int * int -> int -> int * int list\n       but an expression was expected of type\n         int list -> int * int -> int list\n       Type int -> int * int list is not compatible with type int list \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let listerine = [z;z]"], "bad": ["(10 / 2), (8 mod 2) :: listerine", "[(10 / 2), (8 mod 2)] :: listerine"], "message": ["Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n", "Error: This expression has type (int * int) list\n       but an expression was expected of type (int * int) list list\n       Type int * int is not compatible with type (int * int) list \n"], "problem": "???"}
{"hw": "hw3", "fix": ["(10/2), (8 mod 2)"], "bad": ["(10 / 2), (8 mod 2) :: listerine"], "message": ["Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n"], "problem": "???"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s)\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \n( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a\nin\nlet base = 0, [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (s, t) = x in \n( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a\nin\nlet base = 0, [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (s, t) = x in \n( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a\nin\nlet base = 0, [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (s, t) = x in \n( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a\nin\nlet base = 0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (s, t) = x in \n( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a\nin\nlet base = [0, 0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a\nin\nlet base = 0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) ) :: a\nin\nlet base = 0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) ) :: a\nin\nlet base = 0, [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) ) :: a\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type\n         (int * int) list -> int * int -> int -> (int * int) list\n       but an expression was expected of type\n         (int * int) list -> int * int -> (int * int) list\n       Type int -> (int * int) list is not compatible with type\n         (int * int) list \n", "Error: This expression has type int * 'a list\n       but an expression was expected of type (int * int) list\n", "Error: This expression has type int * 'a list\n       but an expression was expected of type (int * int) list\n", "Error: This expression has type int * int list\n       but an expression was expected of type (int * int) list\n", "Error: This expression has type (int * int) list\n       but an expression was expected of type 'a * 'b\n", "Error: Unbound value t\n", "Error: This expression has type int * 'a\n       but an expression was expected of type (int * int) list\n", "Error: This expression has type int * 'a\n       but an expression was expected of type (int * int) list\n", "Error: This expression has type int * 'a\n       but an expression was expected of type (int * int) list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.len s == List.len x)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.lenth s == List.length x)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.length s == List.length x)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.length s = List.length x)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ((List.length s) = (List.length x))\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ((List.length s) = (List.length (x)))\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ((List.length a) = (List.length x))\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ((List.length s) = (List.length x))\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ((List.length x) = (List.length s))\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ((h :: t) x = [])\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (x = [])\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (x = [(,)])\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (x = [(), ()])\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.length x = 5)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.length a = 5)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.length s = 5)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (s = [])\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (s != [])\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (s != [])\nthen c :: s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (s = [])\nthen c :: s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (s)\nthen c :: s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch s with\n| [] -> c :: s\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch s with\n| [] -> (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch s with\n| [] -> ((c + x' + x'') :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch s with\n| [] -> ((c + x' + x'' + 0) :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch s with\n| [] -> ((c + 0) :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> ((c + 0) :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> ((c) :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Unbound value List.len\n", "Error: Unbound value List.lenth\nHint: Did you mean length?\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: Unbound value h\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: Syntax error: operator expected.\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type bool but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = (List.length s) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = (List.length a) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = (List.length x) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length x) = (List.length x) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a * 'b list\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = (List.length l1) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = (List.length a) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a * 'b list\n       but an expression was expected of type 'c list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = \nif i > 0\nthen bigAdd l (mulByDigit (i - 1) l)\nelse [0]"], "bad": ["let rec mulByDigit i l = \nif i > 0\nthen bigAdd l (mulByDigit (i - 1) l)\nelse bigAdd [0]"], "message": ["Error: This expression has type int list -> int list\n       but an expression was expected of type int list\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = fun x' -> x (a x') in \nlet base = fun x -> x in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = \n\"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n = match n with\n| n when n <= 0 -> []\n| _ -> x :: (clone x (n-1))", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let rec padZero l1 l2 = \nif List.length l1 > List.length l2\nthen (l1, (clone 0 (List.length l1 - List.length l2)) @ l2)\nelse (clone 0 (List.length l2 - List.length l1) @ l1, l2)", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let rec removeZero l = match l with\n[] -> []\n| h::t ->\nif h = 0\nthen removeZero t\nelse l", "let _ = removeZero [0;0;0;1;0;0;2]", "let _ = removeZero [9;9]", "let _ = removeZero [0;0;0;0]", "let ee = [1;2]", "let zz = [3;4]", "List.combine ee zz", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = ((List.length l1) - 1) )\nthen c, ((c + x' + x'') / 10) :: ((c + x' + x'') mod 10) :: s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]", "let rec mulByDigit i l = \nif i > 0\nthen bigAdd l (mulByDigit (i - 1) l)\nelse [0]", "let _ = mulByDigit 9 [9;9;9;9]", "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet () =  \nlet (i', l') = x in\nmatch i' with\n| [] -> l'\n| h :: t -> t, bigAdd( (mulByDigit h l') l') in\nlet base = (h, l1) in\nlet args = (List.rev l2), l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = (1, []) in\nlet args = (List.rev l2), l1 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet i' l' = a in\nmatch i with\n[] -> a\n| h :: t -> mulByDigit h l' :: a", "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet i' l' = a in\nmatch i with\n[] -> a\n| h :: t -> (mulByDigit h l') :: a", "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet i' l' = a in\nmatch i with\n[] -> a\n| h :: t -> (mulByDigit h l'), t", "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet i' l' = a in\nmatch i with\n[] -> a\n| h :: t -> ((mulByDigit h l'), t)", "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet i' l' = a in\nmatch i with\n[] -> \n| h :: t -> bigAdd( (mulByDigit h l'), l')", "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet i' l' = a in\nmatch i with\n[] -> l'\n| h :: t -> bigAdd( (mulByDigit h l'), l')", "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet i' l' = a in\nmatch i with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l'), l')", "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet i', l' = a in\nmatch i with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l'), l')", "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l'), l')", "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i' with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l'), l')", "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i' with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l'), l')", "let base = (1, l1) in\nlet args = (List.rev l2), l1 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l'), l')", "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l') l')", "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l') l') in\nlet base = (1, l1) in\nlet args = (List.rev l2), l1 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l'), l') in\nlet base = (1, l1) in\nlet args = (List.rev l2), l1 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l') l') in\nlet base = (1, l1) in\nlet args = (List.rev l2), l1 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i' with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l') l') in\nlet base = (1, l1) in\nlet args = (List.rev l2), l1 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i' with\n| [] -> l'\n| h :: t -> t, bigAdd( (mulByDigit h l') l') in\nlet base = (1, l1) in\nlet args = (List.rev l2), l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type 'a list * 'b\n       but an expression was expected of type 'c list\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value l1\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list * 'a\n       but an expression was expected of type int list\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1, a')\n| h :: t -> bigAdd (mulByDigit (h l1')) a' in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1, a')\n| h :: t -> bigAdd ((mulByDigit (h l1')) a)' in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1, a')\n| h :: t -> bigAdd ((mulByDigit (h l1')) a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1, a')\n| h :: t -> bigAdd (mulByDigit (h l1') a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = x in\nmatch a with\n| [] -> (l1, a')\n| h :: t -> bigAdd (mulByDigit (h l1') a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = x in\nmatch a with\n| [] -> (l1, a')\n| h :: t -> bigAdd (mulByDigit (h l1') a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = x in\nmatch a with\n| [] -> (l1', a')\n| h :: t -> bigAdd (mulByDigit (h l1') a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> bigAdd (mulByDigit (h l1') a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> bigAdd (mulByDigit (h l1') a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> bigAdd (mulByDigit h (l1') a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> bigAdd (mulByDigit h (l1')) a'", "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> li', bigAdd (mulByDigit h (l1')) a'", "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> li', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type int list -> int list\n       but an expression was expected of type int list\n", "Error: Syntax error\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type 'a * int list\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type 'a * int list\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type 'a * int list\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type 'a * int list\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type 'a * int list\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type 'a * int list\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type 'a * int list\n", "Error: This function has type int -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value li'\nHint: Did you mean l1'?\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let _ = bigMul [9;9;9;9] [9;9;9;9]", "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let _ = bigMul [9;9;9;9] [9;9;9;9]", "let _ = bigMul [9;9;9;9] [9;9;9;9]", "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let _ = bigMul [9;9;9;9] [9;9;9;9]", "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, 0) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int list * int\n       but an expression was expected of type int list * int list\n       Type int is not compatible with type int list \n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, [0]) in\nlet args = (List.hd (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, [0]) in\nlet args = (List.hd (List.rev List.hd l2)) in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.hd (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let _ = bigMul [9;9;9;9] [9;9;9;9]", "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list list\n", "Error: This expression has type int but an expression was expected of type\n         int list list\n"], "problem": "bigMul"}
{"hw": "hw2", "fix": ["let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0\nin\nhelper d k l"], "bad": ["let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki tt\n| _ -> 0\nin\nhelper d k l"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a list list\n       The type variable 'a occurs inside 'a list\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0\nin\nhelper d k l"], "bad": ["let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0", "| _ -> 0", "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0", "| _ -> 0\nin\nhelper d k l", "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0", "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0", "in\nhelper d k l"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n\n| _ -> 0\nin\nhelper d k l"], "bad": ["let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t", "| _ -> 0\nin\nhelper d k l"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type string list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type string list\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let assoc (d,k,l) = \nmatch l with\n| h::t -> h"], "bad": ["let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type string list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type string list\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then d\nelse assoc(d,k,t)\n| _-> d"], "bad": ["let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let assoc (d,k,l) = \nmatch l with\n| h::t ->\nlet rec helper di ki li = \nlet (name,age) = li in\nif name = ki then di\nelse \nmatch li with\n| h::t -> helper di ki t\n| _-> di\nin\nhelper d k h", "let assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then d\nelse assoc(d,k,t)\n| _-> d\n\nin\nhelper d k h", "let assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then d\nelse assoc(d,k,t)\n| _-> d\n\nin\nhelper d k h"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b * 'c\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = let func = f b in\nlet (value,boo) = func in\nif boo then wwhile (f,value)\nelse value"], "bad": ["let rec wwhile (f,b) = let func = f b in\nlet (value,boo) = func in\nif boo then wwhile (func, boo)\nelse value", "let rec wwhile (f,b) = let func = f b in\nlet (value,boo) = func in\nif boo then wwhile (func)\nelse value", "let rec wwhile (f,b) = let func = f b in\nlet (value,boo) = func in\nif boo then wwhile (f)\nelse value"], "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'a * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type ('b -> 'a * bool) * 'b\n", "Error: This expression has type 'a -> 'b * bool\n       but an expression was expected of type ('a -> 'b * bool) * 'a\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)"], "bad": ["let fixpoint (f,b) = wwhile (let xx = x*x*x in (xx, xx < 100),b)", "let fixpoint (f,b) = wwhile (let xx = f b in (xx, xx = b),b)", "let fixpoint (f,b) = wwhile ((f b, xx = b),b)", "let fixpoint (f,b) = wwhile ((let xx = f b, xx = b),b)", "let fixpoint (f,b) = wwhile ((let xx = (f b), xx = b),b)", "let fixpoint (f,b) = wwhile ((f b, xx = b),b)", "let fixpoint (f,b) = wwhile (((let xx = f b), xx = b),b)", "let fixpoint (f,b) = wwhile (((let xx = (f b), xx = b),b)", "let fixpoint (f,b) = wwhile ((let xx = (f b), xx = b),b)", "let fixpoint (f,b) = wwhile (let xx = x*x*x in (xx, xx < 100),b)", "let fixpoint (f,b) = wwhile (let xx = b*b*b in (xx, xx < 100),b)", "let fixpoint (f,b) = wwhile (let f x = let xx = x*x*x in (xx, xx < 100),b)", "let fixpoint (f,b) = wwhile (let f b = let xx = x*x*x in (xx, xx < 100),b)", "let fixpoint (f,b) = wwhile (let xx = x*x*x in (xx, xx < 100),b)", "let fixpoint (f,b) = wwhile ((b*b*b, b*b*b < 100),b)", "let fixpoint (f,b) = wwhile ((b*b*b, b < 100),b)", "let fixpoint (f,b) = wwhile ((f b, false),b)", "let fixpoint (f,b) = wwhile ((let f b = let xx = f b in (xx, xx = b)),b)", "let fixpoint (f,b) = wwhile ((let f b = let xx = b*b*b in (xx, xx = b)),b)", "let fixpoint (f,b) = wwhile ((let f b = let xx = b*b*b in (xx, xx = b)),b)", "let fixpoint (f,b) = wwhile ((let f b = let xx = b*b*b in xx, xx = b),b)"], "message": ["Error: Unbound value x\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Unbound value x\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Unbound value x\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((let d x = let xx = f x in (xx, xx = b) in d),b)"], "bad": ["let fixpoint (f,b) = wwhile ((let d x = let xx = f x in (xx, xx = b) in d b),b)"], "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let fixpoint (f,b) = wwhile ((let g x = let xx = f x in (xx, xx = b) in g),b)", "let fixpoint (f,b) = wwhile ((let g x = let xx = f x in (xx, xx = b) in g),b)", "let fixpoint (f,b) = wwhile ((let g x = let xx = (f x) in (xx, xx = b) in g),b)"], "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let fixpoint (f,b) = wwhile ((let g x = (f x, x = fx) in g,b)", "let fixpoint (f,b) = wwhile ((let g x = (f x, x = fx) in g),b)", "let fixpoint (f,b) = wwhile ((let g x = (f x, x = f x) in g),b)", "let fixpoint (f,b) = wwhile ((let g x = let d = f x in (d, x = d) in g),b)"], "message": ["Characters 28-29:\n  let fixpoint (f,b) = wwhile ((let g x = (f x, x = fx) in g,b);;\n                              ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Characters 28-29:\n  let fixpoint (f,b) = wwhile ((let g x = (f x, x = fx) in g,b);;\n                              ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let fixpoint (f,b) = wwhile ((let g x = let d = (f b) in (d, x = d) in g),b)"], "message": ["Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let fixpoint (f,b) = wwhile ((let g x = let d = let (f b) in (d, x != d) in g),b)", "let fixpoint (f,b) = wwhile ((let g x = let d = (f b) in (d, x != d) in g),b)"], "message": ["Error: Unbound value wwhile\n", "Characters 52-53:\n  let fixpoint (f,b) = wwhile ((let g x = let d = let (f b) in (d, x != d) in g),b);;\n                                                      ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let fixpoint (f,b) = wwhile ((let g x = let d = (f x) in (d, x = d) in g),b)", "let fixpoint (f,b) = wwhile ((let g x = let d = (f x) in (d, x = d) in g),b)"], "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t ->  \nlet seen' = if List.mem h seen then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) = let func = f b in\nlet (value,boo) = func in\nif boo then wwhile (f,value)\nelse value", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) = wwhile ((let g x = (f x, x != f x) in g),b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let _ = fixpoint (collatz, 9001)"], "message": ["Error: Unbound value fixpoint\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "let _ = exprToString sampleExpr1"], "bad": ["^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4", "let rec exprToString e = match e with \nVarX = \"x\"\n|VarY = \"y\"\n|Sine(e) = \"sin (pi*\"^exprToString e^\")\"\n|Cosine(e) = \"cos (pi*\"^exprToString e^\")\"\n|Average(e1,e2) = \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) = exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) = \"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4", "let rec exprToString e = match e with \n|VarX = \"x\"\n|VarY = \"y\"\n|Sine(e) = \"sin (pi*\"^exprToString e^\")\"\n|Cosine(e) = \"cos (pi*\"^exprToString e^\")\"\n|Average(e1,e2) = \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) = exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) = \"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4", "let rec exprToString e = match e with \n|VarX = x\n|VarY = \"y\"\n|Sine(e) = \"sin (pi*\"^exprToString e^\")\"\n|Cosine(e) = \"cos (pi*\"^exprToString e^\")\"\n|Average(e1,e2) = \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) = exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) = \"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4", "let rec exprToString e = \nmatch e with \n|VarX = \"x\"\n|VarY = \"y\"\n|Sine(e) = \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) = \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) = \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) = exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) = \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4", "let rec exprToString e = \nmatch e with \n|VarX e = \"x\"\n|VarY e = \"y\"\n|Sine(e) = \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) = \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) = \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) = exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) = \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4", "let rec exprToString ex = \nmatch ex with \n|VarX e = \"x\"\n|VarY e = \"y\"\n|Sine(e) = \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) = \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) = \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) = exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) = \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4", "let rec exprToString ex = \nmatch ex with \n|VarX e = \"x\"\n|VarY e = \"y\"\n|Sine(e) = \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) = \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) = \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) = exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) = \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4", "let rec exprToString ex = \nmatch ex with \n(*|VarX = \"x\"\n|VarY = \"y\"*)\n|Sine(e) = \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) = \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) = \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) = exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) = \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4", "let rec exprToString ex = \nmatch ex with \n|VarX = (\"x\")\n|VarY = \"y\"\n|Sine(e) = \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) = \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) = \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) = exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) = \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4", "let rec exprToString ex = \nmatch ex with \n|VarX -> (\"x\")\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr,0.5,0.2)"], "bad": ["let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)"], "message": ["Error: Syntax error\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand 0 5 in\nlet depth = depth - 1 in\nmatch randNum with \n|0 -> buildSine(build(makeRand(5,16), depth))\n|1 -> buildCosine(build(rand, depth))\n|2 -> buildTimes(build(rand, depth),build(rand, depth))\n|3 -> buildAverage(build(rand, depth),build(rand, depth))\n|_ -> buildY()"], "bad": ["let random = makeRand(5,16) in\nlet _ = build(random,5)", "let random = makeRand(5,16) in\nlet _ = build(random,5)", "let random = makeRand(5,16) in\nlet _ = build(random,5)", "let random = makeRand(5,16) in\nbuild(random,5)", "Let _ = let random = makeRand(5,16) in\nbuild(random,5)", "let _ = let random = makeRand(5,16) in\nbuild(random,5)", "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand 0 5 in\nlet depth = depth - 1 in\nmatch randNum with \n|0 -> buildSine(build(rand, depth))\n|1 -> buildCosine(build(rand, depth))\n|2 -> buildTimes(build(rand, depth),build(rand, depth))\n|3 -> buildAverage(build(rand, depth),build(rand, depth))\n|_ -> buildY()"], "message": ["Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n", "Error: Syntax error\n", "Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t ->  \nlet seen' = if List.mem h seen then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) = let func = f b in\nlet (value,boo) = func in\nif boo then wwhile (f,value)\nelse value", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) = wwhile ((let g x = (f x, x != f x) in g),b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)", "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "let rec exprToString ex = \nmatch ex with \n|VarX -> \"x\"\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"", "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "let _ = exprToString sampleExpr1", "let buildX()                       = VarX", "let buildY()                       = VarY", "let buildSine(e)                   = Sine(e)", "let buildCosine(e)                 = Cosine(e)", "let buildAverage(e1,e2)            = Average(e1,e2)", "let buildTimes(e1,e2)              = Times(e1,e2)", "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "let pi = 4.0 *. atan 1.0", "let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)", "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr,0.5,0.2)", "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand 0 5 in\nlet depth = depth - 1 in\nmatch randNum with \n|0 -> buildSine(build(rand, depth))\n|1 -> buildCosine(build(rand, depth))\n|2 -> buildTimes(build(rand, depth),build(rand, depth))\n|3 -> buildAverage(build(rand, depth),build(rand, depth))\n|_ -> buildY()"], "bad": ["let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand 0 5 in\nlet depth = depth - 1 in\nmatch randNum with \n|0 -> buildSine(build(makeRand(5,16), depth))\n|1 -> buildCosine(build(makeRand(5,16), depth))\n|2 -> buildTimes(build(makeRand(5,16), depth),build(makeRand(5,16), depth))\n|3 -> buildAverage(build(makeRand(5,16), depth),build(makeRand(5,16), depth))\n|_ -> buildY()"], "message": ["Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec exprToString ex = \nmatch ex with \n|VarX -> \"x\"\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"\n|MyExpr1 (e1,e2,e3) -> \"(sqrt(\"^exprToString e1^\")*sqrt(\"^exprToString e2^\")*\"^exprToString e3^\")\"\n|MyExpr2 (e) -> \"halve(\"^exprToString^\")\""], "bad": ["let rec exprToString ex = \nmatch ex with \n|VarX -> \"x\"\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"\n|MyExpr1 (e1,e2,e3) -> \"(sqrt(\"^exprToString e1^\")*sqrt(\"^exprToString e2^\")*\"^exprToString e3^\")\""], "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let sampleExpr1 = MyExpr2(MyExpr1(Varx,VarY,Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))))", "let _ = exprToString sampleExpr1"], "bad": ["let rec exprToString ex = \nmatch ex with \n|VarX -> \"x\"\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"\n|MyExpr1 (e1,e2,e3) -> \"(sqrt(\"^exprToString e1^\")*sqrt(\"^exprToString e2^\")*\"^exprToString e3^\")\"\n|MyExpr2 (e) -> \"halve(\"^exprToString e^\")\""], "message": ["Error: This expression has type expr -> string\n       but an expression was expected of type string\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)\n|MyExpr1(e1,e2,e3) -> cos(pi*.eval (e1,x,y))*.sin(pi*.eval (e2,x,y))*.eval(e3,x,y)\n|MyExpr2(e) -> sin(pi*.eval (e,x,y)*.0.5)"], "bad": ["let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)\n|MyExpr1(e1,e2,e3) -> cos(pi*.eval (e1,x,y))*.sin(pi*.eval (e2,x,y))*.eval(e3,x,y)\n|MyExpr2(e) -> Sine(eval (e,x,y)*.0.5)", "let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)\n|MyExpr1(e1,e2,e3) -> cos(pi*.eval (e1,x,y))*.sin(pi*.eval (e2,x,y))*.eval(e3,x,y)\n|MyExpr2(e) -> sin(pi*.eval (e,x,y)*.0.5)"], "message": ["Error: This expression has type expr but an expression was expected of type\n         float\n", "Error: This expression has type expr but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + x in\nlet base = 0 in\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = ( +. ) in\nlet base = 0 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = ( +. ) in\nlet base = 0. in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = ( +. ) in\nlet base = 0. in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = ( + ) in\nlet base = 0 in\nList.fold_left f base xs"], "message": ["Error: This expression has type int but an expression was expected of type\n         float -> float -> float\n", "Error: This expression has type float but an expression was expected of type\n         float -> float -> float\n", "Error: This expression has type float but an expression was expected of type\n         float -> float -> float\n", "Error: This expression has type int but an expression was expected of type\n         int -> int -> int\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs", "let _ = pipe [] 3"], "bad": ["let pipe fs = \nlet f a x = List.map f x in\nlet base = 0 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = List.map x in\nlet base = 0 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = List.map x -> x in\nlet base = 0 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = List.map x in\nlet base = 0 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = List.map x in\nlet base = 3 in\nList.fold_left f base fs"], "message": ["Error: Unbound value f\n", "Error: This expression has type int but an expression was expected of type\n         'a list -> 'b list\n", "Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         'a list -> 'b list\n", "Error: This expression has type int but an expression was expected of type\n         'a list -> 'b list\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let f x = 1", "let f x = if x<2 then 1 else (x * f(x-1))", "let res = f 5"], "bad": ["let res = (x, y)"], "message": ["Error: Unbound value x\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x in\nlet base = 0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = x a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x in\nlet base = x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x in\nlet base = x in\nList.fold_left f base fs"], "message": ["Error: Unbound value x\n", "Error: Unbound value x\n", "Error: Unbound value x\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fs in\nlet base = fs in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let pipe fs = \nlet f a x = x in\nlet base = x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = base in\nlet base = base in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = base in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = f x a in\nlet base = f x a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = f x a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a' in\nlet base = a' in\nList.fold_left f base fs"], "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Syntax error\n", "Error: Unbound value base\n", "Error: Unbound value base\n", "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value x\n", "Error: Unbound value a'\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun x -> x  in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let pipe fs = \nlet f a x = f a x in\nlet base = 3 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = pipe a x in\nlet base = 3 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = pipe a x in\nlet base = 3 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = pipe fs in\nlet base = 3 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = pipe base  in\nlet base = 3 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = pipe fs  in\nlet base = 3 in\nList.fold_left f base fs"], "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: Unbound value base\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun a -> x  in\nlet base = fun a -> a in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let pipe fs = \nlet f a x = fun a -> x  in\nlet base = fun a -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type int but an expression was expected of type\n         int -> int\n", "Error: Unbound value x\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun a -> a  in\nlet base = fun a -> a in\nList.fold_left f base fs", "let _ = pipe [] 3"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         int -> int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun a -> x  in\nlet base = fun a -> a in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun a -> x  in\nlet base = fun a -> x in\nList.fold_left f base fs"], "message": ["Error: Unbound value x\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = pipe [] in\nlet base = pipe [] in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'a\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'a\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun a -> x in\nlet base = pipe [] in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let pipe fs = \nlet f a x = x -> a in\nlet base = pipe [] in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a -> x in\nlet base = pipe [] in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x -> a in\nlet base = pipe [] in\nList.fold_left f base fs"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'a\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'a\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = pipe [] in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let pipe fs = \nlet f a x = fun x a in\nlet base = pipe [] in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base = pipe [] in\nList.fold_left f base fs"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'a\n", "Error: This expression has type int but an expression was expected of type\n         int -> int\n", "Error: Syntax error\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun p -> p in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let pipe fs = \nlet f a x = x a in\nlet base = x a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'a\n", "Error: Unbound value x\n", "Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun x a-> a in\nlet base = fun p -> p in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a x in\nlet base = fun p -> p in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x a-> x in\nlet base = fun p -> p in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun p -> p in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'a\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun x a -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun d x -> g in\nlet base = fun p -> p in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun d x -> a in\nlet base = fun p -> p in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x a -> d in\nlet base = fun p -> p in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x a -> fun x a in\nlet base = fun p -> p in\nList.fold_left f base fs"], "message": ["Error: Unbound value g\n", "Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n", "Error: Unbound value d\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun x a -> x a in\nlet base = pipe [] in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun x a -> fun d -> d in\nlet base = fun p -> p in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let f x = 1", "let f x = if x<2 then 1 else (x * f(x-1))", "let res = f 5", "let pipe fs = \nlet f a x = fun p -> p", "let base = pipe [] in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let pipe fs = \nlet f a x = fun a x -> fun d -> d", "let base = fun p -> p in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a", "let base = fun p -> p in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x", "let base = fun p -> p in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun a x -> a x", "let base = fun p -> p in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x", "let base = fun p -> p in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x", "let base = (fun p -> p) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun p -> p", "let base = pipe [] in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun p -> p", "let base = pipe [] in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x", "let base = pipe [] in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a", "let base = pipe [] in\nList.fold_left f base fs"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'b -> 'b\n", "Error: Syntax error\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n", "Error: Syntax error\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n", "Error: Syntax error\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n", "Error: Syntax error\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n", "Error: Syntax error\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n", "Error: Syntax error\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n", "Error: Syntax error\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n", "Error: Syntax error\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n", "Error: Syntax error\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n", "Error: Syntax error\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun d -> d in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a", "let base = pipe [] in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x", "let pipe fs = \nlet f a x = a x", "let base = pipe [] in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x", "let pipe fs = \nlet f a x = fun a x -> a x", "let base = fun d -> d in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun a x -> x a", "let base = fun d -> d in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x a", "let base = fun d -> d in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun a x", "let base = fun d -> d in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun d -> x a", "let base = fun d -> d in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun d -> a x", "let base = fun d -> d in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun p -> a x", "let base = fun d -> d in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x", "let base = fun d -> d in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base = fun d -> d in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n", "Error: Syntax error\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n", "Error: Syntax error\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n", "Error: Syntax error\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n", "Error: Syntax error\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n", "Error: Syntax error\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n", "Error: Syntax error\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n", "Error: Syntax error\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun a x -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun a x -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun b a x -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun b a x -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "let _ = pipe [] 3"], "bad": ["let _ = pipe [] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         ('a -> 'b) -> 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun x -> x in\nlet base = fun d -> d in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x -> x in\nlet base = fun d -> d in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun x -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a  in\nlet base = fun d -> d in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun x a -> fun x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x a -> fun d in\nlet base = fun d -> d in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun d -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "let _ = pipe [] 3"], "bad": ["let pipe fs = \nlet f a x = fun x a -> fun x in\nlet base = fun d -> d in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun x -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun a -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun a -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun a ->  x a in\nlet base = fun d -> d in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun a -> fun x -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun a -> fun x -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun x ->  a x in\nlet base = fun d-> d in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun p a -> a x  in\nlet base = fun d-> d in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         ('a -> 'b) -> 'a -> 'b\n", "Error: This expression has type int but an expression was expected of type\n         ('a -> 'b) -> 'a -> 'b\n", "Error: This expression has type int but an expression was expected of type\n         ('a -> 'b) -> 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun a x -> x in\nlet base = fun d-> d in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let pipe fs = \nlet f a x = fun a x  in\nlet base = fun d-> d in\nList.fold_left f base fs"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type int but an expression was expected of type\n         int -> int\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun a -> a in\nlet base = fun d-> d in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun a x -> a in\nlet base = fun d-> d in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun d ->  x a in\nlet base = fun d-> d in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun d -> a in\nlet base = fun d-> d in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun p -> fun s a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun d x -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun p -> fun s a x -> a x", "let base = fun d -> d in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun p -> fun s a x -> x a", "let base = fun d -> d in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun p -> fun s a -> x a", "let base = fun d -> d in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun p -> fun s a -> x a"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'c -> 'a -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'c -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: Syntax error\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n", "Error: Syntax error\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n", "Error: Syntax error\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun p -> fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'b -> 'c\n", "Error: This expression has type int but an expression was expected of type\n         'a -> int -> int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type int but an expression was expected of type\n         int -> int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun b (fun a -> x a) -> b in\nlet base = fun d -> d in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun b (a -> x a) -> b in\nlet base = fun d -> d in\nList.fold_left f base fs"], "message": ["Error: Syntax error: operator expected.\n", "Characters 33-34:\n  let f a x = fun b (a -> x a) -> b in\n                    ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun a -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun a d -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun a x -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun a -> fun x -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x  in\nlet base = fun p -> p in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a x  in\nlet base = let p -> p in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x  in\nlet base = fun p -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x  in\nlet base = fun p -> p in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x  in\nlet base = fun p -> p in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: Unbound value x\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun x -> x in\nlet base = fun p -> p in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun x -> a in\nlet base = fun p -> p in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = List.rev x in\nlet base = fun p -> p in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'b list\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)"], "bad": ["let pipe fs = \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base List.rev fs", "let pipe fs = \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base List.rev fs"], "message": ["Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type ('b -> 'b) list\n", "Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type ('b -> 'b) list\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 4)] 3"], "bad": ["let pipe fs = \nlet f a x = x in fun x-> x in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a  in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)"], "bad": ["let pipe fs = \nlet f a x = x fs in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type ('a list -> 'b -> 'b) list\n       The type variable 'a occurs inside 'a list -> 'b -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun d-> x a d in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)"], "bad": ["let pipe fs = \nlet f a x = fun d-> a x d in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)"], "message": ["Error: This expression has type ('a -> 'a -> 'b) -> 'a -> 'a -> 'b\n       but an expression was expected of type\n         ('a -> 'a -> 'b) -> 'a -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)"], "bad": ["let pipe fs = \nlet f a x = x in\nlet base = fun p -> x p in\nList.fold_left f base (List.rev fs)", "let pipe fs = \nlet f a x = x in\nlet base = fun p ->a  p in\nList.fold_left f base (List.rev fs)"], "message": ["Error: Unbound value x\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun a' -> a' in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a x in\nlet base = fun a' -> a' in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (a x) in\nlet base = fun a' -> a' in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun p' -> a x  in\nlet base = fun a' -> a' in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun p' -> a  in\nlet base = fun a' -> a' in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =  fun p -> a x in\nlet base = pipe [] in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x =  a x in\nlet base = pipe [] in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun p -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x =   in\nlet base = p -> p in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun p -> a x in\nlet base = p -> p in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun p -> x a in\nlet base = p -> p in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun l -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun x -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun l -> fun x -> a in\nlet base = fun p -> p in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun l -> fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun l -> fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n", "Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n", "Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n", "Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun l -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun l -> fun x -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b -> 'c -> ('a -> 'd) -> 'd\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> ('a -> 'd) -> 'd\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun l -> x (a l) in\nlet base = fun p -> p in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun l -> l(x a) in\nlet base = fun p -> p in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let stringOfList f l = \"[\"^ sepConcat \"; \" (List.map f l) ^\"]\""], "bad": ["let stringOfList f l = List.map f (sepConcat l);\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6]", "let stringOfList f l = \"[\"^ List.map f (sepConcat l) ^\"]\";\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6]", "let stringOfList f l = \"[\"^ List.map f (sepConcat l) ^\"]\"", "let stringOfList f l = \"[\"^ List.map f (sepConcat \"; \" l) ^\"]\""], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type string list -> string\n       but an expression was expected of type 'a list\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let rec clone x n = \nif n < 1 then \n[]\nelse \nx::(clone x (n-1))"], "bad": ["let rec clone x n = \nif n > 0 then \nx @ clone x n-1\nelse \n[]", "let rec clone x n = \nif n > 0 then \nx @ (clone x n-1)\nelse \n[]", "let rec clone x n = \nif n < 1 then \n[]\nelse \nx::(clone x n-1)"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet x = List.length l1 - List.length l2 in \nlet list_p = clone 0 x in \n(l1,list_p@l2)\nelse if List.length l1 < List.length l2 then\nlet x = List.length l2 - List.length l1 in \nlet list_p = clone 0 x in \n(list_p@l1,l2)\nelse\n(l1,l2)"], "bad": ["let padZero l1 l2 = \nif List.length l1 == List.length l2 then\n(l1)@(l2)", "let padZero l1 l2 = \nif List.length l1 = List.length l2 then\nl1 @ l2", "let padZero l1 l2 = \nif List.length l1 == List.length l2 then\nl1 @ l2", "let padZero l1 l2 = \nif List.length l1 == List.length l2 then\n(l1 @ l2)", "let padZero l1 l2 = \nif List.l1 > List.l2 then\nlet x = List.l1 - List.l2 in \nlet list_p = clone 0 x in \n(l1,list_p@l2)\nelse if List.l1 < List.l2 then\nlet x = List.l2 - List.l1 in \nlet list_p = clone 0 x in \n(list_p@l1,l2)\nelse\n(l1,l2)"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type unit\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n", "Error: Unbound value List.l1\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let rec removeZero l = match l with\n| [] -> []\n| h::t ->\nif h == 0 then \nremoveZero t\nelse \nl"], "bad": ["let rec removeZero l = match l with\n| [] = []\n| h::t = \nif h == 0 then \nremoveZero t\nelse \nl"], "message": ["Error: Syntax error\n"], "problem": "removeZero"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then (1, listy @ (initsum % 10))\nelse (0,listy@initsum)", "let base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then (1, listy @ (initsum % 10))\nelse (0,listy@initsum)", "let base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then \n(1, listy @ [initsum mod 10])\nelse \n(0,listy @ [initsum]) in\nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then (1, listy @ (initsum % 10))\nelse (0,listy @ initsum)", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then (1, listy @ (initsum % 10))\nelse (0,listy @ initsum)", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then (1, listy @ [initsum mod 10])\nelse (0,listy @ initsum)", "let base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then (1, listy @ [initsum mod 10])\nelse (0,listy @ [initsum])", "let base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then (1, listy @ [initsum mod 10])\nelse (0,listy @ [initsum])", "let base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then (1, listy @ [initsum mod 10])\nelse (0,listy @ initsum)", "let base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then \n(1, listy @ [initsum mod 10])\nelse \n(0,listy @ initsum) in\nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> \nlet initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nlet v = List.rev(t) in \nhelpy p v carrying accList@[intKeep] in\nremoveZero(List.rev(helpy i l 0 [0;0]))"], "bad": ["let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numList with\n|[] -> accList\n|h::t -> let initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-initKeep) mod 100 in\nhelpy p List.rev(t) carrying accList@initKeep in\nremoveZero(list.rev(helpy i l 0 [0,0]))", "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> let initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-initKeep) mod 100 in\nhelpy p List.rev(t) carrying accList@initKeep in\nremoveZero(list.rev(helpy i l 0 [0,0]))", "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> let initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nhelpy p List.rev(t) carrying accList@initKeep in\nremoveZero(list.rev(helpy i l 0 [0,0]))", "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> \nlet initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nlet v = List.rev(t) in \nhelpy p v carrying accList@initKeep in\nremoveZero(list.rev(helpy i l 0 [0,0]))", "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> \nlet initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nlet v = List.rev(t) in \nhelpy p v carrying accList@intKeep in\nremoveZero(list.rev(helpy i l 0 [0,0]))", "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> \nlet initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nlet v = List.rev(t) in \nhelpy p v carrying accList@[intKeep] in\nremoveZero(list.rev(helpy i l 0 [0,0]))", "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> \nlet initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nlet v = List.rev(t) in \nhelpy p v carrying accList@[intKeep] in\nremoveZero(List.rev(helpy i l 0 [0,0]))"], "message": ["Error: Unbound value numList\nHint: Did you mean numsList?\n", "Error: Unbound value initKeep\nHint: Did you mean intKeep?\n", "Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type int list\n", "Error: Unbound value initKeep\nHint: Did you mean intKeep?\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: Unbound value list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = \nlet (upper_mult, total) = a in\nlet newTotal = mulByDigit x upper_mult in\nlet updateTotal = bigAdd newTotal total in\n(upper_mult@[0],updateTotal) in\nlet base = (l1,[]) in\nlet args =  l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = in\nlet base =  in\nlet args =  in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = \nlet (bottom_mult, total) = a in match a with\n|[] -> total\n|h::t -> \nlet newTotal = mulByDigit h x in\nlet updateTotal = bigAdd newTotal updateTotal in\n(t,updateTotal)", "let base = (l1,[]) in\nlet args =  l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = \nlet (bottom_mult, total) = a in match bottom_mult with\n|[] -> total\n|h::t -> \nlet newTotal = mulByDigit h x in\nlet updateTotal = bigAdd newTotal updateTotal in\n(t,updateTotal)", "let base = (l1,[]) in\nlet args =  l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = \nlet (bottom_mult, total) = a in match bottom_mult with\n|[] -> total\n|h::t -> \nlet newTotal = mulByDigit h x in\nlet updateTotal = bigAdd newTotal total in\n(t,updateTotal)", "let bigMul l1 l2 = \nlet f a x = \nlet (bottom_mult, total) = a in match bottom_mult with\n|[] -> total\n|h::t -> \nlet newTotal = mulByDigit h x in\nlet updateTotal = bigAdd newTotal total in\n(t,updateTotal) in\nlet base = (l1,[]) in\nlet args =  l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value l1\n", "Error: Syntax error\n", "Error: Unbound value l1\n", "Error: Syntax error\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun x1->x1 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun x -> x a in\nlet base = fun x1->x1 in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let stringOfList f l = List.map (f (sepConcat \" \" l))"], "bad": ["let stringOfList f l = List.map (f (sepconcat \" \" l))"], "message": ["Error: Unbound value sepconcat\nHint: Did you mean sepConcat?\nError: Unbound value sepconcat\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sepconcat\nHint: Did you mean sepConcat?\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = fun y ->  x (a y) in\nlet base = fun x1->x1 in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = sepConcat \" \" List.map(f l)"], "bad": ["let stringOfList f l = sepConcat (\" \" List.map(f l))"], "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = sepConcat \" \" l"], "bad": ["let stringOfList f l = sepConcat (\" \" List.map(f l))", "let stringOfList f l = sepConcat (\" \" (List.map(f l)))"], "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let rec clone x n = \nif (n <= 0) then []\nelse x::(clone x (n-1))"], "bad": ["let rec clone x n = \nif (n <= 0) then []\nelse x::(clone x n-1)"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = fun y ->  x (a y) in\nlet base = fun x1->x1 in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = \"[\"^sepConcat \"; \" (List.map f l)^\"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n = \nif (n <= 0) then []\nelse x::(clone x (n-1))", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let padZero l1 l2 = \nif List.length l1 < List.length l2\nthen ((clone 0 (List.length l2 - List.length l1))@l1,l2)\nelse (l1,(clone 0 (List.length l1 - List.length l2))@l2)", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let rec removeZero l = match l with\n| [] -> []\n| h::t -> if (h=0) then removeZero t else l", "let _ = removeZero [0;0;0;1;0;0;2]", "let _ = removeZero [9;9]", "let _ = removeZero [0;0;0;0]", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (x,y) -> a::[(x+y) mod 10] in\nlet base = [] in\nlet args = failwith List.combine(l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (x,y) -> a::[(x+y) mod 10 in\nlet base = [] in\nlet args = failwith List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (x,y) -> a::[(x+y) mod 10] in\nlet base = [] in\nlet args = failwith List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n", "Error: This expression has type 'a list -> 'b list -> ('a * 'b) list\n       but an expression was expected of type string\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = fun y ->  x (a y) in\nlet base = fun x1->x1 in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = \"[\"^sepConcat \"; \" (List.map f l)^\"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n = \nif (n <= 0) then []\nelse x::(clone x (n-1))", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let padZero l1 l2 = \nif List.length l1 < List.length l2\nthen ((clone 0 (List.length l2 - List.length l1))@l1,l2)\nelse (l1,(clone 0 (List.length l1 - List.length l2))@l2)", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let rec removeZero l = match l with\n| [] -> []\n| h::t -> if (h=0) then removeZero t else l", "let _ = removeZero [0;0;0;1;0;0;2]", "let _ = removeZero [9;9]", "let _ = removeZero [0;0;0;0]", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (y,z) -> let sum = y+z in\nmatch a with \n| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t\n| [] -> (sum/10)::[(sum mod 10)] in\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (y,z) -> let sum = y+z in\nmatch a with \n| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t\n| [] -> (sum/10)::[(sum mod 10)] in\nlet base = [] in\nlet args = failwith List.combine(l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (y,z) -> let sum = y+z in\nmatch a with \n| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t\n| [] -> (sum/10)::[(sum mod 10)] in\nlet base = [] in\nlet args = List.combine(l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a list -> 'b list -> ('a * 'b) list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list -> ('b * 'a) list\n       but an expression was expected of type (int * int) list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (y,z) -> let sum = y+z in\nmatch a with \n| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t\n| _ -> (sum/10)::[(sum mod 10)] in\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in\n(*let (_, res) =*) List.fold_left f base args (*in\nres*)\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (y,z) -> let sum = y+z in\nmatch a with \n| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t\n| _ -> (sum/10)::[(sum mod 10)] in\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l =  \nlet f a x = let mult = i*x in\nmatch a with \n|h::t -> ((h+mult)/10)::(h+mult) mod 10::t\n| _ -> mult/10::[mult mod 10] in\nlet base = [] in\nremoveZero (List.fold_left f base (List.rev l))"], "bad": ["let rec mulByDigit i l = match l with \nlet f a x = let mult = i*x in\nmatch a with \n|h::t -> ((h+mult)/10)::(h+mult) mod 10::t\n| _ -> mult/10::[mult mod 10] in\nlet base = [] in\nremoveZero (List.fold_left f base (List.rev l))"], "message": ["Error: Syntax error\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet g =\nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in\nlet base = [] in\nlet args = List.rev l2 in List.fold_left f base args in\nList.fold_left bigAdd [] g"], "bad": ["let bigMul l1 l2 = \nlet f a x = List.append((mulByDigit x l1) (clone 0 (List.length b)))::b in\nlet base = [] in\nlet args = List.rev l2 in List.fold_left f base args", "let bigMul l1 l2 = \nlet g =\nlet f a x = List.append((mulByDigit x l1) (clone 0 (List.length b)))::b in\nlet base = [] in\nlet args = List.rev l2 in List.fold_left f base args in\nList.fold_left bigAdd [] g", "let bigMul l1 l2 = \nlet g =\nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length b)))::b in\nlet base = [] in\nlet args = List.rev l2 in List.fold_left f base args in\nList.fold_left bigAdd [] g"], "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: Unbound value b\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value b\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let _ = mulByDigit (-9) [9;9;9;9]"], "bad": ["let _ = mulByDigit -9 [9;9;9;9]"], "message": ["Error: This expression has type int -> int list -> int list\n       but an expression was expected of type int\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = match a with\n|(move,result) -> match x with\n|(fac,dig) -> let prod = mulByDigit dig (fac @ (clone 0 move)) in\n(move +1, bigAdd result prod) in \nlet base = (0,[]) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in \nlet (_,res) = List.fold_left f base args in\nres", "let _ = bigMul [9;9;9;9] [9;9;9;9]", "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"], "bad": ["let bigMul l1 l2 = \nlet f a x = match a with\n|(move,result) -> match x with\n|(fac,dig) -> let prod = mulByDigit dig (fac @ (clone 0 move)) in\n(move +1, bigAdd result prod) in \nlet base = (0,[]) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev 12) in \nlet (_,res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "bigMul"}
{"hw": "hw1", "fix": ["let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]", "let rec digitsOfInt n = match n with\n| [] -> []\n| h::t -> if (n< 0) then []"], "bad": ["let rec digitsOfInt n = match n with\nif( h % 2) = 0 \nthen [] \nelse tail", "let rec digitsOfInt n = \nif( h % 2) = 0 \nthen [] \nelse tail", "let rec digitsOfInt n = \nif( h mod 2) = 0 \nthen [] \nelse tail", "let rec digitsOfInt n = \nif( head mod 2) = 0 \nthen [] \nelse tail", "let rec digitsOfInt n = \nif( hd mod 2) = 0 \nthen [] \nelse tl", "let rec digitsOfInt n = match n with\n|if( hd mod 2) = 0 \nthen [] \nelse tl", "let rec digitsOfInt n = match n with\n|if( n < 0) -> []", "let rec digitsOfInt n = match n with\n|( n < 0) -> []", "let rec digitsOfInt n = match n with\n| n < 0 -> []", "let rec digitsOfInt n = match n with\n| (n < 0) -> []", "let rec digitsOfInt n = \nif n < 0 -> []", "let rec digitsOfInt n = \nif (n < 0) then []"], "message": ["Error: Syntax error\n", "Error: Unbound value %\n", "Error: Unbound value h\n", "Error: Unbound value head\n", "Error: Unbound value hd\n", "Error: Syntax error\n", "Error: Syntax error\n", "Characters 38-39:\n  |( n < 0) -> [];;\n   ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Characters 39-40:\n  | (n < 0) -> [];;\n    ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]", "let rec digitsOfInt n = match n with\n| [] -> []\n| h::t -> if n < 0 then []"], "bad": ["let rec digitsOfInt n = match n with\n| [] -> []\n| h::t -> if (n < 0) then []"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]", "let rec digitsOfInt n = match n with\n| _ when n < 0 -> []"], "bad": ["let rec digitsOfInt n = match n with\n| [] -> []\n| _ -> if n < 0 then []", "let rec digitsOfInt n = match n with\n| _ -> if n < 0 then []"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt(n/10)::[]"], "bad": ["let digitsOfInt n = \nif n < 0 \nthen []\nelse if n < 10\nthen n:: []\nelse\ndigitsOfInt (n mod 10)", "let digitsOfInt n = \nif n < 0 \nthen []\nelse if n < 10\nthen n:: []\nelse\ndigitsOfInt (n / 10)"], "message": ["Error: This expression has type (int * int) list list\n       but an expression was expected of type int list\n       Type (int * int) list is not compatible with type int \n", "Error: This expression has type (int * int) list list\n       but an expression was expected of type int list\n       Type (int * int) list is not compatible with type int \n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n/10) @ (n mod 10)::[]"], "bad": ["let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n/10) ::[]"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]", "let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\ndigitsOfInt (n/10) -> n mod 10 :: []"], "bad": ["let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n/10)::[]", "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n mod 10)::[]", "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n mod 10)::[]::[]", "let rec digitsOfInt n = \nlet myList = []\nif n <= 0 \nthen []\nelse\ndigitsOfInt (n mod 10)::[]", "let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\ndigitsOfInt (n mod 10)::[]", "let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\ndigitsOfInt n mod 10::[]", "let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\ndigitsOfInt (n mod 10) :: digitsOfInt(n / 10) :: []"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: Syntax error\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["56554 mod 3"], "bad": ["56554 % 3"], "message": ["Error: Unbound value %\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\nif n < 10\nthen [n]\nelse\ndigitsOfInt (n/10) @ n mod 10 :: []"], "bad": ["let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\nif n < 10\nthen [num]\nelse\ndigitsOfInt (n/10) @ n mod 10 :: []"], "message": ["Error: Unbound value num\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let n = 0 in\nn > -300"], "bad": ["let n = 0 in\nif(n > -300)\nthen true", "let n = 0 in\nif(n > -300)\nthen 1"], "message": ["Error: This variant expression is expected to have type unit\n       The constructor true does not belong to type unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse(t)", "let _ = listReverse [1; 2; 3; 4]"], "bad": ["let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse(t) :: l", "let _ = listReverse [1; 2; 3; 4]"], "message": ["Error: Unbound value listReverse\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse t @ [h]", "let _ = listReverse [1; 2; 3; 4]"], "bad": ["let rec listReverse l = match l with\n|[] -> [];\n|h::t -> h:: [listReverse t]", "let _ = listReverse [1; 2; 3; 4]"], "message": ["Error: This expression has type string but an expression was expected of type\n         int\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 352663"], "bad": ["let _ = digitsOfInt 3124"], "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digits (-123)"], "bad": ["let _ = digits (-1)"], "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = x*x in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = List.fold_left f a x in\nlet base = x*x in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = List.fold_left f a b in\nlet base = x*x in\nList.fold_left f base xs"], "message": ["Error: Unbound value x\n", "Error: Unbound value f\n", "Error: Unbound value f\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = function g -> a x in\nlet base = function x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a (x) in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a (x) in\nlet base = 0 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a (x) in\nlet base = a(0) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a (x) in\nlet base = fs in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a (x) in\nlet base = match base with\n|0 -> 0\n|_ -> fs in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a (x) in\nlet base = match x with\n|0 -> 0\n|_ -> fs in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a (x) in\nlet base = match fs with\n|0 -> 0\n|_ -> fs in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a (x) in\nlet base = 0 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = f a x in\nlet base =  in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base =  in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = f a x in\nlet base = x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = f a x in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: Unbound value a\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: Unbound value base\n", "Error: Unbound value x\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value f\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = function g -> g in\nlet base = function x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = function g -> g a x in\nlet base = function x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = function g -> g x a in\nlet base = function x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = function g -> g(x a) in\nlet base = function x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = function g -> g(x) in\nlet base = function x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b -> ('a -> 'b -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'b -> 'c) -> 'c\n", "Error: This expression has type 'a -> 'b -> ('b -> 'a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('b -> 'a -> 'c) -> 'c\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = function g -> x in\nlet base = function x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = function g -> g (a(x)) in\nlet base = function x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'a) -> 'a -> 'a\n       but an expression was expected of type ('a -> 'a) -> 'a\n       The type variable 'a occurs inside 'a -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = function g -> a( x g)  in\nlet base = function x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = function g -> g( a x) in\nlet base = function x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'a) -> 'a -> 'a\n       but an expression was expected of type ('a -> 'a) -> 'a\n       The type variable 'a occurs inside 'a -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = function g -> x (a g)  in\nlet base = function b -> b in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "bad": ["let pipe fs = \nlet f a x = function g -> function x (a x)  in\nlet base = function b -> b in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = function g -> function z (a x)  in\nlet base = function b -> b in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = function g -> function z (a z)  in\nlet base = function b -> b in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) < 2\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif x.length < 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif sl.length < 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length < 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length = 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif t.length = 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) = 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"], "message": ["Error: Unbound record field length\n", "Error: Unbound record field length\n", "Error: This expression has type int but an expression was expected of type\n         'a list -> int\n", "Error: This expression has type int but an expression was expected of type\n         'a list -> int\n", "Error: Unbound record field length\n", "Error: This expression has type string but an expression was expected of type\n         unit\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length() = 0\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \",\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(l) = 0\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"], "message": ["Error: Unbound value l\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 2\nthen a ^ x ^ sep\nelse x ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \",\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 2\nthen a ^ x ^ sep\nelse x ^ x in\nlet base = \"\" in\nlet l = sepConcat sep t in\nList.fold_left f base l"], "message": ["Error: This expression has type string but an expression was expected of type\n         string list\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let _ = sepConcat \"---\" [\"a\"]"], "bad": ["let _ = sepConcat \"---\" [a]"], "message": ["Error: Unbound value a\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let stringOfList f l = sepConcat \";\" (List.map f l)"], "bad": ["let stringOfList f l = sepConcat \";\" List.map f l"], "message": ["Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = \nlet string str = sepConcat \"; \" (List.map (f) l )\nin \"[\" ^str ^ \"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"], "bad": ["let stringOfList f l = let", "val str = sepConcat \";\" (List.map (f) l )\nin \"[\" ^str ^ \"]\"", "let stringOfList f l = let", "val str = sepConcat \";\" (List.map (f) l )\nin \"[\" ^str ^ \"]\"", "let stringOfList f l = \nlet string str = sepConcat \";\" (List.map (f) l )\nin \"[\" ^str ^ \"]\""], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value str\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let rec clone x n = \nif n < 1\nthen []\nelse x:: (clone x (n-1))"], "bad": ["let rec clone x n = \nif n =< 0\nthen []\nelse h::t ->\nx::clone x n-1", "let rec clone x n = match n with\n|0 -> []\n|h::t ->\nx::clone x n-1", "let rec clone x n = \nif n =< 0\nthen []\nelse x::clone x n-1", "let rec clone x n = \nif n < 1\nthen []\nelse x::clone x n-1", "let rec clone x n = \nif n < 1\nthen []\nelse x:: (clone x n-1)"], "message": ["Error: Syntax error\n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n", "Error: Unbound value =<\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let int a = List.length([0]) - List.length([0;1])"], "bad": ["let int a = List.length(l1) - List.length(l2)"], "message": ["Error: Unbound value l1\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen \"hi\"\nelse \"bye\""], "bad": ["let padZero l1 l2 = \nlet int a = List.length(l1) - List.length(l2)", "let padZero l1 l2 = \nlet int a = List.length(l1) - List.length(l2) in\nif a > 0\nthen \"hi\"\nelse \"bye\""], "message": ["Error: Syntax error\n", "Error: Unbound value a\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(clone 0 a))\nelse (l1,l2)"], "bad": ["let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen l1 * (clone 0 a)\nelse \"bye\"", "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen l1 * (clone 0 a)\nelse l1 * l2", "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1 * (clone 0 a))\nelse l1 * l2", "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1 * (clone 0 a))\nelse (l1 * l2)"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(List.append (clone 0 a) l2))\nelse (l1,l2)"], "bad": ["let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(List.apend (clone 0 a) l2))\nelse (l1,l2)"], "message": ["Error: Unbound value List.apend\nHint: Did you mean append?\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(List.append (clone 0 a) l2))\nelse ((List.append (clone 0 (0-a)) l1), l2)", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]"], "bad": ["let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(List.append (clone 0 a) l2))\nelse (List.append ( clone 0 (0 -a)) l2)", "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(List.append (clone 0 a) l2))\nelse (List.append ( clone 0 (0 -a)), l2)"], "message": ["Error: This expression has type int list\n       but an expression was expected of type 'a list * int list\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type 'a list\n"], "problem": "padZero"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\nmatch n < 0 with\n| true -> 0\n| false -> 1", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663"], "bad": ["let rec digitsOfInt n =\nmatch n with\n| < 0 0\n| >= 0 1", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let rec digitsOfInt n =\nmatch n with\n| <0 0\n| >=0 1", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let rec digitsOfInt n =\nmatch n with\n| 1\n| _ 1", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let rec digitsOfInt n =\nmatch n with\n| 1 0\n| _ 1", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let rec digitsOfInt n =\nmatch n with\n| < 1 -> 0\n| >= 0 -> 1", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663"], "message": ["Error: Syntax error\n", "Error: Unbound value digitsOfInt\n", "Error: Unbound value digitsOfInt\n", "Error: Syntax error\n", "Error: Unbound value digitsOfInt\n", "Error: Unbound value digitsOfInt\n", "Error: Syntax error: pattern expected.\n", "Error: Unbound value digitsOfInt\n", "Error: Unbound value digitsOfInt\n", "Error: Syntax error\n", "Error: Unbound value digitsOfInt\n", "Error: Unbound value digitsOfInt\n", "Error: Syntax error\n", "Error: Unbound value digitsOfInt\n", "Error: Unbound value digitsOfInt\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> []", "let _ = 100 >> 2"], "bad": ["let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> 1", "let _ = 100 >> 2"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: Unbound value >>\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> digitsOfInt n div 10 :: [n mod 10]", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663"], "bad": ["let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> (digitsOfInt n/10) @ [n%10]", "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> [digitsOfInt n/10] @ [n%10]", "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> digitsOfInt n/10 @ [n%10]", "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> [n%10] @ digitsOfInt n/10"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: Unbound value %\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec listReverse l =\nmatch l with\n| []\t    -> []\n| (_ :: h :: [])  -> h :: listReverse []", "let _ = listReverse [1; 2; 3; 4]", "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]"], "bad": ["let rec listReverse l =\nmatch l with\n| []\t    -> []\n| (t :: h :: [])  -> h :: listReverse t::[]", "let rec listReverse l =\nmatch l with\n| []\t    -> []\n| (t :: h :: [])  -> h :: listReverse t"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["1::[2]"], "bad": ["1::2"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 2401"], "bad": ["let _ = digitsOfInt -2401"], "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt (-1)"], "bad": ["let _ = digitsOfInt -2401", "let _ = digitsOfInt -1"], "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n", "Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 0"], "bad": ["let _ = digitsOfInt asr\n\n(* digits : int -> int list\n* (digits n) is the list of digits of n in the order in which they appear\n* in n\n* e.g. (digits 31243) is [3,1,2,4,3]\n*      (digits (-23422) is [2,3,4,2,2]\n*)\n\nlet digits n = digitsOfInt (abs n)"], "message": ["Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt ~-21041"], "bad": ["let _ = digitsOfInt -21041"], "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = palindrome \"malayalam\"", "let _ = palindrome \"myxomatosis\""], "bad": ["let palindrome w = \nif (explode(w)) = (listReverse (explode(w)))\nthen true\nelse false"], "message": ["Error: Unbound value palindrome\n"], "problem": "palindrome"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) =\nmatch f(b-1) with\n| (_, false) -> b\n| (bb, true) -> wwhile(f, bb)", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "bad": ["xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "message": ["Error: Syntax error\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 0)"], "bad": ["xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "message": ["Error: Syntax error\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["ate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n ="], "bad": ["let fixpoint (f, b) = wwhile (fun ff b -> (f(b), f(b) = f(b-1)) ,b)", "let fixpoint (f, b) = wwhile (fun ff b -> (f(b), f(b) != f(b-1)) ,b)", "let ff (b) =\n(f(b), f(b) != f(b-1)\nin\nlet fixpoint (f, b) = wwhile (ff ,b)", "let ff (b) =\n(f(b), f(b) != f(b-1))\nin\nlet fixpoint (f, b) = wwhile (ff ,b)", "let ff (b) =\n(f(b), f(b) != f(b-1))\nin\nlet fixpoint (f, b) = wwhile (ff, b)", "let fixpoint (f, b) = \nlet ff (b) =\n(f(b), f(b) != f(b-1))\nin\nwwhile (ff, b)"], "message": ["Error: Syntax error: operator expected.\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Characters 13-14:\n  (f(b), f(b) != f(b-1)\n  ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["true || false", "let fixpoint (f, b"], "bad": ["ate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n =", " match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)", "*", ")"], "message": ["Error: Unbound value trunc\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value n\n", "Error: Unbound value collatz\n", "Error: Unbound value collatz\n", "Error: Unbound value collatz\n", "Error: Unbound value collatz\n", "Error: Unbound value collatz\n", "Error: Syntax error\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)", "*", ")"], "bad": ["let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || b != f(b-1))), b)", "let g x = trunca", "te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n =", " match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint"], "message": ["Error: Unbound value trunca\nHint: Did you mean truncate?\n", "Error: Unbound value wwhile\n", "Error: Unbound value trunca\nHint: Did you mean truncate?\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value n\n", "Error: Unbound value fixpoint\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || b != f b-1)), b)", "let g x = trunca"], "bad": ["te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n ="], "message": ["Error: Unbound value trunca\nHint: Did you mean truncate?\n", "Error: Syntax error\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint"], "bad": ["te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n ="], "message": ["Error: Unbound value trunca\nHint: Did you mean truncate?\n", "Error: Syntax error\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)), b)", "let g x = trunca"], "bad": [" match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint"], "message": ["Error: Syntax error\n", "Error: Unbound value n\n", "Error: Unbound value fixpoint\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)", "*", ")"], "bad": ["let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b))), b)", "let g x = trunca", "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)", "let g x = trunca", "te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n =", " match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint", " (collatz, 3)", "let _ = fixpoint", " (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)", "*", ")"], "message": ["Error: Unbound value trunca\nHint: Did you mean truncate?\n", "Characters 27-28:\n  let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b))), b);;\n                             ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Unbound value trunca\nHint: Did you mean truncate?\n", "Error: Unbound value wwhile\n", "Error: Unbound value trunca\nHint: Did you mean truncate?\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value n\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value collatz\n", "Error: Unbound value fixpoint\n", "Error: Unbound value collatz\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Syntax error\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["exp 2.", "let _ = fixpoint ("], "bad": ["exp 2", "let _ = fixpoint ("], "message": ["Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let _ = fixpoint (exp, -1)", "let _ = fixpoint"], "bad": ["let _ = fixpoint (exp, 1)", "let _ = fixpoint", "let _ = fixpoint (exp, 1.)", "let _ = fixpoint"], "message": ["Error: Syntax error: operator expected.\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let _ = fixpoint ((fun b -> b ** 2), 0.)", "let _ = fixpoint"], "bad": ["let _ = fixpoint (exp, 0)", "let _ = fixpoint", "let _ = fixpoint (exp, 0.)", "let _ = fixpoint"], "message": ["Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["0. ** 2", "let _ = fixpoint ("], "bad": ["let _ = fixpoint ((fun b -> b ** 2.), 0.)", "let _ = fixpoint"], "message": ["Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["1. != 1.", "let _ = fixpoint ("], "bad": ["let _ = fixpoint ((fun b -> b ** 2.), 1.)", "let _ = fixpoint"], "message": ["Error: Syntax error: operator expected.\n", "Error: Unbound value fixpoint\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["(1. = 1.)", "let _ = fixpoint ("], "bad": ["!(1. = 1.)", "let _ = fixpoint ("], "message": ["Error: Syntax error: operator expected.\n", "Error: This expression has type bool but an expression was expected of type\n         'a ref\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)", "not (1. = 1.)", "let _ = fixpoint ("], "bad": ["let fixpoint(f, b) = wwhile((fun b -> (f(b), not (f(b) = b) || not (f(b) != f(f(b))))) , b)", "let g x = trunca"], "message": ["Error: Syntax error: operator expected.\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": [" ((fun b -> b ** 4.), 0.)", "let _ = fixpoint ((fun b -> b ** 4.), 1.)", "let _ = fixpoint"], "bad": ["let _ = fixpoint ((fun b -> b ** 2.), 1.)", "let _ = fixpoint", "let _ = fixpoint ((fun b -> b ** 2.), 0.)", "let _ = fixpoint ((fun b -> b ** 2.), 1.)", "let _ = fixpoint"], "message": ["Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": [" (sqrt, 12489124)", "let _ = fixpoint"], "bad": ["let _ = fixpoint ((fun b -> b ** 2.), 0.)", "let _ = fixpoint ((fun b -> b ** 2.), 1.)", "let _ = fixpoint ((fun b -> b ** 4.), 0.)", "let _ = fixpoint ((fun b -> b ** 4.), 1.)", "let _ = fixpoint (sqrt, 10.)", "let _ = fixpoint"], "message": ["Error: Syntax error: operator expected.\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec exprToString e = \nmatch e with\n| VarX _\t    -> \"x\"\n| VarY _\t    -> \"y\"\n| Sine x\t    -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine x\t    -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Average (x,y)     -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^\")/2)\"\n| Times (x,y)       -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (a,b,c,d)  -> \n\"(\" ^ exprToString(a) ^ \"<\" exprToString(y) ^ \"?\" ^ \nexprToString(c) ^ \":\" ^ exprToString(d)"], "bad": ["let rec exprToString e = \nmatch e with\n| VarX _ -> \"x\"\n| VarY _ -> \"y\"\n| Sine x -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Average (x,y) -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^\")/2)\""], "message": ["Error: Unbound value exprToStringx\nHint: Did you mean exprToString?\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec exprToString e = \nmatch e with\n| VarX\t\t    -> \"x\"\n| VarY\t\t    -> \"y\"\n| Sine x\t    -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine x\t    -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Average (x,y)     -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^\")/2)\"\n| Times (x,y)       -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (a,b,c,d)  -> \n\"(\" ^ exprToString(a) ^ \"<\" ^ exprToString(b) ^ \"?\" ^ \nexprToString(c) ^ \":\" ^ exprToString(d)"], "bad": ["let rec exprToString e = \nmatch e with\n| VarX _\t    -> \"x\"\n| VarY _\t    -> \"y\"\n| Sine x\t    -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine x\t    -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Average (x,y)     -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^\")/2)\"\n| Times (x,y)       -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (a,b,c,d)  -> \n\"(\" ^ exprToString(a) ^ \"<\" ^ exprToString(y) ^ \"?\" ^ \nexprToString(c) ^ \":\" ^ exprToString(d)", "let rec exprToString e = \nmatch e with\n| VarX _\t    -> \"x\"\n| VarY _\t    -> \"y\"\n| Sine x\t    -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine x\t    -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Average (x,y)     -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^\")/2)\"\n| Times (x,y)       -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (a,b,c,d)  -> \n\"(\" ^ exprToString(a) ^ \"<\" ^ exprToString(b) ^ \"?\" ^ \nexprToString(c) ^ \":\" ^ exprToString(d)"], "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: Unbound value y\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr,0.5,0.2)"], "bad": ["let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi * eval (a,x,y))\n| Cosine a -> cos (pi * eval (a,x,y))\n| Average (a,b) -> (eval(a,x,y) + eval(b,x,y)) /. 2.\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)", "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi *. eval (a,x,y))\n| Cosine a -> cos (pi *. eval (a,x,y))\n| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)"], "message": ["Error: Syntax error\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval (mySampleExpr3, 1.,2.)", "let _ = eval (mySampleExpr3, 14.,14.)", "let _ = eval (mySampleExpr3, 1203.,12.)"], "bad": ["let _ = eval (mySampleExpr3, 1,2)", "let _ = eval (mySampleExpr3, 14,14)", "let _ = eval (mySampleExpr3, 1203,12)"], "message": ["Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (fun a -> a) in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "message": ["Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs"], "message": ["Error: Unbound value a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs", "let _ = pipe [] 3"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let pipe fs = \nlet f a x = x a in\nlet base = base in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: Unbound value base\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x(a) in\nlet base = 0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs"], "message": ["Error: Unbound value x\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs b = \nlet f a x = x(a) in\nlet base = b in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x(a) in\nlet base =  in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x(a) in\nlet base = fun x in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x(a) in\nlet base = 0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x(a) in\nlet base = rec x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x(a) in\nlet base = x in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: Unbound value x\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs b = \nlet f a x = x(a) in\nlet base = b in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let _ = sqsum [1;1;1;1;1;0;1;0]", "let _ = sqsum [(-5); (-4); 1; 0; 7]", "let _ = sqsum [1]", "let _ = sqsum [0]", "let pipe fs = \nlet f a x = x(a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let _ = pipe []"], "bad": ["let _ = pipe [] 3"], "message": ["Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x(a) in\nlet base = \"\" in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3"], "message": ["Error: This function has type ('a list -> 'a list) list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x(a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x(a) in\nlet base = a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x(a) in\nlet base = _ in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x(a) in\nlet base = fun x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x(a) in\nlet base = (fun x) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x(a) in\nlet base =  in\nList.fold_left f base fs"], "message": ["Error: Unbound value a\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a x in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let y f g = fun x -> f (g x)"], "bad": ["let (y) f g = fun x -> f (g x)", "let (y) f g = fun x -> f (g x)"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base =  in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = function | a -> a in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let pipe fs = \nlet f a x = x a in\nlet base = int in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = function in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: Unbound value int\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = fun x' ->\nlet f a x = x a in\nlet base = x' in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let pipe fs = \nlet f a x = x a in\nlet base = int a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = b of int in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: Unbound value int\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let _ = stringOfList (fun x -> string_of_int(5*x)) [1;2;3;4;5;6]"], "bad": ["let _ = stringOfList (string_of_int fun x -> 5*x) [1;2;3;4;5;6]"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let rec clone x n = \nmatch n > 0 with\n| false -> []\n| true  -> x :: clone x (n-1)"], "bad": ["let rec clone x n = \nmatch n > 0 with\n| false -> []\n| true  -> [x] @ (clone x n-1)", "let rec clone x n = \nmatch n > 0 with\n| false -> []\n| true  -> x :: (clone (x n-1))", "let rec clone x n = \nmatch n > 0 with\n| false -> []\n| true  -> x :: clone x n-1"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         int -> int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nmatch List.length l1 = List.length l2 with\n| true -> (l1, l2)\n| false ->\nlet lendiff = List.length l1 - List.length l2 in\nmatch lendiff > 0 with\n| true  -> (l1, (clone 0 lendiff) @ l2)\n| false -> ((clone 0 (-lendiff)) @ l1, l2)"], "bad": ["let padZero l1 l2 = \nmatch List.length l1 = List.length l2 with\n| true -> (l1, l2)\n| false ->\nlet lendiff = List.length l1 - List.length l2 in\nmatch lendiff > 0 with\n| true  -> (l1, (clone 0 lendiff) @ l2)\n| false -> ((clone 0 -lendiff) @ l1, l2)"], "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = (x + y) / 10 :: a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = (x + y + a) / 10 in\nlet base = 0 in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = (x + y + a) / 10 in\nlet base = 0 in\nlet args = List.combine l1 l2 in\nList.fold_left f base args\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = (x + y + a) / 10 in\nlet base = 0 in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = (x + y) / 10 :: a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = ((x + y) mod 10) :: a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = ((x + y) % 10) :: a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Unbound value %\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = ((x + y) / 10) :: a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = ((x + y) % 10) :: a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Unbound value %\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = \nmatch a with\n| [] -> (x + y) :: a \n| h :: t -> [x + y + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in\nlet (res) = List.fold_left f base args in\nres\nin \n(add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = \nmatch a with\n| [] -> (x + y) :: a \n| h :: t -> [x + y + h/10; h % 10] @ t\nin\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in\nlet (res) = List.fold_left f base args in\nres\nin \n(add (padZero l1 l2))"], "message": ["Error: Unbound value %\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = \nmatch a with\n| [] -> (x + y) :: a \n| h :: t -> [x + y + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev((0,0) :: List.combine l1 l2) in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = \nmatch a with\n| [] -> (x + y) :: a \n| h :: t -> [x + y + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev((0,0) :: List.combine l1 l2) in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZeros (add (padZero l1 l2))"], "message": ["Error: Unbound value removeZeros\nHint: Did you mean removeZero?\nError: Unbound value removeZeros\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value removeZeros\nHint: Did you mean removeZero?\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = \nlet f a x = \nmatch a with\n| [] -> (i * x) :: a \n| h :: t -> [i * x + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev(0 :: l) in\nList.fold_left f base args"], "bad": ["let rec mulByDigit i l = \nlet f a x = \nmatch a with\n| [] -> (i * x) :: a \n| h :: t -> [x * y + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev(0 :: l) in\nList.fold_left f base args"], "message": ["Error: This expression has type ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b\n       but an expression was expected of type int\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = \nmatch a with\n| [] -> (x + y) :: a \n| h :: t -> [x + y + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev((0,0) :: List.combine l1 l2) in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = \nmatch a with\n| [] -> (x + y) :: a \n| h :: t -> [x + y + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev((0,0) :: List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd a (mulByDigit x l2)\nin\nlet base = [] in\nlet args = List.rev l1 in\nlet (res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []      -> (mulByDigit x l2) :: a\n| h :: t  -> [bigAdd (mulByDigit x l2) h/10; h mod 10] @ t \nin\nlet base = [] in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []      -> (mulByDigit x l2) :: a\n| h :: t  -> [bigAdd (mulByDigit x l2) [h/10]; h mod 10] @ t \nin\nlet base = [] in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd a (mulByDigit x l2)\nin\nlet base = [] in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd (List.rev(0 :: (List.rev a))) (mulByDigit x l2)\nin\nlet base = [] in\nlet args = List.rev l1 in\nlet (res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd List.rev(0 :: (List.rev a)) (mulByDigit x l2)\nin\nlet base = [] in\nlet args = List.rev l1 in\nlet (res) = List.fold_left f base args in\nres"], "message": ["Error: This function has type int list -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let test = mulByDigit 1 [1;0]", "List.rev test"], "bad": ["let test = mulByDigit 1 [1;0]\nList.rev test", "let test = mulByDigit 1 [1;0]\nList.rev test"], "message": ["Error: This function has type int -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "mulByDigit"}
{"hw": "hw1", "fix": ["let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x::y -> x + sumList y"], "bad": ["let rec sumList xs = \nmatch xs with\n| [] -> 0\n| [x] -> x\n| [x::y] -> x + sumList y", "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| [x::y] -> x + sumList y"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n / 10) @ [n mod 10]"], "bad": ["let rec digitsOfInt n =\nmatch n with\n| n < 0 -> []\n| n > 0 -> (n % 10)::digitsOfInt (n / 10)", "let rec digitsOfInt n =\nmatch n with\n| n <= 0 -> []\n| n > 0 -> (n % 10)::digitsOfInt (n / 10)", "let rec digitsOfInt n =\nmatch n with\n| n <= 0 -> []\n| n < 10 -> [n]\n| n > 0 -> (n % 10)::digitsOfInt (n / 10)", "let rec digitsOfInt n =\nif n < 0 then []\nelse match n with\n| a -> [a]\n| a^b -> a::digitsOfInt b", "let rec digitsOfInt n =\nif n < 0 then []\nelse match n with\n| a -> [a]\n| ab -> a::digitsOfInt b", "let rec digitsOfInt n =\nif n < 0 then []\nelse if n == 0 then 0\nelse digitsOfInt (n / 10) :: (n % 10)", "let rec digitsOfInt n =\nif n < 0 then []\nelse if n == 0 then []\nelse digitsOfInt (n / 10) :: (n % 10)", "let rec digitsOfInt n =\nif n < 0 then []\nelse if n == 0 then 0\nelse  digitsOfInt (n / 10) @ [n % 10]", "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n / 10) @ [n % 10]"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value a\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: Unbound value %\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec additivePersistence n =\nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then 1\nelse\n1 + additivePersistence sum"], "bad": ["let rec additivePersistence n =\nlet sum = sumList digitsOfInt n in\nif (sum < 10) then 1\nelse\n1 + additivePersistance sum", "let rec additivePersistence n =\nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then 1\nelse\n1 + additivePersistance sum"], "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value additivePersistance\nHint: Did you mean additivePersistence?\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4]", "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]"], "bad": ["let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> b :: listReverse a", "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> b :: listReverse [a]"], "message": ["Error: Unbound value digitalRoot\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4]", "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]"], "bad": ["let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ a"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4]", "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]"], "bad": ["let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b :: a", "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ a"], "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4]", "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]"], "bad": ["let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: [b] -> listReverse [b] @ a"], "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4]", "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]"], "bad": ["let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse (b) @ a"], "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4]", "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]"], "bad": ["let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ a"], "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let _ = digitsOfInt 0", "let digits n = digitsOfInt (abs n)", "let rec additivePersistence n =\nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then 1\nelse 1 + additivePersistence sum", "let _ = additivePersistence 9876", "let rec digitalRoot n =\nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then sum\nelse digitalRoot sum", "let _ = digitalRoot 9876", "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ [a]", "let _ = listReverse [1; 2; 3; 4]", "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]", "let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0", "let palindrome w =\nlet wList = explode (w) in\nlet wReverse = listReverse (explode (w)) in\n\nif (wList = wReverse) then true\nelse false", "let _ = palindrome \"malayalam\"", "let _ = palindrome \"myxomatosis\""], "bad": ["let palindrome w =\nlet wList = explode (w) in\nlet wReverse = listReverse (explode (w)) in\nif (true) then wList"], "message": ["Error: Syntax error\n"], "problem": "palindrome"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4]", "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]", "let _ = listReverse []"], "bad": ["let rec listReverse l =\nmatch l with\n| [] -> []\n(*| a :: b -> listReverse b @ [a] ;;*)\n| [a] @ b -> b :: listReverse a", "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ [a]"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let _ = digitsOfInt 0", "let _ = digitsOfInt (-1)"], "bad": ["let rec digitsOfInt n =\nif n < 0 then []\nelse if n < 10 then [n]\nelse (n mod 10) :: digitsOfInt (n/10)"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let _ = digitsOfInt 0", "let _ = digitsOfInt (-1)"], "bad": ["let rec digitsOfInt n =\nif n < 0 then []\nelse if n < 10 then [n]\nelse digitsOfInt (n/10) :: [n mod 10]", "let rec digitsOfInt n =\nif n < 0 then []\nelse if n > 10 then digitsOfInt (n / 10) :: [n mod 10]\nelse n", "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse if n > 10 then digitsOfInt(n mod 10)\nelse\nlet a = n mod 10 in\nlet b = n / 10 in\nif b = 0 then [n]\nelse a :: []"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let _ = digitsOfInt 0", "let _ = digitsOfInt (-1)"], "bad": ["let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse if n > 99 then digitsOfInt(n mod 10)\nelse\nlet a = n mod 10 in\nlet b = n / 10 in\nif b = 0 then [n]\nelse a :: digitsOfInt n"], "message": ["Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let _ = digitsOfInt 0", "let _ = digitsOfInt (-1)"], "bad": ["let rec digitsOfInt n =\nlet s = string_of_int n in\nmatch s with\n| a -> [a]\n| a ^ b -> a :: digitsOfInt b", "let rec digitsOfInt n =\nlet s = string_of_int n in\nmatch s with\n| a -> [a]\n| a ^ b -> a :: digitsOfInt b", "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse if n < 10 then [n]\nelse (n mod 10) :: digitsOfInt (n / 10)"], "message": ["Error: This expression has type int but an expression was expected of type\n         string\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 3124"], "bad": ["let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet a = n / 10 in\nlet b = n mod 10 in\nlet c = [a; b] in\nc"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 3124"], "bad": ["let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet a = n / 10 in\nlet b = n mod 10 in\nlet c = [a; b] in\nif a < 10 then c\nelse digitsOfInt (a / 10)"], "message": ["Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4]", "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]", "let _ = listReverse []"], "bad": ["let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ [a]"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4]", "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]", "let _ = listReverse []"], "bad": ["match l with\n| [] -> []\n| a :: b -> let c = listReverse b in", "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> let c = listReverse b in\nmatch c with\n| [] -> []\n| d :: e -> [d; a]"], "message": ["Error: Unbound value b\n", "Error: Syntax error\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4]"], "bad": ["let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> [listReverse b ; [a]]", "let rec listReverse l =\nmatch l with\n| [] -> []\n| b :: [] -> b :: []"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4]"], "bad": ["let rec listReverse l =\nmatch l with\n| [] -> []\n| [a;b] -> 0", "let rec listReverse l =\nmatch l with\n| [] -> []\n| [a;b] -> [a]"], "message": ["Error: Unbound value s\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4]", "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]", "let _ = listReverse []"], "bad": ["let rec listReverse l =\nlet last t =\nmatch t with\n| [] -> []\n| [a] -> a\n| a :: b -> last b\nin\nlast t :: listReverse l", "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b"], "message": ["Error: Syntax error\n", "Error: Unbound value last\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4]"], "bad": ["let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse [a]"], "message": ["Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4]"], "bad": ["let rec listReverse l =\nlet last t = function\nmatch t with\n| [] -> []\n| [a] -> [a]\n| b :: c -> last c\nin last l", "let rec listReverse l =\nlet last t = function\n| [] -> []\n| [a] -> [a]\n| b :: c -> last c\nin last l", "let rec listReverse l =\nlet rec last t =\nmatch t with\n| [] -> []\n| [a] -> [a]\n| b :: c -> last c\nin last l"], "message": ["Error: Unbound value last\n", "Error: Syntax error\n", "Error: Unbound value last\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec listReverse l =\nlet a = [] in\nlet get b = function\n| [] -> []\n| x :: xs -> x :: a\nin get l"], "bad": ["let rec listReverse l =\nlet a = [] in\nlet getHead b = function\nmatch b with\n| [] -> []\n| x :: xs ->\nx :: a\ngetHead xs\nin getHead l", "let rec listReverse l =\nlet a = [] in\nlet getHead b = function\n| [] -> []\n| x :: xs ->\nx :: a\ngetHead xs\nin getHead l", "let rec listReverse l =\nlet a = [] in\nlet rec get a =\nmatch a with\n| [] -> []\n| x :: xs -> get xs :: [x]\nin get l", "let rec listReverse l =\nlet a = [] in\nlet get a = function\n| [] -> []\n| x :: xs -> x :: a\nin get l"], "message": ["Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: Syntax error\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]"], "bad": ["let _ = listReverse [1; 2; 3; 4]"], "message": ["Error: Syntax error\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 3124"], "bad": ["let rec digitsOfInt n =\nlet rec integers a b =\nmatch a with\n| [] -> b\n| x :: xs -> integers xs ((a mod 10)::b)\nin integers n []", "let rec digitsOfInt n =\nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 3124"], "bad": ["let rec digitsOfInt n =\nif n = 0 then [0]\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let _ = digitsOfInt 0", "let _ = digitsOfInt (-10)"], "bad": ["et _ = digitsOfInt 3124", "let _ = digitsOfInt 3124"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n| []      ->\nd\n| h :: t  ->\nmatch h with\n| (s,l) ->\nif d = s then l\nelse assoc (d, k, t)"], "bad": ["let rec assoc (d,k,l) = match l with\n| []      ->\nd\n| h :: t  ->\nmatch h with\n| s * l ->\nif d = s then l\nelse assoc (d, k, t)", "let rec assoc (d,k,l) = match l with\n| []      ->\nd\n| h :: t  ->\nmatch h with\n| (s * l) ->\nif d = s then l\nelse assoc (d, k, t)"], "message": ["Error: Syntax error\n", "Characters 80-81:\n  | (s * l) ->\n    ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n| []      ->\nd\n| h :: t  ->\nmatch h with\n| (s,l) ->\nif k = s then l\nelse assoc (d, k, t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "bad": ["let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "message": ["Error: This expression has type string but an expression was expected of type\n         int\n", "Error: This expression has type string but an expression was expected of type\n         int\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with\n| []    ->\nseen\n| h::t  ->\nlet seen' =\nif (List.mem h seen) then seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) =\nmatch (f b) with\n| (b',c') -> 0"], "bad": ["let rec wwhile (f,b) =\nmatch (b',c')=(f b) in", "let rec wwhile (f,b) =\nmatch (f b) in\n| (b',c') -> 0"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) =\nwwhile (f ? false : true,b)", "*\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let fixpoint (f,b) =\nwwhile (f f b,b)", "let fixpoint (f,b) =\nwwhile (,b)"], "message": ["Error: This expression has type 'a -> 'b -> 'c\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b -> 'c\n", "Error: Syntax error: operator expected.\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) =\nwwhile ((f b) b,b)"], "bad": ["let fixpoint (f,b) =\nwwhile (f b = b,b)", "let fixpoint (f,b) =\nwwhile (fun x -> f x = b,b)", "let fixpoint (f,b) =\nwwhile (fun x -> (f x = b,b),b)"], "message": ["Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) =0", "*\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "bad": ["*\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Syntax error\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) =\nwwhile ((f b) b,b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["*\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Syntax error\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) =\nmatch l with\n| []      ->\nd\n| h :: t  ->\nmatch h with\n| (s,l) ->\nif k = s then l\nelse assoc (d, k, t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with\n| []    ->\nseen\n| h::t  ->\nlet seen' =\nif (List.mem h seen) then seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) =\nmatch (f b) with\n| (b',c') ->\nif c' then wwhile (f,b')\nelse b'", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) =\nwwhile (not f,b)"], "bad": ["let fixpoint (f,b) =\nwwhile (equ f b,b)", "let fixpoint (f,b) =\nwwhile (if b=(f b) then true else false,b)", "let fixpoint (f,b) =\nwwhile ((b,f b = b),b)", "let fixpoint (f,b) =\nwwhile (fun b -> (b,f b = b),b)", "let fixpoint (f,b) =\nwwhile (fun b -> (b,(f b) = b),b)", "let fixpoint (f,b) =\nwwhile ((f b <> b),b)", "let fixpoint (f,b) =\nwwhile (fun b -> (f b <> b),b)", "let fixpoint (f,b) =\nwwhile (match (f,b) with | (b',c') -> (f b' <> b'),b)"], "message": ["Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) =\nwwhile (f,b)"], "bad": ["let fixpoint (f,b) =\nwwhile (not ((f b)=b),b)", "let fixpoint (f,b) =\nwwhile ((not f),((f b)=b),b)", "let fixpoint (f,b) =\nwwhile (fun x -> not x,(f b)=b),b", ")", "let fixpoint (f,b) =\nwwhile (x -> not x,(f b)=b),b", ")", "let fixpoint (f,b) =\nwwhile ((x -> not x,(f b)=b),b)", "let fixpoint (f,b) =\nwwhile ((f,(f b)=b),b)"], "message": ["Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type ('d -> 'd * bool) * 'd\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: Syntax error\n", "Characters 28-29:\n  wwhile (x -> not x,(f b)=b),b;;\n         ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Characters 29-30:\n  wwhile ((x -> not x,(f b)=b),b);;\n          ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) =\nwwhile (f b,b)"], "bad": ["let fixpoint (f,b) =\nlet\nwwhile (fun f -> (f,(f b)=b),b)", "let fixpoint (f,b) =\nwwhile (fun f -> (f,(f b)=b),b)", "let fixpoint (f,b) =\nwwhile ((f,(f b) = b),b)", "let fixpoint (f,b) =\nwwhile (f -> (not f,(f b) = b),b)", "let fixpoint (f,b) =\nwwhile (let x -> not f in (x,(f b) = b),b)", "let fixpoint (f,b) =\nwwhile (let x = not f in (x,(f b) = b),b)"], "message": ["Error: Syntax error: operator expected.\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Characters 28-29:\n  wwhile (f -> (not f,(f b) = b),b);;\n         ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error: operator expected.\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) =\nwwhile (let func x = fun x -> (0,true) in func b,b)"], "bad": ["let fixpoint (f,b) =\nwwhile (fun x y -> (y,true) in func f b,b", ")", "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (0,true) in func f b,b)"], "message": ["Characters 28-29:\n  wwhile (fun x y -> (y,true) in func f b,b;;\n         ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Error: This expression has type int * bool\n       but an expression was expected of type 'a -> 'a * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f b,(f b) = b) in func b,b)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) =\nwwhile (let rec func x = fun x -> (f b,not ((f b) = b)) in func b,b)"], "bad": ["let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f b,(f b) = b) in func b,b)", "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b)", "let fixpoint (f,b) =\nwwhile (let _ = fun x -> (f b,not ((f b) = b)) in func b,b)", "let fixpoint (f,b) =\nwwhile (fun x -> (f b,not ((f b) = b)),b)", "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b)", "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b)", "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f b,f b = b),b)", "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f b,f b = b) in func,b)", "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f x,f x = x),b)", "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f x,f x = x) in func,b)", "let fixpoint (f,b) =\nwwhile (let func = fun x -> (f x,f x = x) in func,b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let fixpoint (f,b) =\nwwhile (let func = fun x -> (f x,f x <> x) in func,b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Syntax error: operator expected.\n", "Error: Unbound value wwhile\n", "Error: Syntax error: operator expected.\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "let _ = exprToString sampleExpr1"], "bad": ["let rec exprToString e =\nmatch e with\nVarX\t\t\t\t      ->\n\"x\"\n| VarY\t\t\t\t\t->\n\"y\"\n| Sine    of\t\t\t\t->\n\"sin(\" ^ exprToString expr ^ \")\"\n| Cosine  of expr\t\t\t->\n\"cos(\" ^ exprToString expr ^ \")\"\n| Average of expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"+\" ^ exprToString expr ^ \")/2)\"\n| Times   of expr * expr\t\t->\n| Thresh  of expr * expr * expr * expr  ->", "let rec exprToString e =\nmatch e with\nVarX\t\t\t\t      ->\n\"x\"\n| VarY\t\t\t\t\t->\n\"y\"\n| Sine    of expr\t\t\t->\n\"sin(\" ^ exprToString expr ^ \")\"\n| Cosine  of expr\t\t\t->\n\"cos(\" ^ exprToString expr ^ \")\"\n| Average of expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"+\" ^ exprToString expr ^ \")/2)\"\n| Times   of expr * expr\t\t->\n| Thresh  of expr * expr * expr * expr  ->", "let rec exprToString e =\nmatch e with\nVarX\t\t\t\t      ->\n\"x\"\n| VarY\t\t\t\t\t->\n\"y\"\n| Sine    of expr\t\t\t->\n\"sin(\" ^ exprToString expr ^ \")\"\n| Cosine  of expr\t\t\t->\n\"cos(\" ^ exprToString expr ^ \")\"\n| Average of expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"+\" ^ exprToString expr ^ \")/2)\"\n| Times   of expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"*\" ^ exprToString expr ^ \")\"\n| Thresh  of expr * expr * expr * expr  ->\n\"(\" ^ expr ^ \"<\" ^ expr ^ \"?\" ^ expr ^ \":\" ^ expr ^ \")\"", "let rec exprToString e =\nmatch e with\nVarX\t\t\t\t      ->\n\"x\"\n| VarY\t\t\t\t\t->\n\"y\"\n| Sine of expr\t\t\t->\n\"sin(\" ^ exprToString expr ^ \")\"\n| Cosine  of expr\t\t\t->\n\"cos(\" ^ exprToString expr ^ \")\"\n| Average of expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"+\" ^ exprToString expr ^ \")/2)\"\n| Times   of expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"*\" ^ exprToString expr ^ \")\"\n| Thresh  of expr * expr * expr * expr  ->\n\"(\" ^ expr ^ \"<\" ^ expr ^ \"?\" ^ expr ^ \":\" ^ expr ^ \")\"", "let rec exprToString e =\nmatch e with\nVarX\t\t\t\t      ->\n\"x\"\n| VarY\t\t\t\t\t->\n\"y\"\n| Sine expr\t\t\t->\n\"sin(\" ^ exprToString expr ^ \")\"\n| Cosine  of expr\t\t\t->\n\"cos(\" ^ exprToString expr ^ \")\"\n| Average of expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"+\" ^ exprToString expr ^ \")/2)\"\n| Times   of expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"*\" ^ exprToString expr ^ \")\"\n| Thresh  of expr * expr * expr * expr  ->\n\"(\" ^ expr ^ \"<\" ^ expr ^ \"?\" ^ expr ^ \":\" ^ expr ^ \")\"", "let rec exprToString e =\nmatch e with\nVarX\t\t\t\t      ->\n\"x\"\n| VarY\t\t\t\t\t->\n\"y\"\n| Sine    expr\t\t\t->\n\"sin(\" ^ exprToString expr ^ \")\"\n| Cosine  expr\t\t\t->\n\"cos(\" ^ exprToString expr ^ \")\"\n| Average expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"+\" ^ exprToString expr ^ \")/2)\"\n| Times   expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"*\" ^ exprToString expr ^ \")\"\n| Thresh  expr * expr * expr * expr  ->\n\"(\" ^ expr ^ \"<\" ^ expr ^ \"?\" ^ expr ^ \":\" ^ expr ^ \")\"", "let rec exprToString e =\nmatch e with\nVarX\t\t\t\t  ->\n\"x\"\n| VarY\t\t\t\t    ->\n\"y\"\n| Sine    expr\t\t\t    ->\n\"sin(\" ^ exprToString expr ^ \")\"\n| Cosine  expr\t\t\t    ->\n\"cos(\" ^ exprToString expr ^ \")\"\n| Average (expr * expr)\t    ->\n\"(\" ^ exprToString expr ^ \"+\" ^ exprToString expr ^ \")/2)\"\n| Times   expr * expr\t\t    ->\n\"(\" ^ exprToString expr ^ \"*\" ^ exprToString expr ^ \")\"\n| Thresh  expr * expr * expr * expr ->\n\"(\" ^ expr ^ \"<\" ^ expr ^ \"?\" ^ expr ^ \":\" ^ expr ^ \")\"", "let rec exprToString e =\nmatch e with\nVarX\t\t\t\t  ->\n\"x\"\n| VarY\t\t\t\t    ->\n\"y\"\n| Sine    expr\t\t\t    ->\n\"sin(\" ^ exprToString expr ^ \")\"\n| Cosine  expr\t\t\t    ->\n\"cos(\" ^ exprToString expr ^ \")\"\n| Average (expr,expr)\t\t    ->\n\"(\" ^ exprToString expr ^ \"+\" ^ exprToString expr ^ \")/2)\"\n| Times   (expr,expr)\t\t    ->\n\"(\" ^ exprToString expr ^ \"*\" ^ exprToString expr ^ \")\"\n| Thresh  (expr,expr,expr,expr)     ->\n\"(\" ^ expr ^ \"<\" ^ expr ^ \"?\" ^ expr ^ \":\" ^ expr ^ \")\"", "let rec exprToString e =\nmatch e with\nVarX\t\t\t\t  ->\n\"x\"\n| VarY\t\t\t\t    ->\n\"y\"\n| Sine    expr0\t\t\t    ->\n\"sin(\" ^ exprToString expr0 ^ \")\"\n| Cosine  expr0\t\t\t    ->\n\"cos(\" ^ exprToString expr0 ^ \")\"\n| Average (expr0,expr1)\t\t    ->\n\"(\" ^ exprToString expr0 ^ \"+\" ^ exprToString expr1 ^ \")/2)\"\n| Times   (expr0,expr1)\t\t    ->\n\"(\" ^ exprToString expr0 ^ \"*\" ^ exprToString expr1 ^ \")\"\n| Thresh  (expr0,expr1,expr2,expr3)     ->\n\"(\" ^ expr0 ^ \"<\" ^ expr1 ^ \"?\" ^ expr2 ^ \":\" ^ expr3 ^ \")\"", "let rec exprToString e =\nmatch e with\nVarX\t\t\t\t  ->\n\"x\"\n| VarY\t\t\t\t    ->\n\"y\"\n| Sine    expr0\t\t\t    ->\n\"sin(\" ^ exprToString expr0 ^ \")\"\n| Cosine  expr0\t\t\t    ->\n\"cos(\" ^ exprToString expr0 ^ \")\"\n| Average (expr0,expr1)\t\t    ->\n\"(\" ^ exprToString expr0 ^ \"+\" ^ exprToString expr1 ^ \")/2)\"\n| Times   (expr0,expr1)\t\t    ->\n\"(\" ^ exprToString expr0 ^ \"*\" ^ exprToString expr1 ^ \")\"\n| Thresh  (expr0,expr1,expr2,expr3)     ->\n\"(\" ^ exprToString expr0 ^ \"<\" ^ exprToString expr1 ^ \"?\" ^ exprToString expr2 ^ \":\" ^ exprToString expr3 ^ \")\""], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Characters 200-201:\n  | Average (expr * expr)\t    ->\n            ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Variable expr is bound several times in this matching\n", "Error: This expression has type expr but an expression was expected of type\n         string\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr,0.5,0.2)"], "bad": ["let rec eval (e,x,y) =\nmatch e with\nVarX\t\t\t\t  ->\nx\n| VarY\t\t\t\t    ->\ny\n| Sine    expr0\t\t\t    ->\nsin (eval (expr0,x,y))\n| Cosine  expr0\t\t\t    ->\ncos (eval (expr0,x,y))\n| Average (expr0,expr1)\t\t    ->\n(eval (expr0,x,y) +. eval (expr1,x,y)) /. 2.\n| Times (expr0,expr1)\t\t    ->\neval (expr0,x,y) *. eval (expr1,x,y)\n| Thresh  (expr0,expr1,expr2,expr3) ->\nmatch (eval (expr0,x,y) < eval (expr1,x,y)) with\ntrue  ->\neval (expr2,x,y)\n| false ->\neval (expr3,x,y)"], "message": ["Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 -> buildX()\n| 1 -> buildY()\n)\n| _ ->\n(match rand (0,3) with\n0 ->\nbuildSine(build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n)"], "bad": ["let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 -> buildX()\n| 1 -> buildY()\n)\n| _ ->\n(match rand (0,4) with\n0 ->\nbuildSine(build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n)"], "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * expr\n"], "problem": "build"}
{"hw": "hw2", "fix": ["type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\n| Maximum  of expr * expr * expr\n| Absolute of expr", "let rec exprToString e =\nmatch e with\nVarX\t\t\t\t  ->\n\"x\"\n| VarY\t\t\t\t    ->\n\"y\"\n| Sine    expr0\t\t\t    ->\n\"sin(pi*\" ^ exprToString expr0 ^ \")\"\n| Cosine  expr0\t\t\t    ->\n\"cos(pi*\" ^ exprToString expr0 ^ \")\"\n| Average (expr0,expr1)\t\t    ->\n\"(\" ^ exprToString expr0 ^ \"+\" ^ exprToString expr1 ^ \")/2)\"\n| Times   (expr0,expr1)\t\t    ->\nexprToString expr0 ^ \"*\" ^ exprToString expr1\n| Thresh  (expr0,expr1,expr2,expr3) ->\n\"(\" ^ exprToString expr0 ^ \"<\" ^ exprToString expr1 ^ \"?\" ^ exprToString expr2 ^ \":\" ^ exprToString expr3 ^ \")\"\n| Maximum (expr0,expr1,expr2)\t    ->\n\"maximum(\" ^ exprToString expr0 ^ \",\" ^ exprToString expr1 ^ \",\" ^ exprToString expr2 ^ \")\"\n| Absolute expr0\t\t    ->\n\"absolute(\" ^ exprToString expr0 ^ \")\"", "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "let _ = exprToString sampleExpr1", "let buildX()                       = VarX", "let buildY()                       = VarY", "let buildSine(e)                   = Sine(e)", "let buildCosine(e)                 = Cosine(e)", "let buildAverage(e1,e2)            = Average(e1,e2)", "let buildTimes(e1,e2)              = Times(e1,e2)", "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "let buildMaximum(e1,e2,e3)\t   = Maximum(e1,e2,e3)", "let buildAbsolute(e)\t\t   = Absolute(e)", "let pi = 4.0 *. atan 1.0", "let rec eval (e,x,y) =\nmatch e with\nVarX\t\t\t\t  ->\nx\n| VarY\t\t\t\t    ->\ny\n| Sine    expr0\t\t\t    ->\nsin (pi *. eval (expr0,x,y))\n| Cosine  expr0\t\t\t    ->\ncos (pi *. eval (expr0,x,y))\n| Average (expr0,expr1)\t\t    ->\n(eval (expr0,x,y) +. eval (expr1,x,y)) /. 2.\n| Times (expr0,expr1)\t\t    ->\neval (expr0,x,y) *. eval (expr1,x,y)\n| Thresh  (expr0,expr1,expr2,expr3) ->\n(match (eval (expr0,x,y) < eval (expr1,x,y)) with\ntrue  ->\neval (expr2,x,y)\n| false ->\neval (expr3,x,y)\n)\n| Maximum (expr0,expr1,expr2)       ->\n(match (eval (expr0,x,y) < eval (expr1,x,y)) with\ntrue  ->\n(match (eval (expr1,x,y) < eval (expr2,x,y)) with\ntrue  ->\neval (expr2,x,y)\n| false ->\neval (expr1,x,y)\n)\n| false ->\n(match (eval (expr0,x,y) < eval (expr2,x,y)) with\ntrue  ->\neval (expr2,x,y)\n| false ->\neval (expr0,x,y)\n)\n)\n| Absolute (expr0)\t\t    ->\n(match (eval (expr0,x,y) < 0) with\ntrue  ->\n0.0 -. eval (expr0,x,y)\n| false ->\neval (expr0,x,y)\n)", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "let _ = eval (sampleExpr,0.5,0.2)", "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 ->\nbuildX()\n| _ ->\nbuildY()\n)\n| _ ->\n(match rand (0,6) with\n0 ->\nbuildSine(build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 5 ->\nbuildMaximum(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 6 ->\nbuildAbsolute(build(rand,depth-1)\n)", "let g1 () = (12,0,9)", "let g2 () = (11,1,8)", "let g3 () = (10,2,7)", "let c1 () = (9,3,6)", "let c2 () = (8,4,5)", "let c3 () = (7,5,4)", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))\n\n\nlet rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))\n\n(********************* Bitmap creation code ***************)\n\n(* \nYou should not have to modify the remaining functions.\nAdd testing code to the bottom of the file.\n*)\n\n(* Converts an integer i from the range [-N,N] into a float in [-1,1] *)\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\n\n(* Converts real in [-1,1] to an integer in the range [0,255]  *)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\n\n\n(* ffor: int * int * (int -> unit) -> unit\nApplies the function f to all the integers between low and high\ninclusive; the results get thrown away.\n*)\n\nlet rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)\n\n(* emitGrayscale :  ((real * real) -> real) * int -> unit\nemitGrayscale(f, N) emits the values of the expression\nf (converted to intensity) to the file art.pgm for an \n2N+1 by 2N+1 grid of points taken from [-1,1] x [-1,1].\n\nSee \"man pgm\" on turing for a full description of the file format,\nbut it's essentially a one-line header followed by\none byte (representing gray value 0..255) per pixel.\n*)\n\nlet emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))\n\n(* doRandomGray : int * int * int -> unit\nGiven a depth and two seeds for the random number generator,\ncreate a single random expression and convert it to a\ngrayscale picture with the name \"art.pgm\" *)\n\nlet doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)\n\n(* uncomment when you have implemented `build` *)\n\nlet _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")"], "bad": ["let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 ->\nbuildX()\n| _ ->\nbuildY()\n)\n| _ ->\n(match rand (0,6) with\n0 ->\nbuildSine(build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 5 ->\nbuildMaximum(build(ran,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 6 ->\n)"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 ->\nbuildX()\n| _ ->\nbuildY()\n)\n| _ ->\n(match rand (0,6) with\n0 ->\nbuildSine(build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 5 ->\nbuildMaximum(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ ->\nbuildAbsolute(build(rand,depth-1))\n)"], "bad": ["let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 ->\nbuildX()\n| _ ->\nbuildY()\n)\n| _ ->\n(match rand (0,6) with\n0 ->\nbuildSine(build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 5 ->\nbuildMaximum(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 6 ->\nbuildAbsolute(build(rand,depth-1))\n)"], "message": ["Error: This expression has type expr/2139\n       but an expression was expected of type expr/3472\nError: Unbound constructor Average\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type expr/2139\n       but an expression was expected of type expr/3472\n"], "problem": "build"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = a x in\nlet base = 0 in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "message": ["Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs n = \nlet f a x = x a in\nlet base n = 0 in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "bad": ["let pipe fs = \nlet f a x = f a x in\nlet base = 0 in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let pipe fs = \nlet f a x = a x in\nlet base = x in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "message": ["Error: Unbound value f\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value x\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = \"\" in\nlet l =  in\nList.fold_left f base l"], "message": ["Error: Syntax error\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let stringOfList f l = \"[ \" ^ sepConcat \"; \" l ^ \" ]\""], "bad": ["let stringOfList f l = \"[ \" ^ sepConCat \"; \" l ^ \" ]\""], "message": ["Error: Unbound value sepConCat\nHint: Did you mean sepConcat?\nError: Unbound value sepConCat\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sepConCat\nHint: Did you mean sepConcat?\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs n = \nlet f a x = x a in\nlet base = n in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n =\nmatch n > 0 with\ntrue  ->\nx :: (clone x (n - 1))\n| false ->\n[]", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let padZero l1 l2 =\nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nmatch length1 >= length2 with\ntrue  ->\nlet n = length1 - length2 in\nlet zeroes = clone 0 n in\n(l1, List.append zeroes l2)\n\n| false ->\nlet n = length2 - length1 in\nlet zeroes = clone 0 n in\n(List.append zeroes l1, l2)", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let rec removeZero l =\nmatch l with\n[]    ->\n[]\n| h::t  -> match h with\n0 ->\nremoveZero t\n| _ -> t", "let _ = removeZero [0;0;0;1;0;0;2]", "let _ = removeZero [9;9]", "let _ = removeZero [0;0;0;0]", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch a with\n(carry,result)  ->\nmatch x with\n(h1::t1, h2::t2)  ->\n((h1+h2+carry)/10,  ((h1+h2) mod 10)::result)\nin\nlet base = (0, []) in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = (0,0) in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (0, a + x) in\nlet base = (0,0) in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = (0,0) in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = l1 in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = (_, l1) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = (0, l1) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = in\nlet base = in\nlet args = in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (a, a+x) in\nlet base = 0 in\nlet args = 1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (a, a+x) in\nlet base = 0 in\nlet args = [1] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch a with \nah::at  ->\nmatch x with\nxh::xt  ->\nah+at\nin\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch a with \nah::at  ->\nmatch x with\nxh::xt  ->\nah+xh\nin\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch x with \n(ah::at, bh::bt)  ->\n(1,(ah+bh)::a)\nin\nlet base = [] in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch x with \n(ah::at, bh::bt)  ->\n(1,(ah+bh)::a)\nin\nlet base = (0, []) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int * int\n       but an expression was expected of type int\n", "Error: This expression has type int -> int -> int * int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n", "Error: This expression has type int * int\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: Syntax error: operator expected.\n", "Error: This expression has type int * 'a\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int -> int -> int * int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n", "Error: This expression has type int -> int -> int * int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list -> int list -> int\n       but an expression was expected of type\n         int list -> int list -> int list\n       Type int is not compatible with type int list \n", "Error: This expression has type\n         int list -> int list * int list -> int * int list\n       but an expression was expected of type\n         int list -> int list * int list -> int list\n       Type int * int list is not compatible with type int list \n", "Error: This expression has type\n         int list -> int list * int list -> int * int list\n       but an expression was expected of type\n         int list -> int list * int list -> int list\n       Type int * int list is not compatible with type int list \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let padZero l1 l2 =\nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nmatch length1 >= length2 with\ntrue  ->\nlet n = length1 - length2 in\nlet zeroes = clone 0 n in\n(l1, List.append zeroes l2)\n\n| false ->\nlet n = length2 - length1 in\nlet zeroes = clone 0 n in\n(List.append zeroes l1, l2)"], "bad": ["let padZero l1 l2 =\nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nmatch length1 >= length2 with\ntrue  ->\nlet n = length1 - length2 in\nlet zeroes = clone 0 n in\n(l1, List.append (zeroes l2))\n\n| false ->\nlet n = length2 - length1 in\nlet zeroes = clone 0 n in\n(List.append (zeroes l1, l2))", "let padZero l1 l2 =\nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nmatch length1 >= length2 with\ntrue  ->\nlet n = length1 - length2 in\nlet zeroes = clone 0 n in\n(l1, List.append (zeroes l2))\n\n| false ->\nlet n = length2 - length1 in\nlet zeroes = clone 0 n in\n(List.append (zeroes l1), l2)"], "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\n(*\nlet f a x = (0,[]) in\nlet base = (l1, []) in\nlet args = l2 in*)\nlet (_, res) = (0,[0;0;0;0])(*List.fold_left f base args*) in\nres\nin\nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\n(*\nlet f a x = (0,[]) in\nlet base = (l1, []) in\nlet args = l2 in*)\nlet (_, res) = (0;[0;0;0;0])(*List.fold_left f base args*) in\nres\nin\nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = (0,[0;0;0;0]) in\nlet base = (0,[0;0;0;0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = (0,[0;0;0;0]) in\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = (0,[0;0;0;0]) in\nlet base = (l1) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = (0,[0;0;0;0]) in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int list * int list\n       but an expression was expected of type int * 'a list\n       Type int list is not compatible with type int \n", "Error: This expression has type int list * int list\n       but an expression was expected of type (int * int list) * 'a list\n       Type int list is not compatible with type int * int list \n", "Error: This expression has type int list * int list\n       but an expression was expected of type (int * int list) * 'a list\n       Type int list is not compatible with type int * int list \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = (0,[0;0;0;0]) in\nlet base = (0,l1) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = (0,[0;0;0;0]) in\nlet base = (0,[]) in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =(*\nmatch a with\n[]  ->\n([],[])\n| h1::t1  ->*)\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = function  ->\nmatch a with\n[]  ->\n([],[])\n| h1::t1  ->\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = function\nmatch a with\n[]  ->\n([],[])\n| h1::t1  ->\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = fun\nmatch a with\n[]  ->\n([],[])\n| h1::t1  ->\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n[]  ->\n([],[])\n| h1::t1  ->\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type 'a list -> 'b -> 'c list * int list\n       but an expression was expected of type 'a list -> 'b -> 'a list\n       Type 'c list * int list is not compatible with type 'a list \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1,_)  ->\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n[]  ->\n(l1,[0;0;0;0])\n| h1::t1  ->\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\nh1::t1  ->\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a list -> 'b -> 'c * int list\n       but an expression was expected of type 'a list -> 'b -> 'a list\n       Type 'c * int list is not compatible with type 'a list \n", "Error: This expression has type 'a list -> 'b -> 'c * int list\n       but an expression was expected of type 'a list -> 'b -> 'a list\n       Type 'c * int list is not compatible with type 'a list \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1,((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nPrintf.printf(%d, a)\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1,((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "message": ["Characters 64-65:\n  Printf.printf(%d, a)\n               ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1,(h1+x+rh)/10::((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1,(h1+x+rh)/10)::((h1+x+rh) mod 10)::rt", ")\nin\nlet base = (l1,[0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\n(List.tl (List.rev (h1::t1)), (h1+x)/10::((h1+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\n(List.tl (List.rev (h1::t1)), (h1+x+rh)/10::((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\n(List.tl List.rev h1::t1, (h1+x)/10::((h1+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\n(List.tl List.rev h1::t1, (h1+x+rh)/10::((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\nlet h2::t2 = List.rev (h1::t1) in\n(List.rev t2, (h2+x)/10::((h2+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\nlet h2::t2 = List.rev (h1::t1) in\n(List.rev t2, (h2+x+rh)/10::((h2+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\nlet h2::t2 = List.rev h1::t1 in\n(List.rev t2, (h2+x)/10::((h2+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\nlet h2::t2 = List.rev h1::t1 in\n(List.rev t2, (h2+x+rh)/10::((h2+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\nlet h2::t2 = List.rev h1::t1 in\n(List.rev t2, (h2+x)/10::((h2+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\nlet h2::t2 = List.rev h1::t1 in\n(List.rev t2, (h2+x+rh)/10::((h2+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, rh::rt)  ->\n(t1, bigAdd (mulByDigit h1 (rh::rt)) rt)\nin\nlet base = (List.rev l1, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let _ = bigMul [9;9;9;9] [9;9;9;9]"], "bad": ["let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, rh::rt)  ->\n(t1, bigAdd (mulByDigit h1 rh::rt) rt)\nin\nlet base = (List.rev l1, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let _ = bigMul [9;9;9;9] [9;9;9;9]"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: Unbound value bigMul\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, r) ->\n(h1::t1, bigAdd (mulByDigit x (h1::t1)) r)\n| _\t      ->\n(* Should not get here *) ([], [])\nin\nlet base = (List.rev l1, [1]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let _ = bigMul [2] [1]"], "bad": ["let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, r) ->\n(h1::t1, bigAdd (mulByDigit x h1::t1) r)\n| _\t      ->\n(* Should not get here *) ([], [])\nin\nlet base = (List.rev l1, [1]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let _ = bigMul [2] [1]"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let pipe fs n =\nlet f a x = x a in\nlet base = n in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = n in\nList.fold_left f base fs", "let pipe fs = fun\nlet f a x = x a in\nlet base = n in\nList.fold_left f base fs"], "message": ["Error: Unbound value n\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\n\n| _   ->\nx a\nin\nlet base = n in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\n1\n| _   ->\n0\n\nin\nlet base = f 0 [] in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x =\nlet g b y n =\nmatch n with\n[]  ->\nn\n| _   ->\ny b\nin g a x\nin\nlet base = f 0 [] in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int -> 'b list\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =\nmatch a with\n[]  ->\n[]\n| _   ->\nx a\nin\nlet base = f [] (fun x -> x) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\n1\n| _   ->\nx a\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\n[]\n| _   ->\nx a\nin\nlet base = f 0 [] in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =\nfun a x ->\nmatch x with\nx',y  ->\nx' a\nin\nlet base = f 0 [] in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\n[]\n| _   ->\nx a\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "let pipe fs = \nlet f a x =\nmatch x with\n[] ->\na\n| _  ->\nx a\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "let pipe fs = \nlet f a x =\nfun g b y z ->\nmatch y with\n[] ->\nz\n| _  ->\nb a\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "let pipe fs = \nlet f a x =\nfun a x ->\nmatch x with\nx' y  ->\nmatch x' with\n[]  ->\ny\n| _   ->\nx' a\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "let pipe fs = \nlet f a x =\nfun a x ->\nmatch x with\nx',y  ->\nmatch x' with\n[]  ->\ny\n| _   ->\nx' a\nin\nlet base = f 0 [] in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type\n         'a -> 'b -> 'c -> ('a -> 'd) -> 'e list -> 'd -> 'd\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside\n       'c -> ('a -> 'd) -> 'e list -> 'd -> 'd\n", "Error: Syntax error\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\n0\n| _   ->\n1\nin\nlet base = 0 in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\n0\n| _   ->\n1\nin\nlet base = [] in\nList.fold_left f base fs"], "message": ["Error: This function has type 'a list list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =\nx a\nin\nlet base = 0 in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "bad": ["let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\na\n| _   ->\nx a\nin\nlet base = 0 in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs n = \nlet f a x = x a in\nlet base = n in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "bad": ["let pipe fs = \nlet f a x =\nx\nin\nlet base = a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x =\nx\nin\nlet base = f x in\nList.fold_left f base fs"], "message": ["Error: Unbound value a\n", "Error: Unbound value x\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x y -> y in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base =match fs with\n(fn,n)  -> n in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type ('b -> 'b) list\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs =\nlet f a x = fun fn -> fun x a -> fn in\nlet base = fun b -> b in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "bad": ["let pipe fs =\nlet f a x = let fn = fun x a in fn in\nlet base = fun b -> b in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs =\nlet f a x = fun y -> x a in\nlet base = fun b -> b in\nList.fold_left f base fs"], "bad": ["let pipe fs =\nlet f a x = fun y -> x base in\nlet base = fun b -> b in\nList.fold_left f base fs"], "message": ["Error: Unbound value base\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs =\nlet f a x = fun y -> fun z -> y z in\nlet base = fun b -> b in\nList.fold_left f base fs"], "bad": ["let pipe fs =\nlet f a x = match x with\nfun y -> y a in\nlet base = fun b -> b in\nList.fold_left f base fs", "let pipe fs =\nlet f a x = match x with\n(fun y) -> y a in\nlet base = fun b -> b in\nList.fold_left f base fs", "let pipe fs =\nlet f a x = match x with\n(function y) -> y a in\nlet base = fun b -> b in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs =\nlet f a x = fun y -> x a in\nlet base = fun b -> b in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs =\nlet f a x = fun y -> x a in\nlet base = fun b -> b in\nList.fold_left f base fs"], "bad": ["let pipe fs =\nlet f a x = fun y -> x a in\nlet base = b in\nList.fold_left f base fs", "let pipe fs =\nlet f a x = fun y -> x a in\nlet base = fun b in\nList.fold_left f base fs", "let pipe fs =\nlet f a x = fun y -> x a in\nlet base = fun b -> fun b in\nList.fold_left f base fs"], "message": ["Error: Unbound value b\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs =\nlet f a x = let an = a in x an in\nlet base = fun b -> b in\nList.fold_left f base fs"], "bad": ["let pipe fs =\nlet f a x = fun y -> fun z -> z (fun r -> y) in\nlet base = fun b -> b in\nList.fold_left f base fs", "let pipe fs =\nlet f a x = fun y -> fun z -> z (fun r -> y) in\nlet base = fun b -> b in\nList.fold_left f base fs", "let pipe fs =\nlet f a x = fun y -> fun z -> z y in\nlet base = fun b -> b in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> (('b -> 'a) -> 'c) -> 'c\n       The type variable 'a occurs inside (('b -> 'a) -> 'c) -> 'c\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> (('b -> 'a) -> 'c) -> 'c\n       The type variable 'a occurs inside (('b -> 'a) -> 'c) -> 'c\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs =\nlet f a x = let y = a in x y in\nlet base = fun b -> b in\nList.fold_left f base fs"], "bad": ["let pipe fs =\nlet f a x = let fun y z = fun xn -> fun an -> xn an in y in\nlet base = fun b -> b in\nList.fold_left f base fs", "let pipe fs =\nlet f a x = let y z = fun xn -> xn a in y in\nlet base = fun b -> b in\nList.fold_left f base fs", "let pipe fs =\nlet f a x = let y z = fun xn -> xn a in y in\nlet base = fun b -> b in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: This expression has type 'a -> 'b -> 'c -> ('a -> 'd) -> 'd\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> ('a -> 'd) -> 'd\n", "Error: This expression has type 'a -> 'b -> 'c -> ('a -> 'd) -> 'd\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> ('a -> 'd) -> 'd\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs =\nlet f a x = let y = pipe x a in y in\nlet base = fun b -> b in\nList.fold_left f base fs"], "bad": ["let pipe fs =\nlet f a x = let y = pipe x a in x y in\nlet base = fun b -> b in\nList.fold_left f base fs"], "message": ["Error: This expression has type (('a -> 'a) -> 'a -> 'a) list\n       This is not a function; it cannot be applied.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs =\nlet f a x = x(a) in\nlet base = fun b -> b in\nList.fold_left f base fs"], "bad": ["let pipe fs =\nlet f a x = f x(a) in\nlet base = fun b -> b in\nList.fold_left f base fs"], "message": ["Error: Unbound value f\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs =\nlet f a x = fun y z -> z (x (a)) in\nlet base = fun b -> b in\nList.fold_left f base fs"], "bad": ["let pipe fs =\nlet f a x = fun c y z -> z (a (c)) in\nlet base = fun b -> b in\nList.fold_left f base fs", "let pipe fs =\nlet f a x = fun y z -> z (a (c)) in\nlet base = fun b -> b in\nList.fold_left f base fs"], "message": ["Error: This expression has type\n         ('a -> 'b) -> 'c -> 'a -> 'd -> ('b -> 'e) -> 'e\n       but an expression was expected of type ('a -> 'b) -> 'c -> 'a -> 'b\n       The type variable 'b occurs inside 'd -> ('b -> 'e) -> 'e\n", "Error: Unbound value c\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs =\nlet f a x = fun c -> x (a) in\nlet base = fun b -> b in\nList.fold_left f base fs"], "bad": ["let pipe fs =\nlet f a x = fun c -> c (x (a)) in\nlet base = fun b -> b in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs =\nlet f a x = fun c -> x c in\nlet base = fun b -> b in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs =\nlet f a x = fun c -> fun d -> x c in\nlet base = fun b -> b in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type int but an expression was expected of type\n         int -> int\n", "Error: This expression has type int but an expression was expected of type\n         int -> int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs =\nlet f a x = fun c -> x (fun d -> a) in\nlet base = fun b -> b in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let pipe fs =\nlet f a x = fun c -> fun d -> d c in\nlet base = fun b -> b in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let pipe fs =\nlet f a x = fun c -> a in\nlet base = fun b -> b in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs =\nlet f a x = fun c -> x in\nlet base = fun b -> b in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type int but an expression was expected of type\n         int -> int\n", "Error: This expression has type int but an expression was expected of type\n         int -> int\n"], "problem": "pipe"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = \nmatch l with\n| [] -> k\n| (s,i)::xs -> if k = s then i else assoc (d,k,xs)"], "bad": ["let rec assoc (d,k,l) = \nmatch l with\n| [] -> k\n| (s,i):xs -> if k = s then i else assoc (d,k,xs)", "let rec assoc (d,k,l) = \nmatch l with\n| [] -> k\n| x:xs -> let x = (s,i) in\nif k = s then i else assoc (d,k,xs)", "let rec assoc (d,k,l) = \nmatch l with\n| [] -> k\n| x::xs -> let x = (s,i) in\nif k = s then i else assoc (d,k,xs)"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value s\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (s,i)::xs -> if k = s then i else assoc (d,k,xs)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "bad": ["let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "message": ["Error: This expression has type int but an expression was expected of type\n         string\n", "Error: This expression has type int but an expression was expected of type\n         string\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = \nlet calc = f b in\nlet (b',c') = calc in\nif c' then wwhile (f,b') else b'"], "bad": ["let rec wwhile (f,b) = \nlet calc = f b in\nlet (b',c') = calc in\nif c' then f b' else b'", "let rec wwhile (f,b) = \nlet calc = f b in\nlet (b',c') = calc in\nif c' then f (b') else b'", "let rec wwhile (f,b) = \nlet calc = f b in\nlet (b',c') = calc in\nif c' then (f b') else b'"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((f),b)"], "bad": [" fixpoint (f,b) = wwhile ((f b),b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value f\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value f\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((let f x = f x in f b),b)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((fun x -> f b),b)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let fixpoint (f,b) = wwhile ((let f x = wwhile(f,x) in f b),b)"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((let f x = f b in f),b)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((fun x -> (f x,f x!=x)),b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let fixpoint (f,b) = wwhile ((fun x -> (f x,f x!=b)),b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine x -> \"sin(pi*%s)\" x\n| Cosine x -> \"cos(pi*%s)\" x\n| Average x y -> \"((%s+%s)/2)\" x y\n| Times x y -> \"%s*%s\" x y\n| Thresh x y z a -> \"%s<%s?%s:%s\" x y z a"], "bad": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\""], "message": ["Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "let _ = exprToString sampleExpr1"], "bad": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine x -> \"sin(pi*%s)\" x\n| Cosine x -> \"cos(pi*%s)\" x\n| Average (x,y) -> \"((%s+%s)/2)\" x y\n| Times (x,y) -> \"%s*%s\" x y\n| Thresh (x,y,z,a) -> \"%s<%s?%s:%s\" x y z a", "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine x -> sprintf \"sin(pi*%s)\" x\n| Cosine x -> sprintf \"cos(pi*%s)\" x\n| Average (x,y) -> sprintf \"((%s+%s)/2)\" x y\n| Times (x,y) -> sprintf \"%s*%s\" x y\n| Thresh (x,y,z,a) -> sprintf \"%s<%s?%s:%s\" x y z a", "let rec exprToString e = match e with\n| VarX -> Printf.sprintf \"x\"\n| VarY -> Printf.sprintf \"y\"\n| Sine x -> Printf.sprintf \"sin(pi*%s)\" x\n| Cosine x -> Printf.sprintf \"cos(pi*%s)\" x\n| Average (x,y) -> Printf.sprintf \"((%s+%s)/2)\" x y\n| Times (x,y) -> Printf.sprintf \"%s*%s\" x y\n| Thresh (x,y,z,a) -> Printf.sprintf \"%s<%s?%s:%s\" x y z a", "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\" ^ exprToString x ^ \"+\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (x,y,z,a) -> exprToString x ^ \"<\" ^ expToString y ^ \"?\" ^ exprToString z ^ \":\" ^ exprToString a", "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\" ^ exprToString x ^ \"+\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (x,y,z,a) -> exprToString x ^ \"<\" ^ exprToString y ^ \"?\" ^ exprToString z ^ \":\" ^ exprToString a"], "message": ["Error: Syntax error\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: Unbound value sprintf\n", "Error: This expression has type expr but an expression was expected of type\n         string\n", "Error: Unbound value expToString\nHint: Did you mean exprToString?\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr,0.5,0.2)"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin(pi * eval(a,x,y))\n| Cosine a -> cos(pi * eval(a,x,y))\n| Average (a,b) -> (eval(a,x,y) + eval(b,x,y)) / 2\n| Times (a,b) -> eval(a,x,y) * eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin(pi *. eval(a,x,y))\n| Cosine a -> cos(pi * eval(a,x,y))\n| Average (a,b) -> (eval(a,x,y) + eval(b,x,y)) / 2\n| Times (a,b) -> eval(a,x,y) * eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin(pi *. eval(a,x,y))\n| Cosine a -> cos(pi *. eval(a,x,y))\n| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin(pi *. eval(a,x,y))\n| Cosine a -> cos(pi *. eval(a,x,y))\n| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)"], "message": ["Error: Syntax error\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]"], "bad": ["let sqsum xs = \nlet f a x = match x with\n| []   -> a\n| h::t -> List.fold_left f (a + (h*h)) t in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]"], "message": ["Error: Unbound value f\n", "Error: Unbound value sqsum\n", "Error: Unbound value sqsum\n", "Error: Unbound value sqsum\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "message": ["Error: Unbound value a\n", "Error: Unbound value pipe\n", "Error: Unbound value pipe\n", "Error: Unbound value pipe\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let padZero l1 l2 =\nlet diff = (List.length l1 - List.length l2) in\nif diff >= 0 then (l1, (clone 0 diff) @ l2)\nelse ((clone 0 (abs diff)) @ l1, l2)"], "bad": ["let padZero l1 l2 =\nlet diff = (List.length l1 - List.length l2) in\nif diff >= 0 then (l1, (clone 0 diff) @ l2)\nelse ((clone 0 -diff) @ l1, l2)", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let padZero l1 l2 =\nlet diff = (List.length l1 - List.length l2) in\nif diff >= 0 then (l1, (clone 0 diff) @ l2)\nelse ((clone 0 abs diff) @ l1, l2)"], "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n", "Error: Unbound value padZero\n", "Error: Unbound value padZero\n", "Error: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| []   -> \nif ((arg1 + arg2) > 9)\nthen [1] @ [(arg1 + arg2) mod 10] @ a\nelse ((arg1 + arg2)::a)\n| h::t -> \nif ((arg1 + arg2 + h) > 9)\nthen [1] @ [(arg1 + arg2 + h) mod 10] @ a\nelse ((arg1 + arg2 + h)::a)\nin\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| []   -> \nif ((arg1 + arg2) > 9)\nthen [1] @ [(arg1 + arg2) mod 10] @ a\nelse ((arg1 + arg2)::a)\n| h::t -> \nif ((arg1 + arg2 + h) > 9)\nthen [1] @ [(arg1 + arg2 + h) mod 10] @ a\nelse ((arg1 + arg2 + h)::a)\nin\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0,[])   -> \nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0,[arg1 + arg2])\n| (1,_::t) -> \nif ((arg1 + arg2 + 1) > 9)\nthen (1, [(arg1 + arg2 + 1) mod 10] @ t)\nelse (0, ((arg1 + arg2 + 1)::t))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0,[])   -> \nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0,[arg1 + arg2])\n| (1,_::t) -> \nif ((arg1 + arg2 + h) > 9)\nthen (1, [(arg1 + arg2 + 1) mod 10] @ t)\nelse (0, ((arg1 + arg2 + 1)::t))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Unbound value h\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0,[])   -> \nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0,[arg1 + arg2])\n| (1, h::t) -> \nif ((arg1 + arg2 + 1) > 9)\nthen (1, [(arg1 + arg2 + 1) mod 10] @ t)\nelse (0, ((arg1 + arg2 + 1)::t))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0,[])   -> \nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0,[arg1 + arg2])\n| (1, _) -> \nif ((arg1 + arg2 + 1) > 9)\nthen (1, [(arg1 + arg2 + 1) mod 10] @ t)\nelse (0, ((arg1 + arg2 + 1)::t))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0,[])   -> \nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0,[arg1 + arg2])\n| (1, [h] @ [t]) -> \nif ((arg1 + arg2 + 1) > 9)\nthen (1, [(arg1 + arg2 + 1) mod 10] @ t)\nelse (0, ((arg1 + arg2 + 1)::t))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Unbound value t\n", "Error: Syntax error: pattern expected.\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0, acc) -> \nif ((arg1 + arg2) > 9)\nthen (1, ((arg1 + arg2) mod 10)::acc)\nelse (0,(arg1 + arg2)::acc)\n| (0, [])  ->\nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0, [arg1 + arg2])\n| (_, acc) -> \nif ((arg1 + arg2 + 1) > 9)\nthen (1, ((arg1 + arg2 + 1) mod 10)::acc)\nelse (0, ((arg1 + arg2 + 1)::acc))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0,_)   -> \nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0,[arg1 + arg2])\n| (_, _) -> \nif ((arg1 + arg2 + 1) > 9)\nthen (1, [(arg1 + arg2 + 1) mod 10] @ a)\nelse (0, ((arg1 + arg2 + 1)::a))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int * 'a\n       but an expression was expected of type int list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nlet (carry, acc) = a in \nif ((arg1 + arg2 + carry) > 9)\nthen (1, ((arg1 + arg2 + carry) mod 10)::acc)\nelse (0, ((arg1 + arg2 + carry)::acc))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (fin,res) = List.fold_left f base args in\nfin::res\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]", "let mulByDigit i l = \nlet saved = l in\nlet rec helper i' l' = \n| 1 -> l'\n| _ -> helper (i'-1) (bigAdd saved l')\nin helper i l"], "bad": ["let mulByDigit i l = \nlet rec helper i' l' = \nmatch i' with\n| 1 -> l'\n| _ -> mulByDigit (i'-1) (bigAdd l l')", "let mulByDigit i l = \nlet rec helper i' l' = \nmatch i' with\n| 1 -> l'\n| _ -> helper (i'-1) (bigAdd l l')", "let mulByDigit i l = \nlet rec helper i l' = \nmatch i with\n| 1 -> l'\n| _ -> helper (i-1) (bigAdd l l')"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = a in(*let (acc, l) = a in*)\n(*match l with\n| []   -> ([], [])\n| h::t -> let (first, second) = padZero [h] acc in\nlet f_rev = List.rev first in\n(0::acc, mulByDigit x f_rev) *)\nlet base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = let (acc, l) = a in\nmatch l with\n| []   -> ([], [])\n| h::t -> let (first, second) = padZero [h] acc in\nlet f_rev = List.rev first in\n(0::acc, (mulByDigit x f_rev))", "let base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = let (acc, l) = a in\nmatch l with\n| []   -> ([], [])\n| h::t -> let (first, second) = padZero [h] acc in\nlet f_rev = List.rev first in\n(0::acc, [](*mulByDigit x f_rev*))", "let base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x =\nlet (acc, l) = a in\nlet h::t = l in\n([],[])", "let base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = ([], [])", "let base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = (0, [])", "let base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = a", "let base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: Syntax error\n", "Error: Unbound value l1\n", "Error: Syntax error\n", "Error: Unbound value l1\n", "Error: Syntax error\n", "Error: Unbound value l1\n", "Error: Syntax error\n", "Error: Unbound value l1\n", "Error: Syntax error\n", "Error: Unbound value l1\n", "Error: Syntax error\n", "Error: Unbound value l1\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 n-1) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nmatch l with\n| []   -> \n([], [], acc)\n| h::t -> \nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\n(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet padded_x = x*10^((List.length padding) - 1) in\nmatch l with\n| []   -> \n([], [], acc)\n| h::t -> \nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\n(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet padded_x = x*10**((List.length padding) - 1) in\nmatch l with\n| []   -> \n([], [], acc)\n| h::t -> \nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\n(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet padded_x = x*10.**((List.length padding) - 1) in\nmatch l with\n| []   -> \n([], [], acc)\n| h::t -> \nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\n(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type int but an expression was expected of type\n         string\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         string\n", "Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         float\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 (n-1)) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nlet rec helper padding l acc padded_x = \nmatch l with\n| []   ->\n[]\n| h::t ->\nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\nbigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x) in\nlet result = helper padding l acc padded_x in\n([0], l, result) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 (n-1)) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nlet rec helper padding l acc padded_x = \nmatch l with\n| []   ->\n[]\n| h::t ->\nlet (first, second) = padZero [h] padding in\nlet f_rev = List.reverse first in\nbigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x in\nlet result = helper padding l acc padded_x in\n([0], t, result) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 (n-1)) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nlet rec helper padding l acc padded_x = \nmatch l with\n| []   ->\n[]\n| h::t ->\nlet (first, second) = padZero [h] padding in\nlet f_rev = List.reverse first in\nlet this_guy = bigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x in\nlet result = helper padding l acc padded_x in\n([0], t, result) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 (n-1)) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nlet rec helper padding l acc padded_x = \nmatch l with\n| []   ->\n[]\n| h::t ->\nlet (first, second) = padZero [h] padding in\nlet f_rev = List.reverse first in\nbigAdd (mulByDigit (padded_x) (f_rev)) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x in\nlet result = helper padding l acc padded_x in\n([0], t, result) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 (n-1)) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nlet rec helper padding l acc padded_x = \nmatch l with\n| []   ->\n[]\n| h::t ->\nlet (first, second) = padZero [h] padding in\nlet f_rev = List.reverse first in\nbigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x) in\nlet result = helper padding l acc padded_x in\n([0], t, result) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 (n-1)) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nlet rec helper padding l acc padded_x = \nmatch l with\n| []   ->\n[]\n| h::t ->\nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\nbigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x) in\nlet result = helper padding l acc padded_x in\n([0], t, result) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres"], "message": ["Characters 382-383:\n  bigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x in\n                                     ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Characters 397-398:\n  let this_guy = bigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x in\n                                                    ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Characters 386-387:\n  bigAdd (mulByDigit (padded_x) (f_rev)) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x in\n                                         ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Unbound value List.reverse\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value List.reverse\n", "Error: Unbound value t\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value t\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x =\nlet (padding, acc) = a in\n(padding+1, bigAdd acc ((mulByDigit x l1) @ (clone 0 padding))) in\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x =\nlet (padding, acc) = a in\n(padding+1, l1, bigAdd acc ((mulByDigit x l1) @ (clone 0 padding))) in\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type\n         int * int list -> int -> int * int list * int list\n       but an expression was expected of type\n         int * int list -> int -> int * int list\n       Type int * int list * int list is not compatible with type\n         int * int list \nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type\n         int * int list -> int -> int * int list * int list\n       but an expression was expected of type\n         int * int list -> int -> int * int list\n       Type int * int list * int list is not compatible with type\n         int * int list \n"], "problem": "bigMul"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = if n > 0\nthen\n(n mod 10) :: (digitsOfInt (n/10))\nelse\n[]"], "bad": ["let rec digitsOfInt n = if n > 0\nthen\n(digitsOfInt (n/10)) :: n mod 10\nelse\n0", "let rec digitsOfInt n = if n > 0\nthen\n(digitsOfInt (n/10)) :: n mod 10\nelse\n[]"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec listReverse l = function\n| [] -> l\n| (h::t) -> listReverse (h::l) t"], "bad": ["let rec listReverse l = function\n| [] -> l\n| (h::t) -> listReverse (h::l) t"], "message": ["Error: Unbound value listReverse\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec listReverse l = match l with\n| [] -> l\n| [other::tail::[]] -> tail :: other"], "bad": ["let rec listReverse l = function\n| [] -> l\n| (h::t) -> listReverse (h::l) t in\nlistReverse [] l", "let rec listReverse l = match l with\n| [] -> l\n| [_::tail::[]] -> l"], "message": ["Error: Unbound value l\n", "Error: Unbound value l\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec listReverse l =\nlet rec listReverseHelper l ans = match ans with\n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans"], "bad": ["let rec listReverseHelper l ans = \n[] -> [];\n(h::t) -> ans :: listReverseHelper t ans", "let rec listReverse l =\nlistReverseHelper l []", "let rec listReverseHelper l ans = \n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans", "let rec listReverseHelper l ans = match l with\n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "Error: Syntax error\n", "Error: Unbound value listReverseHelper\n", "Error: Syntax error\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4]", "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]"], "bad": ["let rec listReverse l =\nlet rec listReverseHelper l ans = match ans with\n| [] -> []\n| h::t -> listReverseHelper t (h::ans)\n\nlistReverseHelper l []", "let rec listReverse l =\nlet rec listReverseHelper l ans = match ans with\n| [] -> []\n| h::t -> listReverseHelper t (h::ans) in \n\nlistReverseHelper l []"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = additivePersistence 9876"], "bad": ["let rec additivePersistence n = \nlet rec sumDigits n1 = \nif n < 10 then \nn \nelse\nn1 mod 10 + sumDigits (n1 / 10) in \nif (n < 10) then\n0\nelse\n1 + additivePersistence (sumDigits n)"], "message": ["Error: Unbound value %\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let _ = digitalRoot 9873"], "bad": ["let rec digitalRoot n = \nif (n > 10) then \ndigitalRoot (sumDigits n)\nelse\nn"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "problem": "digitalRoot"}
{"hw": "hw1", "fix": ["let palindrome w = (explode w) = (listReverse (explode w))"], "bad": ["let palindrome w = (explode w) = (listReverse (explode w))"], "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n"], "problem": "palindrome"}
{"hw": "hw2", "fix": ["let rec fixpoint (f,x) = \nlet x' = f x in\nif x' = x then x else fixpoint (f, x')"], "bad": ["let rec fixpoint (f,x) = \nlet x' = f x in\nif x' = x then x else fixpoint f x'"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type\n         (('a -> 'b) -> 'a -> 'b) * ('a -> 'b)\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec fixpoint (f,x) = \nlet x' = f x in\nlet g x = (x', x' = x) in \nwwhile (g,x)"], "bad": ["let rec fixpoint (f,x) = \nlet x' = f x in\nlet g x = (f, x' = x) in \nwwhile (g,x)"], "message": ["Error: This expression has type 'a -> ('b -> 'a) * bool\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'b -> 'a\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 2)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, .2)"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine     (e1) -> sin(pi *. (eval (e1, x, y)))\n| Cosine   (e1) -> cos(pi *. (eval (e1, x, y)))\n| Average  (e1, e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y)))/.2.\n| Times    (e1, e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n| Thresh   (e1, e2, e3, e4) \n-> if (eval (e1, x, y)) < (eval (e2, x, y)) then\n(eval (e3, x, y)) else\n(eval (e4, x, y))"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine     (e1) -> sin(pi *. (exprToString e1))\n| Cosine   (e1) -> cos(pi *. (exprToString e1))\n| Average  (e1, e2) -> ((exprToString e1) +. (exprToString e2))/.2.\n| Times    (e1, e2) -> (exprToString e1) *. (exprToString e2)\n| Thresh   (e1, e2, e3, e4) \n-> if (exprToString e1) < (exprToString e2) then\n(exprToString e3) else\n(exprToString e4)", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine     (e1) -> sin(pi *. (eval e1))\n| Cosine   (e1) -> cos(pi *. (eval e1))\n| Average  (e1, e2) -> ((eeval e1) +. (eval e2))/.2.\n| Times    (e1, e2) -> (eval e1) *. (eval e2)\n| Thresh   (e1, e2, e3, e4) \n-> if (eval e1) < (eval e2) then\n(eval e3) else\n(eval e4)"], "message": ["Error: This expression has type string but an expression was expected of type\n         float\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine     (e1) -> sin(pi *. (eval (e1, x, y)))\n| Cosine   (e1) -> cos(pi *. (eval (e1, x, y)))\n| Average  (e1, e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y)))/.2.\n| Times    (e1, e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n| Thresh   (e1, e2, e3, e4) \n-> if (eval (e1, x, y)) < (eval (e2, x, y)) then\n(eval (e3, x, y)) else\n(eval (e4, x, y))\n| AbsThresh (e1, e2, e3) -> let s = eval (e3, x, y) in\nif abs_float (eval (e1, x, y)) < abs_float (eval (e2, x, y)) then\ns else\nabs_float s\n| ModThresh (e1, e2, e3) -> \nif (truncate (100. *. (eval (e1, x, y)))) mod 5 = 0 then\n(eval (e2, x, y)) else\n(eval (e3, x, y))"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine     (e1) -> sin(pi *. (eval (e1, x, y)))\n| Cosine   (e1) -> cos(pi *. (eval (e1, x, y)))\n| Average  (e1, e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y)))/.2.\n| Times    (e1, e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n| Thresh   (e1, e2, e3, e4) \n-> if (eval (e1, x, y)) < (eval (e2, x, y)) then\n(eval (e3, x, y)) else\n(eval (e4, x, y))\n| AbsThresh (e1, e2, e3) -> let s = eval (e3, x, y) in\nif abs_float (eval (e1, x, y)) < abs_float (eval (e2, x, y)) then\ns else\nabs_float s\n| ModThresh (e1, e2, e3) -> \nif (truncate (100 *. (eval (e1, x, y)))) mod 5 = 0 then\n(eval (e2, x, y)) else\n(eval (e3, x, y))"], "message": ["Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = buildY()"], "bad": ["let rec build (rand, depth) = \nlet r = rand (0,99) in\nif depth = 0 then\nif (r < 50) then\nbuildX\nelse\nbuildY\nelse\nif (r < 5) then\nbuildX()\nelse if (r < 10) then\nbuildY()\nelse if (r < 30) then \nbuildSine (build (rand, depth - 1))\nelse if (r < 50) then \nbuildCosine (build (rand, depth - 1))\nelse if (r < 60) then \nbuildAverage (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 70) then \nbuildTimes (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 80) then \nbuildThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 90) then \nbuildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))\nelse if (r < 90) then \nbuildModThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))", "let rec build (rand, depth) = \nlet r = rand (0,99) in\nif depth = 0 then\nif (r < 50) then\nbuildX()\nelse\nbuildY()\nelse\nif (r < 5) then\nbuildX()\nelse if (r < 10) then\nbuildY()\nelse if (r < 30) then \nbuildSine (build (rand, depth - 1))\nelse if (r < 50) then \nbuildCosine (build (rand, depth - 1))\nelse if (r < 60) then \nbuildAverage (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 70) then \nbuildTimes (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 80) then \nbuildThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 90) then \nbuildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))\nelse if (r < 90) then \nbuildModThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))"], "message": ["Error: This expression has type expr but an expression was expected of type\n         unit -> expr\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nlet r = rand (0,99) in\nif depth = 0 then\nif (r < 50) then\nbuildX()\nelse\nbuildY()\nelse\nbuildY()"], "bad": ["let rec build (rand, depth) = \nlet r = rand (0,99) in\nif depth = 0 then\nif (r < 50) then\nbuildX() : expr\nelse\nbuildY()\nelse\nif (r < 5) then\nbuildX()\nelse if (r < 10) then\nbuildY()\nelse if (r < 30) then \nbuildSine (build (rand, depth - 1))\nelse if (r < 50) then \nbuildCosine (build (rand, depth - 1))\nelse if (r < 60) then \nbuildAverage (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 70) then \nbuildTimes (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 80) then \nbuildThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 90) then \nbuildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))\nelse if (r < 90) then \nbuildModThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))", "let rec build (rand, depth) = \nlet r = rand (0,99) in\nif depth = 0 then\nif (r < 50) then\nbuildX() :: expr\nelse\nbuildY()\nelse\nif (r < 5) then\nbuildX()\nelse if (r < 10) then\nbuildY()\nelse if (r < 30) then \nbuildSine (build (rand, depth - 1))\nelse if (r < 50) then \nbuildCosine (build (rand, depth - 1))\nelse if (r < 60) then \nbuildAverage (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 70) then \nbuildTimes (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 80) then \nbuildThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 90) then \nbuildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))\nelse if (r < 90) then \nbuildModThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))"], "message": ["Error: Syntax error\n", "Error: Unbound value expr\nHint: Did you mean exp?\nError: Unbound constructor AbsThresh\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value expr\nHint: Did you mean exp?\n"], "problem": "build"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nlet dif = (List.length l1) - (List.length l2) in\nif (dif = 0) then\n(l1, l2)\nelse if (dif < 0) then (*l2 is bigger*)\n((clone 0 (0-dif)) @ l1, l2)\nelse\n(l1, ((clone 0 dif) @ l2))", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let _ = padZero [1;0;0;2] [9;9;9;9]"], "bad": ["let padZero l1 l2 = \nlet dif = (List.length l1) - (List.length l2) in\nif (dif = 0) then\n(l1, l2)\nelse if (dif < 0) then (*l2 is bigger*)\n((clone 0 (0-diff)) @ l1, l2)\nelse\n(l1, ((clone 0 diff) @ l2))", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let _ = padZero [1;0;0;2] [9;9;9;9]"], "message": ["Error: Unbound value diff\nHint: Did you mean dif?\n", "Error: Unbound value padZero\n", "Error: Unbound value padZero\n", "Error: Unbound value padZero\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, rest) = a in\nlet (d1, d2) = x in\nlet sum = d1 + d2 + carry in\nif (sum > 9) then\n(1, (sum - 10)::rest)\nelse\n(0, sum::rest) in\nlet base = (0, []) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, rest) = a in\nlet (d1, d2) = x in\nlet sum = d1 + d2 + carry in\nif (sum > 9) then\n(1, (sum - 10)::rest)\nelse\n(0, sum::rest) in\nlet base = (0, []) in\nlet args = List.combine (list.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Unbound value list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let _ = bigMul [0;99] []"], "bad": ["let _ = bigMul [0,99] []"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"], "problem": "bigMul"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \nn :: []"], "bad": ["let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \n|", "let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \nn mod 10", "let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \nn mod 10\nn::[]"], "message": ["Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]", "let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)"], "bad": ["let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \n(n mod 10) :: [digitsOfInt n]", "let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \n(n mod 10) :: digitsOfInt n :: []"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList"], "bad": ["let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)\ntoAdd@[]", "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)\ntoAdd@myList", "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)\ntoAdd@myList", "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)\ntoAdd@myList", "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)\ntoAdd@myList", "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)\ntoAdd@myList", "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)\ntoAdd@myList\nhi", "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)", "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)", "toAdd@myList", "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)", "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse (\nlet toAdd = (n mod 10)", "toAdd@myList", "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse (\n(n mod 10)@myList", ")", "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse (\n(n mod 10)@myList", ")", "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse (\nn mod 10 @myList", ")", "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse (\nn mod 10 @myList", ")", "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 @myList"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value toAdd\n", "Error: Syntax error\n", "Error: Syntax error: operator expected.\n", "Error: Unbound value toAdd\n", "Characters 70-71:\n  else (\n       ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Characters 70-71:\n  else (\n       ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Characters 70-71:\n  else (\n       ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Characters 70-71:\n  else (\n       ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []", "let _ = 1"], "bad": ["let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []", "let _ = 1;l\nn mod 10 :: myList"], "message": ["Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "Error: Unbound value l\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse []"], "bad": ["let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\n\nn mod 10 :: myList", "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []", "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []", "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen ->[]", "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen -> []"], "message": ["Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn mod 10 :: myList"], "bad": ["let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []", "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse"], "message": ["Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn mod 10 :: myList"], "bad": ["let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\n\nn mod 10 :: myList", "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []", "n mod 10 :: myList"], "message": ["Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "Error: Unbound value n\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn mod 10 :: myList", "n mod 100 :: myList"], "bad": ["let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn mod 10 :: myList\nn mod 100 :: myList"], "message": ["Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt n"], "bad": ["let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn = n - (n mod 10);\n(n :: myList) :: digitsOfInt", "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nlet n = n - (n mod 10);\n(n :: myList) :: digitsOfInt", "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nlet n = n - (n mod 10);\n(n :: myList) :: digitsOfInt", "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse (\nlet n = n - (n mod 10);\n(n :: myList) :: digitsOfInt\n)", "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse (\nlet n = n - (n mod 10);\n(n :: myList) :: digitsOfInt\n)", "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse (\nlet n = n - (n mod 10);\n(n :: myList) :: digitsOfInt", ")", "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse (\n(n mod 10 :: myList) :: digitsOfInt\n)"], "message": ["Error: This expression has type bool but an expression was expected of type\n         'a list\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error\n", "Error: This expression has type int -> int list list\n       but an expression was expected of type int list list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt (n - n mod 10)"], "bad": ["let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt"], "message": ["Error: This expression has type int -> int list list\n       but an expression was expected of type int list list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))"], "bad": ["let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10)"], "message": ["Characters 70-71:\n  (n mod 10 :: digitsOfInt (n / 10);;\n  ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\nif (n <= 0) then []\nelse \nList.rev (n mod 10 :: digitsOfInt (n / 10))"], "bad": ["let rec digitsOfInt n =\nif (n <= 0) then []\nelse \nrev (n mod 10 :: digitsOfInt (n / 10))"], "message": ["Error: Unbound value rev\nHint: Did you mean ref?\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))"], "bad": ["let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: List.rev digitsOfInt (n / 10))"], "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))"], "bad": ["let rec digitsOfInt n =\nif (n <= 0) then []\nelse \nlet _ = (n mod 10 :: digitsOfInt (n / 10))"], "message": ["Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))"], "bad": ["let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))\nList.rev"], "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: List.rev (digitsOfInt (n / 10)))"], "bad": ["let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: List.rev digitsOfInt (n / 10))", "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: (List.rev digitsOfInt (n / 10)))"], "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \n(digitsOfInt n)"], "bad": ["let rec additivePersistence n = \n- = digitsOfInt n", "let rec additivePersistence n = \nlet a = (digitsOfInt n)"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0\n| _ -> sumList (digitsOfInt n)"], "bad": ["let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0\n| (h::t) -> h + t", "let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0\n| _ -> sumList digitsOfInt n", "let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0;\n| _ -> sumList digitsOfInt n", "let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0\n| _ -> sumList digitsOfInt n;"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) then additivePersistence (sumList (digitsOfInt n))", ")"], "bad": ["let rec additivePersistence n = \nlet _ = sumList (digitsOfInt n)", "let rec additivePersistence n = \nlet _ = sumList (digitsOfInt n)", "let rec additivePersistence n = \nlet _ = 2", "let rec additivePersistence n = \nlet _ = 2"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen  \nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count"], "bad": ["let rec additivePersistence n = \nlet count = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen  \ncount++\nelse\nsumList (digitsOfInt n)", "let rec additivePersistence n = \nlet count = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen  \ncount++", "let rec additivePersistence n = \nlet count = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen  \ncount = count + 1", "let rec additivePersistence n = \nlet count = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen  \nlet count = count + 1", "let rec additivePersistence n = \nlet count = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen  \nlet count = 9", "let rec additivePersistence n = \nlet count = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen  \nlet co = 9", "let rec additivePersistence n = \nlet count = [] in\nif (sumList (digitsOfInt n) > 9) \nthen  \n1::count\nadditivePersistence (sumList (digitsOfInt n))", "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen  \n1::count\nadditivePersistence (sumList (digitsOfInt n))", "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen  \n1::count\nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type bool but an expression was expected of type\n         unit\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]", "let rec digitsOfInt n = \nif (n <= 0) then []\nelse \nList.rev (n mod 10 :: List.rev (digitsOfInt (n/10)))", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let digits n = digitsOfInt (abs n)", "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen \n1::count \nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count"], "bad": ["let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen  \n1::count\nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count", "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen (\n1::count\nadditivePersistence (sumList (digitsOfInt n)))\nelse sumList count", "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen \n1::count\nelse sumList count"], "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nlet x = 1 in x + 1;\nif (sumList (digitsOfInt n) > 9) \nthen \nadditivePersistence (sumList (digitsOfInt n))\nelse x"], "bad": ["let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen \n1::count & additivePersistence (sumList (digitsOfInt n))\nelse sumList count", "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen \n1::count && additivePersistence (sumList (digitsOfInt n))\nelse sumList count", "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen \n1::count &&& additivePersistence (sumList (digitsOfInt n))\nelse sumList count", "let rec additivePersistence n = \nlet x = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen \nx + 1\nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count", "let rec additivePersistence n = \nlet x = 1 in\nx = x + 1\nif (sumList (digitsOfInt n) > 9) \nthen \nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count", "let rec additivePersistence n = \nlet x = 1 in x + 1\nif (sumList (digitsOfInt n) > 9) \nthen \nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count", "let rec additivePersistence n = \nlet x = 1 in x + 1;\nif (sumList (digitsOfInt n) > 9) \nthen \nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count"], "message": ["Error: This variant expression is expected to have type bool\n       The constructor :: does not belong to type bool\n", "Error: This variant expression is expected to have type bool\n       The constructor :: does not belong to type bool\n", "Error: Unbound value &&&\nHint: Did you mean &&?\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value count\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nlet x = 1 in x + 1", "if (sumList (digitsOfInt n) > 9) \nthen \nadditivePersistence (sumList (digitsOfInt n))\nelse x"], "bad": ["let rec additivePersistence n = \nlet x = 1 in x + 1\nif (sumList (digitsOfInt n) > 9) \nthen \nadditivePersistence (sumList (digitsOfInt n))\nelse x"], "message": ["Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nlet x = [0] in\nif (sumList (digitsOfInt n) > 9) then begin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse sumList x"], "bad": ["let rec additivePersistence n = \nlet x = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen begin\nlet x = x + 1;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse x", "let rec additivePersistence n = \nlet x = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen begin\nlet x = x + 1;\nadditivePersistence (sumList (digitsOfInt n))\nend;\nelse x", "let rec additivePersistence n = \nlet x = 1 in\nif (sumList (digitsOfInt n) > 9) then begin\nlet x = x + 1", "additivePersistence (sumList (digitsOfInt n))\nend;\nelse x", "let rec additivePersistence n = \nlet x = [0] in\nif (sumList (digitsOfInt n) > 9) then begin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend;\nelse sumList x"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nlet x = [0] in\nif (sumList (digitsOfInt n) > 9) then begin\n1 :: x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse sumList x"], "bad": ["let rec additivePersistence n = \nlet x = [0] in\nif (sumList (digitsOfInt n) > 9) then begin\n1::x\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse sumList x"], "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nlet x = [1] in\n1::x;\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"], "bad": ["let rec additivePersistence n = \nlet x = [1]\n1::x;\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x", "let rec additivePersistence n = \nlet x = [1]\n1::x\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x", "let rec additivePersistence n = \nlet x = [1]\n1::x\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec a = a+1"], "bad": ["let rec a = a::[]", "let rec a -> a::[]", "let rec a = a->a+1", "let rec a = a -> a+1", "let rec a -> a+1"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let a = \na = a + 1"], "bad": ["let rec a = \na = a + 1"], "message": ["Error: This expression has type bool but an expression was expected of type\n         int\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let frog a = a + 1"], "bad": ["let frog a = \na -> a + 1"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let frog a = a+1"], "bad": ["let frog a -> a + 1"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let x = [1]", "let rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"], "bad": ["let x = [1] in\nlet rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"], "message": ["Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \n1::x", "if (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"], "bad": ["let rec additivePersistence n = \n1::x\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x", "let rec additivePersistence n = \n1::x\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]", "let rec digitsOfInt n = \nif (n <= 0) then []\nelse \nList.rev (n mod 10 :: List.rev (digitsOfInt (n/10)))", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let digits n = digitsOfInt (abs n)", "let x = [0]", "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1:x;\nsumList x;\nend"], "bad": ["let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) then begin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse begin\n1:x;\nsumList x\nend", "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) then begin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend;\nelse begin\n1:x;\nsumList x\nend;", "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) then begin\n1::x\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse begin\n1:x;\nsumList x\nend", "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) then begin\n1::x\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse begin\n1:x;\nsumList x", "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) then begin\n1::x\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse begin\n1:x;\nsumList x\nend", "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) then begin\n1::x\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse begin\n1:x;\nsumList x;\nend", "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) then begin\n1::x\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse begin\n1:x;\nsumList x;", "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) then begin\n1::x\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse begin\n1:x;\nsumList x;\nend", "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) then begin\n1::x\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1:x;\nsumList x;\nend", "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1:x;\nsumList x;\nend"], "message": ["Characters 138-143:\n  else begin\n       ^^^^^\nSyntax error: 'end' expected, the highlighted 'begin' might be unmatched\n", "Error: Syntax error\n", "Characters 137-142:\n  else begin\n       ^^^^^\nSyntax error: 'end' expected, the highlighted 'begin' might be unmatched\n", "Characters 137-142:\n  else begin\n       ^^^^^\nSyntax error: 'end' expected, the highlighted 'begin' might be unmatched\n", "Characters 137-142:\n  else begin\n       ^^^^^\nSyntax error: 'end' expected, the highlighted 'begin' might be unmatched\n", "Characters 137-142:\n  else begin\n       ^^^^^\nSyntax error: 'end' expected, the highlighted 'begin' might be unmatched\n", "Characters 137-142:\n  else begin\n       ^^^^^\nSyntax error: 'end' expected, the highlighted 'begin' might be unmatched\n", "Characters 137-142:\n  else begin\n       ^^^^^\nSyntax error: 'end' expected, the highlighted 'begin' might be unmatched\n", "Characters 138-143:\n  begin\n  ^^^^^\nSyntax error: 'end' expected, the highlighted 'begin' might be unmatched\n", "Characters 141-146:\n  begin\n  ^^^^^\nSyntax error: 'end' expected, the highlighted 'begin' might be unmatched\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \n\nsumList x;"], "bad": ["let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1:x;\nsumList x;\nend", "end", "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1:x;\nsumList x;\nend", "end", "end", "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \n1:x;\nsumList x;", "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \n1::x;\nsumList x;"], "message": ["Characters 141-146:\n  begin\n  ^^^^^\nSyntax error: 'end' expected, the highlighted 'begin' might be unmatched\n", "Error: Syntax error\n", "Characters 141-146:\n  begin\n  ^^^^^\nSyntax error: 'end' expected, the highlighted 'begin' might be unmatched\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList x;\nend"], "bad": ["let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList x;"], "message": ["Characters 141-146:\n  begin\n  ^^^^^\nSyntax error: 'end' expected, the highlighted 'begin' might be unmatched\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList x;\nend"], "bad": ["let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1:x;\nsumList x;\nend"], "message": ["Characters 141-146:\n  begin\n  ^^^^^\nSyntax error: 'end' expected, the highlighted 'begin' might be unmatched\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList [1;2];\nend", "let _ = additivePersistence 9876"], "bad": ["let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList [1:2];\nend"], "message": ["Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList x\nend", "let _ = additivePersistence 9876"], "bad": ["let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x", "additivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x", "sumList x\nend", "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x", "additivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x\nsumList x\nend"], "message": ["Characters 73-78:\n  begin\n  ^^^^^\nSyntax error: 'end' expected, the highlighted 'begin' might be unmatched\n", "Error: Syntax error\n", "Error: Syntax error\n", "Characters 73-78:\n  begin\n  ^^^^^\nSyntax error: 'end' expected, the highlighted 'begin' might be unmatched\n", "Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n(1::x);\nsumList x\nend"], "bad": ["let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x", "sumList x\nend", "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x", "additivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList x\nend"], "message": ["Characters 141-146:\n  begin\n  ^^^^^\nSyntax error: 'end' expected, the highlighted 'begin' might be unmatched\n", "Error: Syntax error\n", "Characters 73-78:\n  begin\n  ^^^^^\nSyntax error: 'end' expected, the highlighted 'begin' might be unmatched\n", "Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0", "explode \"nikhil\""], "bad": ["let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0\n\nexplode \"nikhil\""], "message": ["Error: This function has type int -> char list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec listReverse l = \nlet explosion = explode l;", "listReverse \"nikhil\""], "bad": ["let rec listReverse l = \nexplode l\n\nlistReverse \"nikhil\""], "message": ["Error: This function has type string -> char list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec listReverse l = \nexplode l"], "bad": ["let rec listReverse l = \nlet explosion = explode l"], "message": ["Error: Syntax error\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec listReverse l = match l with \n[] -> []"], "bad": ["let rec listReverse l = \nexplode l match l with\n| [] -> 0", "let rec listReverse l = \nlet p = explode l match p with\n| [] -> 0", "let rec listReverse l = \nlet p = (explode l) match p with\n| [] -> 0", "let rec listReverse l = \nlet p -> (explode l) match p with\n| [] -> 0", "let rec listReverse l = \nlet explosion = \n(explode l) match p with\n| [] -> 0"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec listReverse l = match l with \n|[] -> []\n|[h1] -> h1::[]\n|(h::t) -> h::(listReverse t)"], "bad": ["let rec listReverse l = match l with \n|[] -> []\n|(h1) -> h1::[]\n|(h::t) -> h::(listReverse t)"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> h::(listReverse t)"], "bad": ["let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> (listReverse t)::h"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> begin\n(listReverse t);\nh::[]\nend"], "bad": ["let rec listReverse l = match l with \n|[] -> h::[]\n|(h::t) -> listReverse t", "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> listReverse t\n|_ -> h::[]", "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> listReverse t\nh::[]", "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> (listReverse t)\nh::[]"], "message": ["Error: Unbound value h\n", "Error: Unbound value h\n", "Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rev list =\nlet rec aux acc =\n| [] -> acc\n| h::t -> aux (h::acc) t in\naux [] list", "rev [1;2;3]"], "bad": ["let rev list =\nlet rec aux acc = function\n| [] -> acc\n| h::t -> aux (h::acc)  in\naux [] list", "let rev list =\nlet rec aux acc = function\n| [] -> acc\n| h::t -> aux (h::acc) h in\naux [] list"], "message": ["Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'a list\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec own n =\nown n"], "bad": ["let own =\nlet x = [];\nlet y = 1;\nlet rec own1 n =\nown1 e"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let own n =\nlet rec own1 n =\nown1", ";;"], "bad": ["let rec own n =\nlet rec own1 n =\nown1 n", "let own n =\nlet rec own1 n =\nown1"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let own n = n + 1"], "bad": ["let own n =\nlet rec own1 n = in\nown1 n", "let own n =\nlet rec own1 n in =\nown1 n"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let average a b = \nlet sum = a + b in\nsum / 2"], "bad": ["let average a b = \nlet sum = a + b;\nsum / 2", "let average a b = \nlet sum = a + b\nsum / 2"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]", "let rec digitsOfInt n = \nif (n <= 0) then []\nelse \nList.rev (n mod 10 :: List.rev (digitsOfInt (n/10)))", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let digits n = digitsOfInt (abs n)", "let own n = n + 1", "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count = in\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count"], "bad": ["let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count = function\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n\nsumList x\nend", "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count = function\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n\nsumList x\nend", "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count = function\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n\nsumList x\nend", "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count = function\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n\nsumList x\nend", "let additivePersistence n = \nlet count = 1", "let rec apCalc n count = function\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n\nsumList x\nend", "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count = function\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\napCalc (sumList (digitsOfInt n)) (count + 1)\nend\nelse \nbegin\nprint_string \"going into else | \";\n\ncount\nend", "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count = fun\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\napCalc (sumList (digitsOfInt n)) (count + 1)\nend\nelse \nbegin\nprint_string \"going into else | \";\n\ncount\nend", "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\napCalc (sumList (digitsOfInt n)) (count + 1)\nend\nelse \nbegin\nprint_string \"going into else | \";\n\ncount\nend", "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\napCalc (sumList (digitsOfInt n)) (count + 1)\nend\nelse \nbegin\nprint_string \"going into else | \";\n\ncount\nend\nin", "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count = in\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\napCalc (sumList (digitsOfInt n)) (count + 1)\nend\nelse \nbegin\nprint_string \"going into else | \";\n\ncount\nend"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let additivePersistence n = \nlet count = 1", "let rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count"], "bad": ["let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count", "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count", "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse sumList count", "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count", "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count in", "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count\nin"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count", ";;"], "bad": ["let additivePersistence n = \nlet count = 1;\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count", "let additivePersistence n = \nlet count = 1;\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count", "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count", "let additivePersistence n = \nlet count = 1 in\nbegin \nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count\nend"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count", "let _ = additivePersistence 9876"], "bad": ["let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count"], "message": ["Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]", "let rec digitsOfInt n = \nif (n <= 0) then []\nelse \nList.rev (n mod 10 :: List.rev (digitsOfInt (n/10)))", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let digits n = digitsOfInt (abs n)", "let own n = n + 1", "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse poum"], "bad": ["let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse poum"], "message": ["Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let additivePersistence n = n + 1"], "bad": ["let additivePersistence n ="], "message": ["Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let additivePersistence n a = n + a"], "bad": ["let additivePersistence n a = n + a + b"], "message": ["Error: Unbound value b\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let additivePersistence n a = \nif (sumList (digitsOfInt n) > 9)\nthen additivePersistence (sumList (digitsOfInt n)) (a + 1)\nelse 9"], "bad": ["let additivePersistence n a = \nif (sumList (digitsOfInt n) > 9)\nthen additivePersistence (sumList (digitsOfInt n)) (a + 1)"], "message": ["Error: This expression has type int but an expression was expected of type\n         unit\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let _ = additivePersistence 9876"], "bad": ["let _ = additivePersistence 9876 1"], "message": ["Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec myListReverse origList newList = match origList with\n| [] -> []\n| (h::t) -> myListReverse (t) (h::newList)"], "bad": ["let rec myListReverse origList newList = match origList with\n| [] -> []\n| (h::t) -> myListReverse t h::newList"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let extract (p1, p2) = match (p1, p2) with\n| _ -> p1"], "bad": ["let extract l = match l with\n| (string * int) -> string", "let extract (p1, p2) = match (p1, p2) with\n| (string * int) -> p1", "let extract (p1, p2) = match (p1, p2) with\n| string * int", ") -> p1", "let extract (p1, p2) = match (p1, p2) with\n| (string * int) -> p1"], "message": ["Characters 31-32:\n  | (string * int) -> string;;\n    ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Characters 45-46:\n  | (string * int) -> p1;;\n    ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Error: Syntax error\n", "Characters 45-46:\n  | (string * int) -> p1;;\n    ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let extract n (p1, p2) = match (p1, p2) with\n| _ -> p1"], "bad": ["extract 1 (\"bobby\" 2)"], "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let extract n (p1, p2) = match n with\n| 1 -> p1\n| 2 -> p2", "extract (\"bobby\", 2)"], "bad": ["extract (\"bobby\", 2)"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let extract1 (p1, p2) = match (p1, p2) with\n| _ -> p1", "let extract2 (p1, p2) = match (p1, p2) with\n| _ -> p2"], "bad": ["extract (\"bobby\", 2)", "let extract1 (p1, p2) = \n| _ -> p1", "let extract2 (p1, p2) =\n| _ -> p2"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> if ((extract1 h) = k) then (extract2)\nelse assoc (d, k, t)"], "bad": ["let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t - > if ((extract1 h) = k) then (extract2)\nelse assoc (d, k, t)"], "message": ["Error: Syntax error: pattern expected.\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> d"], "bad": ["let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n|", "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if ("], "message": ["Error: Syntax error\n", "Error: Syntax error: operator expected.\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) else (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (mem h l) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (not l.mem h ) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if not (l.mem h ) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if !(l.mem h ) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if !(List.mem h seen) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (!List.mem h seen) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (!(List.mem h seen)) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::[]) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then ([]) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then ([2]) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen) then (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "message": ["Error: Unbound value mem\n", "Error: This function has type bool -> bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound record field mem\n", "Error: Unbound record field mem\n", "Error: This expression has type bool but an expression was expected of type\n         'a ref\n", "Error: This expression has type 'a -> 'a list -> bool\n       but an expression was expected of type 'b ref\n", "Error: This expression has type bool but an expression was expected of type\n         'a ref\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) else seen in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if !(List.mem h seen) then (h::seen) else seen in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "message": ["Error: This expression has type bool but an expression was expected of type\n         'a ref\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (not (List.mem h seen)) then (h::seen) else seen in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (!List.mem h seen) then (h::seen) else seen in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "message": ["Error: This expression has type 'a -> 'a list -> bool\n       but an expression was expected of type 'b ref\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile (f,b)"], "bad": ["let fixpoint (f,b) = wwhile (b,b)"], "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = b"], "bad": ["let fixpoint (f,b) = wwhile (b,b)"], "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((f),b)"], "bad": ["let fixpoint (f,b) = wwhile (f,f b)"], "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((f ),b)"], "bad": ["let fixpoint (f,b) = wwhile ((f a),b)"], "message": ["Error: Unbound value a\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((f b),b)"], "bad": ["let fixpoint (f,b) = wwhile ((fixpoint (f,b)),b)"], "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (not (List.mem h seen)) then (h::seen) else seen in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) = match (f b) with\n| (a, b) -> if not(b) then a else wwhile (f, a)", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), b)"], "bad": ["let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else fixpoint (f b, b),b))", "let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else fixpoint (f,f b),b))", "let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else (fixpoint (f,f b),b)))", "let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else (fixpoint (f,b))))", "let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else (fixpoint (f,b),b)))", "let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else (fixpoint (f,b),b)))", "let fixpoint (f,b) = wwhile (if ((f b) = b) then b else (fixpoint (f,b),b))", "let fixpoint (f,b) = wwhile (if ((f b) = b) then b else wwhile (f,f b))", "let fixpoint (f,b) = wwhile (if ((f b) = b) then b, b)", "let fixpoint (f,b) = wwhile ((if ((f b) = b) then b), b)", "let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b), b)", "let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), b)", "let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), a)", "let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), b)", "let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), b)"], "message": ["Error: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\n", "Error: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\n", "Error: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\n", "Error: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\n", "Error: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\n", "Error: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\n", "Error: This expression has type\n         ('a -> 'a * bool) * 'a -> ('a -> 'a * bool) * 'a\n       but an expression was expected of type\n         ('a -> 'a * bool) * 'a ->\n         ('a -> 'a * bool) * 'a -> (('a -> 'a * bool) * 'a) * bool\n       Type ('a -> 'a * bool) * 'a is not compatible with type\n         ('a -> 'a * bool) * 'a -> (('a -> 'a * bool) * 'a) * bool \nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type\n         ('a -> 'a * bool) * 'a -> ('a -> 'a * bool) * 'a\n       but an expression was expected of type\n         ('a -> 'a * bool) * 'a ->\n         ('a -> 'a * bool) * 'a -> (('a -> 'a * bool) * 'a) * bool\n       Type ('a -> 'a * bool) * 'a is not compatible with type\n         ('a -> 'a * bool) * 'a -> (('a -> 'a * bool) * 'a) * bool \n", "Error: This expression has type\n         ('a -> 'a * bool) * 'a -> ('a -> 'a * bool) * 'a\n       but an expression was expected of type\n         ('a -> 'a * bool) * 'a -> (('a -> 'a * bool) * 'a) * bool\n       Type ('a -> 'a * bool) * 'a is not compatible with type\n         (('a -> 'a * bool) * 'a) * bool \n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "Error: This expression has type unit but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type unit but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: Unbound value a\n", "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((failwith \"to be written\"), b)"], "bad": ["let fixpoint (f,b) = wwhile (f (if ((f b) = b) then 1 else 0), b)", "let fixpoint (f,b) = wwhile ((let h x = (f x) in (x, x = b), b)", "let fixpoint (f,b) = wwhile ((let h x = (f x) in (x, x = b), b))", "let fixpoint (f,b) = wwhile ((fun x -> x ), b)"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'a * bool\n", "Characters 28-29:\n  let fixpoint (f,b) = wwhile ((let h x = (f x) in (x, x = b), b);;\n                              ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (not (List.mem h seen)) then (h::seen) else seen in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) = match (f b) with\n| (a, b) -> if not(b) then a else wwhile (f, a)", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) = wwhile ((failwith \"to be written\"), b)", "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "let rec exprToString e = match e with\n| Sine s -> printf \"%s\" s"], "bad": ["let rec exprToString e = match e with\n| VarX -> sprintf \"%s\" VarX", "let rec exprToString e = match e with\n| VarX -> sprintf \"%s\"", "let rec exprToString e = match e with\n| VarX -> printf \"%s\"", "let rec exprToString e = match e with\n| VarX a -> sprintf \"%s\" a", "let rec exprToString e = match e with\n| VarX v a -> sprintf \"%s\" a", "let rec exprToString e = match e with\n| VarX a b -> sprintf \"%s\" a", "let rec exprToString e = match e with\n| VarX a -> sprintf \"%s\" a", "let rec exprToString e = match e with\n| Sine s -> sprintf \"%s\" s", "let rec exprToString e = match e with\n| Sine s -> printf \"%s\" s"], "message": ["Error: Unbound value sprintf\n", "Error: Unbound value sprintf\n", "Error: Unbound value printf\n", "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: Unbound value sprintf\n", "Error: Unbound value printf\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with\n| VarX -> \"x\""], "bad": ["let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3.142 * e))", "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * e))", "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * 2))", "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3.0 * 2.0))", "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * 2.0))", "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * 2))", "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%i\" (sin (3 * 2))", "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%i\" (sin (3.0 * 2.0))"], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type expr but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.sprintf \"%expr\" 1.0 ^ \")\""], "bad": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ s ^ \")\"", "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.sprintf \"%expr\" s ^ \")\""], "message": ["Error: This expression has type expr but an expression was expected of type\n         string\n", "Error: This expression has type expr but an expression was expected of type\n         float\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\""], "bad": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.sprintf \"%_\" s  ^ \")\"", "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.sprintf \"%\" s  ^ \")\"", "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.printf \"%\" s  ^ \")\"", "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.printf \"%f\" s  ^ \")\"", "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.printf \"%i\" s  ^ \")\"", "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.printf \"%expr\" s  ^ \")\"", "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.printf \"%e\" s  ^ \")\""], "message": ["Error: invalid format \"%_\": at character number 2, unexpected end of format\n", "Error: invalid format \"%\": at character number 1, unexpected end of format\n", "Error: invalid format \"%\": at character number 1, unexpected end of format\n", "Error: This expression has type expr but an expression was expected of type\n         float\n", "Error: This expression has type expr but an expression was expected of type\n         int\n", "Error: This expression has type expr but an expression was expected of type\n         float\n", "Error: This expression has type expr but an expression was expected of type\n         float\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"\n| Cosine c -> \"cos(pi*\" ^ (exprToString c) ^ \")\"\n| Average (a1,a2) -> \"((\" ^ (exprToString a1) ^ \"+\" ^ (exprToString a2) ^ \")/2)\"\n| Times (t1,t2) -> \"(\" ^ (exprToString t1) ^ \"*\" ^ (exprToString t2) ^ \")\""], "bad": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"\n| Cosine c -> \"cos(pi*\" ^ (exprToString c) ^ \")\"\n| Average a1 a2 -> \"((\" ^ (exprToString a1) ^ \"+\" ^ (exprToString a2) ^ \")/2)\"\n| Times t1 t2 -> \"(\" ^ (exprToString t1) ^ \"*\" ^ (exprToString t2) ^ \")\"", "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"\n| Cosine c -> \"cos(pi*\" ^ (exprToString c) ^ \")\"\n| Average a1 a2 -> \"((\" ^ (exprToString a1) ^ \"+\" ^ (exprToString a2) ^ \")/2)\"\n| Times t1 t2 -> \"(\" ^ (exprToString t1) ^ \"*\" ^ (exprToString t2) ^ \")\"", "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"\n| Cosine c -> \"cos(pi*\" ^ (exprToString c) ^ \")\"\n| Average (a1,a2) -> \"((\" ^ (exprToString a1) ^ \"+\" ^ (exprToString a2) ^ \")/2)\"\n| Times t1 t2 -> \"(\" ^ (exprToString t1) ^ \"*\" ^ (exprToString t2) ^ \")\""], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let mine = buildAverage(VarX, VarY)"], "bad": ["let mine = buildAverage(2.0, 4.0)"], "message": ["Error: This expression has type float but an expression was expected of type\n         expr\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x \n| VarY -> y\n| Average (a1,a2) -> buildAverage(a1,a2)"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> let vx = x in\n| VarY -> let vy = y in \n| Average -> buildAverage (vx, vy)", "let rec eval (e,x,y) = match e with\n| VarX -> let vx = x in \n| VarY -> let vy = y in\n| Sine -> \n| Average -> buildAverage(vx,vy)", "let rec eval (e,x,y) = match e with\n| VarX -> let vx = x  \n| VarY -> let vy = y in\n| Sine -> \n| Average -> buildAverage(vx,vy)", "let rec eval (e,x,y) = match e with\n| VarX -> let vx = x  \n| VarY -> let vy = y \n| Sine -> \n| Average -> buildAverage(vx,vy)", "let rec eval (e,x,y) = match e with\n| VarX -> let vx = x  \n| VarY -> let vy = y \n| Average -> buildAverage(vx,vy)", "let rec eval (e,x,y) = match e with\n| VarX -> let vx = x in vx \n| VarY -> let vy = y in vy\n| Average -> buildAverage(vx,vy)"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: The constructor Average expects 2 argument(s),\n       but is applied here to 0 argument(s)\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (not (List.mem h seen)) then (h::seen) else seen in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) = match (f b) with\n| (a, b) -> if not(b) then a else wwhile (f, a)", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) = wwhile ((failwith \"to be written\"), b)", "let pi = 3.142", "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "let _ = VarX", "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"\n| Cosine c -> \"cos(pi*\" ^ (exprToString c) ^ \")\"\n| Average (a1,a2) -> \"((\" ^ (exprToString a1) ^ \"+\" ^ (exprToString a2) ^ \")/2)\"\n| Times (t1,t2) -> (exprToString t1) ^ \"*\" ^ (exprToString t2)\n| Thresh (h1,h2,h3,h4) -> \"(\" ^ (exprToString h1) ^ \"<\" ^ (exprToString h2) ^ \n\"?\" ^ (exprToString h3) ^ \":\" ^ (exprToString h4) ^ \")\"", "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "let _ = exprToString sampleExpr1", "let buildX()                       = VarX", "let buildY()                       = VarY", "let buildSine(e)                   = Sine(e)", "let buildCosine(e)                 = Cosine(e)", "let buildAverage(e1,e2)            = Average(e1,e2)", "let buildTimes(e1,e2)              = Times(e1,e2)", "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "let pi = 4.0 *. atan 1.0", "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> buildAverage(a1,a2)"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> buildAverage(a1,a2)"], "message": ["Error: This expression has type expr but an expression was expected of type\n         float\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (eval (VarX,a1,a2))", "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (a1 + a2)", "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (eval(VarX,a1,a2) + eval(VarY,a1,a2))", "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (eval(VarX,x,y) + eval(VarY,a1,a2))", "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,a1,a2))"], "message": ["Error: This expression has type expr but an expression was expected of type\n         float\n", "Error: This expression has type expr but an expression was expected of type\n         int\n", "Error: This expression has type expr but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type expr but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin(s1)\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))"], "message": ["Error: This expression has type expr but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Cosine (c1) -> cos (eval (c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.(2.0)"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Cosine (c1) -> cos (eval (c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/2.0", "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Cosine (c1) -> cos (eval (c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.2"], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (pi *. eval(s1,x,y))\n| Cosine (c1) -> cos (pi *. eval(c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.(2.0)\n| Times (t1,t2) -> (eval(t1,x,y) *. eval(t2,x,y))\n| Thresh (h1,h2,h3,h4) -> if (eval(h1,x,y) < eval(h2,x,y)) then eval(h3,x,y) else eval(h4,x,y)"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (pi *. eval(s1,x,y))\n| Cosine (c1) -> cos (pi *. eval(c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.(2.0)\n| Times (t1,t2) -> (eval(t1,x,y) *. eval(t2,x,y))\n| Thresh (h1,h2,h3,h4) ->"], "message": ["Error: Syntax error\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval (Sine(Average(VarX,VarY)), 0.5, -0.5)"], "bad": ["let _ = eval (Sine(Average(Varx,VarY)), 0.5, -0.5)"], "message": ["Error: This variant expression is expected to have type expr\n       The constructor Varx does not belong to type expr\nHint: Did you mean VarX or VarY?\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = makeRand(0,5)"], "bad": ["let _ = rand(0.5)", "let _ = rand(0,5)"], "message": ["Error: Unbound value rand\nHint: Did you mean land?\n", "Error: Unbound value rand\nHint: Did you mean land?\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rand = makeRand (10,39) in\nlet x = rand (1,4) in x"], "bad": ["let rand = makeRand (10,39) in\nlet x = rand (1,4)", "let rand = makeRand (10,39) in\nlet x = rand (1,4) in\n\nlet rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let rand = makeRand (10,39) in\nlet x = rand (1,4) in"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "???"}
{"hw": "hw2", "fix": ["build (makeRand (10,39), 4)"], "bad": ["build (rand, 4)"], "message": ["Error: Unbound value rand\nHint: Did you mean land?\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildX()\n| 4 -> buildY()\n| 5 -> buildX()\n| 6 -> buildY()\n| 7 -> buildX()"], "bad": ["let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> VarX\n| 2 -> 22\n| 3 -> 33\n| 4 -> 44\n| 5 -> 55\n| 6 -> 66\n| 7 -> 77"], "message": ["Error: This expression has type int but an expression was expected of type\n         expr\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildSine(buildX())\n| 2 -> buildY()\n| 3 -> buildX()\n| 4 -> buildY()\n| 5 -> buildX()\n| 6 -> buildY()\n| 7 -> buildX()"], "bad": ["let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX(buildY())\n| 2 -> buildY()\n| 3 -> buildX()\n| 4 -> buildY()\n| 5 -> buildX()\n| 6 -> buildY()\n| 7 -> buildX()"], "message": ["Error: This expression has type expr but an expression was expected of type\n         unit\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildTimes(buildCosine(buildSine(buildX())), buildCosine(buildSine(buildX())))\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine(build(rand, depth))\n| 4 -> buildCosine(build(rand, depth))\n| 5 -> buildAverage(build(rand, depth), build(rand, depth))\n| 6 -> buildTimes(build(rand, depth), build(rand, depth))\n| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))"], "bad": ["let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildTimes(buildCosine(buildSine(buildX())), buildCosine(buildSine(buildX())))\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine(buildX())\n| 4 -> buildSine(buildX())\n| 5 -> buildSine(buildX())\n| 6 -> buildSine(buildX())\n| 7 -> buildSine(buildX())"], "message": ["Error: This variant expression is expected to have type expr\n       The constructor () does not belong to type expr\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ( (if (depth = 0) then buildX() else build(rand, depth - 1)), (if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes(build(rand, depth), build(rand, depth))\n| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))"], "bad": ["let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ( (if (depth = 0) then buildX() else build(rand, depth - 1)), if (depth = 0) then buildY() else build(rand, depth - 1))\n| 6 -> buildTimes(build(rand, depth), build(rand, depth))\n| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))"], "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * expr\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let _ = build (makeRand(1,2), 0)"], "bad": ["let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> rand(1,7)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> rand(1,7)"], "message": ["Error: This expression has type\n         ('a -> 'b, Format.formatter, unit, unit, unit, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, Format.formatter, unit, unit, unit, unit)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type unit \n", "Error: This expression has type expr but an expression was expected of type\n         int\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let _ = build (makeRand(1, 7), 0)"], "bad": ["let _ = build (makeRand(1, 78), 0)"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildThresh(VarX,VarX,VarX,VarX)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))"], "bad": ["let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildTimes (VarX)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "let _ = build (makeRand(1,2), 0)"], "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * expr\n", "Error: This expression has type expr but an expression was expected of type\n         expr * expr\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, f b))"], "bad": ["f 2", "let fixpoint (f,b) = wwhile ((f,b), b)", "let fixpoint (f,b) = wwhile ((f,b), b)", "let fixpoint (f,b) = wwhile ((f, b)", "let fixpoint (f,b) = wwhile (f, b)"], "message": ["Error: Unbound value f\n", "Error: Unbound value f\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Characters 28-29:\n  let fixpoint (f,b) = wwhile ((f, b);;\n                              ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ( (let f x =  in f), b)"], "bad": ["let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, (f b)))", "let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, wwhile (f,b)))"], "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = \nlet h x = let x = b in (x, x != f x)  in\nwwhile (h, b)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = \nlet h x = (b, b != f b)  in\nwwhile (h, b)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = \nlet h b = (b, b != f b)  in\nwwhile (h, b)"], "bad": ["let fixpoint (f,b) = \nlet h x = (b, b != f b)  in\nwwhile (h, b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = \nlet f x = (x, x != f x)  in\nwwhile (h, b)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx != b)  in\nwwhile (f, b)"], "bad": ["let fixpoint (f,b) = \nlet f x = (x, x != f x)  in\nwwhile (f, b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx != b)  in\nwwhile (f, x)", "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx != b)  in\nwwhile (f, b)", "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx != x)  in\nwwhile (f, b)", "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx != x)  in\nwwhile (g, b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let fixpoint (f,b) = \nlet f x = let xx = (f x) in (xx, xx != x)  in\nwwhile (f, b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let fixpoint (f,b) = \nlet a x = let xx = (f x) in (xx, xx != x)  in\nwwhile (a, b)"], "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n"], "problem": "fixpoint"}
{"hw": "hw3", "fix": ["let rec max_list smallest lst = match lst with\n| [] -> smallest\n| h::t -> max_list (max smallest h) t"], "bad": ["let mine xs = match xs with\n| [] -> 0\n| h::t -> t"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = (x *. x) in\nlet base = 0.0 in\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = a -> (x *. x) in\nlet base = 0 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = fun a x -> (x *. x) in\nlet base = 0 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = fun a x -> (x *. x) in\nlet base = 0.0 in\nList.fold_left f base xs"], "message": ["Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         'a -> float -> float\n", "Error: This expression has type float but an expression was expected of type\n         'a -> float -> float\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =  x in\nlet base = 0 in\nList.fold_left f base fs"], "bad": ["let _ = pipe[] 3"], "message": ["Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x + a in\nlet base = 0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a -> a in\nlet base = 0 in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base =  \"\" in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x + a in\nlet base =  in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x + a in\nlet base = \"\" in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: This expression has type string but an expression was expected of type\n         int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = 1 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base =   in\nList.fold_left f base fs\nE"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let _ = pipe[] 3", "let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs"], "message": ["Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value x\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x + 1 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = a' in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = fun in\nList.fold_left f base fs"], "message": ["Error: Unbound value a'\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base =  fun x -> x in\nList.fold_left f base fs", "let _ = pipe [] 3"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base =  0 in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> 0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base =  a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = h::t -> h in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = fun x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs"], "message": ["Error: Unbound value a\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value x\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> a in\nList.fold_left f base fs"], "message": ["Error: Unbound value a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (+) 0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = _ in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (()) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = (_) in\nList.fold_left f base fs"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (+) 0 in\nList.fold_left f base fs", "let _ = pipe [] 3"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = (+) x in\nList.fold_left f base fs"], "message": ["Error: Unbound value x\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base =  fun x b -> b in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base =  fun x b -> 0 + b in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base =  fun x b in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (+) 0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = (+) x in\nList.fold_left f base fs"], "message": ["Error: Unbound value x\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = x a in\nlet base = (+) 0 in\nList.fold_left f base fs", "let _ = pipe [] 3"], "bad": ["let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (+) 0 in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let _ = pipe []"], "bad": ["let _ = pipe [] 3"], "message": ["Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (+) 0   in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = 0 (+)   in\nList.fold_left f base fs"], "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (x a) a in\nlet base = (+) 0 in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3", "let pipe fs = \nlet f a x = a x in\nlet base = (+) 0 in\nList.fold_left f base fs"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (x a) in\nlet base = (+) 0 in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (x a) a in\nlet base = (+) 0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = (a x) a in\nlet base = (+) 0 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (a x) x in\nlet base = (+) 0 in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b -> 'c\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside 'a -> 'b -> 'c\n", "Error: This expression has type ('a -> 'a -> 'b) -> 'a -> 'b\n       but an expression was expected of type\n         ('a -> 'a -> 'b) -> 'a -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (x^sep) ^ a in\nlet base = \"\" in\nlet l = [] in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (x^sep) ^ a in\nlet base = \"\" in\nlet l = \"\" in\nList.fold_left f base l"], "message": ["Error: This expression has type string but an expression was expected of type\n         string list\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (h^sep) ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (h^sep) ^ t in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"], "message": ["Error: This expression has type string list\n       but an expression was expected of type string\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (h^sep) ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (h^sep) ^ x in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (h^sep) ^ x in\nlet base = \"\" in\nlet l = a in\nList.fold_left f base l"], "message": ["Error: This expression has type string but an expression was expected of type\n         string list\n", "Error: Unbound value a\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (x^sep) ^ a in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (x^sep) ^ a in\nlet base = \"\" in\nlet l = h ^ t in\nList.fold_left f base l"], "message": ["Error: This expression has type string list\n       but an expression was expected of type string\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = List.hd fs in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = List.head fs in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = List.hd fs in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type ('a -> 'a) list\n       The type variable 'a occurs inside 'a -> 'a\n", "Error: Unbound value List.head\n", "Error: This expression has type 'a list\n       but an expression was expected of type ('a -> 'a) list\n       The type variable 'a occurs inside 'a -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (+) 0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = -> _ in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = :: 0 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = (::) 0 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = (::) 0 2 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = (::)  in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = 0 (::) in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (-) 0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = * 1 in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = x a in\nlet base =  in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = 0 + in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun y -> (+) y  in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = fun y -> (+) x  in\nList.fold_left f base fs"], "message": ["Error: Unbound value x\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun _ -> 0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = x -> 0 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = fun _ ->  in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = fun _ -> _ in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = fun y -> x (a y) in\nlet base = fun z -> z in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = x -> x + 1 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = x + 1 in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: Unbound value x\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let rec clone x n = \nif n > 0 then clone (x) (n - 1) else []"], "bad": ["let rec clone x n = \nif n > 0 then clone (x::[]) (n - 1) else []"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let rec clone x n = \nlet acc = [] in\nif n > 0 then clone (x@acc) (n - 1) else []"], "bad": ["let rec clone x n = \nlet acc = [] in\nif n > 0 then clone (x::acc) (n - 1) else []"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let rec clone x n = \nlet acc = [x] in\nif n > 0 then clone (x) (n - 1) else []"], "bad": ["let _ = clone 3 5", "let rec clone x n = \nlet acc = [] in\nif n > 0 then clone (x::x) (n - 1) else []"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let rec clone x n = \nlet acc = [0] in\nif n > 0 then clone (x) (n - 1) else []"], "bad": ["let rec clone x n = \nlet acc = [x] in\nif n > 0 then clone (x::acc) (n - 1) else []", "let rec clone x n = \nlet acc = [0] in\nif n > 0 then clone (x::acc) (n - 1) else []"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let acc = []"], "bad": ["let acc = [0] in"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let myfun x = []"], "bad": ["let acc = [x]", "let myfun x =\nlet acc = [x]", "let myfun x =\nlet acc = []", "let myfun x =\nlet acc = [x] in"], "message": ["Error: Unbound value x\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let _ = clone 3 (-4)"], "bad": ["let _ = clone 3 -4"], "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let three = two@one"], "bad": ["let three = one::two", "let three = two::one"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n", "Error: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n"], "problem": "???"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nlet l_diff = l1_len - l2_len in\nlet to_append = clone 0 l_diff in\nif (l_diff < 0) then ((to_append @ l1), l2) else (l1, (to_append @ l2))"], "bad": ["let padZero l1 l2 = \nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nlet l_diff = l1_len - l2_len in\nlet to_append = clone 0 l_diff in\nif (l_diff < 0) then (to_append @ l1), l2", ") else (l1, (to_append @ l2))", "let padZero l1 l2 = \nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nlet l_diff = l1_len - l2_len in\nlet to_append = clone 0 l_diff in\nif (l_diff < 0) then (to_append @ l1), l2", ")", ") else (l1, (to_append @ l2))"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "Error: Syntax error\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nlet l_diff = l1_len - l2_len in\nif (l_diff < 0) then ((clone 0 (l_diff * (-1)) @ l1), l2) else (l1, (clone 0 l_diff @ l2))"], "bad": ["let padZero l1 l2 = \nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nlet l_diff = l1_len - l2_len in\nif (l_diff < 0) then ((clone 0 (l_diff * (-1) @ l1), l2)) else (l1, (clone 0 l_diff @ l2))"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = (l1, l2) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = [(l1,l2)] in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = let (a,b) = List.hd x in ([a+1],[b+2])\nin\nlet base = ([],[]) in\nlet args = [(l1,l2)] in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = let (a,b) = List.hd x in ([(List.hd a)+1],[(List.hd b)+2])\nin\nlet base = ([],[]) in\nlet args = [(l1,l2)] in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([(List.hd x)+1],[(List.hd x)+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = let (a,b) = List.hd x in ((List.hd a)+1", "],(List.hd b)+2", ")\nin\nlet base = ([],[]) in\nlet args = [(l1,l2)] in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = let (a,b) = List.hd x in ((List.hd a)+1,(List.hd b)+2)\nin\nlet base = ([],[]) in\nlet args = [(l1,l2)] in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type ('a * 'b) list\n       but an expression was expected of type int list\n       Type 'a * 'b is not compatible with type int \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int list * int list) list list\n       Type 'a * 'b is not compatible with type (int list * int list) list \n", "Error: This expression has type int list * int list\n       but an expression was expected of type int list list * 'a\n       Type int is not compatible with type int list \n", "Characters 76-77:\n  let f a x = let (a,b) = List.hd x in ((List.hd a)+1;;\n                                       ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type int * int\n       Type 'a list is not compatible with type int \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+1])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+a],[x+a])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int -> int -> int list * int list\n       but an expression was expected of type int -> int -> int\n       Type int list * int list is not compatible with type int \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+1])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [1;1;1;1] [2;2;2;2]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+a],[x+a])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x::a],[x::a])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int -> int -> int list * int list\n       but an expression was expected of type int -> int -> int\n       Type int list * int list is not compatible with type int \n", "Error: This expression has type 'a list -> 'a -> 'a list list * 'a list list\n       but an expression was expected of type 'a list -> 'a -> 'a list\n       Type 'a list list * 'a list list is not compatible with type 'a list \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet y = List.hd l2 in\nlet (one,two) = a in (x::one,y::two)\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet y = l2 in\nlet (one,two) = a in (x::one,y::two)\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int list list\n       but an expression was expected of type int list\n       Type int list is not compatible with type int \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet y = List.hd l2 in\nList.split  ((let (one,two) = a in (x::one,y::two)))\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [1;1;1;1] [2;2;2;2]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet y = List.hd l2 in\nList.combine (let (one,two) = a in (x::one,y::two))\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet y = List.hd l2 in\nList.split (List.combine (let (one,two) = a in (x::one,y::two)))\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet y = List.hd l2 in\n(let (one,two) = a in (x::one,y::two))\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet y = List.hd l2 in\nList.combine (List.split  ((let (one,two) = a in (x::one,y::two))))\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> if ((fir + sec) < 10) then ([], (fir + sec)::b2)  else ([], (fir + sec)::b2)\nin\nlet base = ([],[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match x with\n| (a, b) -> (a + b) mod 10\nin\nlet base = (_,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match x with\n| (a, b) -> (a + b) mod 10\nin\nlet base = ((_),[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = base in \nmatch x with\n| (a, b) -> if ((a + b) < 10) then ([], (a + b)::b2)  else ([], (a + b)::b2)\nin\nlet base = ([],[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Unbound value base\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = fun y -> x (a y) in\nlet base = fun z -> z in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [ (fun x -> x + x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ (sep ^ x) in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n =\nlet rec helper a b acc =\nif b > 0 then helper a (b - 1) (a::acc) else acc\nin\nhelper x n []", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let padZero l1 l2 = \nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nlet l_diff = l1_len - l2_len in\nif (l_diff < 0) then ((clone 0 (l_diff * (-1)) @ l1), l2) else (l1, (clone 0 l_diff @ l2))", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let rec removeZero l = match l with\n| [] -> []\n| (h::t) -> if (h = 0) then removeZero t else h::t", "let _ = removeZero [0;0;0;1;0;0;2]", "let _ = removeZero [9;9]", "let _ = removeZero [0;0;0;0]", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet getTail l = match l with \n| [] -> []\n| (h::t) -> t in\nlet getCarry (c, l) = c in\nlet carry = getCarry a in\nlet getSum (c, l) = l in\nlet sum = \nif carry = 1 \nthen getTail (getSum a) \nelse getSum a in\nlet add (m,n) = m + n in\nlet digit = (add x) + carry in\nif digit > 9 \nthen (1, 1::(digit-10)::sum) \nelse (0, (digit)::sum) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec) < 10) \nthen ([], (fir + sec)::b2)  else ((fir + sec) / 10, (fir + sec) mod 10 ::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec) < 10) \nthen ([], (fir + sec)::b2)  else ((fir + sec) / 10, (fir + sec) mod 10 ::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec) < 10) \nthen (b1, (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec) < 10) \nthen ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec) < 10) \nthen ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)\nin\nlet base = (\"\",[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec) < 10) \nthen ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)\nin\nlet base = ([],[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec) < 10) \nthen ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec + b1) < 10) \nthen \nif (List.length b2 = List.length l1) then (0, b1::b2) else (0, (fir + sec + b1)::b2)  \nelse \nif (List.length b2 = List.length l1) then (0, b1::b2) else (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec + b1) < 10) \nthen (0, (fir + sec + b1)::b2)  \nelse (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)\nif (List.length b2 = List.length l1) then (0,b1::b2) else (0,b1::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec + b1) < 10) \nthen \nif (List.length b2 = List.length l1) \nthen (0, b1::b2) \nelse (0, (fir + sec + b1)::b2)  \nelse \nif (List.length b2 = List.length l1) \nthen (0, b1::b2) \nelse (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec + b1) < 10) \nthen \nif (List.length b2 = List.length l1) \nthen (0, b1::b2) \nelse (0, (fir + sec + b1)::b2)  \nelse if \nif (List.length b2 = List.length l1) \nthen (0, b1::b2) \nelse (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = \nlet rec helper a b acc = \nif (a > 0) \nthen helper (a - 1) b (bigAdd b b)\nelse acc\nin\nhelper i l []"], "bad": ["let rec mulByDigit i l = \nlet rec helper a b acc = \nif (a > 0) \nthen helper (a - 1) b (bigAdd b b)\nelse acc\nin\nhelper i l 0"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let _ = mulByDigit 3 [1;7]"], "bad": ["let _ = mulByDigit 3 [1;7]\nkjlk"], "message": ["Error: This function has type int -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let _ = mulByDigit 9 [9;9;9;9]", "let _ = mulByDigit 0 [9;9;9;9]", "let _ = mulByDigit 1 [9;9;9;9]", "let _ = mulByDigit 2 [9;9;9;9]", "let _ = mulByDigit 3 [1;7]"], "bad": ["let _ = mulByDigit 3 [1;7]\n\nsdf"], "message": ["Error: This function has type int -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = (0,((mulByDigit x l2) @ (clone 0 ((List.length l1) - 1))))\nin\nlet base = (0, [0]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = \nmatch x with\n| (h::t) -> (0,((mulByDigit h sec) @ (clone 0 ((List.length fir) - 1))))\nin\nlet base = (0, [0]) in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = (0,((mulByDigit x l2) @ (clone 0 ((List.length l1) - 1))))\nin\nlet base = (0, [0]) in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: Unbound value sec\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sec\n", "Error: This expression has type int list list\n       but an expression was expected of type int list\n       Type int list is not compatible with type int \nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list list\n       but an expression was expected of type int list\n       Type int list is not compatible with type int \n"], "problem": "bigMul"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"], "bad": ["let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = makeRand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = let r = makeRand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = let r = makeRand(0,2) in in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = r = makeRand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"], "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int but an expression was expected of type\n         int * int -> int\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value r\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let _ = makeRand(0,8)"], "bad": ["let _ = rand"], "message": ["Error: Unbound value rand\nHint: Did you mean land?\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) =\nmatch depth with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"], "bad": ["let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "let rec build (rand, depth) =\nmatch depth with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"], "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int but an expression was expected of type\n         int * int -> int\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) =\nlet rdm = rand in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> Cosine(build(rand, depth-1)) \n| 3 -> Sine(build(rand,depth-1))\n| 4 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 7 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"], "bad": ["let rec build (rand, depth) =\nlet rdm = rand in\nmatch rdm with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 4 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "let rec build (rand, depth) =\nlet rdm = rand in\nmatch rdm with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 4 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"], "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) =\nlet rdm = rand(0,7) in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> Cosine(build(rand, depth-1)) \n| 3 -> Sine(build(rand,depth-1))\n| 4 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 6 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"], "bad": ["let rec build (rand, depth) =\nmatch rand with \n| (a,b) -> \nlet rdm = rand(a,b) in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> Cosine(build(rand, depth-1)) \n| 3 -> Sine(build(rand,depth-1))\n| 4 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 6 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"], "message": ["Error: This expression has type 'a * 'b\n       This is not a function; it cannot be applied.\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let b = build(r,5)"], "bad": ["let b = build(rnd,5)"], "message": ["Error: This expression has type int but an expression was expected of type\n         int * int -> int\n"], "problem": "build"}
{"hw": "hw1", "fix": ["let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]", "let rec digitsOfInt n = if n <= 0 then [] else 1", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663"], "bad": ["let rec digitsOfInt n = match n with\n| n < 0 -> []\n| h::t -> h"], "message": ["Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]", "let rec listReverse l = match l with\n| [] -> []\n| h::t -> listReverse t @ [h]", "let _ = listReverse [1; 2; 3; 4]", "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]", "let rec digitsOfInt n =\n(*if n <= 0 then []*)\nn mod 10 @ [digitsOfInt n/10]"], "bad": ["let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]"], "message": ["Error: Syntax error\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\nif n <= 0 then []\nelse let n2 = [n mod 10] @ digitsOfInt (n/10) in\nlistReverse n2"], "bad": ["let rec digitsOfInt n =\nif n <= 0 then []\nelse let n2 = [n mod 10] @ digitsOfInt (n/10) in\nlistReverse n2"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663"], "bad": ["let rec digitsOfInt n =\nif n <= 0 then []\nelse (n mod 10) :: digitsOfInt (n/10)"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4]", "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]"], "bad": ["let rec listReverse l = match l with\n| [] -> []\n| h::t -> h :: listReverse l"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec myAppend l n = match l with\n| [] -> [i]\n| h::t -> h :: myAppend t i", "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]", "let _ = sumList []", "let _ = sumList [1]", "let rec listReverse l = match l with\n| [] -> []\n| h::t -> myAppend (listReverse l) h"], "bad": ["let rec listReverse l = match l with\n| [] -> []\n| h::t -> listReverse t :: [h]"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = palindrome \"malayalam\"", "let _ = palindrome \"myxomatosis\""], "bad": ["let palindrome w =\nlistReverse (explode w) = explode w"], "message": ["Error: This expression has type string but an expression was expected of type\n         char list\n"], "problem": "palindrome"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| s,i -> s"], "bad": ["let rec assoc (d,k,l) = let l match with\n| [] -> d\n| h::t -> let h match with\n| (s*i) -> s\n| d", "let rec assoc (d,k,l) = l match with\n| [] -> d\n| h::t -> h match with\n| (s*i) -> s\n| d", "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (s*i) -> s\n| d", "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| s,i -> s\n| d"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Characters 72-73:\n  | (s*i) -> s\n    ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| s,i -> i"], "bad": ["let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "message": ["Error: This expression has type string but an expression was expected of type\n         int\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let _ = removeDuplicates []"], "bad": ["let _ = removeDuplicates [];\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"], "message": ["Error: Syntax error\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = match (f b) with\n| (f', x') -> if x' then wwhile (f, f')\nelse f'"], "bad": ["let rec wwhile (f,b) = match b with\n| (f', b') -> if b' then wwhile (f, f')\nelse f'"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = match f,b with\n| (f', bool1) -> if bool1 then wwhile (f, f')\nelse f'"], "bad": ["let rec wwhile (f,b) = match me b with\n| (f', bool1) -> if bool1 then wwhile (f, f')\nelse f'"], "message": ["Error: Unbound value me\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = match f b with\n| (f', bool1) -> if bool1 then wwhile (f, f')\nelse f'", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "bad": ["let me x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (me, 2)", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "message": ["Error: This expression has type int -> int * bool\n       but an expression was expected of type bool\n", "Error: This expression has type int -> int * bool\n       but an expression was expected of type bool\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "let _ = assoc (-1,\"hi\",[])", "let _ = assoc (-1,\"test\",[(\"test\",99)])", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"moose\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates []", "let _ = removeDuplicates [1]", "let _ = removeDuplicates [1;2]", "let _ = removeDuplicates [1;2;1]", "let _ = removeDuplicates [1;1;1;1;1;1;1;1;1;1;1]", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) = match f b with\n| (b',c') -> if c' then wwhile (f,b')\nelse b'", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 3)", "let fixpoint (f,b) = wwhile (let helper = (f b,f b != helper),b)"], "bad": ["let fixpoint (f,b) = wwhile ((let helper = (f b,f b != helper)),b)", "let fixpoint (f,b) = wwhile (let helper = (f b,f b != helper),b)"], "message": ["Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let fixpoint (f,b) = wwhile (let helper = if ((f b) = b) then (f b,true) else (f b, false) in helper,b)", "let fixpoint (f,b) = wwhile (let helper = if ((f b) = b) then (f b,true) else (f b, false) in helper, b)", "let fixpoint (f,b) = wwhile (let helper = if ((f b) = b) then (f b,true)\nelse (f b, false)\nin helper,b)", "let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)"], "message": ["Error: Syntax error: operator expected.\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((let helper b =\nif b = f b then (f b, false)\nelse (f b, true)\nin helper),b)"], "bad": ["let f x = let xx = x*x*x in (xx, xx < 100) in\nfixpoint (f, 1)", "let _ = fixpoint (collatz, 9001)"], "message": ["Error: Unbound value f\n", "Error: This expression has type int -> int * bool\n       but an expression was expected of type int -> int\n       Type int * bool is not compatible with type int \n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = if depth = 0 then\nif rand(0,1) = 0 then buildX()\nelse buildY()\nelse match rand(0,6) with\n|0 -> build(rand,(depth - 1))\n|1 -> buildSine(build(rand,(depth - 1))) \n|2 -> buildCosine(build(rand, (depth - 1)))\n|3 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|4 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|5 -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),build(rand, (depth - 1)))"], "bad": ["let rec build (rand, depth) = if depth = 0 then\nif rand(0,1) = 0 then buildX()\nelse buildY()\nelse match rand(0,7) with\n|0 -> build(rand, (depth-1))\n|1 -> buildSine(build(rand, (depth-1))) \n|2 -> buildCosine(build(rand, (depth - 1)))\n|3 -> buildAverage(build(rand, (depth-1)),build(rand, (depth-1)))\n|4 -> buildTimes(build(rand, (depth-1)),build(rand, (depth-1)))\n|5 -> buildMax(build(rand, (depth-1)),build(rand, (depth-1)))\n|6 -> buildCubic(build(rand, (depth-1)),build(rand, (depth-1)),build(rand, (depth-1)))\n|7 -> buildThresh(build(rand, (depth-1)),build(rand, (depth-1)),build(rand, (depth-1)),build(rand, (depth-1)))", "let rec build (rand, depth) = if depth = 0 then\nif rand(0,1) = 0 then buildX()\nelse buildY()\nelse match rand(0,5) with\n|0 -> build(rand,(depth - 1))\n|1 -> buildSine(build(rand,(depth - 1))) \n|2 -> buildCosine(build(rand, (depth - 1)))\n|3 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|4 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|5 -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),build(rand, (depth - 1)))"], "message": ["Characters 130-131:\n  |0 -> build(rand, (depth-1)\n             ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Unbound value buildMax\nHint: Did you mean build, buildY or buildX?\nError: Unbound value buildMax\nHint: Did you mean build, buildX or buildY?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value buildMax\nHint: Did you mean build, buildY or buildX?\n"], "problem": "build"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let carry = (fst x + snd x) in\nmatch a with\n| h::t -> ((h+carry)/10)::((h+carry) mod 10)::t\n| _ -> (carry/10)::[carry mod 10]\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let carry = (fst x + snd x) in\nmatch a with\n| h::t -> ((h+carry)/10)::((h+c) mod 10)::t\n| _ -> (carry/10)::[carry mod 10]\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Unbound value c\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((o,sum),[])\t      -> (0,sum)\n| ((o,sum),(b,c)::l') -> let d = (b + c + o) in\nif d", "let base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((o,sum),[])\t      -> (0,sum)\n| ((o,sum),(b,c)::l') -> let d = (b + c + o) in\nif d < 10 then (0, d::sum)\nelse (1, (d-10)::sum)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let carry = match a with (x,y) -> x in\nmatch x with (d1,d2) -> let new_carry = (carry + d1 + d2)/10 in\nlet digit = (carry + d1 + d2) mod 10 in\nmatch a with (x,y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (*let carry = match a with (x,y) -> x in*)\nmatch x with (d1,d2) -> let new_carry = (a + d1 + d2)/10 in\nlet digit = (a + d1 + d2) mod 10 in\nmatch a with (x,y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let carry = match a with (x,y) -> x in\nmatch x with (d1,d2) -> let new_carry = (a + d1 + d2)/10 in\nlet digit = (a + d1 + d2) mod 10 in\nmatch a with (x,y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type int\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let c = match a with\n| ((d1,d2),sum) -> let c' = (c + d1 + d2)/10 in\nlet sum = (c + d1 + d2) mod 10 in\nmatch a with (pair,sum) -> (c', digit::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let c = match a with\n| ((d1,d2),sum) -> let c' = (c + d1 + d2)/10 in\nlet sum = (c + d1 + d2) mod 10 in\nmatch a with (pair,sum) -> (c', digit::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let c = match a with\n| ((d1,d2),sum) -> let c' = (c + d1 + d2)/10 in\nlet sum = (c + d1 + d2) mod 10 in\nmatch a with (pair,sum) -> (c', digit::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let c = match a with\n| ((d1,d2),sum) -> let c' = (c + d1 + d2)/10 in\nlet sum = (c + d1 + d2) mod 10 in\nmatch a with (pair,sum) -> (c', digit::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let c = match a with (pair,sum) -> pair in\nmatch x with (d1,d2) -> let c' = (c + d1 + d2)/10 in\nlet digit = (c + d1 + d2) mod 10 in\nmatch a with (pair,sum) -> (c', digit::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let c = match a with (pair,sum) -> pair in\nmatch a with ((d1,d2),sum) -> let c' = (c + d1 + d2)/10 in\nlet sum = (c + d1 + d2) mod 10 in\nmatch a with (pair,sum) -> (c', digit::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let c = match a with (pair,sum) -> pair in\nmatch pair with (d1,d2) -> let c' = (c + d1 + d2)/10 in\nlet digit = (c + d1 + d2) mod 10 in\nmatch a with (pair,sum) -> (c', digit::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n", "Error: Unbound value pair\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = \nif i = 1 then l\nelse if i = 0 then []\nelse if i < 0 then match (bigAdd (bigAdd l l) (mulByDigit ( (i*(-1)) -2) l)) with\n| h::t -> (h*(-1))::t\n| _ -> []\nelse bigAdd (bigAdd l l) (mulByDigit (i-2) l)", "let _ = mulByDigit 9 [9;9;9;9]", "let _ = mulByDigit (-9) [9;9;9;9]"], "bad": ["let rec mulByDigit i l = \nif i = 1 then l\nelse if i = 0 then []\nelse if i < 0 then match (bigAdd (bigAdd l l) (mulByDigit ( (i*(-1)) -2) l)) with\n| h::t -> (h*(-1))::t\n| _ -> 0\nelse bigAdd (bigAdd l l) (mulByDigit (i-2) l)"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = match a with\n(c,sum) -> (c + 1, bigAdd ((mulByDigit x l1) @ clone 0 c) sum) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = match a with\n(c,sum) -> (c + 1, bigAdd ((mulByDigit x l1) @ clone 0 c) sum) in\nlet base = failwith (0, []) in\nlet args = failwith l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type string\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * 'b\n       but an expression was expected of type string\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let foo = List.map incr [9]"], "bad": ["let foo = List.map [incr] 9", "let foo = List.map incr 9"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'b -> 'c\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let foo = (List.map incr [9])@(List.map decr [10])"], "bad": ["let foo = List.map incr [9]::List.map decr [10]", "let foo = (List.map incr [9])::(List.map decr [10])", "let foo = (List.map incr 9)::(List.map decr [10])", "let foo = (List.map incr [9])::(List.map decr [10])"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n", "Error: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n"], "problem": "???"}
{"hw": "hw3", "fix": ["let [f1;f2] = foo [(=);(<)] 2"], "bad": ["let [f1;f2] = a[[ [(=);(<)] 2", "let [f1;f2] = a[[ [(=);(<)] 2", "let [f1;f2] = app [(=);(<)] 2"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value app\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let [f1;f2] = foo [(=);(<)] 2", "f1 1"], "bad": ["let [f1;f2] = foo [(=);(<)] 2\nf1 1"], "message": ["Error: This function has type ('a -> 'b) list -> 'a -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse [1;2;3]"], "bad": ["let rec digitsOfInt n = \nif n < 0 then -> 4", "let _ = digitsOfInt -3124", "let rec digitsOfInt n = \nif n < 0 then 4", "let rec digitsOfInt n = \nif n < 0 then []", "let rec digitsOfInt n = \nif n < 0 then 0", "let rec digitsOfInt n = \nif n < 0 then _", "let rec digitsOfInt n = \nif n < 0 then 'a", "let rec digitsOfInt n = \nif n < 0 then '", "let rec digitsOfInt n = \nif n < 0 then n", "let rec digitsOfInt n = \nif n < 0 then []\nelse n"], "message": ["Error: Syntax error\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 3124"], "bad": ["let _ = digitsOfInt -3124"], "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet f elem =", "open Printf\nPrintf.printf \"Element is %d\\n\" elem in\nList.iter f n", "let _ = digitsOfInt 3124"], "bad": ["let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet f elem = \nPrintf.printf \"Element is %d\\n\" elem in\nList.iter f n"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| _ -> loop n []"], "bad": ["let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet f elem = \nPrintf.printf \"Element is %d\\n\" elem in\nList.iter f n"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nif n mod 10  != 0 then \nx = x + 1", "let total += sumList (digitsOfInt (abs n) )\nelse x", "let _ = additivePersistence 9876"], "bad": ["let rec additivePersistence n =\nlet x = 0\nif n mod 10  != 0 then \nx = x + 1"], "message": ["Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nlet rec loop retVal = \nif retVal < 10 then retVal\nelse loop sumList(digitsOfInt retVal ) \n| 0 -> 0\n| _ -> loop retVal", "let _ = additivePersistence 9876"], "bad": ["let rec additivePersistence n = \nlet x = 0\nif n mod 10  != 0 then \nx = x + 1", "let total += sumList (digitsOfInt (abs n) )\nelse x", "let rec additivePersistence n = \nif n mod 10  != 0 then \nlet x = 0", "let total += sumList (digitsOfInt (abs n) )\nx = x + 1\nelse x", "let rec additivePersistence n = \nif n mod 10  != 0 then \nlet x = 0", "let rec additivePersistence n = \nif n mod 10  != 0 then \nlet x = 0 in\nlet total += sumList (digitsOfInt (abs n) )\nx = x + 1\nelse x", "let rec additivePersistence n = \nif n mod 10  != 0 then \nlet x = 0 in\nlet total = sumList (digitsOfInt (abs n) )\nx = x + 1\nelse x"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n"], "bad": ["let rec additivePersistence n = \nlet rec addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \naddP = addP + 1\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \naddP = addP + 1\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nincr addP\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n"], "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This function has type int ref -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nlet rec addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse recursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n"], "bad": ["let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n\n| addP"], "message": ["Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n"], "bad": ["let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \naddP -> addP + 1\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n"], "bad": ["let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \naddP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \naddP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \naddP + 1\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n"], "message": ["Error: This expression has type bool but an expression was expected of type\n         int\n", "Error: Unbound value retVal\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal addP = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) addP in match n with\n| 0 -> 0\n| _ -> recursive_loop n addP", "let _ = additivePersistence 9876"], "bad": ["let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal addP = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) addP in match n with\n| 0 -> 0\n| _ -> recursive_loop n"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec listReverse l = \nlet rec aux acc = function\n| [] -> acc\n| h::t -> aux (h::acc) t in\naux [] l"], "bad": ["let rec listReverse l = \nlet rev l =\nlet rec aux acc = function\n| [] -> acc\n| h::t -> aux (h::acc) t in\naux [] l", "let rec listReverse l = \nlet rev l =\nlet rec aux acc = \n| [] -> acc\n| h::t -> aux (h::acc) t in\naux [] l"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let palindrome w =\nlet reverse = listReverse w in\nif reverse = w then true\nelse false"], "bad": ["let _ = palindrome \"malayalam\""], "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n"], "problem": "palindrome"}
{"hw": "hw1", "fix": ["let palindrome w =\nlet pk = explode w in\nlet reverse = listReverse (explode w) in\nif reverse = pk then true\nelse false"], "bad": ["let _ = palindrome \"malayalam\"", "let palindrome w =\nlet reverse = explode (listReverse w) in\nif reverse = w then true\nelse false", "let palindrome w =\nlet reverse = listReverse (explode w) in\nif reverse = w then true\nelse false", "let palindrome w =\nlet pk = explode w in\nlet reverse = listReverse (explode w) in\nif reverse = w then true\nelse false"], "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: This expression has type string but an expression was expected of type\n         char list\n", "Error: This expression has type string but an expression was expected of type\n         char list\n"], "problem": "palindrome"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n| [] -> d\n| (num,name)::tail ->\nif num = k then name\nelse assoc(d, k, tail)"], "bad": ["let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = seen in\nif List.mem h seen' then h::seen \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = h in\nif List.mem h l then h::seen'", "let rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = h in\nif List.mem h l then h::seen'", "let rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = h in\nif List.mem h l then h::seen'", "let rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = h in\nif List.mem h l then h::seen' \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = l in\nif List.mem h l then h::seen' \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = h in\nif List.mem h seen then h::seen' \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t ->\n(* Seen' should hold only the unique ones *)\nlet seen' =  \nif List.mem h seen = false then h::seen\nelse seen\nin\n(* If the head is NOT in hte list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = l in \nif List.mem h seen then h::seen'", "let rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = \nif List.mem h seen then h::seen'", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = l in\nif List.mem h seen' then h::seen", "let rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = l in\nif List.mem h l then h::seen", "let rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = l in\nif List.mem h l then h::seen'", "let rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = l in\nif List.mem h seen' then h::seen\nelse seen", "let rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = l in\nif List.mem h seen' then h::seen\nelse h::seen", "let rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t ->\n(* Seen' should hold only the unique ones *)\nlet seen' =  \nif List.mem h seen = false then h::seen\nin\n(* If the head is NOT in hte list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = match (f,b) with\n| (func, param) ->\nif param = true then func param \nelse param\n| _ -> b"], "bad": ["let rec wwhile (f,b) = match (f,b) with\n| (func, param) ->\nif param = true then func param \nelse num\n| _ -> 0", "let rec wwhile (f,b) = match (f,b) with\n| (func, param) ->\nif param = true then func param \nelse num\n| _ -> b"], "message": ["Error: Unbound value num\n", "Error: Unbound value num\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = match (f,b) with\n| (func, param) ->\nif param = true then f param \nelse 0"], "bad": ["let rec wwhile (f,b) = match (f,b) with\n| (func, param) ->\nif param = true then f param \nelse 0\n| _ -> b"], "message": ["Error: This expression has type bool but an expression was expected of type\n         int\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = match b with\n| (e, boo) ->\nif boo = true then e"], "bad": ["let rec wwhile (f,b) = match b with\n| (e, boo) ->\nif boo = true then e\nelse wwhile f e", "let rec wwhile (f,b) = match b with\n| (e, boo) ->\nif boo = true then e\nelse wwhile e b", "let rec wwhile (f,b) = match b with\n| (e, boo) ->\nif boo = true then e\nelse wwhile b", "let rec wwhile (f,b) = match b with\n| (e, boo) ->\nif boo = true then e\nelse wwhile f b"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a * (('b -> 'c) * bool)\n       The type variable 'a occurs inside 'a * (('b -> 'c) * bool)\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'c * (('a -> 'b) * bool)\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b * ('a * bool)\n", "Error: This expression has type 'a but an expression was expected of type\n         'a * (('b -> 'c) * bool)\n       The type variable 'a occurs inside 'a * (('b -> 'c) * bool)\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = match b with\n| (express, boo) ->\nif boo = true then wwhile(express, b)\nelse express"], "bad": ["let rec wwhile (f,b) = match b with\n| (express, boo) ->\nif boo = true then wwhile(f, express)\nelse express"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n"], "problem": "expr"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = \nlet ans = f b in\nmatch ans with\n| (num, boo) ->\nif boo = true then wwhile(f, num)\nelse num"], "bad": ["let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "message": ["Error: This expression has type int but an expression was expected of type\n         (int -> int * bool) * bool\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = \nwwhile \n((let func p = \nlet cal = f p in \nif p == cal then (cal, false)\nelse (cal, true) in func\n),b)"], "bad": ["let fixpoint (f,b) = \nwwhile \n((let func p = \nlet cal = f p in \nif p == cal then (cal, false)\nelse (cal, true) in xx\n),b)"], "message": ["Error: Unbound value xx\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with\n| VarX -> \"X\"\n| VarY -> \"Y\"\n| Sine sin  -> \"( sin \"\n| Cosine cos -> \"cos\"\n| Average (n1, n2) ->  \"( \" ^ (exprToString n1) ^ \"+\" ^ (exprToString n2) ^ \")/2\"\n| Times (t1, t2) -> \"(t1 * t2)\"\n| Thresh (th1, th2, th3, th4) -> \"bullshit\""], "bad": ["let rec exprToString e = match e with\n| VarX -> \"X\"\n| VarY -> \"Y\"\n| Sine sin  -> \"( sin \"\n| Cosine cos -> \"cos\"\n| Average (n1, n2) ->  \"( \" ^ (exprToString n1) ^ \"+\" ^ (exprToString n2) ^ \")/2\"\n| Times (t1, t2) -> \"(t1 * t2)\"\n| Thresh (th1, th2, th3, th4) ->"], "message": ["Error: Syntax error\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine sin  -> \"(sin(pi*\" ^ (exprToString sin) ^ \")\"  \n| Cosine cos -> \"(cos(pi*\" ^ (exprToString cos) ^ \")\"\n| Average (n1, n2) ->  \"( \" ^ (exprToString n1) ^ \"+\" ^ (exprToString n2) ^ \")/2\"\n| Times (t1, t2) -> \"(\" ^ (exprToString t1) ^ \"*\" ^ (exprToString t2) ^ \")\"\n| Thresh (th1, th2, th3, th4) -> \"bullshit\""], "bad": ["let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine sin  -> \"(sin(pi*\" ^ (exprToString sin) ^ \")\"  \n| Cosine cos -> \"(cos(pi*\" ^ (exprToString cos) ^ \")\"\n| Average (n1, n2) ->  \"( \" ^ (exprToString n1) ^ \"+\" ^ (exprToString n2) ^ \")/2\"\n| Times (t1, t2) -> \"(\" ^ (exprToString t1) ^ \"*\" (exprToString t2) ^ \")\"\n| Thresh (th1, th2, th3, th4) -> \"bullshit\""], "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* If it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t ->\n(* Seen' should hold only the unique ones *)\nlet seen' =  \nif List.mem h seen = false then h::seen\nelse seen\nin\n(* If the head is NOT in hte list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) = \n(* Save the function and parameter into an expression *)\n(*let ans = f b in\nmatch ans with\n| (num, tf) ->\n(* If boolean is true, then loop again on new value *)\nif tf = true then wwhile(f, num)\n(* Otherwise, return old value *)\nelse num;;*)\nlet (p,k) = f(b) in\nif k then wwhile(f, p) else p", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) = \nwwhile \n((let func b = \n(* Save the return value of the function to compare with b *)\nlet ans = f b in \n(* If it's equal, say false to quit, else keep going *)\nif b = ans then (ans, false)\nelse (ans, true) in func\n),b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)", "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| DivAdd   of expr * expr * expr * expr\n| TriMult  of expr * expr * expr", "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine sin  -> \"sin(pi*\" ^ (exprToString sin) ^ \")\"  \n| Cosine cos -> \"cos(pi*\" ^ (exprToString cos) ^ \")\"\n| Average (n1, n2) ->  \"((\" ^ (exprToString n1) ^ \"+\" ^ (exprToString n2) ^ \")/2)\"\n| Times (t1, t2) -> (exprToString t1) ^ \"*\" ^ (exprToString t2) \n| Thresh (th1, th2, th3, th4) -> \"(\" ^ (exprToString th1) ^ \"<\" ^ \n(exprToString th2) ^ \"?\" ^ (exprToString th3) ^ \n\":\" ^ (exprToString th4) ^ \")\"\n| DivAdd (ds1, ds2, ds3, ds4) -> \"((\" ^ (exprToString ds1) ^ \"+\" ^\n(exprToString ds2) ^ \") / (\" ^ (exprToString ds3) ^\n\"+\" ^ (exprToString ds4) ^ \"))\"\n| TriMult (tm1, tm2, tm3) -> \"(\" ^ (exprToString tm1) ^ \"*\" ^ (exprToString tm2) ^\n\"*\" (exprToString tm3) ^ \")\""], "bad": ["let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine sin  -> \"sin(pi*\" ^ (exprToString sin) ^ \")\"  \n| Cosine cos -> \"cos(pi*\" ^ (exprToString cos) ^ \")\"\n| Average (n1, n2) ->  \"((\" ^ (exprToString n1) ^ \"+\" ^ (exprToString n2) ^ \")/2)\"\n| Times (t1, t2) -> (exprToString t1) ^ \"*\" ^ (exprToString t2) \n| Thresh (th1, th2, th3, th4) -> \"(\" ^ (exprToString th1) ^ \"<\" ^ \n(exprToString th2) ^ \"?\" ^ (exprToString th3) ^ \n\":\" ^ (exprToString th4) ^ \")\"\n| DivAdd (ds1, ds2, ds3, ds4) -> \"((\" ^ (exprToString ds1) ^ \"+\" ^\n(exprToString ds2) ^ \") / (\" ^ (exprToString ds3) ^\n\"+\" ^ (exprToString ds4) \"))\"\n| TriMult (tm1, tm2, tm3) -> \"(\" ^ (exprToString tm1) ^ \"*\" ^ (exprToString tm2) ^\n\"*\" (exprToString tm3) ^ \")\""], "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "problem": "exprToString"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a  in\nlet base = f  in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a  in\nlet base = f x a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a  in\nlet base = f a in\nList.fold_left f base fs"], "message": ["Error: Unbound value x\n", "Error: Unbound value a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a  in\nlet base =  3 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a  in\nlet base = a  in\nList.fold_left f base fs"], "message": ["Error: Unbound value a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a  in\nlet base =  f 3 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a  in\nlet base =  x 3 in\nList.fold_left f base fs"], "message": ["Error: Unbound value x\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = 3  in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a  in\nlet base =  fs 3 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x in\nlet base =  f (x a) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x in\nlet base =  f ((f a x) a) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x in\nlet base =  f base in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = f x in\nlet base = 3  in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fs x in\nlet base = 3  in\nList.fold_left f base fs"], "message": ["Error: This expression has type int -> 'a\n       but an expression was expected of type ('a -> 'a) list\n", "Error: Unbound value x\n", "Error: Unbound value a\n", "Error: Unbound value base\n", "Error: Unbound value f\n", "Error: This expression has type 'a -> int\n       but an expression was expected of type 'a list\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = f  in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = x  in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = a  in\nList.fold_left f base fs"], "message": ["Error: Unbound value x\n", "Error: Unbound value a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = a in\nlet base = f  in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a x in\nlet base = f  in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nmatch fs with \n| [] -> base\n| f::fs' -> \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs"], "message": ["Error: Unbound value base\n", "Error: Unbound value a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "let pipe fs = \nlet f a x = f x  in\nlet base = 3 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = f 0 in\nList.fold_left f base fs", "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = f a in\nList.fold_left f base fs", "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = f x in\nList.fold_left f base fs", "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs", "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = fs' in\nList.fold_left f base fs", "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = fs' in\nList.fold_left f base fs"], "message": ["Error: This expression has type (int -> 'a) -> 'a\n       but an expression was expected of type int\n", "Error: Unbound value a\n", "Error: Unbound value x\n", "Error: This expression has type 'a -> ('a -> 'b) -> 'b\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type ('a list -> 'a list) list\n       The type variable 'a occurs inside 'a list -> 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type ('a list -> 'a list) list\n       The type variable 'a occurs inside 'a list -> 'a list\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs =\nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs"], "bad": ["let pipe fs =\nlet f a x = x a in\nlet base = f(x,a) in\nList.fold_left f base fs", "let pipe fs =\nlet f a x = x a in\nlet base = f a in\nList.fold_left f base fs"], "message": ["Error: Unbound value x\n", "Error: Unbound value a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs =\nlet f a x = fun p -> x (a p) in\nlet base =  fun b -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs =\nlet f a x = x a in\nlet base = f (x a) in\nList.fold_left f base fs", "let pipe fs =\nlet f a x = x a in\nlet base = _ in\nList.fold_left f base fs"], "message": ["Error: Unbound value x\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let stringOfList f l = \nList.map sepConcat l"], "bad": ["let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let stringOfList f l = \nList.map (sepConcat f l) l"], "message": ["Error: This expression has type int -> string\n       but an expression was expected of type string\n", "Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = \nList.map (sepConcat \"\") l"], "bad": ["let _ = stringOfList string_of_int [1;2;3;4;5;6]"], "message": ["Error: This expression has type int but an expression was expected of type\n         string\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = \nList.map (sepConcat (f \"\")) l"], "bad": ["let stringOfList f l = \nList.map (sepConcat fun y -> f \"\") l"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = \nList.map ( sepConcat (f l) ) l"], "bad": ["let stringOfList f l = \nList.map (( sepConcat \"\" ) l) l", "let stringOfList f l = \nList.map f (( sepConcat \"\" ) l)"], "message": ["Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = \nList.map ( sepConcat (f) ) l"], "bad": ["let _ = stringOfList string_of_int [1;2;3;4;5;6]"], "message": ["Error: This expression has type int -> string\n       but an expression was expected of type string list list -> string\n       Type int is not compatible with type string list list \n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = \nList.map (sepConcat f) l"], "bad": ["let stringOfList f l = \nList.map (sepConcat f) (f l)", "let stringOfList f l = \nList.map (sepConcat f) (f l)"], "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = \nList.map (sepConcat f) l"], "bad": ["let stringOfList f l = \nList.map (sepConcat (\"\" l)) l", "let stringOfList f l = \nList.map (sepConcat \"\" l) l", "let stringOfList f l = \nList.map (sepConcat f l) l"], "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = \n\"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\""], "bad": ["let stringOfList f l = \nList.map f (sepConcat f l)", "let stringOfList f l = \nList.map f (sepConcat l)", "let stringOfList f l = \n(sepConcat \"\" l) List.map (f l)", "let stringOfList f l = \n(sepConcat List.map (f l) l)", "let stringOfList f l = \n(sepConcat (List.map (f l)) l)", "let stringOfList f l = \n\"[\" ^ sepConcat \";\" ^ List.map(f l) ^ \"]\"", "let stringOfList f l = \n\"[\" ^ sepConcat \";\" List.map(f l) ^ \"]\"", "let stringOfList f l = \n\"[\" ^ sepConcat \";\" List.map(f l) ^ \"]\""], "message": ["Error: This expression has type 'a -> 'b\n       but an expression was expected of type string\n", "Error: This expression has type string list -> string\n       but an expression was expected of type 'a list\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a list -> 'b list\n       but an expression was expected of type string\n", "Error: This expression has type string list -> string\n       but an expression was expected of type string\n", "Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let rec clone x n = match n with \n| 0 -> []\n| n -> x@clone x (n-1)"], "bad": ["let rec clone x n = match n with \n| 0 -> []\n| _ -> clone x::[] (n-1)"], "message": ["Error: This expression has type int -> 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside int -> 'a list\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let rec clone x n = \nif n <= 0 then []\nelse [x]@clone x (n-1)"], "bad": ["let rec clone x n = match n with \nif n <= 0 then []\nelse [x]@clone x (n-1)"], "message": ["Error: Syntax error\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs =\n(* Call a function p that returns the function x in fs. Called on the 'a' value *)\nlet f a x = fun p -> x (a p) in\n(* Save base into a function that simply returns the parameter *)\nlet base =  fun b -> b in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \n(* Concatenate the first element with the separator and x *)\nlet f a x = a ^ sep ^ x in\n(* base element be the head *)\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\";]", "let stringOfList f l = \n\"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n = \nif n <= 0 then []\nelse [x]@clone x (n-1)", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)"], "bad": ["let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs =\n(* Call a function p that returns the function x in fs. Called on the 'a' value *)\nlet f a x = fun p -> x (a p) in\n(* Save base into a function that simply returns the parameter *)\nlet base =  fun b -> b in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \n(* Concatenate the first element with the separator and x *)\nlet f a x = a ^ sep ^ x in\n(* base element be the head *)\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\";]", "let stringOfList f l = \n\"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n = \nif n <= 0 then []\nelse [x]@clone x (n-1)", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)"], "bad": ["let padZero l1 l2 = \nif List.length l1 = List.length l2 then List.combine (l1, l2)", "let padZero l1 l2 = \nif List.length l1 = List.length l2 then List.combine l1 l2", "let padZero l1 l2 = \nif List.length l1 = List.length l2 then l1 l2", "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type unit\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs =\n(* Call a function p that returns the function x in fs. Called on the 'a' value *)\nlet f a x = fun p -> x (a p) in\n(* Save base into a function that simply returns the parameter *)\nlet base =  fun b -> b in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \n(* Concatenate the first element with the separator and x *)\nlet f a x = a ^ sep ^ x in\n(* base element be the head *)\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\";]", "let stringOfList f l = \n\"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n = \nif n <= 0 then []\nelse [x]@clone x (n-1)", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then ([0]@l1, l2)"], "bad": ["let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then padZero(0::l1 l2)", "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then padZero((0::l1) l2)", "let rec padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then padZero((0::l1) l2)", "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then 0::l1", "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then (0::l1, l2)"], "message": ["Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then (l1, l2)\nelse (l1, l2)"], "bad": ["let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then (0::l1, l2)", "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then (List.append [0] l1, l2)", "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then (l1, l2)"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nif List.length l1 > List.length l2 then (l1, 0::l2)\nelse if List.length l1 < List.length l2 then (0::l1, l2)\nelse (l1, l2)"], "bad": ["let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then (0::l1, 0::l2)\nelse (l1::[], l2::[])", "let padZero l1 l2 = \nif List.length l1 > List.length l2 then (l1, l2::0)\nelse if List.length l1 < List.length l2 then (0::l1, l2)\nelse (l1, l2)"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a list list\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \n(* L1 is greater, so append 0's to l2 *)\n(l1, List.append (clone 0 l1G) l2) \nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l1 in \n(List.append (clone 0 l2G) l1, l2)\nelse (l1, l2)"], "bad": ["let padZero l1 l2 = \nif List.length l1 > List.length l2 then clone (l1, 0::l2)\nelse if List.length l1 < List.length l2 then clone (0::l1, l2)\nelse (l1, l2)", "let padZero l1 l2 = \nif List.length l1 > List.length l2 then clone (l1, 0::l2) ,\nelse if List.length l1 < List.length l2 then clone (0::l1, l2)\nelse (l1, l2)", "let padZero l1 l2 = \nif List.length l1 > List.length l2 then List.combine(l1, clone(0::l2) \nelse if List.length l1 < List.length l2 then clone (0::l1, l2)\nelse (l1, l2)", "let padZero l1 l2 = \nif List.length l1 > List.length l2 then List.append(l1, clone(0::l2) \nelse if List.length l1 < List.length l2 then List.append (0::l1, l2)\nelse (l1, l2)", "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1, clone(0 l2) )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l2 in \nthen List.append (0::l1, l2)\nelse (l1, l2)", "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1, clone(l1, l2) )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l2 in \nthen List.append (clone (l1 l2G), l2)\nelse (l1, l2)", "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1, clone(l1, l2) )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l2 in \nList.append (clone (l1 l2G), l2)\nelse (l1, l2)", "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1, clone(0, l1G) )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l2 in \nList.append (clone (0 l2G), l2)\nelse (l1, l2)", "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1, clone(0  l1G) )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l2 in \nList.append (clone (0 l2G), l2)\nelse (l1, l2)", "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1 clone(0  l1G) )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l2 in \nList.append (clone (0 l2G) l2)\nelse (l1, l2)", "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1, clone(0  l1G) l2 )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l1 in \nList.append (clone (0 l2G) l1) l2\nelse (l1, l2)", "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1, (clone 0  l1G) l2 )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l1 in \nList.append ((clone 0 l2G) l1, l2)\nelse (l1, l2)"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type\n         int -> (int list * int list) list\n", "Error: Syntax error\n", "Characters 73-74:\n  if List.length l1 > List.length l2 then List.combine(l1, clone(0::l2) \n                                                      ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Characters 72-73:\n  if List.length l1 > List.length l2 then List.append(l1, clone(0::l2) \n                                                     ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (carry, rest) = a in \nlet total = n1 + n2 + carry in\n(total/10, (total mod 10)::rest) in\nlet base = (0, []) in\nlet args = List.rev (List.combine(0::l1) ( 0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| [] -> []\n| h::t -> h in\nmatch x with\n| [] -> [] \n| h2::t2 -> in \nlet base = h in\nlet args = h2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (carry, rest) = a in \nlet total = n1 + n2 + carry in\n(total/10, (sum mod 10)::rest) in\nlet base = (0, []) in\nlet args = List.rev (List.combine(0::l1, 0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (carry, rest) = a in \nlet total = n1 + n2 + carry in\n(total/10, (sum mod 10)::rest) in\nlet base = (0, []) in\nlet args = List.rev (List.combine(0::l1, 0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (carry, rest) = a in \nlet total = n1 + n2 + carry in\n(total/10, (total mod 10)::rest) in\nlet base = (0, []) in\nlet args = List.rev (List.combine(0::l1, 0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n", "Characters 206-207:\n  let args = List.rev (List.combine(0::l1, 0::l2) in\n                      ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Unbound value sum\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10)::(mulByDigit i t))\nelse prod::t"], "bad": ["let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10) + (mulByDigit i t))\nelse prod::t", "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10) + ((mulByDigit i t))\nelse prod::t", "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10) + (mulByDigit i t)::t)\nelse prod::t", "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10))\nelse prod::t"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Characters 124-125:\n  if prod > 10 then (prod mod 10)::((prod / 10) + ((mulByDigit i t))\n                                   ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)::(mulByDigit i t) )\nelse (prod mod 10)::t"], "bad": ["let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::[((prod / 10)::(mulByDigit i t))]\nelse prod::t", "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )::t\nelse prod::t", "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )\nelse prod::t", "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t)::[] )\nelse prod::t", "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> 0\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )\nelse prod::t", "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )\nelse prod::t", "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )\nelse (prod mod 10)::t"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs =\n(* Call a function p that returns the function x in fs. Called on the 'a' value *)\nlet f a x = fun p -> x (a p) in\n(* Save base into a function that simply returns the parameter *)\nlet base =  fun b -> b in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \n(* Concatenate the first element with the separator and x *)\nlet f a x = a ^ sep ^ x in\n(* base element be the head *)\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\";]", "let stringOfList f l = \n\"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n = \nif n <= 0 then []\nelse [x]@clone x (n-1)", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \n(* L1 is greater, so append 0's to l2 *)\n(l1, List.append (clone 0 l1G) l2) \nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l1 in \n(List.append (clone 0 l2G) l1, l2)\nelse (l1, l2)", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let rec removeZero l = match l with\n| [] -> []\n| h::t ->\nif h = 0 then\nremoveZero t \nelse l", "let _ = removeZero [0;0;0;1;0;0;2]", "let _ = removeZero [9;9]", "let _ = removeZero [0;0;0;0]", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \n\n(* Divide two lists into tuples of their digits. i.e.\n[7;2;4;6] and [3;9;2;7] -> (7,3) (2,9) (4,2) (6,7 )*)\nlet (n1, n2) = x in\n\n(* Carry = value after adding them, rest = rest of tuples put in a list *)\nlet (carry, rest) = a in \n\n(* Add up the two digits in the pair plus the carry over *)\nlet total = n1 + n2 + carry in\n(* Grab the first digit of the sum and divide by 10 to check whether there is a carry, last digit::rest *)\n(total/10, (total mod 10)::rest) in\n\n(* Base - sum is initially 0 and pass empty list to store list of\npairs of the digits of the list*)\nlet base = (0, []) in\n\n(* Args == list of tuples of list's digits *)\nlet args = List.rev (List.combine(0::l1) ( 0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]", "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)::(mulByDigit i t) )\nelse (prod mod 10)::t"], "bad": ["let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then ((prod mod 10)::( (prod / 10) + (mulByDigit i t) ))::t\nelse (prod mod 10)::t", "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10) + [(mulByDigit i t)] )\nelse (prod mod 10)::t", "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( [(prod / 10)]::(mulByDigit i t) )\nelse (prod mod 10)::t"], "message": ["Error: This expression has type int list list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = \nlet mult i l = \nlet f a x = \nlet (carryOver, rest) = a in\nlet num = carryOver + (x * i) in\nlet secondDigit = num mod 10 in\nlet carryOver = num / 10 in\nlet result = secondDigit::rest in (carryOver, rest) in\nlet base = (0, []) in\nlet (carryOver, rest) = List.fold_left f base (List.rev l) in\ncarryOver::rest in\nremoveZero(mult i l)"], "bad": ["let rec mulByDigit i l = \nmatch l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nlet lastDigit = prod / 10 in \nlet firstDigit = prod mod 10 in\nif prod > 10 then lastDigit::[firstDigit + mulByDigit(i t)]\nelse firstDigit::t", "let rec mulByDigit i l = \nmatch l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nlet lastDigit = prod / 10 in \nlet firstDigit = prod mod 10 in\nlet ret = mulByDigit ( i t ) in\nmatch ret with \n| [] -> 0\n| h2::t2 -> if h2 > 10 then let temp = h2 \nelse let temp = h2 mod 10 in \nif prod > 10 then lastDigit::[firstDigit + temp]\nelse firstDigit::t", "let rec mulByDigit i l = \nmatch l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nlet lastDigit = prod / 10 in \nlet firstDigit = prod mod 10 in\nlet ret = mulByDigit ( i t ) in\nmatch ret with \n| [] -> 0\n| h2::t2 -> if h2 > 10 then let temp = h2 \nelse temp = h2 mod 10 in \nif prod > 10 then lastDigit::[firstDigit + temp]\nelse firstDigit::t", "let rec mulByDigit i l = \nmatch l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nlet lastDigit = prod / 10 in \nlet firstDigit = prod mod 10 in\nlet ret = mulByDigit ( i t ) in\nmatch ret with \n| [] -> 0\n| h2::t2 -> if h2 > 10 then let temp = h2 in \nif prod > 10 then lastDigit::[firstDigit + temp]\nelse firstDigit::t"], "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in\nlet base = [] in\nlet args = List.rev l2 in\nList.fold_left f base args"], "bad": ["let bigMul l1 l2 = \nlet f a x = List.append ((mulByDigit x l1) (clone 0 (List.length a))::a) in\nlet base = [] in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = ((mulByDigitx l1)@(clone 0 (List.length a)))::a in\nlet base = [] in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in\nlet base = [] in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: Unbound value mulByDigitx\nHint: Did you mean mulByDigit?\nError: Unbound value mulByDigitx\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value mulByDigitx\nHint: Did you mean mulByDigit?\n", "Error: This expression has type int list list\n       but an expression was expected of type 'a * 'b\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list list\n       but an expression was expected of type 'a * 'b\n"], "problem": "bigMul"}
{"hw": "hw1", "fix": ["let rec sumList xs = \nlet x :: t = xs in\nx + sumList (t)"], "bad": ["let rec sumList xs = \nxs.(0) + hd xs", "let rec sumList xs = \nif xs.length != 0 then xs.(0) + sumList(hd xs)", "let rec sumList xs = \nif List.length xs != 0 then xs.(0) + sumList(hd xs)", "let rec sumList xs = \nif List.length xs != 0 then xs.(0) + sumList(List.hd xs)", "let rec sumList xs = \nif List.length xs != 0 then List.nth xs 0 + sumList(List.hd xs)", "let rec sumList xs = \nif List.length xs != 0 then List.nth xs 0 + sumList(List.tl xs)", "let rec sumList xs = \nif List.length xs != 0 then List.nth xs 0 + sumList(List.tl xs)", "let rec sumList xs = \nlet rec int q =\nq + if List.length xs != 0 then List.nth xs 0 \n| sumList(List.tl xs)", "let rec sumList xs = \nlet rec int q =\nq + if List.length xs != 0 then List.nth xs 0 \nsumList(List.tl xs)", "let rec sumList xs = \nlet int q =\nq + x :: xs", "let rec sumList xs = \nlet int q =\nq + x :: xs", "let rec sumList xs = \nlet x :: t = xs in\nlet int q = q + x + sumList(t)", "let rec sumList xs = \nlet x :: t = xs in\nlet int q = q + x + sumList (t)"], "message": ["Error: Unbound value hd\n", "Error: Unbound record field length\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b array\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b array\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let rec sumList xs = \nlet x :: t = xs in\nx + if t = [] then 0 else sumList (t)"], "bad": ["let rec sumList xs = \nlet x :: t = xs in\nif t != [] then x + sumList (t)", "let rec sumList xs = \nlet x :: t = xs in\nif x != [] then x + sumList (t)", "let rec sumList xs = \nlet x :: t = xs in\nx + if t != [] then sumList (t)"], "message": ["Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type unit but an expression was expected of type\n         int\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let rec sumList xs = \nlet x :: t = xs in\nx + if t = [] then 0 else sumList (t)", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]", "let rec digitsOfInt n = \nn mod 10 :: if n > 0 then digitsOfInt (n / 10)"], "bad": ["let rec digitsOfInt n = \nn mod 10 :: if n <> [] then digitsOfInt (n / 10)"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nlet int list digInt = n mod 10 in\nif n > 0 then digitsOfInt (n / 10) else []"], "bad": ["let rec digitsOfInt n = \nlet int list xs = \nn mod 10 :: if n > 0 then digitsOfInt (n / 10)", "let rec digitsOfInt n = \nlet digInt =\nn mod 10 :: if n > 0 then digitsOfInt (n / 10)", "let rec digitsOfInt n = \nlet int list digInt =\nn mod 10 :: if n > 0 then digitsOfInt (n / 10) else []"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nlet int list digInt = n mod 10 in\nif n > 0 then digitsOfInt (n / 10)"], "bad": ["let rec digitsOfInt n = \nlet int list digInt = n mod 10 in\nif n > 0 then digitsOfInt (n / 10) else digInt", "let rec digitsOfInt n = \nlet int list digInt = n mod 10 in\nif n > 0 then digitsOfInt (n / 10) else digInt"], "message": ["Error: Unbound value digInt\n", "Error: Unbound value digInt\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nlet list digInt = (n mod 10) in\nif n / 10 <> 0 then digitsOfInt (n / 10)"], "bad": ["let rec digitsOfInt n = \nlet int list digInt :: n mod 10 in\nif n > 0 then digitsOfInt (n / 10)", "let rec digitsOfInt n = \nlet list digInt :: n mod 10 in\nif n > 0 then digitsOfInt (n / 10)", "let rec digitsOfInt n = \nlet list digInt :: (n mod 10) in\nif n > 0 then digitsOfInt (n / 10)", "let rec digitsOfInt n = \nlet list digInt :: (n mod 10)\nif n > 0 then digitsOfInt (n / 10)", "let rec digitsOfInt n = \nlet list digInt :: (n mod 10) in\nif n / 10 <> 0 then digitsOfInt (n / 10)"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let int list digInt = []", "let rec digitsOfInt n = \ndigInt = n mod 10 :: digitsOfInt( n / 10)"], "bad": ["let rec digitsOfInt n = \nlet int list digInt :: (n mod 10) in\nif n / 10 <> 0 then digitsOfInt (n / 10)", "let rec digitsOfInt n = \nlet int list digInt =\nn mod 10 :: if n / 10 <> 0 then digitsOfInt (n / 10)", "let rec digitsOfInt n = \nlet int list digInt = n mod 10 :: digitsOfInt( n / 10)", "let rec digitsOfInt n = \ndigInt = n mod 10 :: digitsOfInt( n / 10)", "let rec digitsOfInt n = \nint list digInt = n mod 10 :: digitsOfInt( n / 10)"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value digInt\n", "Error: Unbound value int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let r = [2;3]", "let 15 mod 10 :: r"], "bad": ["let r = [2; 3]\n\n15 mod 10 :: r", "let r = [2;3]\n\n15 mod 10 :: r"], "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let r = [2;3]"], "bad": ["let 15 mod 10 :: r = r", "let r = [2;3] \n\n15 mod 10 :: r"], "message": ["Error: Syntax error\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec sumList xs = \nlet x :: t = xs in\nx + if t = [] then 0 else sumList (t)", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]", "let r = [2;3]", "let rec digitsOfInt n = \nlet digInt = [] in\nif (n / 10) <> 0 \nthen digInt :: digitsOfInt ( n / 10) \nelse []"], "bad": ["let rec digitsOfInt n = \nlet int list digInt = n mod 10 :: digInt \nif (n / 10) <> 0 then digitsOfInt ( n / 10)", "let rec digitsOfInt n = \nlet int list digInt = n mod 10 :: digInt in\nif (n / 10) <> 0 then digInt :: digitsOfInt ( n / 10)", "let rec digitsOfInt n = \nlet int list digInt = [] in\nif (n / 10) <> 0 then digInt :: digitsOfInt ( n / 10)"], "message": ["Error: Syntax error\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let l = []", "let rec digitsOfInt n l= \nmatch l with\n| [] -> []\n| (n mod 10) :: l -> if (n / 10) <> 0\nthen digitsOfInt (n / 10) l\nelse []"], "bad": ["let rec digitsOfInt n = \nlet digInt =\nif (n / 10) <> 0 \nthen digInt :: digitsOfInt ( n / 10) \nelse []", "let rec digitsOfInt n = \nlet digInt =\nif (n / 10) <> 0 \nthen n mod 10 :: digitsOfInt ( n / 10) \nelse []", "let rec digitsOfInt n = \nlet digInt = n mod 10\nif (n / 10) <> 0 \nthen n mod 10 :: digitsOfInt ( n / 10) \nelse []", "let rec digitsOfInt n = \nlet digInt =\nif (n / 10) <> 0 \nthen n mod 10 :: digitsOfInt ( n / 10) \nelse []"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\nmatch n / 10 with\n| 0  -> n mod 10 ::[]\n| _  -> n mod 10 :: digitsOfInt( n / 10)"], "bad": ["let digitsOfInt n =\nlet l = [] in\nmatch n / 10 with\n| 0  -> []\n| _  -> l :: n mod 10 :: digitsOfInt( n / 10)", "let digitsOfInt n =\nlet l = [] \nmatch n / 10 with\n| 0  -> []\n| _  -> l :: n mod 10 :: digitsOfInt( n / 10)", "let digitsOfInt n =\nmatch n / 10 with\n| 0  -> []\n| _  -> l :: n mod 10 :: digitsOfInt( n / 10)", "let digitsOfInt n =\nmatch n / 10 with\n| 0  -> n mod 10 ::[]\n| _  -> l :: n mod 10 :: digitsOfInt( n / 10)", "let digitsOfInt n =\nmatch n / 10 with\n| 0  -> n mod 10 ::[]\n| _  -> n mod 10 :: digitsOfInt( n / 10)"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list list\n       but an expression was expected of type int list\n       Type 'a list is not compatible with type int \n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec listReverse l = \nmatch l with \n| []   -> []\n| x::l -> x :: listReverse(l)"], "bad": ["let rec listReverse l = \nmatch l with \n| []   -> []\n| x::l -> listReverse(l) :: x", "let rec listReverse l = \nmatch l with \n| []   -> []\n| x::l -> x :: listReverse(l) x"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let append x y =\nmatch y with\n| [] -> []\n| h::t -> x :: h"], "bad": ["let fun append x y =\nmatch y with\n| [] -> []\n| h::t -> x :: h"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let append x y =\nmatch y with\n| [] -> []\n| h::t -> h :: x"], "bad": ["let _ = append [1;2] [3;4]"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list list\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let append x y =\nmatch y with\n| [] -> []\n| h :: [] -> h :: x\n| h::t -> h :: x"], "bad": ["let append x y =\nmatch y with\n| [] -> []\n| _ -> h :: x"], "message": ["Error: Unbound value h\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec append x y =\nmatch y with\n| []   -> []\n| h::t -> append (h::x) t"], "bad": ["let rec append x y =\nmatch y with\n| []   -> []\n| h::t -> append h::x t"], "message": ["Error: This expression has type 'a list -> 'b list\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside 'a list -> 'b list\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec append x y =\nmatch y with\n| []   -> x\n| h::t -> append (h::x) t", "let rec listReverse l = \nmatch l with \n| [] -> []\n| h::t -> listReverse(t) :: h"], "bad": ["let rec listReverse l = \nmatch l with \n| [] -> []\n| h::t -> listReverse(t) :: h"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec listReverse l = \nlet h::t = l in\nmatch l with \n| []   -> []\n| h::t -> listReverse t"], "bad": ["let rec listReverse l = \nmatch l with \n| [] -> []\n| h::t -> listReverse t :: h :: []"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec sumList xs =\nmatch xs with\n| [] -> 0\n| h::t -> h + sumList(t)"], "bad": ["let rec sumList xs = \nmatch xs with\n| [] -> x + 0\n| h::t -> x + sumList(t)", "let rec sumList xs =\nlet x =\nmatch xs with\n| [] -> x + 0\n| h::t -> x + sumList(t)"], "message": ["Error: Unbound value x\n", "Error: Syntax error\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let rec listReverse l = \nmatch l with\n| [] -> []\n| h::t -> (listReverse t)"], "bad": ["let rec listReverse l = \nmatch l with\n| [] -> []\n| h::t -> (listReverse t) :: h", "let rec listReverse l = \nif l <> [] then let\nmatch l with \n| []   -> l\n| h::t -> (listReverse t) :: h"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: Syntax error\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec listReverse2 l dest = \nmatch l with\n| [] -> []\n| h::t -> listReverse2 t (h::dest)", "let rec listReverse l = listReverse2 l []"], "bad": ["let rec listReverse l = \nif l <> [] then let\nmatch l with \n| []   -> l\n| h::t -> (listReverse t) :: h", "let rec listReverse l = \nif l <> [] then \nmatch l with \n| []   -> l\n| h::t -> (listReverse t) :: h"], "message": ["Error: Syntax error\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec digitalRoot n = digitalRoot(sumList(digits(n)))"], "bad": ["let rec digitalRoot n = digitalRoot(sumList(n))"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "digitalRoot"}
{"hw": "hw1", "fix": ["let _ = digitsToList 5533"], "bad": ["let rec digitsToList n = \nmatch n / 10 with\n| 0  -> n mod 10 ::[]\n| _  -> n mod 10 :: digitsToList( n / 10)"], "message": ["Error: Unbound value listReverse\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let listReverse l = listReverse2 l []"], "bad": ["let listReverse l = listReverse2 l []", "let rec listReverse2 l dest = ", "let rec listReverse2 l dest = \nmatch l with\n| [] -> dest\n| h::t -> listReverse2 t (h::dest)"], "message": ["Error: Unbound value listReverse\n", "Error: Unbound value listReverse2\n", "Error: Syntax error\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = additivePersistence 9876"], "bad": ["let additivePersistence n = additivePersistence2 n 0"], "message": ["NO ERROR FROM MINIMAL PROGRAM!!!\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec proceed a b =\nmatch a, b with\n| [] , [] -> true\n| _::_, [] -> false\n| [], _::_ -> false\n| ha::ta, hb::tb -> if ha = hb then proceed ta tb else false"], "bad": ["let rec proceed a b =\nmatch a, b with\n| [] , [] -> true\n| ha::ta, hb::tb -> if ha = hb then proceed ta tb else false"], "message": ["Error: Unbound value proceed\nHint: Did you mean pred?\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen' then seen' else h :: seen' in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "message": ["Error: Unbound value seen'\nHint: Did you mean seen?\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile (f ,b)"], "bad": ["let fixpoint (f,b) = wwhile (f b <> b,b)"], "message": ["Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile (f b ,b)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ( f, b)"], "bad": ["let fixpoint (f,b) = wwhile (wwhile (f, b),b)", "let fixpoint (f,b) = wwhile (wwhile (f , b) , b)", "let fixpoint (f,b) = wwhile ( if f b = b then b else f b , b)", "let fixpoint (f,b) = wwhile ( fixpoint (f , b), b)", "let fixpoint (f,b) = wwhile ( fixpoint , b)"], "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: This expression has type ('a -> 'a * bool) * 'a\n       but an expression was expected of type 'a -> 'a * bool\n", "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: This expression has type ('a -> 'a -> 'a * bool) * 'a -> 'a\n       but an expression was expected of type\n         ('a -> 'a -> 'a * bool) * 'a ->\n         (('a -> 'a -> 'a * bool) * 'a) * bool\n       The type variable 'a occurs inside\n       (('a -> 'a -> 'a * bool) * 'a) * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type ('a -> 'a -> 'a * bool) * 'a -> 'a\n       but an expression was expected of type\n         ('a -> 'a -> 'a * bool) * 'a ->\n         (('a -> 'a -> 'a * bool) * 'a) * bool\n       The type variable 'a occurs inside\n       (('a -> 'a -> 'a * bool) * 'a) * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ( let b' = f b in if b' = b then f b else f b')"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let fixpoint (f,b) = wwhile ( let b' = f b in if b' = b then f b else f b', b)"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "Error: This expression has type ('a -> 'a * bool) * 'a\n       but an expression was expected of type 'a -> 'a * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = \nmatch l with  \n| [] -> d\n| h::t -> \nlet (p , q) = h in\nif k = p then q\nelse assoc (d, k, t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) = \nlet (b' , c') = f b in\nif c' = false then b' else wwhile(f, b')", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) = wwhile (failwith \"to be written\" , b)"], "bad": ["let fixpoint (f,b) = wwhile ( , b)"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(expr) -> \"sin(pi*\"^exprToString(expr)^\")\"\n| Cosine(expr) -> \"cos(pi\"^ exprToString(expr)^\")\"\n| Average(expr, expr2) -> \"((\"^exprToString(expr)^\"+\"^exprToString(expr2)^\"/2)\"\n| Times(expr, expr2) -> exprToString(expr)^\"*\"^exprToString(expr2)\n| Thresh(expr, expr2, expr3, expr4) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?\"^exprToString(expr3)^\":\"^exprToString(expr4)^\")\""], "bad": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(expr) -> \"sin(pi*\"^exprToString(expr)^\")\"\n| Cosine(expr) -> \"cos(pi\"^ exprToString(expr)^\")\"\n| Average(expr, expr2) -> \"((\"^exprToString(expr)^\"+\"^exprToString(expr2)^\"/2)\"\n| Times(expr, expr2) -> exprToString(expr)^\"*\"exprToString(expr2)\n| Thresh(expr, expr2, expr3, expr4) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?\"^exprToString(expr3)^\":\"^exprToString(expr4)\")\"", "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(expr) -> \"sin(pi*\"^exprToString(expr)^\")\"\n| Cosine(expr) -> \"cos(pi\"^ exprToString(expr)^\")\"\n| Average(expr, expr2) -> \"((\"^exprToString(expr)^\"+\"^exprToString(expr2)^\"/2)\"\n| Times(expr, expr2) -> exprToString(expr)^\"*\"^exprToString(expr2)\n| Thresh(expr, expr2, expr3, expr4) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?\"^exprToString(expr3)^\":\"^exprToString(expr4)\")\""], "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) +. (eval(e2, x ,y) /. 2.0))\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) ./ 2) + (eval(e2, x ,y) ./ 2))\n| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2) + (eval(e2, x ,y) /. 2))\n| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)", "et rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) + (eval(e2, x ,y) /. 2.0))\n| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) + (eval(e2, x ,y) /. 2.0))\n| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)"], "message": ["Error: Syntax error: operator expected.\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: Syntax error\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["uildX()                       = VarX", "let buildY()                       = VarY", "let buildSine(e)                   = Sine(e)", "let buildCosine(e)                 = Cosine(e)", "let buildAverage(e1,e2)            = Average(e1,e2)", "let buildTimes(e1,e2)              = Times(e1,e2)", "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "let pi = 4.0 *. atan 1.0", "let rec eval (e,x,y) = match e with"], "bad": ["let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"], "message": ["Error: Unbound value buildCosine\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nif depth = 0 then \nmatch rand(0, 2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand(2, 7) with \n| 2 -> buildSine(build(rand, depth - 1))\n| 3 -> buildCosine(build(rand, depth - 1))\n| 4 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 6 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))"], "bad": ["let rec build (rand, depth) = \nlet f = makeRand(rand) in\nif depth = 0 then buildX()\nelse\nmatch f with \n| 2 -> buildSine(build(rand, depth - 1))\n| 3 -> buildCosine(build(rand, depth - 1))\n| 4 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 6 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "let rec build (rand, depth) = \nif depth = 0 then \nmatch rand(0, 2)\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand(2, 7) with \n| 2 -> buildSine(build(rand, depth - 1))\n| 3 -> buildCosine(build(rand, depth - 1))\n| 4 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 6 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))"], "message": ["Error: This pattern matches values of type int\n       but a pattern was expected which matches values of type\n         int * int -> int\n", "Error: Syntax error\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile (f, b)"], "bad": ["let fixpoint (f,b) = let xx = f(b) in (xx, xx = b) in wwhile (f, b)"], "message": ["Error: Unbound value f\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = \nmatch l with  \n| [] -> d\n| h::t -> \nlet (p , q) = h in\nif k = p then q\nelse assoc (d, k, t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) = \nlet (b' , c') = f b in\nif c' = false then b' else wwhile(f, b')", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) = \nlet b' = f b in\nif b = b' then b else f b in \nwwhile (f , b)"], "bad": ["let fixpoint (f,b) = wwhile ( wwhile(f, b), b)", "let fixpoint (f,b) = wwhile (if f b = b then b else f b , b)"], "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: This expression has type ('a -> 'a * bool) * 'a\n       but an expression was expected of type 'a -> 'a * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = \nlet (b', c') = f b in\nif b = b' then b else wwhile (f , b)"], "bad": ["let fixpoint (f,b) = \nlet b' = f b in\nif b = b' then b else wwhile (f , b)"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = \nlet f x = let xx = f b in (xx, xx <> b) in wwhile (f, b)"], "bad": ["let fixpoint (f,b) = \nlet b' = f b in\nif b = b' then b else wwhile (f , b)", "let fixpoint (f,b) = \nlet b' = f b in\nif b = b' then b else f b in wwhile (f , b)", "let fixpoint (f,b) = \nlet b' = f b in\nif b = b' then b else f b in wwhile (f b, b)", "let fixpoint (f,b) = \nlet f b = b' in\nif b = b' then b else f b in wwhile (f b, b)", "let fixpoint (f,b) = \nlet f x = let xx = f b in (xx, xx <> b) in wwhile (f b, b)"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: Unbound value f\n", "Error: Unbound value f\n", "Error: Unbound value b'\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let fixpoint (f,b) = \nlet f b = let xx = f b in (xx, xx <>  b) in wwhile (f, b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + x in\nlet base =  0 in\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = (+) x in\nlet base = [] in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = (+) x in\nlet base = 0 in\nList.fold_left f base xs"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int -> int\n", "Error: This expression has type int but an expression was expected of type\n         int -> int\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base =  [] in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base =  _ in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base =  f in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base =  a' in\nList.fold_left f base fs"], "message": ["Error: Unbound value a'\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base =  0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base =  fs in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base =  x a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base =  a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs"], "message": ["Error: Unbound value x\n", "Error: Unbound value a\n", "Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = _ in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (+) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = f g in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = fun x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = fun f in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = f base in\nList.fold_left f base fs"], "message": ["Error: Unbound value g\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value base\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet rec base = base in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = (base) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = (_) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = x a in\nList.fold_left f base fs"], "message": ["Error: Unbound value base\n", "Error: Syntax error: operator expected.\n", "Error: Unbound value x\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + x in\nlet base =  0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = fun q ->  x (a q)in\nlet base = fun x -> x in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = sepConcat(\"\" List.map(f l))"], "bad": ["let stringOfList f l = sepConcat(\"\" List.map(f l))"], "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = \nlet x = List.map f l  in\nsepConcat \";\" x"], "bad": ["let stringOfList f l = sepConcat\"\" List.map(f l)", "let stringOfList f l = sepConcat \"\" List.map(f l)", "let stringOfList f l = let x = List.map(f l) in\nsepConcat \";\" x"], "message": ["Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a list -> 'b list\n       but an expression was expected of type string list\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = \nlet x = List.map f l  in\nsepConcat \";\" x"], "bad": ["let stringOfList f l = sepConcat \";\" List.map f l"], "message": ["Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let rec clone x n = \nif n <= 0 then []\nelse n :: (clone x (n-1))"], "bad": ["let rec clone x n = \nif n <= 0 then []\nelse n :: clone x n-1", "let rec clone x n = \nif n <= 0 then []\nelse n :: (clone x n-1)"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nlet x1 = List.length(l1) in\nlet x2 = List.length(l2) in\nif x1 < x2 then l1 @ clone 0 (x2-x1)\nelse l2 @ clone 0 (x1-x2)"], "bad": ["let padZero l1 l2 = \nlet x1 = List.length(l1) in\nlet x2 = List.length(l2) in\nif x1 < x2 then x1 @ clone 0 (x2-x1)\nelse x2 @ clone 0 (x1-x2)"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a +. x**2.0 in\nlet base =  0.0 in\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = a + x**2 in\nlet base =  0 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = a + x**2.0 in\nlet base =  0 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = a +. x**2.0 in\nlet base =  0 in\nList.fold_left f base xs"], "message": ["Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + int_of_float(float_of_int(x)**2.0) in\nlet base =  0 in\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = a + x**2 in\nlet base =  0 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = a + (pow x 2) in\nlet base =  0 in\nList.fold_left f base xs"], "message": ["Error: This expression has type int but an expression was expected of type\n         float\n", "Error: Unbound value pow\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let _ = [(1,2); ]"], "bad": ["); ()]", "let _ = [(1,2); ()]", "let _ = [(1,2); (,)]"], "message": ["Error: Syntax error\n", "Error: This expression has type unit but an expression was expected of type\n         int * int\n", "Error: Syntax error: operator expected.\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"], "bad": ["let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];["], "message": ["Error: Syntax error\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (a1, a2) = a in\nlet h :: _ = a1 in\nlet tens = x1 + x2 + h / 10 in\nlet ones = x1 + x2 + h mod 10 in\n(tens :: a1, ones :: a2)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch x with\n| h :: t -> a\n(*\nlet (x1, x2) = h in\nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones) :: a *)\n| [] -> a\nin\nlet base = (0 , 0) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x\n(*\nmatch x with\n| h :: t -> a\n\nlet (x1, x2) = h in\nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones) :: a \n| [] -> a *)\nin\nlet base = (0 , 0) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones) :: a \nin\nlet base = (0 , 0) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones) :: a \nin\nlet base = (0 , 0) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones) :: a \nin\nlet base = [(0 , 0)] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones)\nin\nlet base = (0 , 0) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones) :: a\nin\nlet base = [(0 , 0)] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: Unbound value x1\n", "Error: This expression has type int * int\n       but an expression was expected of type (int * int) list\n", "Error: This expression has type (int * int) list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type (int * 'a) list -> int * int -> int * int\n       but an expression was expected of type\n         (int * 'a) list -> int * int -> (int * 'a) list\n       Type int * int is not compatible with type (int * 'a) list \n", "Error: This expression has type (int * int) list\n       but an expression was expected of type 'a * 'b\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nmatch carry with\n| h :: t -> \nlet tens = x1 + x2 + h / 10 in\nlet ones = x1 + x2 + h mod 10 in\n(tens :: carry, ones :: res)\n| [] ->\nlet tens = x1 + x2 / 10 in\nlet ones = x1 + x2 mod 10 in\n(tens :: carry, ones :: res)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nmatch carry with\n| h :: t -> \nlet tens = x1 + x2 + h / 10 in\nlet ones = x1 + x2 + h mod 10 in\n(tens :: carry, ones :: res)\n| [] ->\nlet tens = x1 + x2 / 10 in\nlet ones = x1 + x2 mod 10 in\n(carry :: a1, ones :: res)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nif carry <> [] then\nlet ch :: _ = carry in\nlet tens = (x1 + x2 + ch) / 10 in\nlet ones = (x1 + x2 + ch) mod 10 in\n([tens] , tens :: ones :: res)\nelse\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: res)\n\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nmatch x2 with\n| h :: t ->\nlet (carry, res) = a in\nlet tens = (x1 + x2 + h) / 10 in\nlet ones = (x1 + x2 + h) mod 10 in\n(tens :: carry, ones :: res)\n| [] ->\nlet (carry, res) = a in\nlet tens = (x1 + x2 + h) / 10 in\nlet ones = (x1 + x2 + h) mod 10 in\n(tens :: ones :: res)\n\nin\nlet base = ([0], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nmatch x with\n| h :: t ->\nlet (carry, res) = a in\nlet tens = (x1 + x2 + h) / 10 in\nlet ones = (x1 + x2 + h) mod 10 in\n(tens :: carry, ones :: res)\n| [] ->\nlet (carry, res) = a in\nlet tens = (x1 + x2 + h) / 10 in\nlet ones = (x1 + x2 + h) mod 10 in\n(tens :: ones :: res)\n\nin\nlet base = ([0], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| h :: t -> \nlet (x1, x2) = x in\nlet (carry, res) = a in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\nif t = [] then (0 ,tens :: ones :: res)\nelse (tens :: carry, ones :: res)\n| [] -> a\n\n\nin\nlet base = ([0], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nlet tens = x1 + x2 + carry / 10 in\nlet ones = x1 + x2 + carry mod 10 in\n(tens :: ones :: res)\nin\nlet base = ([0], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nlet tens = x1 + x2 + carry / 10 in\nlet ones = x1 + x2 + carry mod 10 in\n(tens ,tens :: ones :: res)\nin\nlet base = ([0], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nlet tens = x1 + x2 + carry / 10 in\nlet ones = x1 + x2 + carry mod 10 in\n(tens , tens :: ones :: res)\nin\nlet base = ([0], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nlet tens = x1 + x2 + carry / 10 in\nlet ones = x1 + x2 + carry mod 10 in\n(tens , tens :: ones :: res)\nin\nlet base = ([0], [0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nlet tens = x1 + x2 + carry / 10 in\nlet ones = x1 + x2 + carry mod 10 in\n([tens] , tens :: ones :: res)\nin\nlet base = ([0], [0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nif carry <> [] then\nlet tens = (x1 + x2 + carry) / 10 in\nlet ones = (x1 + x2 + carry) mod 10 in\n([tens] , tens :: ones :: res)\nelse\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: res)\n\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b * 'c\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type int * int list -> int * int -> int list\n       but an expression was expected of type\n         int * int list -> int * int -> int * int list\n       Type int list is not compatible with type int * int list \n", "Error: This expression has type int list * 'a list\n       but an expression was expected of type int * int list\n       Type int list is not compatible with type int \n", "Error: This expression has type int list * 'a list\n       but an expression was expected of type int * int list\n       Type int list is not compatible with type int \n", "Error: This expression has type int list * int list\n       but an expression was expected of type int * int list\n       Type int list is not compatible with type int \n", "Error: This expression has type\n         int * int list -> int * int -> int list * int list\n       but an expression was expected of type\n         int * int list -> int * int -> int * int list\n       Type int list is not compatible with type int \n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nif res <> [] then\nlet lastTens :: rest = res in\nif carry <> [] then\nlet ch :: _ = carry in\nlet tens = (x1 + x2 + ch) / 10 in\nlet ones = (x1 + x2 + ch) mod 10 in\n([tens] , tens :: ones :: rest)\nelse\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: rest)\n\nelse \nif carry <> [] then\nlet ch :: _ = carry in\nlet tens = (x1 + x2 + ch) / 10 in\nlet ones = (x1 + x2 + ch) mod 10 in\n([tens] , tens :: ones :: res)\nelse\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: res)\n\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nif res <> [] then\nlet lastTens :: rest = res in\nelse let rest = res in\nif carry <> [] then\nlet ch :: _ = carry in\nlet tens = (x1 + x2 + ch) / 10 in\nlet ones = (x1 + x2 + ch) mod 10 in\n([tens] , tens :: ones :: rest)\nelse\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: rest)\n\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = \nif i <> 0 then mulByDigit (i-1) (bigAdd l l)\nelse l"], "bad": ["let rec mulByDigit i l = \nif i <> 0 then mulByDigit (i-1) bigAdd l l\nelse l"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         (int list -> int list -> int list) ->\n         (int list -> int list -> int list) -> 'a\n       The type variable 'a occurs inside\n       (int list -> int list -> int list) ->\n       (int list -> int list -> int list) -> 'a\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nmatch res with\n| h :: t -> \n(match carry with\n| h1 :: t1 ->\nlet tens = (x1 + x2 + h1) / 10 in\nlet ones = (x1 + x2 + h1) mod 10 in\n([tens], tens :: ones :: t)\n| [] ->\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: t)\n)\n| [] -> \n(match carry with\n| h1 :: t1 ->\nlet tens = (x1 + x2 + h1) / 10 in\nlet ones = (x1 + x2 + h1) mod 10 in\n([tens], tens :: ones :: res)\n| [] ->\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: res)\n)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nmatch res with\n| h :: t -> \n(match carry with\n| h1 :: t1 ->\nlet tens = (x1 + x2 + h1) / 10 in\nlet ones = (x1 + x2 + h1) mod 10 in\n([tens], tens :: ones :: t)\n| [] ->\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: t)\n)\n| [] -> \n(match carry with\n| h1 :: t1 ->\nlet tens = (x1 + x2 + h1) / 10 in\nlet ones = (x1 + x2 + h1) mod 10 in\n([tens], tens :: ones :: res)\n| [] ->\nlet tens = (x1 + x2 + h1) / 10 in\nlet ones = (x1 + x2 + h1) mod 10 in\n([tens], tens :: ones :: res)\n)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Unbound value h1\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = helper [0] i l", "let _ = mulByDigit 9 [9;9;9;9]"], "bad": ["let rec mulByDigit i l = helper 0 i l"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "mulByDigit"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = \nlet h x = (f x, if f x = x then false else true) in\nwwhile (h ,b)"], "bad": ["let fixpoint (f,b) = \nlet h x = (f x, if f x = x then false else true)\nwwhile (h ,b)"], "message": ["Error: Syntax error\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin\" ^ exprToString a\n| Cosine a -> \"cos\" ^ exprToString a\n| Average (a,b) -> exprToString a ^ \"/\" ^ exprToString b\n| Times (a,b) -> exprToString a ^ \"*\" ^ exprToString b\n| Thresh (a,b,c,d) -> exprToString a ^ \"<\" ^ exprToString b ^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d"], "bad": ["let rec exprToString e = \nstring x = e", "let rec exprToString e = \nString x = e", "let rec exprToString e = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> \"sin\" ^ exprToString a\n| Cosine a -> \"cos\" ^ exprToString a\n| Average (a,b) -> exprToString a ^ \"/\" ^ exprToString b\n| Times (a,b) -> exprToString a ^ \"*\" ^ exprToString b\n| Thresh (a,b,c,d) -> exprToString a ^ \"<\" ^ exprToString b ^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d"], "message": ["Error: Unbound value string\nHint: Did you mean stdin?\n", "Error: Unbound constructor String\n", "Error: Unbound value x\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = \nmatch e with\n|VarX -> x\n|VarY -> y\n|Sine a -> sin (pi *. eval(a,x,y))\n|Cosine a -> cos (pi *. eval(a,x,y))\n|Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.\n|Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n|Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)"], "bad": ["let rec eval (e,x,y) = \nmatch e with\n|VarX -> x\n|VarY -> y\n|Sine a -> sin (pi *. eval(a,x,y))\n|Cosine a -> cos (pi *. eval(a,x,y))\n|Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2\n|Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n|Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)"], "message": ["Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nif depth = 0 then \nlet result = rand 0 1 in\nif result = 0 then \nbuildX() else\nbuildY()\nelse\nlet result = rand 0 6 in\nmatch result with\n|0 -> buildX()\n|1 -> buildY()\n|2 -> buildSine(build(rand,depth-1))\n|3 -> buildCosine(build(rand,depth-1))\n|4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n|_ -> buildX()"], "bad": ["let rec build (rand, depth) = \nif depth = 0 then \nlet result = rand 0 1 in\nif result = 0 then \nbuildX() else\nbuildY()\nelse\nlet result = rand 0 6 in\nmatch result with\n|0 -> buildX()\n|1 -> buildY()\n|2 -> buildSine(build(rand,depth-1))\n|3 -> buildCosine(build(rand,depth-1))\n|4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n|_ -> build()"], "message": ["Error: This expression has type unit but an expression was expected of type\n         (int -> int -> int) * int\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = \nmatch e with\n|VarX -> x\n|VarY -> y\n|Sine a -> sin (pi *. eval(a,x,y))\n|Cosine a -> cos (pi *. eval(a,x,y))\n|Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.\n|Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n|Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)\n|Inverse a -> let result  = eval(a,x,y) in\nif result = 0. then 0.\nelse\n1. /. result\n|Max (a,b) -> let aResult = eval(a,x,y) in\nlet bResult = eval(b,x,y) in\nif aResult > bResult then aResult\nelse bResult\n|Range (a,b,c) -> let aResult = eval(a,x,y) in\nlet bResult = eval(b,x,y) in\nlet cResult = eval(c,x,y) in\nif aResult < bResult then bResult else\nif aResult < cResult then cResult else\naResult"], "bad": ["let rec eval (e,x,y) = \nmatch e with\n|VarX -> x\n|VarY -> y\n|Sine a -> sin (pi *. eval(a,x,y))\n|Cosine a -> cos (pi *. eval(a,x,y))\n|Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.\n|Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n|Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)\n|Inverse a -> let result  = eval(a,x,y) in\nif result = 0. then 0.\nelse\n1 /. result\n|Max (a,b) -> let aResult = eval(a,x,y) in\nlet bResult = eval(b,x,y) in\nif aResult > bResult then aResult\nelse bResult\n|Range (a,b,c) -> let aResult = eval(a,x,y) in\nlet bResult = eval(b,x,y) in\nlet cResult = eval(c,x,y) in\nif aResult < bResult then bResult else\nif aResult < cResult then cResult else\naResult"], "message": ["Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = doRandomGray (12,12,12)"], "bad": ["let _ = doRandomGray 12"], "message": ["Error: This expression has type int but an expression was expected of type\n         int * int * int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         int * int * int\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let _ = doRandomGray (8,10,10)", "let _ = doRandomGray (10,132,14123)", "let _ = doRandomColor (12,123412,90)", "let _ = doRandomColor (20,21,22)", "let _ = doRandomColor (11,1234,4312)"], "bad": ["let _ = doRandomGray 8,10,10", "let _ = doRandomGray 10,132,14123", "let _ = doRandomColor 12,123412,90", "let _ = doRandomColor 20,21,22", "let _ = doRandomColor 11,1234,4312"], "message": ["Error: This expression has type int but an expression was expected of type\n         int * int * int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         int * int * int\n", "Error: This expression has type int but an expression was expected of type\n         int * int * int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         int * int * int\n", "Error: This expression has type int but an expression was expected of type\n         int * int * int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         int * int * int\n", "Error: This expression has type int but an expression was expected of type\n         int * int * int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         int * int * int\n", "Error: This expression has type int but an expression was expected of type\n         int * int * int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         int * int * int\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nlet num1 = List.length l2 - List.length l1 in\nlet num2 = List.length l1 - List.length l2 in\n(clone 0 num1 @l1,clone 0 num2 @ l2)"], "bad": ["let padZero l1 l2 = \nlet num1 = List.length l2 - List.length l1 in\nlet num2 = List.length l1 - list.length l2 in\n(clone 0 num1 @l1,clone 0 num2 @ l2)"], "message": ["Error: Unbound value list\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n|(z,y) -> let sum = z + y in\nif sum > 10 then let result = ((sum mod 10)::a) in\n1::result else\nsum::a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n|(z,y) -> let sum = z + y in\nif sum > 10 then let result = a @ sum mod 10 in\nresult @ 1 else\na @ result in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n|(z,y) -> let sum = z + y in\nif sum > 10 then let result = a @ (sum mod 10) in\nresult @ 1 else\na @ result in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n|(z,y) -> let sum = z + y in\nif sum > 10 then let result = (a @ (sum mod 10)) in\nresult @ 1 else\na @ result in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n|(z,y) -> let sum = z + y in\nif sum > 10 then let result = ((sum mod 10)::a) in\n1::result else\nsum::a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|[] -> let sum = z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\n(intlist sum) @ t) in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then x \nelse (intlist (x / 10))::[x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|h -> let sum = h + z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\n(intlist sum)::t) in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10))::[x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|h -> let sum = h + z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\n(intlist sum)::t) in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|h -> let sum = h + z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\n(intlist sum) @ t) in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10]", ")\n\nintlist 10", "intlist 22", "intlist 5", "intlist 12345"], "bad": ["let rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] \n\nintlist 10", "intlist 22", "intlist 5", "intlist 12345", "let rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] \n\nintlist 10", "intlist 22", "intlist 5", "intlist 12345"], "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: Unbound value intlist\n", "Error: Unbound value intlist\n", "Error: Unbound value intlist\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: Unbound value intlist\n", "Error: Unbound value intlist\n", "Error: Unbound value intlist\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let f a x = \nlet rec intlist l =\nif l < 10 then [l] \nelse (intlist (l / 10)) @ [l mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|[] -> let sum = z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\n(intlist sum) @ t)", "let _ = f [] (9;2)"], "bad": ["let _ = f [] (9;2)"], "message": ["Error: This expression has type int but an expression was expected of type\n         int * int\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let _ = f [0] (9,2)"], "bad": ["let _ = f [] (9;2)", "let _ = f ([] (9;2))", "let _ = f [0] (9;2)", "let _ = f [0] (9;2)"], "message": ["Error: This expression has type int but an expression was expected of type\n         int * int\n", "Error: The constructor [] expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: This expression has type int but an expression was expected of type\n         int * int\n", "Error: This expression has type int but an expression was expected of type\n         int * int\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|[] -> let sum = z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\nresult = (intlist sum) @ t in\nif sum < 10 then 0::result else result", ") in \n\nlet base = [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|[] -> let sum = z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\nresult = (intlist sum) @ t) in\nif sum < 10 then 0::result else result in \n\nlet base = [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Unbound value result\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l =\nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> let zeroList = (match t with \n|[] -> []\n|h'::t' -> let (_,zeroList') = padZero(t',[]) in zeroList') in\nlet mult = intlist h*i in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit t)", "let _ = mulByDigit 9 [9;9;9;9]"], "bad": ["let rec mulByDigit i l =\nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> (match t with \n|[] -> let zeroList = []\n|h'::t' -> let (_,zeroList) = padZero(t',[])) in\nlet mult = intlist h*i in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit t)"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l =\nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> let zeroList = (match t with \n|[] -> []\n|h'::t' -> (match padZero(t' [0]) with \n|(a,b) -> b)) in\nlet mult = intlist h*i in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit t)", "let _ = mulByDigit 9 [9;9;9;9]"], "bad": ["let rec mulByDigit i l =\nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> let zeroList = (match t with \n|[] -> []\n|h'::t' -> (match padZero((t',[0])) with \n|(a,b) -> b)) in\nlet mult = intlist h*i in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit t)"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"], "problem": "mulByDigit"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nmatch n > 0 with\n| true  -> digOfIntHelper n::[n mod 10] \n| false -> []"], "bad": ["let rec digitsOfInt n = \nmatch n > 0 with\n| true  -> digOfIntHelper::[n mod 10] \n| false -> []", "let rec digitsOfInt n = \nmatch n > 0 with\n| true  -> digOfIntHelper::[n % 10] \n| false -> []"], "message": ["Error: This expression has type int but an expression was expected of type\n         int -> int\n", "Error: Unbound value %\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]", "let rec digOfIntHelper h = \nmatch h > 0 with\n| true  -> 1\n| false -> 0", "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt n\n| true  -> digitsOfInt n mod 10"], "bad": ["let rec digitsOfInt n = \nmatch n with\n| 0    -> []\n| [0]   -> []\n| 1     -> []\n| true  -> digOfIntHelper n::[]::[n mod 10] \n| false -> []", "let rec digitsOfInt n = \nmatch n > 0 with\n| true  -> digOfIntHelper n::[]::[n mod 10] \n| false -> []", "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt n\n| true  -> digitsOfInt n mod 10"], "message": ["Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: []\n| true  -> (n / 10) :: digitsOfInt (n mod 10)"], "bad": ["let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: []\n| true  -> digitsOfInt (n / 10) :: digitsOfInt (n mod 10)"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: []\n| true  -> n / 10 :: digitsOfInt (n / 10)"], "bad": ["let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: []\n| true  -> digitsOfInt (n / 10) ::  (n mod 10)"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> 1 :: 1", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663"], "bad": ["let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> 1"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 )"], "bad": ["let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> 1 :: 2"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec reverse l = \nmatch l with\n| h::t  -> reverse t\n| [a,b] -> [b,a]"], "bad": ["let rec reverse l = \nmatch l with\n| h::t -> reverse t :: [h]"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec reverse l = \nmatch l with\n| h::t  -> reverse t\n| [a,b] -> [b,a]\n| [a]   -> [a]\n| []    -> []"], "bad": ["let rec reverse l = \nmatch l with\n| h::t  -> reverse t\n| [a,b] -> [b,a]\n| _     -> _"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec reverse l = \nmatch l with\n| h::t  -> reverse t\n| [a]   -> [a] \n| []    -> []"], "bad": ["let rec reverse l = \nmatch l with\n| h::t  -> reverse t\n| [a]   -> [a] :: reverse t\n| []    -> []"], "message": ["Error: Unbound value t\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> reverseHelper t h::revd \nin\nreverseHelper [] l", ";;"], "bad": ["let rec listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> reverseHelper t h::revd \nin\nreverseHelper [] l"], "message": ["Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]", "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::revd )\nin\nlistReverse [] l"], "bad": ["let listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> reverseHelper t h::revd \nin\nreverseHelper [] l", "let listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> reverseHelper t (h::revd )\nin\nreverseHelper [] l", "let listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nreverseHelper [] l", "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nreverseHelper [] l", "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nlistReverse[] l", "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nlistReverse [] l", "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nlistReverse l []", "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nlistReverse [] l", "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nreverseHelper []", "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nreverseHelper l", "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::revd )\nin\nin\n\nlistReverse l []", "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::revd )\nin\nlistReverse l []", "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::revd )\nin\nlistReverse [] l"], "message": ["Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "Error: Syntax error\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []"], "bad": ["let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::revd )\nin\nreverseHelper [] l", "let rec listReverse l =\nlet rec reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r )\nin\nlistReverse l []", "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r )\nin\nlistReverse l []", "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r )", "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r )", "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r ) \nin\nlistReverse l []", "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r ) \nin\nlistReverse [] []", "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nlistReverse [] []", "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper l []", "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nr", "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\n\n\nlet _ = listReverse [1; 2; 3; 4]"], "message": ["Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a list -> 'a list\n", "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a list -> 'a list\n", "Error: Unbound value r\n", "Error: Syntax error\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec listReverse l =\nlet rec reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> reverseHelper t ( h::r ) \nin\nreverseHelper []"], "bad": ["let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> reverseHelper t ( h::r ) \nin\nreverseHelper []"], "message": ["Error: Unbound value reverseHelper\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec digOfInt = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 )", "let rec digitsOfInt n = listReverse (digOfInt n)", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663"], "bad": ["let rec digitsOfInt n = \nlet digOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) \nin\nlistReverse n", "let rec digitsOfInt n = \nlet digOfInt n r = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) \nin\nlistReverse n r", "let rec digitsOfInt n = \nlet digOfInt n r = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) \nin\nlistReverse n r", "let rec digitsOfInt n = \nlet digOfInt n r = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) \nin\nlistReverse n", "let rec digitsOfInt n = \nlet digOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) \nin\nlistReverse n"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]", "let digitsOfInt n =  \nlet rec digOfIntHelper n l = \nif (n > 0)\nthen (\nif (n > 9)\nthen (\ndigOfIntHelper (n / 10) ((n mod 10)::l) )\nelse (\nn :: l )\nelse ( \n[] )\nin\ndigOfIntHelper n []", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663"], "bad": ["let digitsOfInt n =  \nlet rec digOfIntHelper n l = \nif n > 0 \nthen (\nmatch n > 9 with\n| false -> n :: l\n| true  -> digOfIntHelper (n / 10) ((n mod 10)::l))\nelse ( \n[] )\nin\ndigOfIntHelper n []"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec palindrome w = \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalindrome t )\nelse (\nfalse ) )", "let _ = palindrome \"malayalam\"", "let _ = palindrome \"myxomatosis\""], "bad": ["let palindrome w = \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalindrome t )\nelse (\nfalse ) )", "let rec palindrome w = \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalindrome t )\nelse (\nfalse ) )"], "message": ["Error: Unbound value h1\n", "Error: Unbound value palindrome\n"], "problem": "palindrome"}
{"hw": "hw1", "fix": ["let rec palind w = \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalind t )\nelse (\nfalse ) )", "let palindrome w = palind (explode w)"], "bad": ["let palindrome w = palind (explode w)", "let rec palind w = \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalind t )\nelse (\nfalse ) )"], "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n", "Error: Unbound value palind\n"], "problem": "palindrome"}
{"hw": "hw1", "fix": ["let listReverse l = lReverse (l, [])", "let rec lReverse (l, rl) = \nmatch l with\n| []    -> rl\n| h::t  -> lReverse (t, h::rl)", "let _ = listReverse [1; 2; 3; 4]", "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]"], "bad": ["let listReverse l =\nlet rec reverseHelper l rl = \nmatch l with\n| []    -> rl\n| h::t  -> reverseHelper t ( h::rl ) \nin\nreverseHelper l []"], "message": ["Error: Unbound value reverseHelper\n"], "problem": "listReverse"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n| []        -> d\n| (n,v)::t  -> if k = n \nthen v\nelse assoc (d,k,t)"], "bad": ["let rec assoc (d,k,l) = match (d,k,l with\n| []        -> d\n| (n,v)::t  -> if k = n \nthen v\nelse assoc (d,k,t)"], "message": ["Characters 30-31:\n  let rec assoc (d,k,l) = match (d,k,l with\n                                ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let fixpoint (f,b) = let (b', c) =  (f(b), f(b)<>b)\nin\nwwhile ((b', c) ,b)", "let fixpoint (f,b) = wwhile (f ,b)"], "message": ["Error: Unbound value fixpoint\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let fixpoint (f,b) = wwhile ( (b, b<>f(b)) ,b)", "let fixpoint (f,b) = let b' = f(b) \nin\n(b', f(b)<>b)\nin\nwwhile ( f ,b)", "let fixpoint (f,b) = let b' = f(b) \nin\n(b', f(b)<>b)\nin\nwwhile ( f ,b)", "let fixpoint (f,b) = let b' = f(b) \nin\n(b', f(b)<>b)\nin\nwwhile ( f ,b)", "let fixpoint (f,b) = let f b = let b' = f(b) \nin\n(b', f(b)<>b)\nin\nwwhile (f ,b)"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: Unbound value f\n", "Error: Unbound value f\n", "Error: Unbound value f\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "let _ = exprToString sampleExpr1"], "bad": ["let rec exprToString e = \nVarX\t\t      -> \"x\"\n| VarY\t\t\t-> \"y\"\n| Sine(x)\t\t-> \"sin(pi*\" ^ (exprToString x) ^ \")\"\n| Cosine(x)\t\t-> \"cos(pi*\" ^ (exprToString x) ^ \")\"\n| Average(x1,x2)\t-> \"((\" ^ (exprToString x1) ^ \"+\" ^ (exprToString x2) ^ \")/2)\"\n| Times(x1,x2)\t\t-> (exprToString x1) ^ \"*\" ^ (exprToString x2)\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4)", "let rec exprToString e = \nVarX _ \t\t      -> \"x\"\n| VarY _\t\t-> \"y\"\n| Sine(x)\t\t-> \"sin(pi*\" ^ (exprToString x) ^ \")\"\n| Cosine(x)\t\t-> \"cos(pi*\" ^ (exprToString x) ^ \")\"\n| Average(x1,x2)\t-> \"((\" ^ (exprToString x1) ^ \"+\" ^ (exprToString x2) ^ \")/2)\"\n| Times(x1,x2)\t\t-> (exprToString x1) ^ \"*\" ^ (exprToString x2)\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4)", "let rec exprToString e = match e with\nVarX   \t\t      -> \"x\"\n| VarY  \t\t-> \"y\"\n| Sine(x)\t\t-> \"sin(pi*\" ^ (exprToString x) ^ \")\"\n| Cosine(x)\t\t-> \"cos(pi*\" ^ (exprToString x) ^ \")\"\n| Average(x1,x2)\t-> \"((\" ^ (exprToString x1) ^ \"+\" ^ (exprToString x2) ^ \")/2)\"\n| Times(x1,x2)\t\t-> (exprToString x1) ^ \"*\" ^ (exprToString x2)\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4)"], "message": ["Error: Unbound value exprToString\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.", ") \n"], "bad": ["let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x)\t\t-> sin (eval (pi *. x) )\n| Cosine(x)\t\t-> cos (pi *. (eval x) )\n| Average(x1,x2)\t-> ( (eval x1) +. (eval x2) ) /. 2.", ") \n", "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y ) ) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y ) ) )\n| Average(x1,x2)\t-> ( (eval x1) +. (eval x2) ) /. 2.", ") \n"], "message": ["Error: Syntax error\n", "Error: This expression has type expr but an expression was expected of type\n         float\n", "Error: Syntax error\n", "Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr,0.5,0.2)"], "bad": ["| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4) ^ \")\"", "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4) ^ \")\"", "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> (eval (x1,x,y )) < (eval (x2,x,y )) \n? (eval (x3,x,y )) : (eval (x4,x,y ))", "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> (eval (x1,x,y )) < (eval (x2,x,y )) ? (eval (x3,x,y )) : (eval (x4,x,y ))", "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> ((eval (x1,x,y )) < (eval (x2,x,y )) \n? (eval (x3,x,y )) : (eval (x4,x,y )))", "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> (eval (x1,x,y )) <. (eval (x2,x,y )) \n? (eval (x3,x,y )) : (eval (x4,x,y ))", "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> (eval (x1,x,y )) < (eval (x2,x,y )) \n? eval (x3,x,y ) : (eval (x4,x,y ))", "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> (eval (x1,x,y )) < (eval (x2,x,y )) \n? eval (x3,x,y ) : eval (x4,x,y )", "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> (eval (x1,x,y )) < (eval (x2,x,y )) \n? eval (x3,x,y ) : eval (x4,x,y )", "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> if (eval (x1,x,y )) < (eval (x2,x,y )) \nthen eval (x3,x,y ) \nelse eval (x4,x,y )"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type string but an expression was expected of type\n         float\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = match depth with\n| 0   -> ( match (rand 1 3 ) with\n| 1 -> buildX()\n| 2 -> buildY() \n)\n| _   -> ( match (rand 1 5 ) with\n| 1 -> buildSine(build(rand,depth-1))\n| 2 -> buildCosine(build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),\nbuild(rand,depth-1),build(rand,depth-1))\n)"], "bad": ["let rec build (rand, depth) = match depth with\n| 0   -> ( match (rand 1 3 ) with\n| 1 -> buildX()\n| 2 -> buildY() \n)\n| _   -> ( match (rand 1 4 ) with\n| 1 -> buildThresh(build(rand,depth-1),build(rand,depth-1),\nbuild(rand,depth-1),build(rand,depth-1))\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCos(build(rand,depth-1))\n| 4 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n)", "let rec build (rand, depth) = match depth with\n| 0   -> ( match (rand 1 3 ) with\n| 1 -> buildX()\n| 2 -> buildY() \n)\n| _   -> ( match (rand 1 4 ) with\n| 1 -> buildThresh(build(rand,depth-1),build(rand,depth-1),\nbuild(rand,depth-1),build(rand,depth-1))\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n)"], "message": ["Error: Unbound value buildSin\nHint: Did you mean buildSine?\nError: Unbound value buildSin\nHint: Did you mean build, buildY or buildX?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value buildSin\nHint: Did you mean buildSine?\n", "Error: Unbound value buildCos\nHint: Did you mean build, buildCosine, buildY or buildX?\nError: Unbound value buildCos\nHint: Did you mean build, buildX or buildY?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value buildCos\nHint: Did you mean build, buildCosine, buildY or buildX?\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = match depth with\n| 0   -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY() \n)\n| _   -> ( match (rand (1,5) ) with\n| 1 -> buildSine(build (rand,depth-1) )\n| 2 -> buildCosine(build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),\nbuild(rand,depth-1),build(rand,depth-1))\n)"], "bad": ["let rec build (rand, depth) = match depth with\n| 0   -> ( match (rand 1 3 ) with\n| 1 -> buildX()\n| _ -> buildY() \n)\n| _   -> ( match (rand 1 5 ) with\n| 1 -> buildSine(build (rand,depth-1) )\n| 2 -> buildCosine(build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),\nbuild(rand,depth-1),build(rand,depth-1))\n)"], "message": ["Error: Syntax error\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let c2 = (11,3131,73)", "let c3 = (12,31331,73373)"], "bad": ["let c3 = (12,31331,73373) \n\n\ndoRandomColor (g1())", "let c2 = (11,3131,73) \n\n\n\ndoRandomColor (g1())"], "message": ["Error: This expression has type int * int * int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int * int * int\n       This is not a function; it cannot be applied.\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let _ () = doRandomColor (c1 )"], "bad": ["let _ = doRandomColor (c1 ())", "let _ = doRandomColor (c1 )"], "message": ["Error: This expression has type int * int * int\n       This is not a function; it cannot be applied.\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int * int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int * int * int\n       This is not a function; it cannot be applied.\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int * int\n       This is not a function; it cannot be applied.\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let _ = doRandomColor (c2 )"], "bad": ["let _ = doRandomColor (c1 )"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with\nVarX   \t\t      -> \"x\"\n| VarY  \t\t-> \"y\"\n| Sine(x)\t\t-> \"sin(pi*\" ^ (exprToString x) ^ \")\"\n| Cosine(x)\t\t-> \"cos(pi*\" ^ (exprToString x) ^ \")\"\n| Average(x1,x2)\t-> \"((\" ^ (exprToString x1) ^ \"+\" ^ (exprToString x2) ^ \")/2)\"\n| Times(x1,x2)\t\t-> (exprToString x1) ^ \"*\" ^ (exprToString x2)\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4) ^ \")\"\n| CosE(x1,x2,x3)\t-> \"cos(pi*\" ^ (exprToString x1) ^ \"*\" ^ (exprToString x2) ^ \")e^(-pi*\" \n^ (exprToString x3) ^ \"^2)\""], "bad": ["let rec exprToString e = match e with\nVarX   \t\t      -> \"x\"\n| VarY  \t\t-> \"y\"\n| Sine(x)\t\t-> \"sin(pi*\" ^ (exprToString x) ^ \")\"\n| Cosine(x)\t\t-> \"cos(pi*\" ^ (exprToString x) ^ \")\"\n| Average(x1,x2)\t-> \"((\" ^ (exprToString x1) ^ \"+\" ^ (exprToString x2) ^ \")/2)\"\n| Times(x1,x2)\t\t-> (exprToString x1) ^ \"*\" ^ (exprToString x2)\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4) ^ \")\"\n| CosE(x1,x2,x3)\t-> \"cos(pi*\" ^ (exprToString x1) ^ \"*\" ^ (exprToString x1) ^ \")e^(-pi*\" \n^ (exprToString x1) ^ \"^2)\""], "message": ["Error: This expression has type expr but an expression was expected of type\n         float\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = match depth with\n| 0 -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY()\n)\n| _ -> ( match (rand (5,8) ) with\n| 1 -> buildSine( build (rand, depth-1) )\n| 2 -> buildCosine(  build (rand, depth-1) )\n| 3 -> buildTimes( build (rand, depth-1), build (rand, depth-1) )\n| 4 -> buildAverage(  build (rand, depth-1), build (rand, depth-1) )\n| 5 -> buildSine( build (rand, depth-1) )\n| 6 -> buildCosine(  build (rand, depth-1) )\n| 7 -> buildCosE(build (rand, depth-1), build (rand, depth-1), build (rand, depth-1) )\n)", "let g1 = (12,1441,5311)", "let g2 = (12,1627,3507)", "let g3 = (12,1219,5301)", "let c1 = (12,33,3703)", "let c2 = (12,31,7113)", "let c3 = (12,3351,7373)", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "let _ = doRandomColor (c1 )", "let _ = doRandomColor (c2 )", "let _ = doRandomColor (c3 )", "let _ = doRandomGray (g1 )", "let _ = doRandomGray (g2 )", "let _ = doRandomGray (g3 )"], "bad": ["let rec build (rand, depth) = match depth with\n| 0 -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY()\n)\n| _ -> ( match (rand (5,8) ) with\n| 1 -> buildSine( build (rand, depth-1) )\n| 2 -> buildCosine(  build (rand, depth-1) )\n| 3 -> buildTimes( build (rand, depth-1), build (rand, depth-1) )\n| 4 -> buildAverage(  build (rand, depth-1), build (rand, depth-1) )\n| 5 -> buildSine( build (rand, depth-1) )\n| 6 -> buildCosine(  build (rand, depth-1) )\n| 7 -> buildCosE(build (rand, depth-1), build (rand, depth-1), build (rand, depth-1) )\n)"], "message": ["Error: Unbound value doRandomGray\n"], "problem": "build"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]"], "bad": ["let sqsum xs = \nlet f a x = a * a + in\nlet base = 0 in\nList.fold_left f base xs"], "message": ["Error: Syntax error\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs"], "message": ["Error: Unbound value a\n", "Error: Unbound value x\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = base in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = + in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base = _ in\nList.fold_left f base fs"], "message": ["Error: Unbound value base\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3"], "message": ["Error: This function has type (unit -> unit) list -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (+) in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let pipe fs = \nlet f a x = x a in\nlet base = (_) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base =  in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> ('a -> 'b) -> 'b\n       but an expression was expected of type int\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x (a) in\nlet base = () in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let pipe fs = \nlet f a x = a x in\nlet base = a in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base = x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base = f in\nList.fold_left f base fs"], "message": ["Error: This expression has type int -> int -> int\n       but an expression was expected of type int\n", "Error: Unbound value a\n", "Error: Unbound value x\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x (a) in\nlet base = f in\nList.fold_left f base fs", "let _ = pipe [] 3"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This function has type (unit -> unit) list -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type (unit -> unit) list -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x (a) in\nlet base = (+) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x (a) in\nlet base = + in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x (a ) in\nlet base = fun x->x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x (a) in\nlet base = 0(+) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x (a) in\nlet base = 0(+) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = x (a p) in\nlet base = p in\nList.fold_left f base fs", "let pipe fs p = \nlet f a x = x (a p) in\nlet base = p in\nList.fold_left f base fs"], "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: Unbound value p\n", "Error: This expression has type 'a but an expression was expected of type\n         'a -> 'b\n       The type variable 'a occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun p -> x (a p) in\nlet base = fun x->x in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sepConcat sep t  in\nlet base = h in\nlet l =  t in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep  in\nlet base = h in\nlet l =  sepConcat sep t in\nList.fold_left f base l"], "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l) ) ^ \"]\""], "bad": ["let stringOfList f l = \"[\" ^ sepConcat \"; \" List.map f l ^ \"]\"", "let stringOfList f l = \"[\" ^ (sepConcat \"; \" List.map f l) ^ \"]\""], "message": ["Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let rec clone x n = \nmatch n with \n| 0 -> []\n| _ -> x :: (clone x (n-1) )"], "bad": ["let rec clone x n = \nlet helper = \nmatch n with\n| 0 -> []\n| _ -> x :: clone x n-1", "let rec clone x n = \nlet helper = \nmatch n with\n| 0 -> []\n| _ -> x :: clone x n-1\nin \nhelper n", "let rec clone x n = \nlet helper = \nmatch n with\n| 0 -> []\n| _ -> x :: clone x (n-1)\nin \nhelper n", "let rec clone x n = \nlet helper = \nmatch n with\n| 0 -> []\n| _ -> x :: helper n-1\nin \nhelper n", "let rec clone x n = \nlet rec helper = \nmatch n with\n| 0 -> []\n| _ -> x :: helper n-1\nin \nhelper n", "let rec clone x n = \nlet rec helper = \nmatch n with\n| 0 -> []\n| _ -> x :: (helper n-1)\nin \nhelper n", "let rec clone x n = \nlet rec helper = \nmatch n with\n| 0 -> []\n| _ -> helper n-1\nin \nhelper n", "let rec clone x n = \nlet rec helper n = \nmatch n with\n| 0 -> []\n| _ -> helper n-1\nin \nhelper n", "let rec clone x n = \nmatch n with \n| 0 -> []\n| _ -> x :: (clone x n-1)"], "message": ["Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: Unbound value helper\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "clone"}
{"hw": "hw1", "fix": ["type test = unit -> string", "let key        = \"\"", "let prefix130  = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")", "let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max"], "bad": ["type test = unit -> strin"], "message": ["Error: Unbound type constructor strin\nHint: Did you mean string?\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec sumList xs = match xs with\n[] -> 0 \n| h::t -> h + sumList t"], "bad": ["let rec sumList xs = match sumList with\n| h::t -> h + sumList t", "let rec sumList xs = match sumList with\n[] -> 0 \n| h::t -> h + sumList t", "let rec sumList xs = match sumList with\n[] -> 0 \n| h::t -> h + sumList t"], "message": ["Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt (-2)"], "bad": ["let _ = digitsOfInt -2"], "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []"], "bad": ["let rec digitsOfInt n = \nif n < 0 then []", "let rec digitsOfInt n = \nif n < 0 -> []", "let rec digitsOfInt n = \nif n < 0 then -> []", "let rec digitsOfInt n = \nwhen n < 0 -> []", "let rec digitsOfInt n =\nif n < 0 then []"], "message": ["Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digits (-31243)"], "bad": ["let _ = digits -31243"], "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let additivePersistence n = \ndigits n"], "bad": ["let additivePersistence n = \nlet digits n = x in\nsumList x", "let additivePersistence n = \ndigits n\nsumList n"], "message": ["Error: Unbound value x\n", "Error: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let additivePersistence n = \nsumList (digits n)"], "bad": ["let additivePersistence n = \ndigits n = n"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec digitalRoot n = \nif sumList (digits n) > 9\nthen digitalRoot (sumList (digits n))\nelse sumList (digits n)"], "bad": ["let digitalRoot n = \nlet x = sumList (digits n) in\nif x > 9\nthen digitalRoot x\nelse sumList x", "let rec digitalRoot n = \nlet x = sumList (digits n) in\nif x > 9\nthen digitalRoot x\nelse sumList x"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "digitalRoot"}
{"hw": "hw1", "fix": ["let listReverse l = \nlet rec aux acc = function\n| [] -> acc\n| h::t -> aux (h::acc) t in\naux [] l"], "bad": ["let listReverse l = \nlet rec aux acc = function\n| [] -> acc\n| h::t -> aux (h::acc) t in\naux [] list"], "message": ["Error: Unbound value list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let additivePersistence n = \nlet rec helper n count =\nlet rec digitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin digitalRoot n\nin helper n 0"], "bad": ["let additivePersistence n = \nlet rec helper n count = function\ndigitalRoot n", "let additivePersistence n = \nlet rec helper n count = \ndigitalRoot n", "let additivePersistence n = \nlet rec helper n count = \nlet rec digitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse sumList (digits n)", "let additivePersistence n = \nlet rec helper n count = \nlet rec digitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse sumList (digits n)\nin helper n 0", "let additivePersistence n = \nlet rec helper n count = \nlet rec digitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse sumList (digits n)\nin helper n 0", "let additivePersistence n = \nlet rec helper n count = \nlet rec digitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse sumList (digits n)\nin helper n 0", "let additivePersistence n = \nlet rec helper n count = \nlet rec digitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin helper n 0", "let additivePersistence n = \nlet rec helper n count = \ndigitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin helper n 0", "let additivePersistence n = \nlet rec helper n count = function\ndigitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin helper n 0"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type bool but an expression was expected of type\n         int\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type bool but an expression was expected of type\n         int\n", "Error: Syntax error\n"], "problem": "digitalRoot"}
{"hw": "hw1", "fix": ["let listReverse l = \nlet rec helper xs = function\n| [] -> []\n| hd::tl -> helper (hd::xs) tl\nin helper [] l"], "bad": ["let listReverse l = \nlet rec helper xs = match xs with\n| [] -> []\n| hd::tl -> helper (hd::xs) tl\nin helper [] l"], "message": ["Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let listReverse l = \nlet rec helper xs = function\n| [] -> xs\n| hd::tl -> helper (hd::xs) tl\nin helper [] l"], "bad": ["let listReverse l = \nlet rec helper xs = function\n| [] -> xs\n| hd::tl -> helper (hd::xs) \nin helper [] l"], "message": ["Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let listReverse l = \nlet rec helper xs l  = match l with\n| [] -> []\n| hd::tl -> helper (hd::xs) l\nin helper [] l"], "bad": ["let listReverse l = \nlet rec helper xs n  = function\n| [] -> xs\n| hd::tl -> helper (hd::xs) tl\nin helper [] l", "let listReverse l = \nlet rec helper xs l  = match n with\n| [] -> []\n| hd::tl -> helper (hd::xs) l\nin helper [] l"], "message": ["Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'a list\n", "Error: Unbound value n\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec reverse res list = match list with\n| [] -> []\n| hd::tl -> reverse (hd::res) list", "let listReverse l = reverse [] list"], "bad": ["let rec reverse res list = match list with\n| [] -> []\n| hd:tl -> reverse (hd::res) list", "let listReverse l = reverse [] list"], "message": ["Error: This expression has type 'a list -> 'b list\n       but an expression was expected of type 'b list\n", "Error: Syntax error\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec helper xs list  = match list with\n| [] -> []\n| hd::tl -> helper (hd::xs) \nin helper [] l", "let _ = listReverse [1; 2; 3; 4]"], "bad": ["let listReverse l = reverse [] l"], "message": ["Error: Unbound value list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec mylength xs = match xs with\n| [] -> 0\n| hd::tl -> 1 + mylength tl", "let digitsOfInt n =\nlet rec digits n x list =\nif n < 10 then n :: list\nelse digits (n/10 + n mod 10) (mylength n/10 + n mod 10) list\nin digits n (mylength n) []"], "bad": ["let digitsOfInt n =\nlet rec digits n x list =\nif n < 10 then n :: list\nelse digits (n/10 + n mod 10) (mylength n/10 + n mod 10) list\nin digits n (mylength n) []"], "message": ["Characters 37-38:\n  let rec digits n (mylength n) list =\n                   ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let num_of_digits xs =\nlet y = log10 (float_of_int xs)\nin y + 1"], "bad": ["let num_of_digits xs =\n(log 10 (xs)) + 1", "let num_of_digits xs =\nlog10 xs + 1", "let num_of_digits xs =\nlog10 float_of_int xs + 1", "let num_of_digits xs =\nlog10 (float_of_int xs) + 1", "let num_of_digits xs =\nlog10 (int_of_float xs) + 1", "let num_of_digits xs =\nlog10 (int_of_float xs)", "let num_of_digits xs =\nlog10 (float_of_int xs)"], "message": ["Error: This function has type float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This function has type float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "???"}
{"hw": "hw1", "fix": ["num_of_digits 10"], "bad": ["let num_of_digits xs =\nlet y = log10 (float_of_int xs)\nin (int_of_float y) + 1"], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 3124"], "bad": ["let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/(10** numdig -1) mod 10 :: l\nelse numdig :: 1\nin digits n []", "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/(int_of_float 10 ** numdig -1) mod 10 :: l\nelse numdig :: 1\nin digits n []", "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/(float_of_int 10 ** numdig -1) mod 10 :: l\nelse numdig :: 1\nin digits n []", "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: l\nelse numdig :: 1\nin digits n []", "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: l\nelse numdig :: 1\nin digits n []", "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: l\nelse numdig :: l\nin digits n []"], "message": ["Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 3124"], "bad": ["let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: \n(digits (x/10) l)\nelse numdig :: l\nin digits n []"], "message": ["Error: This expression has type 'a -> int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 3124"], "bad": ["let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt n/10) :: [n/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10]", "let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) :: [n/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10]", "let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) @ [n/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10]", "let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) @ [n/int_of_float(float_of_int 10 ** float_of_int (num_of_digits x -1)) mod 10]", "let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) @ [n/int_of_float(float_of_int 10 ** float_of_int (num_of_digits n -1)) mod 10]"], "message": ["Error: Syntax error\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: Unbound value numdig\n", "Error: Unbound value x\nError: Unbound value num_of_digits\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value x\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 122"], "bad": ["let digitsOfInt n =\nif n < 10 then n :: []\nelse (digitsOfInt (n/10))\nmatch n with\n| hd::tl -> hd\n:: [n mod 10]", "let digitsOfInt n =\nif n < 10 then n :: []\nelse match n with\n| hd::tl -> hd\n(digitsOfInt (n/10)) :: [n mod 10]", "let digitsOfInt n =\nif n < 10 then n :: []\nelse match n with\n| (digitsOfInt (n/10)) :: [n mod 10]", "let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) :: [n mod 10]", "let digitsOfInt n =\nlet rec recurse x l =\nif x < 10 then x :: l\nelse\nrecurse (x/10) [n mod 10]\nin recurse n []"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value num_of_digits\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       but an expression was expected of type int\n", "Error: Syntax error\n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\nError: Unbound value num_of_digits\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n", "Characters 63-64:\n  | (digitsOfInt (n/10)) :: [n mod 10];;\n    ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value num_of_digits\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4]"], "bad": ["let listReverse l = \nlet rec recurse x xs = match x with\n| [] -> []\n| hd::tl -> recurse tl (hd::xs)\nin recurse l []"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "listReverse"}
{"hw": "hw2", "fix": ["let _ = removeDuplicates [1]"], "bad": ["let _ = removeDuplicates [1];\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"], "message": ["Error: Syntax error\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen)\nthen (h :: seen)\nelse seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen)\nthen seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type unit\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let buildX()                       = VarX", "let buildY()                       = VarY", "let buildSine(e)                   = Sine(e)", "let buildCosine(e)                 = Cosine(e)", "let buildAverage(e1,e2)            = Average(e1,e2)", "let buildTimes(e1,e2)              = Times(e1,e2)", "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> exprToString buildThresh(a,b,c,d)\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX"], "bad": ["let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> exprToString buildThresh(a,b,c,d)\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX\n| None -> 0", "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> exprToString buildThresh(a,b,c,d)\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX"], "message": ["Error: This variant pattern is expected to have type expr\n       The constructor None does not belong to type expr\n", "Error: This expression has type expr * expr * expr * expr -> expr\n       but an expression was expected of type expr\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> let e' = buildThresh(a,b,c,d) in exprToString e'\n| Times (a,b) -> let e' = buildTimes(a,b) in exprToString e'\n| Average (a,b) -> let e' = buildAverage(a,b) in exprToString e'\n| Cosine (a) -> let e' = buildCosine(a) in exprToString e'\n| Sine (a) -> let e' = buildSine(a) in exprToString e'\n| VarY -> exprToString VarX\n| VarX -> exprToString VarY"], "bad": ["let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> exprToString Thresh a,b,c,d\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX", "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> exprToString Thresh (a,b,c,d)\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX", "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> exprToString Thresh(a *b*c*d)\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX", "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> exprToString buildThresh(a,b,c,d)\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX", "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> let a = buildThresh(a,b,c,d) in exprToString a\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX", "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> let e' = buildThresh(a,b,c,d) in exprToString e'\n| Times (a,b) -> let e' = buildTimes(a,b) in exprToString e'\n| Average (a,b) -> let e' = buildAverage(a,b) in exprToString e'\n| Cosine (a) -> let e' = buildCosine(a) in exprToString e'\n| Sine (a) -> let e' = buildSine(a) in exprToString e'\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX"], "message": ["Error: This function has type expr -> 'a * 'b * 'c * 'd\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: The constructor Thresh expects 4 argument(s),\n       but is applied here to 0 argument(s)\n", "Error: The constructor Thresh expects 4 argument(s),\n       but is applied here to 0 argument(s)\n", "Error: This expression has type expr * expr * expr * expr -> expr\n       but an expression was expected of type expr\n", "Error: This expression has type expr * expr -> expr\n       but an expression was expected of type expr\n", "Error: This expression has type unit -> expr\n       but an expression was expected of type expr\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "let _ = exprToString sampleExpr1"], "bad": ["let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b ^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d ^ \")\"\n| Times (a,b) -> exprToString a ^ \"*\" ^ exprToString b\n| Average (a,b) -> \"((\" ^ exprToString a ^ \"+\" ^ exprToString b ^ \")/20\"\n| Cosine (a) -> \"cos(pi*\" ^ exprToString a ^ \")\"\n| Sine (a) -> \"sin(pi*\" ^ exprToString a ^ \")\"\n| VarY -> \"x\"\n| VarX -> \"y\""], "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)"], "bad": ["let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, t))/2\n| Cosine (a) -> cos ( pi * eval (a,x,y) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY -> x\n| VarX -> y", "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos ( pi * eval (a,x,y) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY -> x\n| VarX -> y", "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos ( pi * eval (a,x,y) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY -> float_of_int x\n| VarX -> float_of_int y", "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos ( pi * float_of_int eval (a,x,y) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos ( pi * float_of_int (eval (a,x,y)) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> int_of_float cos ( pi * float_of_int (eval (a,x,y)) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> int_of_float cos( pi * float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) ->  cos( pi * float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos( pi * pi)\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos( pi )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) ( *.) eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) ( *.) eval (b, x, y))/2\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) ( *.) (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y) ( *.) eval (b, x, y))/2\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y) ( *.) eval (b, x, y))/2\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y))/2\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0\n| Cosine (a) -> cos( pi * (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0\n| Cosine (a) -> cos( pi ** (eval (a,x,y)))\n| Sine (a) -> sin (pi ** eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y"], "message": ["Error: Syntax error\n", "Error: Unbound value t\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This function has type float -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type float -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type\n         expr * 'a * 'b -> (float -> float -> float) -> 'c -> 'd -> 'e\n       but an expression was expected of type 'c\n       The type variable 'c occurs inside\n       expr * 'a * 'b -> (float -> float -> float) -> 'c -> 'd -> 'e\n", "Error: This expression has type (float -> float -> float) -> 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside\n       (float -> float -> float) -> 'a -> 'b\n", "Error: This function has type expr * 'a * 'b -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval (Average(VarX,VarY), 0.5, 0.0)"], "bad": ["let _ = eval (Sine(0.0))", "let _ = eval (Sine(VarX ** VarY), 0.0, 0.0)", "let _ = eval (Average(VarX,VarY)), 0.0, 0.0", "let _ = eval (Average(VarX,VarY), 0.0, 0.0)"], "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "Error: This expression has type expr but an expression was expected of type\n         float\n", "Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval (Times(VarX,VarY), 3.0, 2.0)"], "bad": ["let _ = eval (Times(VarX,VarY), 1.0, 2.0)"], "message": ["Error: This variant expression is expected to have type expr\n       The constructor Time does not belong to type expr\nHint: Did you mean Times?\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "bad": ["let rec wwhile (f,b) = \nlet f b -> (b',c')\nif f b = (b',c')\nthen wwhile(f,b)\nelse wwhile(f,b)", "let rec wwhile (f,b) = \nlet x = f b", "let rec wwhile (f,b) = \nlet (b',c') = f b in", "let rec wwhile (f,b) = \nlet (b',c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'"], "message": ["Error: Unbound value b'\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1"], "bad": ["let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1"], "message": ["Error: Unbound value fixpoint\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rand = makeRand(10,39) in rand(1,4)"], "bad": ["let rand = makeRand(10,39) in \nlet _ =  rand(1,4)", "let rand = makeRand(10,39) in rand(1,4)"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let g1 () = failwith \"to be implemented\"", "let g2 () = failwith \"to be implemented\"", "let g3 () = failwith \"to be implemented\"", "let c1 () = failwith \"to be implemented\"", "let c2 () = failwith \"to be implemented\"", "let c3 () = failwith \"to be implemented\"", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "let _ = doRandomGray (10,10,34)"], "bad": ["let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(0,1) in match x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet x = rand(5,10) in match x with\n| 5 -> buildSine( build (rand, depth - 1) )\n| 6 -> buildCosine( build (rand, depth - 1) )\n| 7 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 9 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )"], "message": ["Error: Unbound value doRandomGray\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "let g1 () = failwith \"to be implemented\"", "let g2 () = failwith \"to be implemented\"", "let g3 () = failwith \"to be implemented\"", "let c1 () = failwith \"to be implemented\"", "let c2 () = failwith \"to be implemented\"", "let c3 () = failwith \"to be implemented\"", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "let _ = doRandomGray (10,10,34)", "let _ = doRandomColor (5,2,10)"], "bad": ["let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,3) in match x with\n| 1 -> buildX()\n| 2 -> buildY()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,3) in match x with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 2 | 3 -> buildY()\n| 1 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 | 0 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )"], "message": ["Error: Unbound value doRandomColor\n", "Error: Unbound value buildX\nHint: Did you mean build?\n", "Error: Unbound value buildY\nHint: Did you mean build?\n", "Error: Unbound value buildY\nHint: Did you mean build?\n", "Error: Unbound value buildY\nHint: Did you mean build?\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let g1 () = failwith \"to be implemented\"", "let g2 () = failwith \"to be implemented\"", "let g3 () = failwith \"to be implemented\"", "let c1 () = failwith \"to be implemented\"", "let c2 () = failwith \"to be implemented\"", "let c3 () = failwith \"to be implemented\"", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "let _ = doRandomGray (10,10,34)", "let _ = doRandomColor (8,2,10)"], "bad": ["let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(1,10) in match x with\n| 6 | 1 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )"], "message": ["Error: Unbound value doRandomColor\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let g1 () = failwith \"to be implemented\"", "let g2 () = failwith \"to be implemented\"", "let g3 () = failwith \"to be implemented\"", "let c1 () = failwith \"to be implemented\"", "let c2 () = failwith \"to be implemented\"", "let c3 () = failwith \"to be implemented\"", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "let _ = doRandomGray (8,10,34)"], "bad": ["let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 .. 5 -> buildY()\n| 6 .. 10 -> buildX()\nelse\nlet x = rand(1,10) in match x with\n| 6 | 1 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in \nif x < 5 then buildY()\nelse buildX()\nelse\nlet x = rand(1,10) in match x with\n| 6 | 1 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )"], "message": ["Error: Unbound value doRandomColor\n", "Error: Only character intervals are supported in patterns.\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "let _ = doRandomColor (3,19,25)"], "bad": ["let _ = \nlet g = makeRand (19,25) in\nlet e1 = build (g, 3) in Format.printf \"red   = %s \\n\" (exprToString e1)"], "message": ["Error: Unbound value doRandomColor\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(1,10) in match x with\n| 6 | 1 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "let g1 () = failwith \"to be implemented\"", "let g2 () = failwith \"to be implemented\"", "let g3 () = failwith \"to be implemented\"", "let c1 () = failwith \"to be implemented\"", "let c2 () = failwith \"to be implemented\"", "let c3 () = failwith \"to be implemented\"", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "let _ = doRandomGray (8,3,34)", "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "let _ = doRandomColor (8,5,25)"], "bad": ["let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in \nif x < 5 then buildY()\nelse buildX()\nelse\nlet x = rand(1,10) in match x with\n| 6 | 1 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )"], "message": ["Error: Unbound value doRandomColor\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "bad": ["let rec assoc (d,k,l) = \nlet rec helper (a,b,c) = match c with\n| [] -> a\n| (n,v)::t -> \nif n = b then v\nelse helper (a,b,t)\nin helper (d,k,l)"], "message": ["Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a * 'b) list\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let _ = assoc (0, \"hi\", [(\"hi\",3)])"], "bad": ["let _ = assoc (0, \"hi\", [])"], "message": ["Error: Unbound value assox\nHint: Did you mean assoc?\nError: Unbound value assox\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value assox\nHint: Did you mean assoc?\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "bad": ["let rec assoc (d,k,l) = match l with\n| [] -> d\n| (n,v)::t -> \nif n = k then v\nelse assoc (d,k,t)"], "message": ["Error: Unbound value a\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let _ = doRandomGray (9, 2, 17)"], "bad": ["let _ = doRandomGray (9, 1, 17)"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = a*a + x in\nlet base = [] in\nList.fold_left f base xs"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = a**2 + x in\nlet base = 0 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = a^2 + x in\nlet base = 0 in\nList.fold_left f base xs", "let sqsum xs = \nlet f a x = a^^2 + x in\nlet base = 0 in\nList.fold_left f base xs"], "message": ["Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         string\n", "Error: This expression has type int but an expression was expected of type\n         ('a, 'b, 'c, 'd, 'e, 'f) format6 =\n           ('a, 'b, 'c, 'd, 'e, 'f) CamlinternalFormatBasics.format6\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = match x with\n| x::xs' -> x a\nin\nlet base = (fun _ x -> x) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = match x with\n| [] -> (fun b -> b)\nin\nlet base = 0 in\nList.fold_left f base fs"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = match x with\n| x::xs' -> ( fun z d -> x d)\nin\nlet base = (fun _ y -> y) in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This expression should not be a function, the expected type is\n(('a -> 'b -> 'b) -> 'a -> 'b -> 'b) list\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (fun b a -> a x)in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         int -> int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (fun y -> a x)in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let pipe fs = \nlet f a x = (fun b c -> a x)in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "message": ["Error: This expression has type int but an expression was expected of type\n         ('a -> 'b) -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'a -> 'c -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'c -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (fun y -> a x) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "let _ = fun y -> a x"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         int -> int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = ( fun c -> x ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a x in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = ( fun c -> y ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "let (o) f g = fun x -> f (g x)", "let foo   = (fun x -> x + 1) o (fun y -> 2 * y)", "let ans  = foo 10"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: Unbound value y\n", "Error: Syntax error\n", "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value foo\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = ( fun y -> a (x y) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = ( fun c -> f a x ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = ( fun c -> f (a x) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = ( fun c -> fun d -> (a x) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = ( fun x -> f (g x) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs"], "message": ["Error: Unbound value f\n", "Error: Unbound value f\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'a -> 'c -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'c -> 'b\n", "Error: Unbound value f\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = ( fun y -> a (x y) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = ( fun y -> a (y x) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'c -> ('c -> 'a) -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'c -> 'a -> 'b\n       The type variable 'a occurs inside 'c -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (fun acc x -> x ^ cc) in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (fun acc x -> x ^ acc) in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (fun acc x -> x ^ acc) in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (fun acc x -> x ^ acc) in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"], "message": ["Error: Unbound value cc\n", "Error: This expression has type string but an expression was expected of type\n         string -> string -> string\n", "Error: This expression has type string -> string -> string\n       but an expression was expected of type string\n", "Error: This expression has type string but an expression was expected of type\n         string -> string -> string\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" ^ h ^ \"\" in\nlet l = t in\nList.fold_left f base l"], "bad": ["let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]"], "message": ["Error: This expression has type string but an expression was expected of type\n         string list\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let stringOfList f l = \n\"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\""], "bad": ["let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let stringOfList f l = \nList.map f (sepConcat \";\") l"], "message": ["Error: This expression has type int but an expression was expected of type\n         string list\n", "Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let rec clone x n = match n with\n| 0 -> []\n| _ -> clone x (n-1) @ [x]"], "bad": ["let rec clone x n = match n with\n| 0 -> []\n| _ -> clone x (n-1) :: [h]", "let rec clone x n = match n with\n| 0 -> []\n| _ -> clone x (n-1) :: [x]", "let rec clone x n = match n with\n| 0 -> []\n| 1 -> clone x (n-1) :: [x]"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let rec removeZero l = match l with\n| [] -> l\n| h::t ->\nif h = 0 \nthen removeZero t\nelse l"], "bad": ["let rec removeZero l = match l with\n| [] -> l\n| h::t -> if h = 0 then removeZero t", "let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h = 0 then removeZero t"], "message": ["Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"], "problem": "removeZero"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = ( fun y -> x (a y) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base =  h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = \n\"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n = match n with\n| 0 -> []\n| a -> if a < 0 then [] else clone x (n-1) @ [x]", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let padZero l1 l2 = \nif (List.length l1 > List.length l2)\nthen (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2)\nelse (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let _ = padZero [1;0;0;2] [0;0;9;9]", "let _ = padZero [9;1] [1;2]", "let _ = padZero [1;1] [1]", "let rec removeZero l = match l with\n| [] -> l\n| h::t ->\nif h = 0 \nthen removeZero t\nelse l", "let _ = removeZero [0;0;0;1;0;0;2]", "let _ = removeZero [9;9]", "let _ = removeZero [0;0;0;0]", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| (h1,h2)::t -> [t]\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet a = h::t in \nmatch x with\n| (x1,x2) -> if x1 + x2 + h > 9 then 1 :: (h = x1 + x2 + h mod 10)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t, (x1,x2) -> if x1 + x2 + h > 9 then 1 :: (h = x1 + x2 + h mod 10)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t, (x1,x2) -> if x1 + x2 + h > 9 then 1 :: (x1 + x2 + h mod 10)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t, (x1,x2) -> if x1 + x2 + h > 9 then (1 :: (x1 + x2 + h mod 10))\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 1 :: (x1 + x2 + h mod 10)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9(*1 :: (x1 + x2 + h mod 10) *)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t -> a * x\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t, (x,y) -> a * x\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Unbound value h\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = ( fun y -> x (a y) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base =  h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = \n\"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n = match n with\n| 0 -> []\n| a -> if a < 0 then [] else clone x (n-1) @ [x]", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let padZero l1 l2 = \nif (List.length l1 > List.length l2)\nthen (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2)\nelse (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let _ = padZero [1;0;0;2] [0;0;9;9]", "let _ = padZero [9;1] [1;2]", "let _ = padZero [1;1] [1]", "let rec removeZero l = match l with\n| [] -> l\n| h::t ->\nif h = 0 \nthen removeZero t\nelse l", "let _ = removeZero [0;0;0;1;0;0;2]", "let _ = removeZero [9;9]", "let _ = removeZero [0;0;0;0]", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| (h1,h2)::t -> [h1]\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| (h1,h2)::t -> [h1]\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nlet carry =\nmatch a with\n| (x,y) -> x in\nmatch x with\n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| (h1,h2)::t -> 9\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| (h1,h2)::t -> [h1]\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| h1::t -> [h1]\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| h1::t -> []\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| h1 -> []\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| h1::t -> []\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| h::t -> []\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| (h1,h2)::t -> []\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| h::t -> []\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| h::t -> []\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| h -> []\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1,h1) -> []\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1,h2) -> []\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1,h2) -> (h2,h1)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1,h2) -> [h2]\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1,h2) -> [h2]\nin\nlet base =  [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: Variable h1 is bound several times in this matching\n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  f + g + carry mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet digit = match x with\n| (f,g)::t -> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)::t) else (0, (f+g+carry mod 10)::t)\nin digit\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet digit = match x with\n| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)::t) else (0, (f+g+carry mod 10)::t)\nin digit\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet digit = match x with\n| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)) else (0, (f+g+carry mod 10))\nin digit\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,[g])-> f\nin\nlet digit = match x with\n| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)) else (0, (f+g+carry mod 10))\nin digit\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet digit = match x with\n| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)) else (0, (f+g+carry mod 10))\nin digit\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  f + g + carry mod 10\nin \nmatch a with\n| (o,p) -> (newcarry, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n", "Error: Unbound value t\n", "Error: This expression has type int * 'a list\n       but an expression was expected of type int * int\n       Type 'a list is not compatible with type int \n", "Error: This expression has type int * 'a list -> int * int -> int * int\n       but an expression was expected of type\n         int * 'a list -> int * int -> int * 'a list\n       Type int is not compatible with type 'a list \n", "Error: This expression has type int * 'a list\n       but an expression was expected of type int * int\n       Type 'a list is not compatible with type int \n", "Error: Unbound value newcarry\nHint: Did you mean carry?\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\n| []   -> carry\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int * int\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g) -> f\n| (f',g'::h)-> g'\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g) ->\n| (f',g'::h)-> g\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = \nif i = 0 then l\nelse\nlet a = i :: [] in\nbigAdd (mulByDigit (i-1) l) (mulByDigit (i-1) l)"], "bad": ["let rec mulByDigit i l = \nif i = 0 then l\nelse\nlet a = i :: [] in\nbigAdd (mulByDigit i-1 l) (mulByDigit i-1 l)"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = match a with\n| (_,y) -> (0, bigAdd y x) in\nlet base = (0,[]) in\nlet args = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h b) :: acc) a t\nin\nconstructargs [] l1 (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = [] in\nlet args = match x with in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = [] in\nlet args = match l2 with\nin\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = bigAdd a x in\nlet base = [] in\nlet args = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h b) :: acc) a t\nin\nconstructargs [] l1 (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = match a with\n| (_,y) -> (0, bigAdd a x) in\nlet base = (0,[]) in\nlet args = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h b) :: acc) a t\nin\nconstructargs [] l1 (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let unzeroed = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h a) :: acc) a t\nin\nconstructargs [] [1;2;3] (List.rev [4;5;6])\nin \nlet rec addZeroes num somelist = match num with\n| 0 -> somelist \n| _ -> addZeroes (num-1) (List.append somelist [0])\nin\nlet rec addZeroesWhole acc a = match a with\n| [] -> acc\n| h::t -> addZeroesWhole ( (addZeroes (List.length t) h) :: acc ) t\nin\naddZeroesWhole [] unzeroed"], "bad": ["let unzeroed = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h a) :: acc) a t\nin\nconstructargs [] [1;2;3] (List.rev [4;5;6])\nin \nlet rec addZeroes num somelist = match num with\n| 0 -> somelist \n| _ -> addZeroes (num-1) (List.append somelist 0)\nin\nlet rec addZeroesWhole acc a = match a with\n| [] -> acc\n| h::t -> addZeroesWhole ( (addZeroes (List.length t) h) :: acc ) t\nin\naddZeroesWhole [] unzeroed"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = \nif i <= 0 then [0] else\nif i = 1 then l\nelse\nbigAdd (mulByDigit (i-1) l)  l"], "bad": ["let rec mulByDigit i l = \nif i <= 0 then 0 else\nif i = 1 then l\nelse\nbigAdd (mulByDigit (i-1) l)  l"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "mulByDigit"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse let x = n/10 and y = n mod 10\nin digitsOfInt x @ y", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663"], "bad": ["let rec digitsOfInt n = \nlet x = n/10 \nand y = n mod 10\nand if y = 0 && x = 0 then []::resultList\nelse y::resultList -> digitsOfInt x", "let rec digitsOfInt n = \nlet x = n/10 \nand y = n mod 10 in\nif y = 0 && x = 0 then []::resultList\nelse y::resultList -> digitsOfInt x", "let rec digitsOfInt n = \nlet x = n/10 \nand y = n mod 10 in\nif y = 0 && x = 0 then []::resultList\nelse y::resultList -> y :: digitsOfInt x"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt (-300)"], "bad": ["let _ = digitsOfInt (digits -300)", "let _ = digitsOfInt (digits (-300))"], "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\nError: Unbound value digitsOfInt\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int -> int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value digitsOfInt\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let x = sumList (digitsOfInt 10)"], "bad": ["let x = sumList digitsOfInt 10", "let x = sumList digitsOfInt 10"], "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l'"], "bad": ["let rec listReverse l = \n| [] -> 0\n| x :: l' -> listReverse l' @ [x]", "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l' @ [x]", "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse [l'] @ [x]", "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse [l'] @ [x]"], "message": ["Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec listReverse l = \nmatch l with\n| [] -> []\n| head::tail -> listReverse tail @ head"], "bad": ["let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l'::x", "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l'::[x]", "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> \n\n(* uncomment and run AFTER you have implemented listReverse\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n*)\n\n(* explode : string -> char list \n* (explode s) is the list of characters in the string s in the order in \n*   which they appear\n* e.g.  (explode \"Hello\") is ['H';'e';'l';'l';'o']\n*)\nlet explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0", "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: xl -> listReverse x :: []", "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: xl -> listReverse xl :: []", "let rec listReverse l = \nmatch l with\n| [] -> 0\n| head::tail -> tail", "let rec listReverse l = \nmatch l with\n| [] -> 0\n| head :: tail -> tail"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: Syntax error\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let palindrome w = \n(listReverse (explode w))"], "bad": ["let palindrome w = \nif listReverse explode w = w then true\nelse false", "let palindrome w = \nif (listReverse (explode w)) = w then true\nelse false"], "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type string but an expression was expected of type\n         char list\n"], "problem": "palindrome"}
{"hw": "hw1", "fix": ["let palindrome w = \nif (listReverse (explode w)) = explode w then true\nelse false"], "bad": ["let palindrome w = \nif (listReverse (explode w)) = w then 1\nelse 0"], "message": ["Error: This expression has type string but an expression was expected of type\n         char list\n"], "problem": "palindrome"}
{"hw": "hw1", "fix": ["List.hd x"], "bad": ["x.hd"], "message": ["Error: Unbound record field hd\n"], "problem": "???"}
{"hw": "hw1", "fix": ["List.rev x"], "bad": ["List.revs x"], "message": ["Error: Unbound value List.revs\nHint: Did you mean rev?\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let x = [1;2;3]"], "bad": ["(x 3)", "(x 3)::[1;2;3]"], "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::third -> head::[tail]"], "bad": ["let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::t::s -> s::t::tail::head", "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::t::s -> s::t::tail::head", "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::t::s = l -> s::t::tail::head", "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::t::s::l -> s::t::tail::head", "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::third -> head::tail"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: Syntax error\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::third::fourth::fifth -> fourth::third::tail::[head]"], "bad": ["let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::third::fourth -> fourth::third::tail::[head]"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail -> head::listReverse tail"], "bad": ["let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail -> head::listReverse tail::tail"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["1::2::3::[4]"], "bad": ["1::2::3::4"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec getLast l =\nmatch l with\n| [x] -> x\n| head::tail -> getLast tail"], "bad": ["let rec getLast l =\n| [] -> _\n| [x] -> x\n| head::tail -> getLast tail", "let rec getLast l =\n| [x] -> x\n| head::tail -> getLast tail"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec getLast l =\nmatch l with\n| [] -> []\n| [x] -> x\n| head::tail -> getLast tail"], "bad": ["let rec getLast l =\nmatch l with\n| [] -> _\n| [x] -> x\n| head::tail -> getLast tail"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let x = [1;2;3]", "getLast x"], "bad": ["getLast [1;2;3]"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec reverseInt x y =\nif x != 0 then reverseInt (x/10) (y*10+10 mod 10)\nelse y"], "bad": ["let rec reverseInt x y =\n(x != 0)? reverseInt(x/10, y*10+x mod 10) : y", "let rec reverseInt x y =\n(x != 0)? reverseInt(x/10, y*10+x mod 10):y", "let rec reverseInt x y =\n(x != 0)? reverseInt(x/10, y*10+x mod 10):y", "let rec reverseInt x y =\n(x != 0)? reverseInt x/10 y*10+x mod 10 :y", "let rec reverseInt x y =\n(x != 0)? reverseInt (x/10) (y*10+x mod 10) :y"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverseInt n 0/10 \nand y = reverseInt n 0 mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"], "bad": ["let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet m = n", "let x = m/10 \nand y = m mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet m = n \nand x = m/10 \nand y = m mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet m = n \nand x = m/10 \nand y = m mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet m = n \nand x = m/10 \nand y = m mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet m = reverseInt n\nand x = m/10 \nand y = m mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet m = reverseInt n\nin let x = m/10 \nand y = m mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverseInt n/10 \nand y = reverseInt n mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverseInt n 0/10 \nand y = reverseInt n mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"], "message": ["Error: Syntax error\n", "Error: Unbound value m\n", "Error: Unbound value m\n", "Error: Unbound value m\n", "Error: Unbound value m\n", "Error: Unbound value m\n", "Error: This expression has type int -> int\n       but an expression was expected of type int\n", "Error: This expression has type int -> int\n       but an expression was expected of type int\n", "Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let reverseInt x y=\nwhile x > 0 do\nlet k = x mod 10\nand y = y*10\nand x = x/10 in x done"], "bad": ["let reverseInt x y=\nwhile x > 0 do\nlet k = x mod 10\nand y = y*10 + k\nand x = x/10 in\nx", "let reverseInt x y=\nwhile x > 0 do\nlet k = x mod 10\nand y = y*10 + k\nand x = x/10", "let reverseInt x y=\nwhile x > 0 do\nlet k = x mod 10\nand y = y*10 + k\nand x = x/10", "let reverseInt x y=\nwhile x > 0 do\nlet k = x mod 10\nand y = y*10 + k\nand x = x/10", "let reverseInt x y=\nwhile x > 0 do\nlet k = x mod 10\nand y = y*10 + k\nand x = x/10", "let reverseInt x y=\nwhile x > 0 do\nlet k = x mod 10\nand y = y*10 + k\nand x = x/10", "let reverseInt x y=\nwhile x > 0 do\nlet k = x mod 10\nand y = y*10 + k\nand j = x/10", "let reverseInt x y=\nwhile x > 0 do\nlet k = x mod 10\nand y = y*10 + k", "let reverseInt x y=\nwhile x > 0 do\nlet k = x mod 10\nand y = y*10 + k", "let reverseInt x y=\nwhile x > 0 do\nlet k = x mod 10\nand y = y*10 + k\nand x = x/10 in x", "let reverseInt x y=\nwhile x > 0 do\nlet k = x mod 10\nand y = y*10 + k\nand x = x/10 in x done"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value k\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let reverseInt x y=\nwhile x > 0 do\nlet y = y*10 + x mod 10  \nand x = x/10 in x done"], "bad": ["let reverseInt x y=\nwhile x > 0 do\nlet k = x mod 10\nand y = y*10 + k\nand x = x/10 in x done"], "message": ["Error: Unbound value k\n"], "problem": "???"}
{"hw": "hw1", "fix": ["string_of_list x"], "bad": ["_of_st", "int_of_string x;"], "message": ["Error: Syntax error\n", "Error: Unbound value _of_st\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let x = 13", "string_of_int x"], "bad": ["string_of_List x", "string_of_int x", "lsit_of_string x", "int_of_string x"], "message": ["Error: Unbound value string_of_list\nHint: Did you mean string_of_int?\n", "Error: Unbound value string_of_List\nHint: Did you mean string_of_int?\n", "Error: This expression has type string but an expression was expected of type\n         int\n", "Error: Unbound value lsit_of_string\nHint: Did you mean float_of_string or int_of_string?\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let _ = digitsOfInt (-42313)"], "bad": ["let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverse (string_of_int n) \nand y= x /10 \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y", "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverse (string_of_int n) \nand y= x /10 \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y", "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverse (string_of_int n) \nand y= x /10 \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y", "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverse (string_of_int n) \nand y= x /10 \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y", "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = int_of_string reverse (string_of_int n) \nand y= x /10 \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y", "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet s = reverse (string_of_int n) \nand n2 = int_of_string s  \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y", "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet s = reverse (string_of_int n) in\nlet n2 = int_of_string s  \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y", "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet s = reverse (string_of_int n) in\nlet n2 = int_of_string s  in\nlet x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"], "message": ["Error: This expression has type string but an expression was expected of type\n         int\nError: Unbound value x\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type string but an expression was expected of type\n         int\n", "Error: This expression has type string but an expression was expected of type\n         int\nError: Unbound value x\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type string but an expression was expected of type\n         int\n", "Error: This expression has type string but an expression was expected of type\n         int\nError: Unbound value x\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type string but an expression was expected of type\n         int\n", "Error: This expression has type string but an expression was expected of type\n         int\nError: Unbound value x\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type string but an expression was expected of type\n         int\n", "Error: This expression has type string but an expression was expected of type\n         int\nError: Unbound value x\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type string but an expression was expected of type\n         int\n", "Error: This function has type string -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value s\n", "Error: This expression has type string but an expression was expected of type\n         int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let _ = digitsOfInt (-42313)"], "bad": ["let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 and let n2 = reverse n in z = z+1", "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0", "let n2 = reverse n in z = z+1", "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then let n2 = reverse n in z = z+1", "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then let n2 = reverse (string_of_int n) in z = z+1", "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then let n2 = reverse (string_of_int n) in z+1", "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then let n2 = reverse (string_of_int n)", "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitOfInt n2", "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2", "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nlet x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nelse \nlet x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"], "message": ["Error: Unbound value n2\n", "Error: Syntax error\n", "Error: Unbound value n2\n", "Error: Syntax error\n", "Error: Unbound value n\n", "Error: Unbound value n2\n", "Error: This expression has type int but an expression was expected of type\n         bytes = string\n", "Error: Unbound value n2\n", "Error: This expression has type bool but an expression was expected of type\n         unit\n", "Error: Unbound value n2\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: Unbound value n2\n", "Error: Syntax error\n", "Error: Unbound value n2\n", "Error: Unbound value digitOfInt\nHint: Did you mean digitsOfInt?\n", "Error: Unbound value n2\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n", "Error: Unbound value n2\n", "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "Error: Unbound value n2\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\nlet s = string_of_int n in\nlet s2 = String.length s in\nfor i=0 to (s2-1)/2 do\nlet c = s.[i] in\ns.[i] <- s.[n-i-1];\ns.[n-i-1] <- c;\ndone;\nint_of_string s", "let rec reverse s = \nelse let x = s2/10 \nand y = s2 mod 10 in\nif x = 0 & y = 0 then []\nelse y::reverse x"], "bad": ["let rec digitsOfInt n =\nlet s = string_of_int n in\nlet s2 = String.length s in\nfor i=0 to (s2-1)/2 do\nlet c = s2.[i] in\ns2.[i] <- s2.[n-i-1];\ns2.[n-i-1] <- c;\ndone;\nint_of_string s2", "let rec digitsOfInt n =\nlet s = string_of_int n in\nlet s2 = String.length s in\nfor i=0 to (s2-1)/2 do\nlet c = s2.[i] in\ns2.[i] <- s2.[n-i-1];\ns2.[n-i-1] <- c;\ndone;\nint_of_string s2", "let rec digitsOfInt n =\nlet s = string_of_int n in\nlet s2 = String.length s in\nfor i=0 to (s2-1)/2 do\nlet c = s2.[i] in\ns2.[i] <- s2.[n-i-1];\ns2.[n-i-1] <- c;\ndone;\nint_of_string s2", "let rec reverse s2 = \nelse let x = s2/10 \nand y = s2 mod 10 in\nif x = 0 & y = 0 then []\nelse y::reverse x", "let rec digitsOfInt n =\nlet s = string_of_int n in\nlet s2 = String.length s in\nfor i=0 to (s2-1)/2 do\nlet c = s2.[i] in\ns2.[i] <- s2.[n-i-1];\ns2.[n-i-1] <- c;\ndone;\nint_of_string s2", "let rec reverse s2 = \nelse let x = s2/10 \nand y = s2 mod 10 in\nif x = 0 & y = 0 then []\nelse y::reverse x"], "message": ["Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         string\n", "Error: This expression has type int but an expression was expected of type\n         string\n", "Error: This expression has type int but an expression was expected of type\n         string\n", "Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         string\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let x = \"1234\"\nreverse x"], "bad": ["let rec reverse s =\nlet s2 = String.length s in\nfor i=0 to (s2-1)/2 do\nlet c = s.[i] in\ns.[i] <- s.[s2-i-1];\ns.[n-i-1] <- c;\ndone;\nint_of_string s", "let rec reverse s =\nlet s2 = String.length s in\nfor i=0 to (s2-1)/2 do\nlet c = s.[i] in\ns.[i] <- s.[s2-i-1];\ns.[s2-i-1] <- c;\ndone;\nint_of_string s"], "message": ["Error: Unbound value n\n", "Error: Unbound value n\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let z = 0", "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"], "bad": ["let z = 0;\n\nlet rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"], "message": ["Error: Unbound value z\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n z= \nif n < 0 then []\nelse if z=0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "let _ = digitsOfInt 3124"], "bad": ["let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let _ = digitsOfInt (-42313)"], "message": ["Error: Unbound value reverse\n", "Error: Unbound value digitsOfInt\n", "Error: Unbound value digitsOfInt\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse\nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "let _ = digitsOfInt 3124"], "bad": ["let rec digitsOfInt n z= \nif n < 0 then []\nelse if z=0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "let rec digitsOfInt n z= \nif n < 0 then []\nelse if z=0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2 0;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "let rec digitsOfInt n z= \nif n < 0 then []\nelse if z=0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2 0;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x 0", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let _ = digitsOfInt (-42313)", "let _ = digitsOfInt (-42313)"], "message": ["Error: Unbound value digitsOfInt\n", "Error: Unbound value reverse\n", "Error: Unbound value reverse\n", "Error: Unbound value reverse\n", "Error: Unbound value digitsOfInt\n", "Error: Unbound value digitsOfInt\n", "Error: Unbound value digitsOfInt\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 3124"], "bad": ["let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n)\nand rest = n. - 1.*(10.**s.) in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n)\nand rest = float_of_int n - 1.*(10.** float_of_int s) in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n)\nand rest = (float_of_int n) - 1.*(10.** float_of_int s) in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n)\nand rest = n - 1* int_of_float (10 ** float_of_int s) in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n)\nand rest = n - 1* int_of_float (10. ** float_of_int s) in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n) in\nlet rest = n - 1* int_of_float (10. ** float_of_int s) in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n) in\nlet rest = n - 1* int_of_float (10. ** float_of_int s) in\nhead::digitsOfInt rest"], "message": ["Error: This expression has type int but an expression was expected of type\n         float\n", "Error: Syntax error\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: Unbound value s\n", "Error: Unbound value y\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let _ = digitsOfInt (-42313)"], "bad": ["let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n) in\nlet rest = head - 1* int_of_float (10. ** float_of_int s) in\nhead::digitsOfInt rest"], "message": ["Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec rev s =\nlet n = String.length s in\nfor i=0 to (n - 1) / 2 do\nlet c = s.[i] in\ns.[i] <- s.[n-i-1];\ns.[n-i-1] <- c;\ndone;\nint_of_string s", "let digitsOfInt n =\nif n < 0 then []\nelse let n2 = rev (string_of_int) in\nlet rec reverse n2 = \nlet x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::reverse x"], "bad": ["let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n) in\nlet rest = head - 1* int_of_float (10. ** float_of_int s);\nhead::digitsOfInt rest", "let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n) in\nlet rest = head - 1* int_of_float (10. ** float_of_int s) in\nhead::digitsOfInt rest"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) = \nlet (number,boolean) = f b in\nif boolean then wwhile(f,number)\nelse number", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) = wwhile (f,b)"], "bad": ["let fixpoint (f,b) = wwhile (f,b)"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "bad": ["let fixpoint (f,b) = wwhile (f b,b)"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sine(pi*\" ^ exprToString e1 ^ \")\"", "let s = Sine VarX"], "bad": ["let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine -> \"sine(pi*\" ^ exprToString e ^ \")\"", "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sine(pi*\" ^ exprToString e1 ^ \")\""], "message": ["Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ exprToString e1 ^ \")\"\n| Cosine e2 -> \"cos(pi*\" ^ exprToString e2 ^ \")\"\n| Average (e3,e4) -> \"((\" ^ exprToString e3 ^ \"+\" ^ exprToString e4 ^ \")/2)\"\n| Times (e5,e6) -> exprToString e5 ^ \"*\" ^ exprToString e6\n| Thresh (e7,e8,e9,e10) -> \"(\" ^ exprToString e7 ^ \"<\" ^ exprToString e8 ^ \"?\" ^ exprToString e9 ^ \":\" ^ exprToString e10 ^ \")\""], "bad": ["let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ exprToString e1 ^ \")\"\n| Cosine e2 -> \"cos(pi*\" ^ exprToString e2 ^ \")\"\n| Average (e3,e4) -> \"((\" ^ exprToString e3 ^ \"+\" ^ exprToString e4 ^ \")/2)\""], "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let _ = eval (Sine(Varx),1,1)"], "bad": ["let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))"], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/2"], "bad": ["let _ = eval (Sine(VarX),1,1)", "let _ = eval (Sine(VarX),1.0,1.0)"], "message": ["Error: This variant expression is expected to have type expr\n       The constructor Varx does not belong to type expr\nHint: Did you mean VarX or VarY?\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.\n| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)"], "bad": ["let rec eval (e,x,y) = \nmatch e with\n| VarX -> float_of_int x\n| VarY -> float_of_int y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> float_of_int (eval(e1,x,y) + eval(e2,x,y))/2", "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) + eval(e2,x,y))/.2", "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) + eval(e2,x,y))/.2", "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2", "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2", "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2."], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) = \nlet (number,boolean) = f b in\nif boolean then wwhile(f,number)\nelse number", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) = wwhile (fun y b ->  (f b, f b = b),b)"], "bad": ["let fixpoint (f,b) = wwhile (fun y b -> (f b, true),b)", "let fixpoint (f,b) = wwhile ((fun y b -> (f b, true)),b)"], "message": ["Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) = wwhile (let y x =\nlet xx = f x in\n(xx, xx != x) in y, b)"], "bad": ["let fixpoint (f,b) = wwhile ((f b, f b = b),b)", "let fixpoint (f,b) = wwhile (fun y = (f b, f b = b),b)", "let fixpoint (f,b) = wwhile (fun y -> (f b, f b = b),b)", "let fixpoint (f,b) = wwhile (fun y -> (f b, f b != b),b)", "let fixpoint (f,b) = wwhile (fun y b-> (f b, f b != b),b)", "let fixpoint (f,b) = wwhile (fun y -> \nlet x = f b in\nif x = b then (x, true)\n,b)", "let fixpoint (f,b) = wwhile (fun y b-> \nlet x = f b in\nif x = b then (x, true)\nelse y x \n,b)", "let fixpoint (f,b) = wwhile (let y x = \nlet z = f x in\nif z = b then (x, true)\nelse y z,b)", "let fixpoint (f,b) = wwhile (let y x = \nlet z = f x in\nif z = b then (x, true)\nelse y z\n,b)", "let fixpoint (f,b) = wwhile (let y x = \nlet z = f x in\nif z = b then (x, true)\nelse y z\n,b)", "let fixpoint (f,b) = wwhile (fun y x -> \nlet z = f x in\nif z = b then (x, true)\nelse y z\n,b)", "let fixpoint (f,b) = wwhile (fun y x -> \nlet z = f x in\nif z = b then (x, true)\nelse y z in wwhile(y, x)\n,b", ")", "let fixpoint (f,b) = wwhile (fun y x -> \nlet z = f x in\nif z = b then (x, true)\nelse y z in wwhile(y, b)\n,b", ")", "let fixpoint (f,b) = wwhile ((fun y x -> \nlet z = f x in\nif z = b then (x, true)\nelse y z in wwhile(y, b)", ")\n,b", ")", "let fixpoint (f,b) = wwhile (let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2),b)", "let fixpoint (f,b) = wwhile (let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2),b)", "let fixpoint (f,b) = wwhile (let f x = let xx = x*x*x in (xx, xx < 100),b)", "let fixpoint (f,b) = wwhile (let y x = let xx = x*x*x in (xx, xx < 100),b)", "let fixpoint (f,b) = wwhile ((let y x = let xx = x*x*x in (xx, xx < 100)), b)", "let fixpoint (f,b) = wwhile (fun y x-> (f x, f x != b), b)", "let fixpoint (f,b) = wwhile ((fun y x-> (f x, f x != b)), b)", "let fixpoint (f,b) = wwhile (fun y -> (f b, f b != b), b)", "let fixpoint (f,b) = wwhile (fun y -> ((f b), (f b) != b), b)", "let fixpoint (f,b) = wwhile (fun y b-> (f b, f b != b), b)", "let fixpoint (f,b) = wwhile (let y b =\nlet xx = f b in\n(xx, xx != b), b)", "let fixpoint (f,b) = wwhile (let y b1 =\nlet xx = f b1 in\n(xx, xx != b), b)", "let fixpoint (f,b) = wwhile (let y b1 =\nlet xx = f b1 in\n(xx, xx != b1), b)"], "message": ["Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: Syntax error: operator expected.\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Characters 28-29:\n  let fixpoint (f,b) = wwhile (fun y x -> \n                              ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Characters 28-29:\n  let fixpoint (f,b) = wwhile (fun y x -> \n                              ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Characters 29-30:\n  let fixpoint (f,b) = wwhile ((fun y x -> \n                               ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'a * bool\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This function expects too many arguments, it should have type\n'a -> 'a * bool\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "let rec build (rand, depth) = failwith \"to be implemented\""], "bad": ["let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(******************* Functions you need to write **********)\n\n(* build: (int*int->int) * int -> Expr \nBuild an expression tree.  The second argument is the depth, \nthe first is a random function.  A call to rand(2,5) will give\nyou a random number in the range [2,5].\n\nYour code should call buildX, buildSine, etc. to construct\nthe expression.\n*)\n\nmakeRand(1,2)", "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(******************* Functions you need to write **********)\n\n(* build: (int*int->int) * int -> Expr \nBuild an expression tree.  The second argument is the depth, \nthe first is a random function.  A call to rand(2,5) will give\nyou a random number in the range [2,5].\n\nYour code should call buildX, buildSine, etc. to construct\nthe expression.\n*)\n\n\n\nmakeRand(1,2)"], "message": ["Error: Unbound value rand\nHint: Did you mean land?\n", "Error: This function has type expr * expr * expr * expr -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nlet rand = makeRand (1,7) in\nlet x = rand(1,7) in x"], "bad": ["let rec build (rand, depth) = \nlet rand = makeRand (1,7) in\nlet x = rand(1,7)", "let rec build (rand, depth) = \nlet rand = makeRand (1,7) in\nlet x = rand(1,7) in rand"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rand = makeRand(1,7)", "let rec build (rand, depth) = \nlet x = rand"], "bad": ["let rec build (rand, depth) = \nlet rand = makeRand (1,7) in\nlet x = rand(1,7) in x"], "message": ["Error: Unbound value rand\nHint: Did you mean land?\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nlet x = rand(0,6) in \nmatch x with \n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 3 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))"], "bad": ["let rec build (rand, depth) = \nlet x = rand(1,7) in \nmatch x with \n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 4 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))"], "message": ["Error: Unbound value buildAverge\nHint: Did you mean buildAverage?\nError: Unbound value buildAverge\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value buildAverge\nHint: Did you mean buildAverage?\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.\n| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh(e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then \neval(e3,x,y)\nelse eval(e4,x,y)\n| Power(e1,e2) -> eval(e1,x,y) ** eval(e2,x,y)\n| AddThree(e1,e2,e3) -> eval(e1,x,y) +. eval(e2,x,y) +. eval(e3,x,y)"], "bad": ["let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.\n| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh(e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then \neval(e3,x,y)\nelse eval(e4,x,y)\n| Power(e1,e2) -> eval(e1,x,y) ** eval(e2,x,y)"], "message": ["Error: Unbound value **.\nHint: Did you mean *. or **?\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval (AddThree(VarX,VarY,VarX),1.,5.)"], "bad": ["let _ = eval (AddThree(VarX,VarY,VarX),1.,2.,3.)", "let _ = eval (AddThree(VarX,VarY,VarX),1.,2.)"], "message": ["Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type 'a * 'b * 'c * 'd\n       but an expression was expected of type expr * float * float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let g1 () = 20,8,9", "let g2 () = 20,10,11", "let g3 () = 20,9,12", "let c1 () = 12,1,100", "let c2 () = 12,2,50", "let c3 () = 12,3,8", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type test = unit -> string", "let key = \"\"", "let prefix130 = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")", "let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0", "let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)", "let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))", "let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p", "let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max"], "bad": ["let _ = eval (Power(VarX,VarY),3.,2.)", "let _ = eval (AddThree(VarX,VarY,VarX),2.,5.)", "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "let _ = eval (sampleExpr,0.5,0.2)", "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "let rec build (rand, depth) = \nlet x = rand(0,7) in \nmatch x with \n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 3 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 4 -> if depth = 0 then build(rand,depth)\nelse buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 5 -> if depth = 0 then build(rand,depth)\nelse buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 6 -> if depth = 0 then build(rand,depth)\nelse buildPower(build(rand,depth-1),build(rand,depth-1))\n| 7 -> if depth = 0 then build(rand,depth)\nelse buildAddThree(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ -> buildX()"], "message": ["Error: Unbound value eval\n", "Error: Unbound value eval\n", "Error: Unbound value eval\n", "Error: Unbound value eval\n", "Error: Unbound value buildCosine\n", "Error: Unbound value eval\n", "Error: Unbound value buildThresh\n"], "problem": "build"}
{"hw": "hw3", "fix": ["(* UNCOMMENT AFTE", "let _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x);", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "bad": ["\n\r\nlet pipe fs = \nlet f a x = x a in\nlet b", "\n\r\nlet pipe fs = \nlet f a x = x a in\nlet b", "\n\r\nlet pipe fs = \nlet f a x = x a in\nlet b", "\n\r\nlet pipe fs = \nlet f a x = x a in\nlet b", "\n\r\nlet pipe fs y = \nlet f a x = x a in\nlet b", "\n\r\nlet pipe fs  = function \nlet f a x = x a in\nlet b", "\n\r\nlet pipe fs  y=  \nlet f a x = x a in\nlet b"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*", "\r\nlet _ = sepConcat \", \" [", "\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"", "let _ = sepConcat \", \" [\"foo\";\""], "bad": ["\n\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = \"\" in\nlet l ", "\n\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ \"x\" in\nlet base = \"\" in\nlet l ", "\n\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l "], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*", "\r\nlet _ = sepConcat \", \" [", "\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"", "let _ = sepConcat \", \" [\"foo\";\""], "bad": ["\n\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep ^ x in\nlet base = \"\" in\nlet l "], "message": ["Error: Syntax error\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*", "\r\nlet _ = sepConcat \", \" [", "\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"", "let _ = sepConcat \", \" [\"foo\";\""], "bad": ["\n\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"h\" in\nlet l"], "message": ["Error: Syntax error\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*", "\r\nlet _ = sepConcat \", \" [", "\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"", "let _ = sepConcat \", \" [\"foo\";\""], "bad": ["\n\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l ="], "message": ["Error: Syntax error\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["\n\r\nlet pipe fs =  \nlet f a x = x a in\nlet b", "(* UNCOMMENT AFTE", "let _ = pipe [] 3"], "bad": ["\n\r\nlet pipe fs y=  \nlet f a x = x a in\nlet b"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["(* UNCOMMENT AFTE", "let _ = pipe [] 3\n\r\nlet _ = pipe [(fun x -> x+x);", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "bad": ["\n\r\nlet _ = pipe [(fun x -> x+x);", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "\n\r\nlet _ = pipe [(fun x -> x+x);", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let pipe fs =  \nlet f a x = x a in\nlet b", "\n\r\nlet pipe fs =  \nlet f a x = x base in\nle", "\n\r\nlet pipe fs =  \nlet f a x = x' (x a)  in", "\n\r\nlet pipe fs =  \nlet f a x = fun (x a)  i", "\n\r\nlet pipe fs =  \nlet f a x = fun x' ->  x", "\n\r\nlet pipe fs y=  \nlet f a x = x a  in\nlet "], "message": ["Error: Unbound value pipe\n", "Error: Syntax error\n", "Error: Unbound value pipe\n", "Error: Syntax error\n", "Error: Unbound value pipe\n", "Error: Syntax error\n", "Error: Unbound value base\n", "Error: Syntax error\n", "Characters 35-36:\n  let f a x = fun (x a)  i;;\n                  ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": [";;", "let sqsum xs = \nlet f a x = x * x + a in"], "bad": ["let sqsum xs = \nlet f a x = x * x + a in"], "message": ["Characters 25-26:\n  (r1 -. r2;;\n  ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": [";;", "let sqsum xs = \nlet f a x = x * x + a in"], "bad": ["let sqsum xs = \nlet f a x = x * x + a in"], "message": ["Error: Syntax error\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = (x * x + a)", "let base = 0 \nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;"], "bad": ["let sqsum xs = \nlet f a x = (x * x + a) "], "message": ["Error: Syntax error\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["\n\nlet sqsum xs = \nlet f a x = x * x + a in", "\n(* UNCOMMENT AF", "(* UNCOMMENT AFTER IMPL", "let _ = sqsum []\nlet _ = sqsum [1;2;3;"], "bad": ["let sqsum xs = \nlet f a x = x * x + a in"], "message": ["Error: Syntax error\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let _ = mulByDigit 9 [9;9;9;9]"], "bad": ["let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)"], "message": ["Error: This expression has type int list -> int list\n       but an expression was expected of type int\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let _ = bigMul [9;9;9;9] [9;9;9;9]", "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"], "bad": ["let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*10 * List.length res) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let _ = bigMul [9;9;9;9] [9;9;9;9]", "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"], "bad": ["let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x) *. 10. ** (float_of_int List.length res)) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x) *. 10. ** (float_of_int (List.length res))) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float ((float_of_int x) *. 10. ** (float_of_int (List.length res)))) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Characters 63-64:\n  | (list1, res) -> (list1, mulByDigit ((int_of_float (float_of_int x *. 10. ** float_of_int List.length res)) list1) in\n                    ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         float\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let _ = bigMul [9;9;9;9] [9;9;9;9]"], "bad": ["let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*List.lengh res) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*List.length res) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type int list -> int list\n       but an expression was expected of type int\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list -> int list\n       but an expression was expected of type int\n", "Error: Unbound value List.lengh\nHint: Did you mean length?\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value List.lengh\nHint: Did you mean length?\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let _ = bigMul [9;9;9;9] [9;9;9;9]", "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"], "bad": ["let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**List.length res))) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**float_of_int List.length res))) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**float_of_int (List.length res)))) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type int list -> int list\n       but an expression was expected of type int\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list -> int list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         float\n", "Error: This function has type int -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type int -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "bigMul"}
{"hw": "hw1", "fix": ["let rec sumList xs =\nmatch xs with\n[] -> 0 | h::t -> h + sumList t", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]"], "bad": ["let rec sumList xs =\nmatch xs with\n[] -> 0 | h::t -> h + sumList"], "message": ["Error: This expression has type int list -> int\n       but an expression was expected of type int\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let rec sumList xs =\nmatch xs with\n[] -> 0 \n| h::t -> h + sumList t", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]", "let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> digitsOfInt n/10 @  [n%10]"], "bad": ["let rec digitsOfInt n =\nmatch n with\nn/10 == 0 -> [n] | digitsOfInt n/10 -> n%10 :: []", "let rec digitsOfInt n =\nmatch n with\n0 -> [] | digitsOfInt n/10 -> n%10 :: []", "let rec digitsOfInt n =\nmatch n with\n0 -> [] | digitsOfInt (n/10) -> n%10 :: []", "let rec digitsOfInt n =\nmatch n with\n0 -> [] | digitsOfInt n -> n%10 :: []", "let rec digitsOfInt n =\nmatch n with\n0 -> [] | n -> digitsOfInt n/10 n%10 :: []", "let rec digitsOfInt n =\nmatch n with\n0 -> [] | n -> digitsOfInt n/10 :: []", "let rec digitsOfInt n =\nmatch n with\n0 -> [] | n -> digitsOfInt n :: []", "let rec digitsOfInt n =\nmatch n with\n0 -> [] | n -> [digitsOfInt n/10]", "let rec digitsOfInt n =\nmatch n with\n0 -> [] | n/10 -> [digitsOfInt n]", "let rec digitsOfInt n =\nmatch n with\n0 -> [] | (n/10) -> [digitsOfInt n]"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value %\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: Syntax error\n", "Characters 47-48:\n  0 -> [] | (n/10) -> [digitsOfInt n];;\n            ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> digitsOfInt (n/10) @  [n mod 10]"], "bad": ["let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> digitsOfInt (n/10) @  [n%10]"], "message": ["Error: Unbound value %\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\n_ -> digitsOfInt (n/10) @  [n mod 10]", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let _ = digitsOfInt 0", "let _ = digitsOfInt 1"], "bad": ["let rec digitsOfInt n =\nn -> digitsOfInt (n/10) @  [n mod 10]"], "message": ["Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let catNum x =\nmatch x with\n[] -> x::[]\n| h::t -> x::[]"], "bad": ["let catNum x\n_ -> x::(h::t)", "let catNum x\nmatch x with\n[] -> x::[]\n| h::t -> x::(h::t)", "let catNum x =\nmatch x with\n[] -> x::[]\n| h::t -> x::(h::t)", "let catNum x =\nmatch x with\n[] -> x::[]\n| h::t -> x::h::t", "let catNum x =\nmatch x with\n[] -> x::[]\n| h::t -> x::h", "let catNum x =\nmatch x with\n[] -> x::[]\n| h::t -> x::catNum", "let catNum x =\nmatch x with\n[] -> x::[]\n| h::t -> x::catNum x"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list list\n       The type variable 'a occurs inside 'a list list\n", "Error: Unbound value catNum\n", "Error: Unbound value catNum\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let catNum x =\nmatch x with\n[] -> x::[]\n| h::t -> x::[]"], "bad": ["let catNum x\nmatch x with\n[] -> x::[]\n| h::t -> x::(h::t)", "let catNum x =\nmatch x with\n[] -> x::[]\n| h::t -> x::(h::t)"], "message": ["Error: Syntax error\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec cat x y =\nmatch x with\n[] -> [y]\n| h::t -> h::( cat t y)"], "bad": ["let rec (:::) x y =\nmatch x with\n[] -> [y]\n| h::t -> h::( (:::) t y)"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\nif n = 0 then [0]\nelse hDigitsofInt n", "let rec hDigitsofInt num =\nmatch num with\n0  -> [] \n| _  -> cat (hDigitsOfInt (num/10)) (num mod 10)", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let _ = digitsOfInt 0", "let _ = digitsOfInt 1"], "bad": ["let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec hDigitsofInt n = \nmatch n with\n0  -> [] \n| _  -> cat (digitsOfInt (n/10)) (n mod 10)", "let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec hDigitsofInt n = \nmatch n with\n0  -> [] \n| _  -> cat (hDigitsOfInt (n/10)) (n mod 10)", "let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec hDigitsofInt n = \nmatch n with\n0  -> [] \n| _  -> cat (hDigitsOfInt (n/10)) (n mod 10)"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> cat (digitsOfInt (n/10)) (n mod 10)", "if n = 0 then [0]"], "bad": ["let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> cat (digitsOfInt (n/10)) (n mod 10)\nif n = 0 then [0]"], "message": ["Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\nif n = 0 then [0]\nelse\nmatch n with\n0  -> [] \n| _  -> cat (digitsOfInt (n/10)) (n mod 10)"], "bad": ["let rec digitsOfInt n =\nif n = 0 then [0]\nmatch n with\n0  -> [] \n| _  -> cat (digitsOfInt (n/10)) (n mod 10)"], "message": ["Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec help n =\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", ";;"], "bad": ["let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec help n =\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)"], "message": ["Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec help n =\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "let rec digitsOfInt n =\nif n = 0 then [0]\nelse help n", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let _ = digitsOfInt 0", "let _ = digitsOfInt 1"], "bad": ["let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec help n =\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec help n = fun\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec help n = fun\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec help n = fun\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec help num = fun\nmatch num with\n0  -> [] \n| _  -> cat (help (num/10)) (n mod 10)", "let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec help n = fun |\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec help n = fun \nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec help n = \nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec help n in \nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "let rec digitsOfInt n =\nif n = 0 then [0]\nelse fun rec help n   ->\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "let rec digitsOfInt n =\nif n = 0 then [0]\nelse fun help n  ->\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec help n  ->\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec help n  =\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression should not be a function, the expected type is\nint list\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec listReverse l = \nmatch l with\n[]   -> []\n| h::t -> listReverse (t::(cat l h))", "let _ = listReverse [1; 2; 3; 4]", "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]"], "bad": ["let rec listReverse l = \nmatch l with\n[]   -> []\n| h::t -> listReverse ((cat l h)::t)"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0", "let palindrome w = \nexplode w = listReverse (explode w)", "let _ = palindrome \"malayalam\"", "let _ = palindrome \"myxomatosis\""], "bad": ["let palindrome w = \nlet l = explode w", "let reverse = listReverse l", "let palindrome w = \nlet l = explode w", "let reverse = listReverse l", "let palindrome w = \nlet l = explode w", "let reverse = listReverse l"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value listReverse\n", "Error: Syntax error\n", "Error: Unbound value listReverse\n", "Error: Syntax error\n"], "problem": "palindrome"}
{"hw": "hw1", "fix": ["let _ = additivePersistence 9999", "let _ = additivePersistence 312"], "bad": ["let _ = additivePersistence (-9999)"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "problem": "additivePersistence"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n[]   -> d\n| h::t -> \nif k = h then 10 else assoc (d,k,t)"], "bad": ["let rec assoc (d,k,l) = match l with\n[]   -> d\n| h::t -> assoc (d,k,l) in\nif k = h then 10 else assoc (d,k,t)"], "message": ["Error: Unbound value k\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "bad": ["let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type string\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type string\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h::seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem (h,t) then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem (h) then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem (h , t) then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h::[] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h@[] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then [] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h::[] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then (h::[]) in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h@seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "message": ["Error: This expression has type ('a * 'a list) list -> bool\n       but an expression was expected of type bool\n", "Error: This expression has type 'a list -> bool\n       but an expression was expected of type bool\n", "Error: This expression has type ('a * 'a list) list -> bool\n       but an expression was expected of type bool\n", "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This expression has type 'a list list\n       but an expression was expected of type 'a list\n       The type variable 'a occurs inside 'a list\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = match f with\n(num, b00l)-> if b00l then num else wwhile (f, num)"], "bad": ["let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "message": ["Error: This expression has type int but an expression was expected of type\n         bool\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = match f with\n(num, b00l)-> if b00l then num else wwhile (f, num)", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "bad": ["let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let rec wwhile (f,b) = match f with\nf(num, b00l)-> if b00l then num else wwhile (f, num)"], "message": ["Error: This expression has type int -> int * bool\n       but an expression was expected of type 'a * bool\n", "Error: Syntax error\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = match f b with\n(num, b00l)-> if b00l then num else wwhile (f, num)"], "bad": ["let rec wwhile (f,b) = let f b in match t with\n()-> if b00l then num else wwhile (f, num)", "let rec wwhile (f,b) = fun f b in match t with\n()-> if b00l then num else wwhile (f, num)", "let rec wwhile (f,b) = fun f b match t with\n()-> if b00l then num else wwhile (f, num)", "let rec wwhile (f,b) = match f b with\n()-> if b00l then num else wwhile (f, num)"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value b00l\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile (f b,b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1"], "bad": ["let fixpoint (f,b) = wwhile (fixpoint(f,b),b)"], "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((f b),b)"], "bad": ["let fixpoint (f,b) = wwhile (b,b)", "let fixpoint (f,b) = wwhile (fixpoint (f,b),b)"], "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile (match f with num -> num,b)"], "bad": ["let fixpoint (f,b) = wwhile (match f with num,b)"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["93", "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (0,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"ranjit\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"moose\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "9", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if not(List.mem h seen) then h::seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9;1]", "let _ = removeDuplicates [1;1;6;6;6;9;9]", "let _ = removeDuplicates []", "let _ = removeDuplicates [1]", "let rec wwhile (f,b) = match f b with\n(num, b00l)-> if not(b00l) then num else wwhile (f, num)", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 3)", "let f x = let xx = x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) = wwhile ((fun x -> let y = (f,x) in (y, y != x)),b)"], "bad": ["let fixpoint (f,b) = wwhile ((),b)"], "message": ["Error: This expression has type unit but an expression was expected of type\n         'a -> 'a * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((fun x -> let y = (f x) in (y, y != x)),b)"], "bad": ["let fixpoint (f,b) = wwhile ((fun x -> let y = (f,x) in (y, y != b)),b)"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside 'a * 'b\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin (pi*\" ^ exprToString e ^\")\""], "bad": ["let rec exprToString e = match e with\nThresh (a,b,c,d) -> exprToString a b c d", "let rec exprToString e = match e with\nThresh (a,b,c,d) -> \n(exprToString a, exprToString b,exprToString c,exprToString d)", "let rec exprToString e = match e with\nVarX x -> \"x\"\n| VarY y -> \"y\"\n| Sine s -> \"sin (pi*\" ^ exprString e ^\")\"", "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin (pi*\" ^ exprString e ^\")\""], "message": ["Error: This expression has type 'a but an expression was expected of type\n         expr -> expr -> expr -> 'a\n       The type variable 'a occurs inside expr -> expr -> expr -> 'a\n", "Error: This expression has type 'a * 'b * 'c * 'd\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b * 'c * 'd\n", "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: Unbound value exprString\nHint: Did you mean exprToString?\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with\nVarX           -> \"x\"\n| VarY           -> \"y\"\n| Sine e         -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e       -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Average (e,f)  -> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)  -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\""], "bad": ["let rec exprToString e = match e with\nVarX     -> \"x\"\n| VarY     -> \"y\"\n| Sine e   -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Averages -> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString e ^ \")/2)\"\n| Times    -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString e ^ \")\"\n| Thresh   \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString e ^ \"?\" ^ exprToString e ^ \":\" ^ exprToString e ^ \")\"", "let rec exprToString e = match e with\nVarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e    -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e  -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Average e -> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString e ^ \")/2)\"\n| Times e   -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString e ^ \")\"\n| Thresh e  \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString e ^ \"?\" ^ exprToString e ^ \":\" ^ exprToString e ^ \")\"", "let rec exprToString e = match e with\nVarX       -> \"x\"\n| VarY       -> \"y\"\n| Sine e     -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e   -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Average e e-> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString e ^ \")/2)\"\n| Times e e  -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString e ^ \")\"\n| Thresh e e e e \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString e ^ \"?\" ^ exprToString e ^ \":\" ^ exprToString e ^ \")\"", "let rec exprToString e = match e with\nVarX       -> \"x\"\n| VarY       -> \"y\"\n| Sine e     -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e   -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Average e f-> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times e f  -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh e f g h \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"", "let rec exprToString e = match e with\nVarX       -> \"x\"\n| VarY       -> \"y\"\n| Sine e     -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e   -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Average (e,f)-> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times (e,f)  -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh e f g h \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\""], "message": ["Error: This variant pattern is expected to have type expr\n       The constructor Averages does not belong to type expr\nHint: Did you mean Average?\n", "Error: The constructor Average expects 2 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> failwith \"sad\""], "bad": ["let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (x,y)    -> (eval (e,x,y) +. eval(e,x,y))/.2.0\n| Times   (x,y)    -> eval(e,x,y) *. eval(e,x,y)\n| Thresh (e1,e2,e3,e4) -> failwith \"sad\""], "message": ["Error: This expression has type expr but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)"], "bad": ["let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )", "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )", "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n( eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )", "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n( eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : e4 )", "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n( eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )", "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )", "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e3,x,y) )", "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) )", "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \neval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y)", "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \neval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y)", "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n(val(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y))", "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y))", "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \neval(e1,x,y) < eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y)"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound type constructor e4\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This function has type expr * float * float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nif(depth > 0) then\nif rand mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rand mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"], "bad": ["let rec build (rand, depth) = \nif(depth > 0) then\nif rand%5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand%5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand%5 = 2 then buildAverage(buildX(),buildY())\nelse if rand%5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand%2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "let rec build (rand, depth) = \nif(depth > 0) then\nif rand%.5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand%5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand%5 = 2 then buildAverage(buildX(),buildY())\nelse if rand%5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand%2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"], "message": ["Error: Unbound value %\n", "Error: Unbound value %.\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand 0 100 in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand 0 100 in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"], "bad": ["let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand 0 100 in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand 0 100 in\nif rand mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"], "message": ["Error: This expression has type int -> int -> int\n       but an expression was expected of type int\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let _ = doRandomGray (10, 10,39)"], "bad": ["let _ doRandomGray (10, 10,39)"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nFormat.sprintf \"%d\" depth in\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "let g1 () = failwith \"to be implemented\"", "let g2 () = failwith \"to be implemented\"", "let g3 () = failwith \"to be implemented\"", "let c1 () = failwith \"to be implemented\"", "let c2 () = failwith \"to be implemented\"", "let c3 () = failwith \"to be implemented\"", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = doRandomGray (55, 13,312)"], "bad": ["let rec build (rand, depth) = \nFormat.sprintf \"%d\" depth\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"], "message": ["Error: Syntax error\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \n\nif(depth > 0) then\nFormat.printf \"%d\" depth"], "bad": ["let rec build (rand, depth) = \n\nif(depth > 0) then\nFormat.sprintf \"%d\" depth"], "message": ["Error: This expression has type string but an expression was expected of type\n         unit\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nlet _ = Format.printf \"%d\" depth in\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"], "bad": ["let rec build (rand, depth) = \n\nif(depth > 0) then\nFormat.printf \"%d\" depth in\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "let rec build (rand, depth) = \nFormat.printf \"%d\" depth\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "let rec build (rand, depth) = \nlet _ = Format.printf \"%d\" depth\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) +. cos(pi*.eval(e,x,y)))*.cos(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/.cos(pi*.eval(e,x,y))", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)"], "bad": ["let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) +. cos(pi*.eval(e,x,y)))*cos(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/cos(pi*.eval(e,x,y))"], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 5) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse (*if rnd mod 7=5 then*)\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\n(*else\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))*)\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "let g1 () = (10,10,10)", "let g2 () = (7,68,488)", "let g3 () = (8,84,872)", "let c1 () = (9,24,987)", "let c2 () = (6,0,164)", "let c3 () = (8,84,282)", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type test = unit -> string", "let key = \"\"", "let prefix130 = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")", "let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0", "let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)", "let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))", "let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p", "let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max", "let _ =\nlet report = Li"], "bad": ["let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 5) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse (*if rnd mod 7=5 then*)\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\n(*else\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))*)\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()"], "message": ["Error: Syntax error\n"], "problem": "build"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = a+x in\nlet base = 0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a x in\nlet base = 0 in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: Unbound value pipe\n", "Error: Unbound value pipe\n", "Error: Unbound value pipe\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x =  f x a  in\nlet base =  fun x -> x in\nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =  fun a -> x  in\nlet base =  fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x =  a + x  in\nlet base =  fun x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =  (fun a->x) a  in\nlet base =  fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x =  fun x -> a  in\nlet base =  fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x =  f (fun a->x)-> a  in\nlet base =  fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x =  f (fun a->x) a  in\nlet base =  fun x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n", "Error: Syntax error\n", "Error: Unbound value f\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =   (fun a->x) x in\nlet base =  fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x =  a (fun a->x) in\nlet base =  fun x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type (('a -> 'b) -> 'c) -> 'b -> 'c\n       but an expression was expected of type\n         (('a -> 'b) -> 'c) -> 'b -> ('a -> 'b) -> 'c\n       The type variable 'c occurs inside ('a -> 'b) -> 'c\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =   (fun a->x) a in\nlet base =  fun x -> x in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "bad": ["let pipe fs = \nlet f a x =   (fun a>x) a in\nlet base =  fun x -> x in\nList.fold_left f base fs"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x =   (fun x->a) a in\nlet base =  0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x =   (fun x->a) a in\nlet base =  x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x =   (fun x->a) a in\nlet base =  a in\nList.fold_left f base fs"], "message": ["Error: Unbound value x\n", "Error: Unbound value a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep  in\nlet base = h in\nlet l = t in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x (a^sep)  in\nlet base = h in\nlet l = t in\nList.fold_left f base l"], "message": ["Error: This expression has type string list\n       but an expression was expected of type (string -> string) list\n       Type string is not compatible with type string -> string \n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^sep  in\nlet base = h in\nlet l = t in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep  in\nlet base = h in\nlet l = x in\nList.fold_left f base l"], "message": ["Error: Unbound value x\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let stringOfList f l =  List.map f l"], "bad": ["let stringOfList f l = f (pipe List.map l)"], "message": ["Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type ('c -> 'c) list\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l =  sepConcat \"\" (List.map f l)", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"], "bad": ["let stringOfList f l =  sepConcat f (List.map f l)"], "message": ["Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l =  sepConcat \"[]\" (List.map f l)"], "bad": ["let stringOfList f l =  sepConcat (List.map f l) l"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l =  sepConcat \"\" (List.map f l)", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"], "bad": ["let stringOfList f l = (List.map f (sepConcat \"\" l))"], "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let rec clone x n = match n with\n0    -> []\n| _ ->  x::clone x (n-1)"], "bad": ["let rec clone x n = match n with\n0    -> []\n| h::t ->  x::clone x (n-1)"], "message": ["Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let rec clone x n = if n <= 0 then [] else x::clone x (n-1)"], "bad": ["let rec clone x n = match n with\nn <= 0 -> []\n| _      ->  x::clone x (n-1)", "let rec clone x n = match n with\nn < 0 -> []\n| _      ->  x::clone x (n-1)", "let rec clone x n = match n with\nn = 0 -> []\n| _      ->  x::clone x (n-1)"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let padZero l1 l2 =\nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) \nelse if (s2<s1) then (l1, (clone 0 (s1-s2))@l2)\nelse (l1,l2)"], "bad": ["let padZero l1 l2 =\nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then (clone 0 l1, l2) \nelse if (s2<s1) then (l1, clone 0 l2)\nelse (l1,l2)", "let padZero l1 l2 =\nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) \nelse if (s2<s1) then (l1, (clone 0 s1-s2)@l2)\nelse (l1,l2)"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let rec removeZero l = match l with\n[]  -> []\n| h1::h2::t-> if(h1=0 && h2!=0) then removeZero t else h1::removeZero t"], "bad": ["let rec removeZero l = match l with\nh   -> if (h != 0) then []\n| h::t-> if(h=0) then removeZero t else h::removeZero t", "let rec removeZero l = match l with\n[]  -> []\n| h1::h2::t-> if(h1=0 && h2!=0) then removeZero t else h::removeZero t"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: Unbound value h\n"], "problem": "removeZero"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\"\nin\nlet base = ([],[]) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\"\nin\nlet base = [] in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n[]   -> []\n| h::t -> []\nin\nlet base = ([],[]) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n[]   -> []\n| h::t -> []\nin\nlet base = [] in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x =   fun b -> x (a b) in\nlet base =  fun x -> x in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 4", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 9", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x  in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l =  \"[\"^(sepConcat \"; \" (List.map f l))^\"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n = if n <= 0 then [] else x::clone x (n-1)", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let padZero l1 l2 =\nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) \nelse if (s2<s1) then (l1, (clone 0 (s1-s2))@l2)\nelse (l1,l2)", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let _ = padZero [1;2] [9;9]", "let rec removeZero l = match l with\n[]  -> []\n| h::t-> if(h!=0) then h::t else removeZero t", "let _ = removeZero [0;0;0;1;0;0;2]", "let _ = removeZero [9;9]", "let _ = removeZero [0;0;0;0]", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n([],[])   -> []\nin\nlet base = ([],[]) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n[]   -> ([],[])\n| h::t -> ([],[])\nin\nlet base = ([],[]) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n([],[])   -> []\nin\nlet base = ([],[]) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\"\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n[]   -> []\nin\nlet base = ([],[]) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\"\nin\nlet base =  [] in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x =   fun b -> x (a b) in\nlet base =  fun x -> x in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 4", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 9", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x  in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l =  \"[\"^(sepConcat \"; \" (List.map f l))^\"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n = if n <= 0 then [] else x::clone x (n-1)", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let padZero l1 l2 =\nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) \nelse if (s2<s1) then (l1, (clone 0 (s1-s2))@l2)\nelse (l1,l2)", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let _ = padZero [1;2] [9;9]", "let rec removeZero l = match l with\n[]  -> []\n| h::t-> if(h!=0) then h::t else removeZero t", "let _ = removeZero [0;0;0;1;0;0;2]", "let _ = removeZero [9;9]", "let _ = removeZero [0;0;0;0]", "let _ = List.combine (List.rev [9;9]) (List.rev [0;0])", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\"\nin\nlet base =  (0, []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\n([], []) -> []\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n([], []) -> []\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n([], []) -> []\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n[] -> []\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n[] -> []\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n[] -> ([], [])\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n[] -> ([], [])\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\"\nin\nlet base =  [] in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\"\nin\nlet base =  fun x -> x in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a list * 'b list -> 'c -> 'd list\n       but an expression was expected of type\n         'a list * 'b list -> 'c -> 'a list * 'b list\n       Type 'd list is not compatible with type 'a list * 'b list \n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n", "Error: This expression has type 'a list -> 'b -> 'c list * 'd list\n       but an expression was expected of type 'a list -> 'b -> 'a list\n       Type 'c list * 'd list is not compatible with type 'a list \n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'b * 'c\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (snd a) with\n[]  -> (fst x + snd x, ((fst x + snd x)/10)::[(fst x + snd x) mod 10]) \n|h::t -> (0, [] )\nin\nlet base =  (0, []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n(c, h::t) -> []\nin\nlet base =  (0, []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a * 'b list -> 'c -> 'd list\n       but an expression was expected of type\n         'a * 'b list -> 'c -> 'a * 'b list\n       Type 'd list is not compatible with type 'a * 'b list \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = match i with\n0 -> []\n| 1 -> l\n| 2 -> bigAdd l l\n| _ -> bigAdd (mulByDigit (i-2) l) (mulByDigit i l)"], "bad": ["let rec mulByDigit i l = \nlet lr = List.rev l in\nmatch lr with\n(_,[])   -> ((fst x * snd x)/10, [(fst x * snd x) mod 10]) \n| (c,h::t) -> \nlet sum = c + (fst x * snd x) in\n(sum/10, (sum mod 10)::(snd a))", "let rec mulByDigit i l = match i with\n0 -> []\n| 1 -> l\n| 2 -> bigAdd l l\n| _ -> bigAdd (mulByDigit (i-2) l) (mulBydigit i l)"], "message": ["Error: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type 'c list\n", "Error: Unbound value mulBydigit\nHint: Did you mean mulByDigit?\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let _ = mulByDigit 9999999999999 [9;9;9;9]"], "bad": ["let _ = mulByDigit 99999999999999999999 [9;9;9;9]"], "message": ["Error: Integer literal exceeds the range of representable integers of type int\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) x)) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x =  match a with\n(_,[])   -> mulByDigit (fst x) l1\n|(c, h::t) -> (c, mulByDigit h x)\nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x =  match a with\n(_,[])   -> mulByDigit (fst x) l1\nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = (fst a, bigAdd () ()) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type 'a * 'b list -> int * 'c -> int list\n       but an expression was expected of type\n         'a * 'b list -> int * 'c -> 'a * 'b list\n       Type int list is not compatible with type 'a * 'b list \n", "Error: This variant expression is expected to have type int list\n       The constructor () does not belong to type list\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) x )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let _ = bigMul [9;9;9;9] [9;9;9;9]", "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]", "let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd snd x (mulByDigit (fst a) x )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This function has type int list -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) (x@ clone 0 (fst a)) )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) (snd x) )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) (l1@ clone 0 (fst a)) )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let _ = bigMul [9;9;9;9] [9;9;9;9]", "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"], "bad": ["let _ = bigMul [9;9;9;9] [9;9;9;9]", "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = \n((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd x (mulByDigit x (l1@ clone 0 (fst a)) )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = match a with\n(0, [])   -> (0, mulByDigit x (l1@ clone 0 0))\n| (c, a) -> (c+1, bigAdd a (mulByDigit x (l1@clone 0 c)))\n(*((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))*)\n\nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = match a with\n(0, [])   -> (0, mulByDigit x (l1@ clone 0 []))\n| (c, a) -> (c+1, bigAdd a (mulByDigit x (l1@clone 0 c))\n(*((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))*)\n\nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = match a with\n(0, [])   -> (0, mulByDigit x (l1@ clone 0 []))\n| (c, a) -> (c+1, bigAdd a (mulByDigit x (l1@clone 0 c)))\n(*((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))*)\n\nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Characters 105-106:\n  | (c, a) -> (c+1, bigAdd a (mulByDigit x (l1@clone 0 c))\n              ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = match a with\n(((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))\n\nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let _ = bigMul [9;9;9;9] [9;9;9;9]", "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]", "let key = \"\"", "let prefix130 = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")", "let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0", "let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)", "let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))", "let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p", "let wrap_curried_2 f (a,b) = f a b", "let"], "bad": ["let bigMul l1 l2 = \nlet f a x = match a with\n((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))\n\nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Characters 46-47:\n  ((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))\n   ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "bigMul"}
{"hw": "hw1", "fix": ["let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0"], "bad": ["let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList List.tl xs\nelse\n0"], "message": ["Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type int list\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let _ = sumList [1; 3; 5; 7; 9; 11]"], "bad": ["let _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n5 mod 4", "let _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n5 mod 4", "let _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n5 mod 4"], "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n>0 then\n[2]\nelse\n[1]"], "bad": ["let rec digitsOfInt n = \nif n>0 then\ndigitOfInt n/10 @ ( n mod 10 ::[])\nelse\n[]", "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10 @ ( n mod 10 ::[])\nelse\n[]", "let rec digitsOfInt n = \nif n>0 then\n(digitsOfInt n/10) @ ( n mod 10 ::[])\nelse\n[]", "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10 \nelse\n[]", "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10 \nelse\n[1;]", "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10 \nelse\n[1]", "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10 \nelse\n[1]"], "message": ["Error: Unbound value digitOfInt\nHint: Did you mean digitsOfInt?\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n>0 then\n[5]@ digitsOfInt (n/10)\nelse\n[1]"], "bad": ["let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10\nelse\n[]", "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10\nelse\n[]", "let rec digitsOfInt n = \nif n>0 then\n[5]@ digitsOfInt n/10\nelse\n[1]"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["digits (-23422)"], "bad": ["digits (-23422) is [2,3,4,2,2]"], "message": ["Error: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec additivePersistence n =\nif n>0 then\n1+ additivePersistence (help n)\nelse\n0"], "bad": ["let rec additivePersistence n =\nif n>0 then\n1+ additivePersistence help  n\nelse\n0"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec listReverse l = \nif List.length l >0 then\n(List.hd l ::[])\nelse\n[]"], "bad": ["let rec listReverse l = \nif List.length>0 then\n(listReverse List.tl l) @ (List.hd l ::[])\nelse\n[]", "let rec listReverse l = \nif List.length l >0 then\n(listReverse List.tl l) @ (List.hd l ::[])\nelse\n[]"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list -> int\n", "Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'b list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)"], "bad": ["let rec sumList xs = match xs with\n[]->0\n|List.hd xs + sumList (List.tl xs)", "let rec sumList xs = match xs with\n[]->0\n| List.hd xs + sumList (List.tl xs)"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let rec listReverse l = match l with\n[]->[]\n|h::x->(listReverse x) @ h"], "bad": ["let rec listReverse l = match l with\n[]->[]\n|h:x->(listReverse x) @ h"], "message": ["Error: Syntax error\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n>10 then\n(n mod 10):: (digitsOfInt (n/10))\nelse\n[n]"], "bad": ["let rec digitsOfInt n = \nif n>10 then\n(n mod 10):: (digitsOfInt (n/10)\nelse\n[n]"], "message": ["Characters 51-52:\n  (n mod 10):: (digitsOfInt (n/10)\n               ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n>=100 then\n[n mod 10]\nelse\n[n]"], "bad": ["let rec digitsOfInt n = \nif n>10 then\n(digitsOfInt (n/10))::[n mod 10]\nelse\nn", "let rec digitsOfInt n = \nif n>10 then\nn::[n mod 10]\nelse\nn"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10])\nelse\n[n]", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663"], "bad": ["let rec digitsOfInt n = \nif n>10 then\napp ((digitsOfInt (n/10)) [n mod 10])\nelse\n[n]", "let rec digitsOfInt n = \nif n>10 then\napp ((digitsOfInt (n/10)) [n mod 10])\nelse\n[n]", "let rec digitsOfInt n = \nif n>=10 then\napp ((digitsOfInt (n/10)) [n mod 10])\nelse\nn::[]", "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10])\nelse\n\n\n\n\n(* uncomment and run AFTER you have implemented digitsOfInt *)\nlet _ = digitsOfInt 3124"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n", "Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n>=10 then\ndigitsOfInt (n/10) @ [n mod 10]\nelse\n[n]"], "bad": ["let rec digitsOfInt n = \nif n>=10 then\napp digitsOfInt (n/10) [n mod 10]\nelse\n[n]"], "message": ["Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n>=10 then\n(digitsOfInt (n/10)) @ ([n mod 10])\nelse\n[n]"], "bad": ["let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10])\nelse\n[n]", "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10])\nelse\nn", "let rec digitsOfInt n = \nif n>=10 then\napp ((digitsOfInt (n/10)) ([n mod 10]))\nelse\n[n]", "let rec digitsOfInt n = \nif n>=10 then\napp ((digitsOfInt (n/10)) ([n mod 10]))\nelse\n[n+0]"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n", "Error: This expression has type int but an expression was expected of type\n         int list -> int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec helpFac a b=\nif 10*a>b then\na\nelse\nhelpFac (10*a) b"], "bad": ["let rec helpFac a b=\nif 10*a>b then\na\nelse\n10*a b", "let rec helpFac a b=\nif 10*a>b then\na\nelse\nhelpFac 10*a b"], "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n>=10 then\n(n/(helpFac n 1))::digitsOfInt (n/10)\nelse\n[n]"], "bad": ["let rec digitsOfInt n = \nif n>=10 then\n(n/(help n 1))::digitsOfInt (n/10)\nelse\n[n]"], "message": ["Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["helpFac 3124 1"], "bad": ["helpFac (3124 1)"], "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n>=10 then\napp [5] [n mod 10] \nelse\napp [3] [8]"], "bad": ["let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10]) \nelse\n[n]", "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10]) \nelse\napp [n] []", "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10]) \nelse\napp [n] [8]", "let rec digitsOfInt n = \nif n>=10 then\napp ([n/10] [n mod 10]) \nelse\napp [3] [8]", "let rec digitsOfInt n = \nif n>=10 then\napp ([(n/10)] [n mod 10]) \nelse\napp [3] [8]", "let rec digitsOfInt n = \nif n>=10 then\napp ([n/10] [n mod 10]) \nelse\napp [3] [8]", "let rec digitsOfInt n = \nif n>=10 then\napp ([n / 10] [n mod 10]) \nelse\napp [3] [8]"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n", "Error: This expression has type int list\n       but an expression was expected of type int list -> int list\n", "Error: This expression has type int list\n       but an expression was expected of type int list -> int list\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)) [n mod 10] \nelse\napp [3] [8]"], "bad": ["let rec digitsOfInt n = \nif n>=10 then\napp digitsOfInt n/10 [n mod 10] \nelse\napp [3] [8]", "let rec digitsOfInt n = \nif n>=10 then\napp digitsOfInt (n/10) [n mod 10] \nelse\napp [3] [8]"], "message": ["Error: This expression has type int -> 'a\n       but an expression was expected of type 'b list\n", "Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let _ = digitsOfInt 3124"], "bad": ["let _ = digitsOfInt 3124let _ =digitsOfInt 1001"], "message": ["Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) (n mod 10::ls)\nelse\n[n]\nin\ndriver n []"], "bad": ["let digitsOfInt n = \nlet driver n ls=\nif n>=10 then\ndriver n/10 (n mod 10::ls)\nelse\n[n]\nin\ndriver n []", "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver n/10 (n mod 10::ls)\nelse\n[n]\nin\ndriver n []"], "message": ["Error: Unbound value driver\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) ((n mod 10)::ls)\nelse\nls\nin\ndriver (n*10) []"], "bad": ["let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) ((n mod 10)::ls)\nelse\nls\nin\ndriver n*10 []"], "message": ["Error: This expression has type int list -> int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let additivePersistence n =let rec county n=\nif n>=10 then\n1+ additivePersistence (help n)\nelse\n0\nin \ncounty n"], "bad": ["let additivePersistence n =let rec county=\nif n>=10 then\n1+ additivePersistence (help n)\nelse\n0\nin \ncounty n"], "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\nError: Unbound value help\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"], "problem": "additivePersistence"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "let _=(assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]))", "let _=(assoc (-1,\"bob\",[(\"ranj it\",85);(\"william\",23);(\"moose\",44)]))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then\nseen \nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \n\nin\nList.rev (helper ([],l))"], "bad": [" _=(removeDuplicates [1,6,2,4,12,2,13,6,9])"], "message": ["Error: Syntax error\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then\nseen \nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \n\nin\nList.rev (helper ([],l))"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem seen h) then\nseen \nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \n\nin\nList.rev (helper ([],l))"], "message": ["Error: This expression has type 'a list list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list list\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then\nseen \nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \n\nin\nList.rev (helper ([],l))"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then\nseen \nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \n\nin\nList.rev helper ([],l)"], "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = match f b with\n|(a,c)->if not c then\na\nelse\nwwhile (f,a)"], "bad": ["let rec wwhile (f,b) = match f b with\n|(a,c)->if not c then\na\nelse\nwwhile f a"], "message": ["Error: This expression has type 'a -> ('b -> 'c) * bool\n       but an expression was expected of type ('a -> ('b -> 'c) * bool) * 'a\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)"], "bad": ["let fixpoint (f,b) = wwhile ((let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x)\n\n,b)", "let fixpoint (f,b) = wwhile ((let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\n(sec (y x) x) )\n\n,b)", "let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\n(sec (y x) x)\n\n,b)", "let fixpoint (f,b) = wwhile ((let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\n(sec (y x) x))\n\n,b)", "let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\n\n,b)", "let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\n\n,b)", "let fixpoint (f,b) = wwhile (let g y x=\n(let sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) )\nin\nsec (y x) x\n\n,b)", "let fixpoint (f,b) = wwhile (let g y x=f b\n,b)", "let fixpoint (f,b) = wwhile (let g y x=y b in\ng y b\n,b)", "let fixpoint (f,b) = wwhile (let g y x=y b in\ng f b\n,b)"], "message": ["Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Unbound value y\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)"], "bad": ["let fixpoint (f,b) = wwhile (let g y x=\n\nin\ng f b\n\n,b)", "let fixpoint (f,b) = wwhile (let g y x= y x\n\nin\ng f b\n\n,b)"], "message": ["Error: This expression has type ('a -> 'a) -> 'a * bool\n       but an expression was expected of type ('a -> 'a) -> ('a -> 'a) * bool\n       The type variable 'a occurs inside 'a -> 'a\n", "Error: Syntax error: operator expected.\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile (let g x=\n\nin\n(g (f b),false)\n\n,b)"], "bad": ["let fixpoint (f,b) = wwhile (let g y x=\n((y x),false)\nin\ng f b\n\n,b)", "let fixpoint (f,b) = wwhile (let g x=\n(x,false)\nin\ng f b\n\n,b)", "let fixpoint (f,b) = wwhile (let g x=\n(x,false)\nin\ng (f b)\n\n,b)", "let fixpoint (f,b) = wwhile (let g x=\nx,false\nin\ng (f b)\n\n,b)", "let fixpoint (f,b) = wwhile (let g x=\nx\nin\ng (f b)\n\n,b)"], "message": ["Error: This expression has type ('a -> 'a) -> 'a * bool\n       but an expression was expected of type ('a -> 'a) -> ('a -> 'a) * bool\n       The type variable 'a occurs inside 'a -> 'a\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "Error: This function has type 'a -> 'a * bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let g x y= ((y x),false)", "let fixpoint (f,b) = wwhile (g b f\n,b)"], "bad": ["let fixpoint (f,b) = wwhile (let g x y= ((y x),false)\nin g b f\n,b)"], "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let g x y= (y (y x),false)"], "bad": ["let g x y= ((y x),false)"], "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let h q x y=q x y", "let g x f= (f x,(f x)=x)", "let fixpoint (f,b) = wwhile (h  g (f) b\n,b)"], "bad": ["let fixpoint (f,b) = wwhile (g b f\n,b)"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let f x = let xx = x*x*x in (xx,xx<100)", "let _ =wwhile (f,2)", "let h x b = b x", "let fixpoint (f,b) = wwhile (h b f,\n,b)"], "bad": ["let fixpoint (f,b) = wwhile (let h x b= b x in h f b", ",\n,b)", "let fixpoint (f,b) = wwhile ((let h x b= b x in h f b),\n,b)", "let fixpoint (f,b) = wwhile ((h x b = b x \nin h f b"], "message": ["Error: Syntax error: operator expected.\n", "Characters 28-29:\n  let fixpoint (f,b) = wwhile (let h x b= b x in h f b;;\n                              ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Error: Syntax error: operator expected.\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let h x y = ((y x),x<100)", "let fixpoint (f,b) = wwhile (h b f\n,b)"], "bad": ["let fixpoint (f,b) = wwhile (let h x y = ((y x),x=x) in\nh b f\n,b)", "let fixpoint (f,b) = wwhile (let h x y = ((y x),x<100) in\nh b f\n,b)"], "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let h x=(x*x,x<100)", "let fixpoint (f,b) = wwhile (h,b)"], "bad": ["let fixpoint (f,b) = wwhile (h b f,b)", "let fixpoint (f,b) = wwhile (f,b)"], "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile (let h a= f a\nin h b,b)"], "bad": ["let fixpoint (f,b) = wwhile (let h = f\nin (h,false),b)", "let fixpoint (f,b) = wwhile (let h a= f\nin h a,b)", "let fixpoint (f,b) = wwhile (let h a= f\nin h b,b)"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: Unbound value a\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile (let h x= (f x,(f x)=x) in\nh,b)"], "bad": ["let fixpoint (f,b) = wwhile (let h x= (f x,false),b)", "let fixpoint (f,b) = wwhile (let h x= (f x,false) in\nh,b)"], "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "Error: Syntax error: operator expected.\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "let _=(assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]))", "let _=(assoc (-1,\"bob\",[(\"ranj it\",85);(\"william\",23);(\"moose\",44)]))", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then\nseen \nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \n\nin\nList.rev (helper ([],l))", "removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) = match f b with\n|(a,c)->if not c then\na\nelse\nwwhile (f,a)", "let f x = let xx = x*x*x in (xx,xx<100)", "let _ =wwhile (f,2)", "let fixpoint (f,b) = wwhile (let h x= let first =f x in\nlet second =f first in \nlet third = f second \nin  (second,not ((first=second)&&(second=third)\n&&(third=first)))\nin\nh,b)"], "bad": ["let fixpoint (f,b) = wwhile (let h x= let first =f x in\nlet second =f first in \nlet third = f second \nin  (second,not ((first=second)&&(second=third)\n&&(third=first))\nin\nh,b)"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["\"x\"\"y\"\"Z\""], "bad": ["\"a\""], "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/. 2\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)"], "bad": ["let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)", "let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)"], "message": ["Error: This expression has type expr\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)"], "bad": ["let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/2\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)", "let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)"], "message": ["Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval (sampleExpr1,0.5,0.2)"], "bad": ["let _ = eval (sampleExpr1,0.5,0.2)"], "message": ["Error: This expression has type expr/2231\n       but an expression was expected of type expr/2334\nError: This expression has type expr/2437\n       but an expression was expected of type expr/2457\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type expr/2231\n       but an expression was expected of type expr/2334\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = let res=rand(0,4) in match depth with\n0-> if (res mod 2)=0 then\nbuildX()\nelse\nbuildY()\n|_ ->let nd=depth-1 in\nmatch res with\n|0->buildAverage(build(rand,nd),build(rand,nd))\n|1->buildThresh(build(rand,nd),build(rand,nd),\nbuild(rand,nd),build(rand,nd))\n|2->buildTimes(build(rand,nd),build(rand,nd))\n|3->buildSine(build(rand,nd))\n|4->buildCosine(build(rand,nd))\n|_->buildX()"], "bad": ["let rec build (rand, depth) = let res=rand(0,4) in match depth with\n0-> if (res mod 2)=0 then\nbuildX()\nelse\nbuildY()\n|_ ->let nd=depth-1 in\nmatch res with\n|0->buildAverage(build(rand,nd),build(rand,nd))\n|1->buildThresh(build(rand,nd),build(rand,nd),\nbuild(rand,nd),build(rand,nd))\n|2->buildTimes(build(rand,nd),build(rand,nd))\n|3->buildSine(build(rand,nd))\n|4->buildCosine(build(rand,nd))"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"], "problem": "build"}
{"hw": "hw2", "fix": ["et rec exprToString e = match e \nwith  \nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine  expr -> \"sin(pi*\"^(exprToString expr)^\")\"\n| Cosine expr-> \"cos(pi*\"^(exprToString expr)^\")\"\n| Average (expr,expr1)->\"((\"^(exprToString expr)^\"+\"\n^(exprToString expr1)^\")/2)\"\n|Times   (expr,expr1)->(exprToString expr)^\"*\"^(exprToString expr1)\n|Nom (expr1,expr2,expr3)->let res1,res2,res3=(exprToString expr1),\n(exprToString expr2),\n(exprToString expr3) \nin\n\"(\"^res1^\"+\"^res2^\"+\"^res3^\")/(abs(\"^res1^\")+abs(\"^res2^\")+abs(\"\n^res3^\"))\"\n\n|Squa expr -> let res=exprToString expr in\n\"abs(\"^res^\")/(abs\"^res^\"+\"^res^\"^2)\"\n| Thresh  (expr,expr1,expr2,expr3)->\"(\"^(exprToString expr)^\"<\"\n^(exprToString expr1)^\"?\"\n^(exprToString expr2)^\":\"^\n(exprToString expr3)"], "bad": ["let rec exprToString e = match e \nwith  \nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine  expr -> \"sin(pi*\"^(exprToString expr)^\")\"\n| Cosine expr-> \"cos(pi*\"^(exprToString expr)^\")\"\n| Average (expr,expr1)->\"((\"^(exprToString expr)^\"+\"\n^(exprToString expr1)^\")/2)\"\n|Times   (expr,expr1)->(exprToString expr)^\"*\"^(exprToString expr1)\n|Nom (expr1,expr2,expr3)->let res1,res2,res3=(exprToString expr1),\n(exprToString expr2),\n(exprToString expr3) \nin\n\"(\"^res1^\"+\"^res2^\"+\"^res3^\")/(abs(\"^res1^\")+abs(\"^res2^\")+abs(\"\n^res3^\"))\"\n\n|Squa expr -> let res=exprToString expr in\n\"abs(\"^res^\")/(abs\"^res^\"+\"^res^\"^2)\"\n| Thresh  (expr,expr1,expr2,expr3)->\"(\"^(exprToString expr)^\"<\"\n^(exprToString expr1)^\"?\"\n^(exprToString expr2)^\":\"^\n(exprToString expr3)"], "message": ["Error: This expression has type string but an expression was expected of type\n         int\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr1,0.5,0.2)"], "bad": ["let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Squa expr->let res=eval(expr,x,y) in res /. ((abs_float res )+. 1.0)\n| Nom (expr,expr1,expr2)-> let r1,r2,r3=(eval(expr,x,y),eval(expr1,x,y),\neval(expr2,x,y)) in\n(r1 +. r2 +. r3) /. ((abs_float r1)+.(abs_float r2)+.(abs_float r3))\n\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)"], "message": ["Error: Unbound value r1\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let c3 () = (4,15,70)"], "bad": ["let c3 () = (11,15,70)"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Squa expr->let res=eval(expr,x,y) in res /. ((abs_float res )+. 1.0)\n| Nom (expr,expr1,expr2)-> let r1,r2,r3=(eval(expr,x,y),eval(expr1,x,y),\neval(expr2,x,y)) in\n(r1 +. r2 +. r3) /. ((abs_float r1)+.(abs_float r2)+.(abs_float r3))\n\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)"], "bad": ["let_=eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _=eval (Sine(Average(VarX,VarY)),0.3,0.3)"], "message": ["Error: This function has type 'a -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value let_\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x))", "fixpoint (g,0)"], "bad": ["let fixpoint (f,b) = wwhile (let h x= let first =x in\nlet second =f first \nin  (second,not ((first=second)))\nin\nh,b)"], "message": ["Error: Unbound value fixpoint\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let buildNom(e,e1,e2)\t\t   = Nom(e,e1,e2)"], "bad": ["let buildNom(e,e1,e2)\t\t   = Nom(e,e1,e2)"], "message": ["Error: Unbound value e\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let _=  (build(makeRand(3,4),3))"], "bad": ["let _= exprToString (build(makeRand(3,4),2))"], "message": ["Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "build"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (fun j y->y) in \nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a x in\nlet base = (fun j y->y) in \nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (fun y->y) in \nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)]"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (fun y->y) in \nList.fold_left f base fs"], "bad": ["let _ = pipe [] 3"], "message": ["Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (fun y->y) in \nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (fun z->z) in \nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = y in \nList.fold_left f base fs"], "message": ["Error: Unbound value y\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = a in\nlet base = fun z->z in \nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x =  in\nlet base = fun z->z in \nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun z->z in \nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (fun a->a) in \nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base = in \nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base =  (fun y->y) in \nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = x a in\nlet base =  a in \nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base =  x in \nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base =  fs in \nList.fold_left f base fs", "let pipe fs = \nlet f a x = x a in\nlet base =  *1 in \nList.fold_left f base fs"], "message": ["Error: Unbound value a\n", "Error: Unbound value x\n", "Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let id=(fun x->x)"], "bad": ["let id=(x->x)"], "message": ["Characters 7-8:\n  let id=(x->x);;\n         ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x a in\nlet base =  (fun x _->x) in \nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let pipe fs = \nlet f a x = a x in\nlet base =  (fun x->x) in \nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base =  (fun x->x) in \nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = x in\nlet base =  (fun x ->x) in \nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a x in\nlet base =  (fun x ->x) in \nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun j->fun y-> x a in\nlet base =  (fun x ->x) in \nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun j->fun x-> a in\nlet base =  (fun x ->x) in \nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun j->a x  in\nlet base =  (fun x ->x) in \nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun j->a-> x  in\nlet base =  (fun x ->x) in \nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let id x= x", "let pipe fs = \nlet f a x = fun j-> (x (a j))  in\nlet base =  (fun x ->x) in \nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         int -> int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = sepConcat sep t in\nList.fold_left f base l"], "message": ["Error: This expression has type string but an expression was expected of type\n         string list\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let stringOfList f l = List.map f l"], "bad": ["let stringOfList f l = map f l", "let stringOfList f l = map f l", "let stringOfList f l = map f l"], "message": ["Error: Unbound value map\nHint: Did you mean max?\n", "Error: Unbound value map\nHint: Did you mean max?\n", "Error: Unbound value map\nHint: Did you mean max?\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l =\"[\"^ (sepConcat \"; \" (List.map f l) )^\"]\""], "bad": ["let stringOfList f l =\"[\"^ (sepConcat \"; \" sepList.map f l) ^\"]\"", "let stringOfList f l =\"[\"^ (sepConcat \"; \" (sepList.map f l) )^\"]\""], "message": ["Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value sepList\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let rec clone x n = let rec  helper xs sub depth=match depth with\n0->xs\n|_->helper (sub::xs) sub (depth-1)\nin helper [] x n"], "bad": ["let rec clone x n = let helper xs sub depth=match depth with\n0->xs\n|_->help (sub::xs) sub (depth -1)", "let rec clone x n = let helper xs sub depth=match depth with\n0->xs\n|_->help (sub::xs) sub (depth-1)", "let rec clone x n = let helper xs sub depth=match depth with\n0->xs\n|_->helper (sub::xs) sub (depth-1)", "let rec clone x n = let helper xs sub depth=match depth with\n0->xs\n|_->helper (sub::xs) sub (depth-1)\nin helper [] x n"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value helper\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["let rec padZero l1 l2 = let sizeDif= (List.length l1)-(List.length l2) in\nlet appendS=(clone ( abs  sizeDif ) 0) in\nif sizeDif<0 then ( appendS@l1,l2)\nelse (l1,appendS@l2)"], "bad": ["let rec padZero l1 l2 = let sizeDif= (List.length l1)-(List.length l2) in\nlet appendS=(clone ( abs  sizeDif ) 0) in\nif sizeDif<0 then ( appendS@l1,l2)\nelse then (l1,appendS@l2)"], "message": ["Error: Syntax error\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,res=(res/10),(res mod 10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],res::c2)\n|y::s->(car::s,(res+y)::c2) in\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,res=(res/10),(res%10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],res::c2)\n|y::s->(car::s,(res+y)::c2)", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = ([10],[10])", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,res=(res/10),(res%10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],res::c2)\n|y::s->(car::s,(res+y)::c2) in\nlet base = ([],[]) in\nlet args = List.combine List.rev l1 List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,res=(res/10),(res mod 10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],res::c2)\n|y::s->(car::s,(res+y)::c2) in\nlet base = ([],[]) in\nlet args = List.combine List.rev l1 List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value %\n", "Error: This function has type 'a list -> 'b list -> ('a * 'b) list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,re=(res/10),(res mod 10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],re::c2)\n|y::s->((car::s),((re+y)mod 10)::c2) in\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,re=(res/10),(res mod 10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],re::c2)\n|y::s->((((re+y)/10)+car)::s),((re+y)mod 10)::c2", ") in\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,re=(res/10),(res mod 10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],re::c2)\n|y::s->let sub=re+y in( ((sub /10) +car)::s),\n((sub mod 10)::c2) in\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,re=(res/10),(res mod 10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],re::c2)\n|y::s->let sub=re+y in ((((sub /10 )+car)::s),\n((sub mod 10)::c2) in\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Characters 205-206:\n  |y::s->let sub=re+y in ((((sub /10 )+car)::s),\n                         ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in\nlet p1,p2=a in\nmatch p2 with \n[]->(p1,(res/10)::(res mod 10)::[])\n|a::b->let re=a+(res mod 10)  in\n(p1,(re/10)::(re mod 10)::b )in\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in\nlet p1,p2=a in\nmatch p2 with \n[]->(res/10)::(res mod 10)::[]\n|a::b->let re=a+(res mod 10)  in\n(re/10)::(re mod 10)::b in\n\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a * int list -> int * int -> int list\n       but an expression was expected of type\n         'a * int list -> int * int -> 'a * int list\n       Type int list is not compatible with type 'a * int list \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = fun j-> (x (a j))  in\nlet base =  (fun x ->x) in \nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _=sepConcat \", \" []", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l =\"[\"^ (sepConcat \"; \" (List.map f l) )^\"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n = let rec  helper xs sub depth=match (depth>0) with\nfalse->xs\n|true->helper (sub::xs) sub (depth-1)\nin helper [] x n", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let rec padZero l1 l2 = let sizeDif= (List.length l1)-(List.length l2) in\nlet appendS=(clone 0 ( abs  sizeDif )) in\nif sizeDif<0 then ( appendS@l1,l2)\nelse (l1,appendS@l2)", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let _ = padZero [9;9] [1;0]", "let rec removeZero l = match l with \n[] ->[]\n|h::t->if(h=0) then\nremoveZero t\nelse\nl", "let _ = removeZero [0;0;0;1;0;0;2]", "let _ = removeZero [9;9]", "let _ = removeZero [0;0;0;0]", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in\nlet p1,p2=a in\nmatch p2 with \n[]->(p1,(res/10)::(res mod 10)::[])\n|a::b->let re=a+(res)  in\n(p1,(re/10)::(re mod 10)::b )in\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]", "let _=bigAdd [5;0;0] [6;0;0]", "let rec mulByDigit i l = let rec helper i l acc=match i with\n0->acc\n|_->helper (i-1) l (bigAdd l  acc)\nin\nhelper i l [0]", "let _ = mulByDigit 0 [9;9;9;9]", "let bigMul l1 l2 = \nlet f a x = let b,c=a in match b with \nd::t-> ((d*10)::t,bigAdd((mulByDigit d*x t) c))\n|_    ->a\nin\n\nlet base =(1::l2,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = s in\nlet base =([0],[0]) in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: Unbound value s\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = let b,c=a in match b with \nd::t-> ((d*10)::t, t)\n|_    ->a\nin\n\nlet base =(1::l2,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = let b,c=a in match b with \nd::t-> ((d*10)::t,bigAdd((mulByDigit (d*x) t) c))\n|_    ->a\nin\n\nlet base =(1::l2,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "problem": "bigMul"}
{"hw": "hw2", "fix": ["let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)"], "bad": ["let _ = fixpoint (collatz, 1)"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile(if f b = b then f, b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)"], "bad": ["let fixpoint (f,b) = wwhile((f::(f b = b)), b)"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'b -> 'b * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile((fun b ->  (f, (f b) != b)), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)"], "bad": ["let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)"], "message": ["Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile(fun b ->  f b, (f b != b), b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)"], "bad": ["let _ = fixpoint (collatz, 3)"], "message": ["Error: Unbound value fixpoint\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))"], "bad": ["let rec exprToString e = match e with\n| VarX -> sprintf\"%s\" e", "let rec exprToString e = match e with\n| VarX -> sprintf(%s) e", "let rec exprToString e = match e with\n| VarX -> sprintf(\"%s\") e", "let rec exprToString e = match e with\n| VarX -> Output.sprintf(\"%s\") e", "let rec exprToString e = match e with\n| VarX -> Module.sprintf(\"%s\") e", "let rec exprToString e = match e with\n| VarX     -> \"%s\" e\n| VarY     -> \"\"\n| Sine  \n| Cosine   \n| Average  \n| Times    \n| Thresh", "let rec exprToString e = match e with\n| VarX     -> \"%s\" e\n| VarY     -> \"%s\" e\n| Sine     ->\n| Cosine   ->\n| Average  ->\n| Times    ->\n| Thresh   ->", "let rec exprToString e = match e with\n| VarX     -> \"%s\" e\n| VarY     -> \"%s\" e\n| Sine     -> \"%s\" e\n| Cosine   -> \"%s\" e\n| Average  -> \"%s\" e\n| Times    -> \"%s\" e\n| Thresh   -> \"%s\" e", "let rec exprToString e = match e with\n| VarX     -> \"%s\" e\n| VarY     -> \"%s\" e\n| Sine     -> \"%s %s\" e e\n| Cosine   -> \"%s\" e\n| Average  -> \"%s\" e\n| Times    -> \"%s\" e\n| Thresh   -> \"%s\" e", "let rec exprToString e = match e with\n| VarX     -> \"%s\" e\n| VarY     -> \"%s\" e\n| Sine     -> \"%s %s\" e \n| Cosine   -> \"%s\" e\n| Average  -> \"%s\" e\n| Times    -> \"%s\" e\n| Thresh   -> \"%s\" e", "let rec exprToString e = match e with\n| VarX              -> \"%s\" e\n| VarY              -> \"%s\" e\n| Sine (e)          -> \"%s\" e \n| Cosine (e)        -> \"%s\" e\n| Average (e,e)     -> \"%s\" e\n| Times (e,e)       -> \"%s\" e\n| Thresh (e,e,e,e)  -> \"%s\" e", "let rec exprToString e = match e with\n| VarX              -> \"%s\" e\n| VarY              -> \"%s\" e\n| Sine (e1)          -> \"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "let rec exprToString e = match e with\n| VarX              -> sprintf\"%s\" e\n| VarY              -> \"%s\" e\n| Sine (e1)          -> \"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\" e\n| VarY              -> \"%s\" e\n| Sine (e1)          -> \"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> \"%s\" e\n| Sine (e1)          -> \"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"e1\"\n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.printf\"e1\"\n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%d\" e1\n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%x\" e1\n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"e1\" \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"e1\" \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0", "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0", "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "let rec exprToString e = match e with\n| VarX x             -> x\n| VarY y             -> y\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "let rec exprToString e = match e with\n| VarX              -> e\n| VarY y             -> y\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "let rec exprToString e = match e with\n| VarX              -> e\n| VarY y             -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "let rec exprToString e = match e with\n| VarX              -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "let rec exprToString e = match e with\n| VarX              -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\" e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "let rec exprToString e = match e with\n| VarX e          -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "let rec exprToString e = match e with\n| VarX e          -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\"", "let rec exprToString e = match e with\n| VarX           -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\"", "let rec exprToString e = match e with\n| VarX           -> \"\"::e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\"", "let rec exprToString e = match e with\n| VarX -> \n\"%d\" e\n| VarY -> \ne\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\"", "let rec exprToString e = match e with\n| VarX -> \nPrintf.sprintf\"%d\" e\n| VarY -> \ne\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\"", "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\""], "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: Unbound value sprintf\n", "Characters 55-56:\n  | VarX -> sprintf(%s) e;;\n                   ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Unbound value sprintf\n", "Error: Unbound module Output\n", "Error: Unbound module Module\n", "Error: Syntax error: pattern expected.\n", "Error: Syntax error\n", "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "Error: Variable e is bound several times in this matching\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: Unbound value sprintf\n", "Error: This expression has type expr but an expression was expected of type\n         string\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type expr but an expression was expected of type\n         string\n", "Error: This expression has type string but an expression was expected of type\n         string -> string\n", "Error: This expression has type unit but an expression was expected of type\n         string -> string\n", "Error: This expression has type expr but an expression was expected of type\n         int\n", "Error: This expression has type expr but an expression was expected of type\n         int\n", "Error: This expression has type string but an expression was expected of type\n         string -> string\n", "Error: This expression has type string but an expression was expected of type\n         string -> string\n", "Error: This expression has type string -> string\n       but an expression was expected of type string\n", "Error: This expression has type string -> string\n       but an expression was expected of type string\n", "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: The constructor VarY expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: The constructor VarY expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: This expression has type expr but an expression was expected of type\n         string\n", "Error: This expression has type expr but an expression was expected of type\n         string\n", "Error: This expression has type expr but an expression was expected of type\n         string\n", "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: This expression has type expr but an expression was expected of type\n         string\n", "Error: This expression has type expr but an expression was expected of type\n         string list\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type expr but an expression was expected of type\n         int\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(eval e0)\n| Cosine e1 ->\ncos(eval e1)\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\nif (eval e6)<(eval e7) then (eval e8)\nelse (eval e9)", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(eval e0)\n| Cosine e1 ->\ncos(eval e1)\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\n(eval e6)<(eval e7)?(eval e8):(eval e9)", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) =\nfailwith \"ugh\"", "let g1 () = failwith \"to be implemented\"", "let g2 () = failwith \"to be implemented\"", "let g3 () = failwith \"to be implemented\"", "let c1 () = failwith \"to be implemented\"", "let c2 () = failwith \"to be implemented\"", "let c3 () = failwith \"to be implemented\"", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type test = unit -> string", "let key = \"\"", "let prefix130 = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")", "let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0", "let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)", "let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))", "let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p", "let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max"], "bad": ["let rec build (rand, depth) =\nif depth = 0 then \nif (rand mod 2) = 0 then buildX()\nelse buildY()\nelse if (rand mod 5) = 0 then \nbuildSine(build(rand, depth - 1))\nelse if (rand mod 5) = 1 then \nbuildCosine(build(rand, depth - 1))\nelse if (rand mod 5) = 2 then \nbuildAverage(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 3 then \nbuildAverage(build(rand, depth - 1))\nelse if (rand mod 5) = 4 then \nbuildThresh(build(rand, depth -1))", "let rec build (rand, depth) =\nif depth = 0 then \nif (rand mod 2) = 0 then buildX()\nelse buildY()\nelse if (rand mod 5) = 0 then \nbuildSine(build(rand, depth - 1))\nelse if (rand mod 5) = 1 then \nbuildCosine(build(rand, depth - 1))\nelse if (rand mod 5) = 2 then \nbuildAverage(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 3 then \nbuildTimes(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 4 then \nbuildThresh(build(rand, depth -1),build(rand, depth - 1),build(rand, depth - 1),build(rand, depth - 1))"], "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * expr\n", "Error: This expression has type expr but an expression was expected of type\n         expr * expr\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let _ = eval (sampleExpr,0.5,0.2)"], "bad": ["let _ = eval (sampleExpr,0.5,0.2)"], "message": ["Error: This expression has type int * int -> int\n       but an expression was expected of type int\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)"], "bad": ["let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)"], "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), build(rand, depth - 2))\n| 3 ->\nbuildTimes(build(rand, depth - 2), build(rand, depth - 2))\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))\n| _ -> buildY()"], "bad": ["let rand = \n\nlet rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), build(rand, depth - 2))\n| 3 ->\nbuildTimes(build(rand depth - 2), build(rand,depth - 2))\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth -4))", "let rand = \n\nlet rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), build(rand, depth - 2))\n| 3 ->\nbuildTimes(build(rand, depth - 2), build(rand, depth - 2))\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))", "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), build(rand, depth - 2))\n| 3 ->\nbuildTimes(build(rand, depth - 2), build(rand, depth - 2))\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))"], "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "build"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| h::t -> f h h\n| [] -> fun x -> x in \nList.fold_left f base fs", "let _ = pipe [] 3"], "bad": ["let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| (b, c)::t -> f b c\n| [] -> fun x -> x in \nList.fold_left f base fs", "let _ = pipe [] 3", "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| h::t -> f h t\n| [] -> fun x -> x in \nList.fold_left f base fs", "let _ = pipe [] 3"], "message": ["Error: This expression has type (('a -> 'b) * ('b -> 'a)) list\n       but an expression was expected of type ('b -> 'b) list\n       Type ('a -> 'b) * ('b -> 'a) is not compatible with type 'b -> 'b \n", "Error: Unbound value pipe\n", "Error: This expression has type ('a -> 'b) list\n       but an expression was expected of type 'c -> 'a\n", "Error: Unbound value pipe\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| h::t -> f (fun x -> x) h\n| [] -> fun x -> x in \nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "bad": ["let pipe fs = \nlet f a x = fun g -> x (a g) in\nlet base = match fs with \n| (fun b -> c)::t -> f (fun x -> x) h\n| [] -> fun x -> x in \nList.fold_left f base fs"], "message": ["Error: Syntax error: operator expected.\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = h in\nlet l = h in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]"], "message": ["Error: This expression has type string but an expression was expected of type\n         string list\n", "Error: Unbound value sepConcat\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet g a x = a ^ \";\" ^ x in\nlet base = f h in \nlet x = t in\nList.fold_left g base l", "let _ = stringOfList string_of_int [1;2;3;4;5;6]"], "bad": ["let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet g a x = a ^ \";\" ^ x in\nlet base = f h in \nlet x = f t in\nList.fold_left g base x", "let _ = stringOfList string_of_int [1;2;3;4;5;6]"], "message": ["Error: This expression has type int -> string\n       but an expression was expected of type string -> string\n       Type int is not compatible with type string \n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type int -> string\n       but an expression was expected of type string -> string\n       Type int is not compatible with type string \n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet m b = \"[\" ^ b ^ \"]\" in\nlet n a x = a ^ \" ;\" ^ x in\nlet base = f h in \nList.fold_left n base t", "let _ = stringOfList string_of_int [1;2;3;4;5;6]"], "bad": ["let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet m b = \"[\" ^ b ^ \"]\" in\nlet n a x = a ^ \" ;\" ^ x in\nlet base = f h in \nList.fold_left g base t", "let _ = stringOfList string_of_int [1;2;3;4;5;6]"], "message": ["Error: Unbound value g\n", "Error: This expression has type int -> string\n       but an expression was expected of type string -> string\n       Type int is not compatible with type string \n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet m a b = \"[\" ^ a ^ \";\" ^ b ^ \"]\" in\nlet base = f h in \nList.fold_left m base l"], "bad": ["let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet m a b = \"[\" ^ a ^ \";\" b ^ \"]\" in\nlet base = f h in \nList.fold_left m base l"], "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet m a b = \"[\" ^ a ^ \";\" ^ b ^ \"]\" in\nlet base = f h in \nList.fold_left m base l"], "bad": ["let _ = stringOfList (fun x -> x) [\"foo\"]"], "message": ["Error: This expression has type string list\n       but an expression was expected of type string\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let _ = stringOfList (fun x -> x) [\"foo\"]"], "bad": ["let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let _ = stringOfList string_of_int [1;2;3;4;5;6]"], "message": ["Error: This expression has type int -> string\n       but an expression was expected of type string -> string\n       Type int is not compatible with type string \n", "Error: This expression has type int -> string\n       but an expression was expected of type string -> string\n       Type int is not compatible with type string \n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]"], "bad": ["let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let stringOfList f l = \"[\" ^ (sepConcat \"; \" f l) ^ \"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]"], "message": ["Error: This expression has type int but an expression was expected of type\n         string\n", "Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int but an expression was expected of type\n         string\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nif List.length l1 < List.length l2 then\n(clone 0 (List.length l2 - List.length l1)::l1),l2\nelse if List.length l2 > List.length l2 then\nl1, (clone 0 (List.length l1 - List.length l2)::l2)\nelse \nl1, l2", "let _ = padZero [9;9] [1;0;0;2]"], "bad": ["let padZero l1 l2 = \nif l1 < l2 then 0"], "message": ["Error: This expression has type int but an expression was expected of type\n         unit\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nlet first = List.length l1 in\nlet sec = List.length l2 in\nif first < sec then\nList.append (clone 0 (sec - first)) l1, l2\nelse if first > sec then\nl1, List.append (clone 0 (first - sec)) l2\nelse \nl1, l2"], "bad": ["let padZero l1 l2 = \nlet first = List.length l1 in\nlet sec = List.length l2 in\nif first < sec then\n((clone 0 (sec - first))::l1)\nelse if first > sec then\nl1, ((clone 0 (first - sec))::l2)\nelse \nl1, l2", "let padZero l1 l2 = \nlet first = List.length l1 in\nlet sec = List.length l2 in\nif first < sec then\nList.append (clone 0 (sec - first)) l1, l2\nelse if first > sec then\nList.append l1 ((clone 0 (first - sec))::l2)\nelse \nl1, l2"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int list list\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in \nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = fun g -> x (a g) in\nlet base = fun y -> y in \nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n = \nif n <= 0 then []\nelse x::clone x (n-1)", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let padZero l1 l2 = \nlet first = List.length l1 in\nlet sec = List.length l2 in\nif first < sec then\nList.append (clone 0 (sec - first)) l1, l2\nelse if first > sec then\nl1, List.append (clone 0 (first - sec)) l2\nelse \nl1, l2", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let rec removeZero l = match l with\n| [] -> []\n| h::t -> \nif h = 0 then removeZero t\nelse l", "let _ = removeZero [0;0;0;1;0;0;2]", "let _ = removeZero [9;9]", "let _ = removeZero [0;0;0;0]", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (i,j)::t -> \nif (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)\n| [] -> \n(0,0) in \nlet base = (0,0) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (i,j)::t -> \nif (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)\n| [] -> \n(0,0) in \nlet base = (0,0) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in\nif (i + j) > 9 then (1, (i + j - 10)) \nelse if (i + j) <= 9 then (0 , i + j) in\nlet base = (0,0) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in\nif (i + j) > 9 then (1, (i + j - 10)) \nelse if (i + j) <= 9 then (0 , i + j) in\nlet base = (0,0) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in\n((i+j+a)/10, (i+j+a)%10) in \nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in\nif (i + j) > 9 then (1, (i + j - 10)) \nelse if (i + j) <= 9 then (0 , i + j) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in\nmultiplier (float_of_int i) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\n((List.length l1) -1,(mulByDigit x*(10**i) l2)::j)in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\n((List.length l1) -1,(mulByDigit (x*(10**i)) l2)::j)in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\n((List.length l1) -1,(mulByDigit (x*((float_of_int 10)**i)) l2)::j)in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\n((List.length l1) -1,(mulByDigit (x*int_of_float((float_of_int 10)**i)) l2)::j)in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\n((List.length l1) -1,(mulByDigit (x*(int_of_float((float_of_int 10)**i))) l2)::j)in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**i))) l2)::n) in\nmultipler (float_of_int i) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**i))) l2)::n) in\nmultiplier (float_of_int i) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10))) l2)::n) in\nmultiplier (float_of_int i) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type int list -> int list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type\n         float * int list list -> int -> int * int list list\n       but an expression was expected of type\n         float * int list list -> int -> float * int list list\n       Type int is not compatible with type float \n", "Error: This expression has type\n         float * int list list -> int -> int * int list list\n       but an expression was expected of type\n         float * int list list -> int -> float * int list list\n       Type int is not compatible with type float \n", "Error: Unbound value multipler\nHint: Did you mean multiplier?\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(i-1, (mulByDigit x l2)::(clone 0 m)::n) in\nmultiplier ((List.length l1)-1) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(i-1, ((mulByDigit x l2)*(int_of_float(10**m)))::n) in\nmultiplier (float_of_int ((List.length l1)-1)) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(i-1, (mulByDigit x l2)::(clone 0 m)::n) in\nmultiplier (float_of_int ((List.length l1)-1)) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "bigMul"}
{"hw": "hw1", "fix": ["let rec sumList xs =\nmatch xs with\n| [] -> 0\n| x::s -> x + sumList s"], "bad": ["let rec sumList xs =\nmatch xs with\n| [] -> 0\n| x:s -> x + sumList s"], "message": ["Error: Syntax error\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let _ = sumList [1; 3; 5; 7; 9; 11]"], "bad": ["let _ = sumList [1; 3; 5; 7; 9; 11]\n\n55 / 10"], "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse n mod 10 :: digitsOfInt (n/10)"], "bad": ["let rec digitsOfInt n = \nif n < 0 then []\nelse n % 10 :: digitsOfInt (n\\10)", "let rec digitsOfInt n = \nif n < 0 then []\nelse n % 10 :: digitsOfInt (n/10)"], "message": ["Error: Illegal character (\\\\)\n", "Error: Unbound value %\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n <= 0 then []\nelse n mod 10 :: digitsOfInt (n/10)", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663"], "bad": ["let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt (n/10) :: n mod 10"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfIntHelper n = \nif n > 0 then digitsOfIntHelper (n/10) @ [n mod 10] \nelse []"], "bad": ["let rec digitsOfIntHelper n = \nif n > 0 digitsOfIntHelper (n/10) @ [n mod 10] \nelse []"], "message": ["Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nif n = 0 then 0\nelse 1 + additivePersistence (sumList (digits n))"], "bad": ["let rec additivePersistence n = \nif n = 0 then 0\nelse 1 + additivePersistence sumList (digits n)", "let rec additivePersistence n = \nif n = 0 then 0\nelse 1 + additivePersistence (sumList digits n)"], "message": ["Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n > 0 then \nlet k = digitsOfInt (n/10) in\n(n mod 10) :: k\nelse []"], "bad": ["let rec digitsOfInt n = \nif n > 0 then \nlet k = digitsOfInt (n/10) in\nk :: (n mod 10)\nelse []"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t else false\n| _ -> false)\n| _ -> false"], "bad": ["let palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x == y then palindromeHelper s t\n| _ -> false)\n| _ -> false", "let palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then palindromeHelper s t\n| _ -> false)", "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then  palindromeHelper s t\n| _ -> false)", "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then  palindromeHelper s t\n| _ -> false)", "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then palindromeHelper s t\n| _ -> false)", "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then palindromeHelper s t\n| _ -> false)\n| _ -> false", "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t\n| _ -> false)\n| _ -> false"], "message": ["Error: Unbound value palindromeHelper\n", "Error: Unbound value palindromeHelper\n", "Error: This expression has type bool but an expression was expected of type\n         unit\n", "Error: This expression has type bool but an expression was expected of type\n         unit\n", "Error: This expression has type bool but an expression was expected of type\n         unit\n", "Error: This expression has type bool but an expression was expected of type\n         unit\n", "Error: This expression has type bool but an expression was expected of type\n         unit\n"], "problem": "palindrome"}
{"hw": "hw1", "fix": ["let palindrome w = \nlet wl = explode w in\nlet rl = listReverse wl in\npalindromeHelper wl rl"], "bad": ["let _ = palindrome \"malayalam\""], "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n"], "problem": "palindrome"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nlet result = [] in \nlet rec digitsOfIntHelper n result = \nif n > 0 then (n mod 10) :: digitsOfIntHelper (n/10) result \nelse result in []"], "bad": ["let rec digitsOfInt n = \nlet result = [] in \nlet rec digitsOfIntHelper n result = \nif n > 0 then (n mod 10) :: digitsOfIntHelper (n/10) result \nelse result", "let rec digitsOfInt n = \nlet result = [] in \nlet rec digitsOfIntHelper n result = \nif n > 0 then (n mod 10) :: digitsOfIntHelper (n/10) result \nelse result in \n\n\nlet _ = digitsOfInt 100"], "message": ["Error: Syntax error\n", "Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nlet rec digitsOfIntHelper n result = \nif n > 0 then digitsOfIntHelper (n/10) (n mod 10 :: result)\nelse result in \ndigitsOfIntHelper n []"], "bad": ["let rec digitsOfInt n = \nlet rec digitsOfIntHelper n result = \nif n > 0 then digitsOfIntHelper (n/10) (n mod 10) :: result\nelse result in \ndigitsOfIntHelper n []"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "digitsOfInt"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "removeDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))\n\nremoveDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]"], "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d"], "bad": ["let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" + exprToString x + \")\"\n| Cosine x -> \"cos(pi*\" + exprToString x + \")\"\n| Average x y -> \"((\"  + exprToString x + \"*\" + exprToString y + \")/2)\"\n| Times x y -> exprToString x + \"*\" + exprToString y\n| Thresh a b c d -> \"(\" + exprToString a + \"<\" + exprToString b \n+ \"?\" exprToString c + \":\" + exprToString d", "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" + exprToString x + \")\"\n| Cosine x -> \"cos(pi*\" + exprToString x + \")\"\n| Average (x,y) -> \"((\"  + exprToString x + \"*\" + exprToString y + \")/2)\"\n| Times x y -> exprToString x + \"*\" + exprToString y\n| Thresh a b c d -> \"(\" + exprToString a + \"<\" + exprToString b \n+ \"?\" exprToString c + \":\" + exprToString d", "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" + exprToString x + \")\"\n| Cosine x -> \"cos(pi*\" + exprToString x + \")\"\n| Average (x,y) -> \"((\"  + exprToString x + \"*\" + exprToString y + \")/2)\"\n| Times (x,y) -> exprToString x + \"*\" + exprToString y\n| Thresh (a,b,c,d) -> \"(\" + exprToString a + \"<\" + exprToString b \n+ \"?\" exprToString c + \":\" + exprToString d", "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^ \"?\" exprToString c ^ \":\" ^ exprToString d"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type string but an expression was expected of type\n         int\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d"], "bad": ["let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x + \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^\"?\" exprToString c ^ \":\" ^ exprToString d", "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^\"?\" exprToString c ^ \":\" ^ exprToString d"], "message": ["Error: This expression has type string but an expression was expected of type\n         int\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)"], "bad": ["let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. (eval u))\n| Cos u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> ((eval s) < (eval t) ? (eval u) : (eval v))", "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. (eval u))\n| Cos u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> ((eval s) < (eval t)) ? (eval u) : (eval v)", "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. (eval u))\n| Cos u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> ((eval s) < (eval t)) ? eval u : eval v", "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. (eval u))\n| Cos u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> (eval s) < (eval t) ? eval u : eval v", "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. (eval u))\n| Cos u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. (eval u))\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. (eval u)\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval u\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi \n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. (eval u)\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi .* (eval u)\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi * (eval u)\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. (eval u)\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. (eval u) * 1 * 1\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v"], "message": ["Error: Syntax error: operator expected.\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This variant pattern is expected to have type expr\n       The constructor Cos does not belong to type expr\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "Error: Syntax error\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec build (rand,depth) = \nif depth = 1 then \nif rand(0,1) = 0 then VarX\nelse VarY\nelse (* depth > 1 *)\nmatch rand(0,4) with\n| 0 -> Sine (build (rand, depth-1))\n| 1 -> Cosine (build (rand, depth-1))\n| 2 -> Average ((build (rand, depth-1)), (build (rand, depth-1)))\n| 3 -> Times ((build (rand, depth-1)), (build (rand, depth-1)))\n| 4 -> Thresh ((build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)))"], "bad": ["let rec build (rand,depth) = \nif depth = 1 then \nif rand(0,1) = 0 then VarX\nelse VarY\nelse (* depth > 1 *)\nmatch rand(0,4) with\n| 0 -> Sine (build (rand, depth-1))\n| 1 -> Cosine (build (rand, depth-1))\n| 2 -> Average (build (rand, depth-1)), (build (rand, depth-1))\n| 3 -> Times (build (rand, depth-1)) (build (rand, depth-1))\n| 4 -> Thresh (build (rand, depth-1)) (build (rand, depth-1)) (build (rand, depth-1)) (build (rand, depth-1))", "let rec build (rand,depth) = \nif depth = 1 then \nif rand(0,1) = 0 then VarX\nelse VarY\nelse (* depth > 1 *)\nmatch rand(0,4) with\n| 0 -> Sine (build (rand, depth-1))\n| 1 -> Cosine (build (rand, depth-1))\n| 2 -> Average (build (rand, depth-1)), (build (rand, depth-1))\n| 3 -> Times (build (rand, depth-1)), (build (rand, depth-1))\n| 4 -> Thresh (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1))", "let rec build (rand,depth) = \nif depth = 1 then \nif rand(0,1) = 0 then VarX\nelse VarY\nelse (* depth > 1 *)\nmatch rand(0,4) with\n| 0 -> Sine (build (rand, depth-1))\n| 1 -> Cosine (build (rand, depth-1))\n| 2 -> Average ((build (rand, depth-1)), (build (rand, depth-1)))\n| 3 -> Times (build (rand, depth-1)), (build (rand, depth-1))\n| 4 -> Thresh (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1))"], "message": ["Error: Syntax error\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let fptest x = truncate (1e6 *. cos (1e-6 *. float x))", "), 0", ")\nfptest 0"], "bad": ["fptest 0"], "message": ["Error: This expression has type (int -> int) * int\n       This is not a function; it cannot be applied.\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let fptest x = truncate (1e6 *. cos (1e-6 *. float x)),\nfptest 0"], "bad": [")\nfptest 0"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw2", "fix": ["fptest (fptest 0)"], "bad": ["fptest fptest 0"], "message": ["Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = sum + x*x in\nlet base = 0 in\nList.fold_left f base xs"], "message": ["Error: Unbound value sum\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = a in\nlet base = [] in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a x in\nlet base = f x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base = let f x = x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base = f -> x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base = x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base = f x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base = fun x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base = (fun x) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base = x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base = f in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base = 0 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base = [] in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = a x in\nlet base = [] in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value x\n", "Error: Unbound value x\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: Syntax error\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: Syntax error: operator expected.\n", "Error: Unbound value x\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun a -> x in\nlet base = fun f x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun a -> x in\nlet base = [] in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun a -> x in\nlet base = x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun a -> x in\nlet base = a in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'b -> 'c\n", "Error: Unbound value x\n", "Error: Unbound value a\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun a -> x in\nlet base = fun f x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = a -> x in\nlet base = fun f x -> x in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun a -> x in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun a -> x in\nlet base = fun f x  in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun a -> x in\nlet base = x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun a -> x in\nlet base = [] in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun a -> a x in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: Syntax error\n", "Error: Unbound value x\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b -> 'c\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun a -> x in\nlet base = x in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type int but an expression was expected of type\n         int -> int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun c -> x (a c) in\nlet base =  fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = fun y -> fun a -> x in\nlet base =  fun a -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun y -> fun a -> x in\nlet base =  fun f -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun y -> fun a -> x in\nlet base =  fun f in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun y -> fun a -> x in\nlet base =  f x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun y -> fun a -> x in\nlet base =  fun a -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun x -> a in\nlet base =  fun a -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun a -> a x in\nlet base =  fun a -> x in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun a -> a x in\nlet base =  0 in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = fun a -> a x in\nlet base =  f -> b in\nList.fold_left f base fs"], "message": ["Error: Unbound value x\n", "Error: Unbound value x\n", "Error: Syntax error\n", "Error: Unbound value x\n", "Error: Unbound value x\n", "Error: Unbound value x\n", "Error: Unbound value x\n", "Error: This expression has type int but an expression was expected of type\n         ('a -> 'b) -> 'b\n", "Error: Syntax error\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = [] in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = fun c -> a ^ sep ^ x in\nlet base = \"\" in\nlet l = l in\nList.fold_left f base l", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = fun c -> a ^ sep ^ x in\nlet base = \"\" in\nlet l = \"\" in\nList.fold_left f base l", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = \"\" in\nList.fold_left f base l"], "message": ["Error: Unbound value l\n", "Error: This expression has type string -> string -> 'a -> string\n       but an expression was expected of type string -> string -> string\n       Type 'a -> string is not compatible with type string \n", "Error: This expression has type string but an expression was expected of type\n         string list\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nlet leng1 = List.length l1 in\nlet leng2 = List.length l2 in\n(clone 0 (leng1-leng2) @ l1 , clone 0 (leng2-leng1) @ l2)"], "bad": ["let padZero l1 l2 = \nlet leng1 = List.length l1 in\nlet leng2 = List.length l2 in\n(clone 0 leng1-leng2 @ l1 , clone 0 leng2-leng1 @ l2)"], "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = fun c -> x (a c) in\nlet base =  fun x -> x in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let rec clone x n = \nif n <= 0 then []\nelse x :: (clone x (n-1))", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let padZero l1 l2 = \nlet leng1 = List.length l1 in\nlet leng2 = List.length l2 in\n(clone 0 (leng2 - leng1) @ l1 , clone 0 (leng1 - leng2) @ l2)", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let rec removeZero l = match l with\n| []    -> []\n| h::t  -> if h = 0 then removeZero t else l", "let _ = removeZero [0;0;0;1;0;0;2]", "let _ = removeZero [9;9]", "let _ = removeZero [0;0;0;0]", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = ([], []) in\nlet args = List.rev List.combine (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = l1  in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = l1  in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = [] in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = [] in\nlet args = ([], []) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = ([], []) in\nlet args = ([], []) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = ([], []) in\nlet args = 0 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = ([], []) in\nlet args = [[],[]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = ([]) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x.first in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  (a.first + x.first, a.second + x.second) in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  (a, a) in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  (a, x) in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + x in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + x.first in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + x in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  [a] in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + 1 in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  (a, a) in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  ([a], a) in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a[0] in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = [0] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = 0 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = [0] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + 1 in\nlet base = ([], []) in\nlet args = [0] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + 1 in\nlet base = 5 in\nlet args = [0] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  [5],[5] in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a.first,a.second in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a.fst,a.snd in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  (fst a), (snd a) in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  (fst a), (snd a) in\nlet base = (List.rev l1, List.rev l2) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  (fst a), (snd a) in\nlet base = (List.rev l1, []) in\nlet args = [List.rev l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| []  -> []. snd a\n| h:t -> t, ((fst h + snd h) % 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| []  -> []. snd a\n| h::t -> t, ((fst h + snd h) % 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| []  -> [], snd a\n| h::t -> t, ((fst h + snd h) % 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| []  -> [], snd snd a\n| h::t -> t, ((fst h + snd h) % 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match snd a with\n| []  -> [], snd a\n| h::t -> t, ((fst h + snd h) % 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match snd a with\n| []  -> [], snd a\n| h::t -> t, ((fst h + snd h) mod 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match snd a with\n| []  -> [], snd a\n| h::t -> t, ((fst h + snd h) mod 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match fst a with\n| []  -> [], snd a\n| h::t -> t, ((fst h + snd h) mod 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Unbound value padZero\n", "Error: Unbound value padZero\n", "Error: Unbound value padZero\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list list\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type ('c list * 'd list) list\n", "Error: This expression has type int but an expression was expected of type\n         ('a list * 'b list) list\n", "Error: Unbound value padZero\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: Unbound value padZero\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: Unbound value padZero\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: Unbound record field first\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: Unbound record field first\n", "Error: This expression has type 'a -> 'b -> 'a * 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'a * 'a\n", "Error: This expression has type 'a -> 'b -> 'a * 'b\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'a * 'b\n", "Error: Unbound value padZero\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type int\n", "Error: Unbound record field first\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type int\n", "Error: Unbound value padZero\n", "Error: This expression has type 'a -> 'b -> 'a list\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'b -> 'a * 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'a * 'a\n", "Error: This expression has type 'a -> 'b -> 'a list * 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'a list * 'a\n", "Error: This expression has type (int list -> 'a) -> 'b -> 'a\n       but an expression was expected of type\n         (int list -> 'a) -> 'b -> int list -> 'a\n       The type variable 'a occurs inside int list -> 'a\n", "Error: Unbound value padZero\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: Unbound value padZero\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: Unbound value padZero\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: Unbound value padZero\n", "Error: Unbound value padZero\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: Unbound record field first\n", "Error: Unbound record field fst\n", "Error: Unbound value padZero\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: Unbound value padZero\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: Unbound value padZero\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: Syntax error\n", "Error: Unbound record field snd\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type 'a * 'b -> 'b\n       but an expression was expected of type 'c * ('d -> 'e)\n", "Error: Unbound value %\n", "Error: This expression has type int but an expression was expected of type\n         int * int\n", "Error: This expression has type int but an expression was expected of type\n         int * int\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = List.combine l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = ([], []) in\nlet args = List.rev (List.combine (l1, l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = ([], []) in\nlet args = List.rev (List.combine (l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = ([], []) in\nlet args = (List.combine (l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = ([], []) in\nlet args = List.combine (l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = ([], []) in\nlet args = List.combine (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = ([], []) in\nlet args = [List.combine (l1, l2)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = [List.combine (l1, l2)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = [List.combine (l1, l2)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = [List.combine l1] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a list -> ('b * 'a) list\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a list -> ('b * 'a) list\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a list -> ('b * 'a) list\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = [List.combine (l1, l2)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = List.combine l1, l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a list -> ('b * 'a) list\n       but an expression was expected of type 'c list\n", "Error: This expression has type ('a list -> ('b * 'a) list) * 'c\n       but an expression was expected of type 'd list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = [0, 0] in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> ( (fst h + snd h) / 10, (fst h + snd h) mod 10 :: t )in \nlet base = (0, []) in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = (0, 0) in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = (0, []) in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type (int * int) list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["List.combine [9] [5]"], "bad": ["List.combine [9], [5]"], "message": ["Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n"], "problem": "???"}
{"hw": "hw3", "fix": ["let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\n(*let (_, res) = List.fold_left f base args in\nres*)\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\n(*let (_, res) = List.fold_left f base args in\nres*)\n(*in*) \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"3232\" in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: Unbound value l1\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| [] -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (fst x + snd x) / 10, ((fst x + snd x) mod 10 :: snd a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| () -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| [] -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| ([]) -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| 5 -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| 'a' -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (_, _) -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type unit list\n       Type 'a * 'b is not compatible with type unit \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type int list\n       Type 'a * 'b is not compatible with type int \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type char list\n       Type 'a * 'b is not compatible with type char \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let _ = bigAdd [9;9] [1;0;0;2]"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (fst x + snd x) / 10, (fst x + snd x) mod 10 :: snd a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "message": ["Characters 74-75:\n  let f a x = (fst x + snd x) / 10, ((fst x + snd x) mod 10 :: snd a in \n                                    ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let _ = mulByDigit 9 [9;9;9;9]", "let _ = mulByDigit 9 [1;1;1;1]"], "bad": ["let rec mulByDigit i l = \nlet f x a = let digitRes = (x * i) + fst a in\ndigitRes / 10, (digitRes mod 10) :: snd a in\nlet base  = (0, []) in\nlet (_, result) = List.fold_right f (0 :: l) base in\nresult"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let _ = bigMul [9;9;9;9] [9;9;9;9]"], "bad": ["let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit l1 x in\n0, bigAdd value snd a in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit l1 x in\n0, bigAdd value (snd a) in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: Unbound value bigSum\n", "Error: This function has type int list -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let _ = bigMul [9;9;9;9] [9;9;9;9]"], "bad": ["let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit l1 x in\n0, bigAdd value x in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit l1 x in\n0, bigAdd value x :: snd a in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let _ = bigMul [9;9;9;9] [9;9;9;9]"], "bad": ["let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit l1 x in\n0, bigAdd value x in \nlet base = ([], []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let _ = bigMul [9;9;9;9] [9;9;9;9]"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type int * int list\n       Type 'a list is not compatible with type int \n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let _ = bigMul [9;9;9;9] [9;9;9;9]"], "bad": ["let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit x l1 in\n0, bigAdd value x :: snd a in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let _ = bigMul [9;9;9;9] [9;9;9;9]", "let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit x l1 in\n0, bigAdd x value :: snd a in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let _ = bigMul [9;9;9;9] [9;9;9;9]", "let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit x l1 in\n0, bigAdd value snd a in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "let _ = bigMul [9;9;9;9] [9;9;9;9]", "let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit x l1 in\n0, bigAdd value (snd a) in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This function has type int list -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "bigMul"}
{"hw": "hw1", "fix": ["let rec sumList xs =\nmatch xs with\n[] -> []\n| head::tail -> head + (sumList tail)", "let _ = sumList [1; 2; 3; 4]", "let _ = sumList [1; -2; 3; 5]", "let _ = sumList [1; 3; 5; 7; 9; 11]"], "bad": ["let rec sumList xs =\nmatch xs with\n[] -> []\n| head::tail- > head + (sumList tail)"], "message": ["Error: Syntax error: pattern expected.\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let rec sumList xs =\nmatch xs with\n[] -> 0\n| head::tail -> head + (sumList tail)", "let _ = sumList [1; 2; 3; 4]"], "bad": ["let _ = sumList [1; 2; 3; 4]"], "message": ["Error: This expression has type int but an expression was expected of type\n         int -> int\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let rec listReverse l = \nmatch l with \n[] -> []\n| head::tail -> listReverse tail @ [head]", "let _ = listReverse [1; 2; 3; 4]", "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]"], "bad": ["let _ = listReverse [1; 2; 3; 4]", "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let rec append_new xs1 xs2= \nmatch xs1 with\n[] -> xs2\n| head::tail -> head :: (append_new tail xs2)"], "bad": ["let rec append_new xs1 xs2= \nmatch xs1 with\n[] -> xs2\n| head::tail -> head :: (append_new tail) :: xs2"], "message": ["Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list -> 'a list\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rec append_new xs1 xs2= \nmatch xs1 with\n[] -> xs2\n| head::tail -> head::(append_new tail xs2)", "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| (ki, vi)::tail -> if (k = ki) then vi\nelse assoc (d, k, tail)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then seen (* if seen, ignore*)\nelse append [h] seen in (* add to front *)\nlet rest' = t in (*recurse of rest*)\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"], "bad": [" _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"], "message": ["Error: Syntax error\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0\n| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))"], "bad": ["let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*(eval(var2, x, y)))\n| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> (eval(var7, x, y) < (eval(var8, x, y)) ? (eval(var9, x, y)):(eval(var0, x, y)))", "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*(eval(var2, x, y)))\n| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> (eval(var7, x, y) < (eval(var8, x, y)) ? (eval(var9, x, y)) : (eval(var0, x, y)))", "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*(eval(var2, x, y)))\n| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if ((eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", ")", "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*(eval(var2, x, y)))\n| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if ((eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*(eval(var2, x, y)))\n| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y) + eval(var4, x, y))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> (.(eval(var3, x, y) + (.eval(var4, x, y)))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((.(eval(var3, x, y)) + (.eval(var4, x, y)))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> .((.(eval(var3, x, y)) + (.eval(var4, x, y)))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> (.(eval(var3, x, y)) + eval(var4, x, y))/2\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y)) + eval(var4, x, y))/2\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2\n| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))"], "message": ["Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Characters 320-321:\n  | Thresh (var7, var8, var9, var0) -> if ((eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y));;\n                                          ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Characters 320-321:\n  | Thresh (var7, var8, var9, var0) -> if ((eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y));;\n                                          ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error\n", "Error: Syntax error: operator expected.\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nif (depth<1) then let base = (rand 0 2) in match base with \n| 0 -> buildX()\n| 1 -> buildY()\nelse let recurse = (rand 0 5) in match recurse with\n| 0 -> buildSine(build(rand, depth-1))\n| 1 -> buildCosine(build(rand, depth-1))\n| 2 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 3 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"], "bad": ["let rec build (rand, depth) = \nif (depth<1) then let base = (rand 0 2) in match base with \n| 0 -> buildX\n| 1 -> buildY", "let rec build (rand, depth) = \nif (depth<1) then let base = (rand 0 2) in match base with \n| 0 -> buildX()\n| 1 -> buildY()\nelse \n(*\ncall rand get some number\nswitch statement to choose\n1 then return expr x\n0 then return expr y\n*)\n\n\n(* g1,g2,g3,c1,c2,c3 : unit -> int * int * int\n* these functions should return the parameters needed to create your \n* top three color / grayscale pictures.\n* they should return (depth,seed1,seed2)\n*)\n\nlet g1 () = failwith \"to be implemented\""], "message": ["Error: This expression has type unit -> expr\n       but an expression was expected of type unit\n", "Error: Syntax error\n"], "problem": "build"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = \nlet index = fst a in\nlet newIn = index + 1 in\n(newIn, bigAdd (snd a) (mulByDigit x (l1@(clone 0 index)))) in\nlet base = (0, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "let _ = bigMul [9;9;9;9] [9;9;9;9]", "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"], "bad": ["let bigMul l1 l2 = \nlet f a x = \nlet index = fst a in\nlet newIn = index + 1 in\n(newIn, bigAdd (snd a) (mulByDigit x (l1@(clone 0 index))))", "let base = (0, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "let _ = bigMul [9;9;9;9] [9;9;9;9]", "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"], "message": ["Error: Syntax error\n", "Error: Unbound value l2\n", "Error: Unbound value bigMul\n", "Error: Unbound value bigMul\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let padZero l1 l2 = \nlet lenl1 = List.length l1 in \nlet lenl2 = List.length l2 in \n((List.append(clone 0 (lenl1 - lenl2)) l1), (List.append (clone 0 (lenl1 - lenl2)) l2))"], "bad": ["let padZero l1 l2 = \nlet lenl1 = List.length l1 in \nlet lenl2 = List.length l2 in \n(List.append(clone 0 (lenl1 - lenl2) l1, (List.append (clone 0 (lenl1 - lenl2)) l2)))"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "problem": "padZero"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n = \nif n<=0 then []\nelse explode (string_of_int n)"], "bad": ["let rec digitsOfInt n = match n with\n| isNotP n ->[]\n| explode (string_of_int n)", "let rec digitsOfInt n = match n with\n| if isNotP n ->[]\n| explode (string_of_int n)", "let rec digitsOfInt n = match n with\n| if isNotP n then n->[]\n| explode (string_of_int n)", "let rec digitsOfInt n = match n with\n| isNotP n then n->[]\n| explode (string_of_int n)", "let rec digitsOfInt n = match n with\n| if isNotP n then []\n| explode (string_of_int n)", "let rec digitsOfInt n = match n with\n| if isNotP n =true then []\n| explode (string_of_int n)", "let rec digitsOfInt n = match n with\n| if n<=0 then []\n| explode (string_of_int n)", "let rec digitsOfInt n = match n with\n| if n<=0 then []\n| else explode (string_of_int n)", "let rec digitsOfInt n = \n| if n<=0 then []\n| else explode (string_of_int n)"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \n\nsumList (digitsOfInt n)"], "bad": ["let rec additivePersistence n = sumList digitOfInt n", "let rec additivePersistence n = \n\nsumList (digitOfInt n)"], "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value digitOfInt\nHint: Did you mean digitsOfInt?\nError: Unbound value digitOfInt\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value digitOfInt\nHint: Did you mean digitsOfInt?\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nif n<10 then a\nelse  additivePersistence (sumList (digitsOfInt n))"], "bad": ["let rec additivePersistence n = match n with\nif n<10 then n\nelse  _=sumList (digitsOfInt n)", "let rec additivePersistence n = match n with\nif n<10 then n\nelse  n=sumList (digitsOfInt n)", "let rec additivePersistence n = \nif n<10 then n\nelse  n=sumList (digitsOfInt n) in \nmatch n with \n|0->0\n|_->n", "let rec additivePersistence n = \nif n<10 then n\nelse  sumList (digitsOfInt n) in \nmatch n with \n|0->0\n|_->n", "let rec additivePersistence n a= \nif n<10 then a\nelse  sumList (digitsOfInt n) in \nmatch n with \n|0->0\n|_->n"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type bool but an expression was expected of type\n         int\n", "Error: Unbound value n\n", "Error: Unbound value n\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nlet c=0 in\nlet rec break(num,count)=\nif num>9 then\nbreak(sumList(digitsOfInt(num)),(count+1))\nelse\ncount\nin\nbreak(n,c)"], "bad": ["let rec additivePersistence n = \nlet c=0 in\nlet rec break(num,count)=\nif num>9\nbreak(sumList(digitsOfInt(num)),(count+1))\nelse\ncount\nin\nbreak(n,c)"], "message": ["Error: Syntax error\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec listReverse l = \nlet rec a acc=function\n|[]-> acc\n|h::t -> a(h::acc) t in\na [] l"], "bad": ["let rec listReverse l = \nlet rec a acc=function\n|[]-> acc\n|h::t -> a(h::acc) t in\na [] list"], "message": ["Error: Unbound value list\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let palindrome w = \nif explode w = listReverse (explode w) then true\nelse false"], "bad": ["let palindrome w = \nif explode w = listReverse (explode w)"], "message": ["Error: Syntax error\n"], "problem": "palindrome"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n|(s,n)::t -> if s=k then n\nelse assoc(d,k,t)\n|[]->d", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if !List.mem(h,seen) then seen@ [h]  in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "bad": ["et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"], "message": ["Error: Syntax error\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = match f with\n| (x,true)->x"], "bad": ["let rec wwhile (f,b) = match f with\n| (x,true) -> f x\n| (x,false) -> x", "let rec wwhile (f,b) = match f with\n|(x,true) -> wwhile(f x)\n| (x,false) -> x", "let rec wwhile (f,b) = match f with\nlet (n,boo) = f b\n| boo=true -> wwhile(f,n)\n| boo=false -> n", "let rec wwhile (f,b) = match f with\n(n,boo) -> f b\n| boo=true -> wwhile(f,n)\n| boo=false -> n", "let rec wwhile (f,b) = match f with\n(n,boo) -> f b\nif boo= true then wwhile(f,n)\nelse n", "let rec wwhile (f,b) = match f with\n(n,boo) -> f b"], "message": ["Error: This expression has type 'a * bool\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a * bool\n       This is not a function; it cannot be applied.\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type 'a * 'b\n       This is not a function; it cannot be applied.\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let rec wwhile (f,b) = match f b with\n| (x,true) -> wwhile(f,x)\n| (x,false)-> x"], "bad": ["let rec wwhile (f,b) = match f with \nlet (i,r) = f b in\n| r=true -> wwhile (f,i)\n| r=false ->i", "let rec wwhile (f,b) = match f with \nlet rec (i,r) = f b in\n| r=true -> wwhile (f,i)\n| r=false ->i", "let rec wwhile (f,b) = \nlet  (x,y) = f b in\nmatch (x,y) with \n| y=true -> wwhile (f,x)\n| y=false -> x", "let rec wwhile (f,b) = \nlet  (x,y) = f b in\nmatch (x,y) with \n| y -> wwhile (f,x)\n| !y -> x", "let rec wwhile (f,b) = \nlet  (x,y) = f b in\nmatch (x,y) with \nif y then wwhile (f,x)\nelse x"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)"], "bad": ["let fixpoint (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true)=f b-1 then (b,false)),b)", "let fixpoint (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true)=f b-1 then (b,false) in f),b)", "let fixpoint (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true)=f (b-1) then (b,false) in ),b)", "let fixpoint (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true)=f (b-1) then (b,false) in f),b)", "let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x<>b && (x,y)<>f (b-1))),b)", "let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x<>b)),b)", "let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x!=b)),b)", "let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x>b||x<b)),b)", "let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x<100)),b)"], "message": ["Error: Syntax error: operator expected.\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type int\n", "Error: Syntax error: operator expected.\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  exprToString e\n| Cosine e-> exprToString e"], "bad": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine -> VarY\"/\"VarX\n| Cosine -> VarX\"/\"VarY", "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine -> VarY@\"/\"@VarX\n| Cosine -> VarX@\"/\"@VarY", "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine -> VarY^\"/\"^VarX\n| Cosine -> VarX^\"/\"^VarY", "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ->  exprToString e\n| Cosine -> exprToString e", "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ->  exprToString e\n| Cosine -> exprToString e", "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ->  exprToString VarX\n| Cosine -> exprToString e", "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  exprToString e\n| Cosine -> exprToString e"], "message": ["Error: Syntax error\n", "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "Error: The constructor Cosine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\""], "bad": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average e1 e2 ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\")/2\"", "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average e1 e ->\"(\"^(exprToString e1)^\"+\"^(exprToString e)^\")/2\"", "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average e e ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\"", "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average e ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\""], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: The constructor Average expects 2 argument(s),\n       but is applied here to 1 argument(s)\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\""], "bad": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\""], "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let aa =exprToString VarX"], "bad": ["let aa = exprToString Average(VarX, VarY)", "let aa =exprToString Average(VarX, VarY)", "let aa =exprToString VarX;\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))"], "message": ["Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Syntax error\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\")/2\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"", "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "let _ = exprToString sampleExpr1"], "bad": ["let aa =exprToString Average(VarY,VarX)"], "message": ["Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "exprToString"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY"], "bad": ["let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine -> buildSine(e)", "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e-> buildSine(e)", "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e-> buildSine(x)", "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e1-> buildSine(e1)", "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e1-> buildSine(e1)", "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e-> 0.34*e", "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e-> build(pi*e)"], "message": ["Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "Error: This expression has type expr but an expression was expected of type\n         unit -> expr\n", "Error: This expression has type expr but an expression was expected of type\n         unit -> expr\n", "Error: This expression has type expr but an expression was expected of type\n         unit -> expr\n", "Error: This expression has type expr but an expression was expected of type\n         unit -> expr\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*x\n| Cosine e-> pi*y\n| Average (e1,e2)-> (e1+e2)/2\n| Times (e1, e2)-> e1*e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)", "let rec eval (e,x,y) = (-:float) match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*x\n| Cosine e-> pi*y\n| Average (e1,e2)-> (e1+e2)/2\n| Times (e1, e2)-> e1*e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)", "let rec eval (e,x,y) = (float) match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*x\n| Cosine e-> pi*y\n| Average (e1,e2)-> (e1+e2)/2\n| Times (e1, e2)-> e1*e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)", "let rec eval (e,x,y) = match e with\n| (float) VarX -> x\n| VarY -> y\n| Sine e -> pi*x\n| Cosine e-> pi*y\n| Average (e1,e2)-> (e1+e2)/2\n| Times (e1, e2)-> e1*e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)", "let rec eval (e,x,y) = match e with\n| VarX -> x:float\n| VarY -> y\n| Sine e -> pi*x\n| Cosine e-> pi*y\n| Average (e1,e2)-> (e1+e2)/2\n| Times (e1, e2)-> e1*e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)", "let rec eval (e,x,y) = match e with\n| VarX -> x of float\n| VarY -> y\n| Sine e -> pi*x\n| Cosine e-> pi*y\n| Average (e1,e2)-> (e1+e2)/2\n| Times (e1, e2)-> e1*e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2)-> (e1+.e2)/2\n| Times (e1, e2)-> e1*.e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2)-> (e1.+.e2.)/2\n| Times (e1, e2)-> e1*.e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2)-> (float)(e1+e2)/2\n| Times (e1, e2)-> e1*.e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2)-> (float_of_int e1+. float_of_int e2)/2\n| Times (e1, e2)-> float_of_int e1*.float_of_int e2\n| Thresh (e1,e2,e3,e4)->(float_of_int e1<float_of_int e2 ? float_of_int e3:float_of_int e4)", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2)-> if e1=VarX then e1=x else e1=y if e2=VarX then e2=x else e2=y -> (e1+e2)/2\n| Times (e1, e2)-> e1*.e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)"], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Characters 23-24:\n  let rec eval (e,x,y) = (-:float) match e with\n                         ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: This expression has type expr but an expression was expected of type\n         float\n", "Error: Syntax error: operator expected.\n", "Error: This expression has type expr but an expression was expected of type\n         int\n", "Error: This expression has type expr but an expression was expected of type\n         int\n", "Error: Syntax error\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x.\n| Cosine e-> pi*.y.\n| Average (e1,e2) -> buildAverage(e1,e2)", "let _=1.00*.5.00"], "bad": ["let rec eval (e,x,y) =\nmatch e with\n| VarX -> x.\n| VarY -> y.\n| Sine e -> pi*.x.\n| Cosine e-> pi*.y.\n| Average (e1,e2) -> buildAverage(e1,e2)"], "message": ["Error: Syntax error\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)"], "bad": ["let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> ((e1*1.00)+(e2*1.00))/.2.0", "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> ((e1*1.00)+.(e2*1.00))/.2.0", "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.evail(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.evail(e2,x,y)\n| Thresh (e1,e2,e3,e4) ->((eval(e1,x,y))<(eval(e2,x,y)) ? (eval(e3,x,y)) : (eval(e4,x,y))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.evail(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.evail(e2,x,y)"], "message": ["Error: This expression has type expr but an expression was expected of type\n         int\n", "Error: This expression has type expr but an expression was expected of type\n         int\n", "Error: Syntax error: operator expected.\n", "Error: Unbound value evail\nHint: Did you mean eval?\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)"], "bad": ["let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2) -> eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y)", "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2) -> eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y):eval(e4,x,y)", "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2) -> (eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y) : eval(e4,x,y))", "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y) : eval(e4,x,y))", "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y) : eval( e4,x,y))", "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<eval(e2,x,y)?(eval(e3,x,y)):(eval(e4,x,y))\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y):eval(e4,x,y)", "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<.eval(e2,x,y)?.eval(e3,x,y):.eval(e4,x,y))", "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<.eval(e2,x,y)?.eval(e3,x,y) : eval(e4,x,y))", "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y) : eval(e4,x,y)"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error: operator expected.\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "bad": ["let rec assoc (d,k,l) = \nlet rec helper(d1,k1,l1) = match l1 with\n|(s,n)::t -> if s=k1 then n\nelse assoc(d1,k1,t)\n|[]->d1\nin helper(d,k,l)"], "message": ["Error: Syntax error\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let _ = eval (sampleExpr,0.5,0.2)"], "bad": ["let _ = eval (sampleExpr1,0.5,0.2)"], "message": ["Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let _ = eval (sampleExpr,0.5,0.2)", "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "let rec build (rand, depth) = \nmatch rand depth with\n| (1,d) -> d=(d-1) && buildX()\n| (2,d) -> d=(d-1) && buildY()"], "bad": ["let rec build (rand, depth) = match rand depth with"], "message": ["Error: This expression has type expr but an expression was expected of type\n         bool\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let _ = eval (sampleExpr,0.5,0.2)", "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "let rec build (rand, depth) = match rand depth with\n| (r,0) -> build (r,0)\n| (r,d) -> (r,d-1)"], "bad": ["let rec build (rand, depth) = \nmatch rand depth with\n| (1,d) -> d=(d-1) && buildX()\n| (2,d) -> d=(d-1) && buildY()"], "message": ["Error: This expression has type expr but an expression was expected of type\n         bool\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let _ = eval (sampleExpr,0.5,0.2)", "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "let rec build (rand, depth) = match (rand, depth) with\n| (r,0) -> build (r,0)\n| (r,d) -> (r,d-1)"], "bad": ["let rec build (rand, depth) = match rand depth with"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         'b -> 'a * int\n       The type variable 'a occurs inside 'b -> 'a * int\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let _ = eval (sampleExpr,0.5,0.2)", "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "let rec build (rand, depth) = \nlet buildd(r,d) = if r=1 then buildX() \nelse if r=2 then buildY() \nelse if r=3 then buildSine(build(r,d))\nelse if r=4 then buildCosine(build(r,d))\nelse if r=5 then buildTimes(build(r1,d1),build(r2,d2))\nelse buildThresh(build(r1,d1), build(r2,2), build(r2,d2), build(r2,d2)) in (depth-1,depth>0)\nin buildd(rand,depth)"], "bad": ["let rec build (rand, depth) = \nlet build(r) = if r=1 then buildX() else buildY() in (depth-1,depth>0)\nin build(r)", "let rec build (rand, depth) = match rand depth with\nif r=1 then buildX() else buildY() in (depth-1,depth>0)", "let rec build (rand, depth) = match rand depth with\nif rand=1 then buildX() else buildY() in (depth-1,depth>0)"], "message": ["Error: Unbound value r\n", "Error: Unbound value r\n", "Error: Syntax error\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = \nlet rec helper(d1,k1,l1) = match l1 with\n|(s,n)::t -> if s=k1 then n\nelse assoc(d1,k1,t)\n|[]->d1\nin helper(d,k,l)", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen = false then [h]@seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let rec wwhile (f,b) = match f b with\n| (x,true) -> wwhile(f,x)\n| (x,false)-> x", "let f x = let xx = x*x*x in (xx, xx < 100) in wwhile (f,2)", "let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,xx!=x)in a),b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)", "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"((\"^(exprToString e1)^\"+\"^(exprToString e2)^\")/2)\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"", "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "let _ = exprToString sampleExpr1", "let buildX()                       = VarX", "let buildY()                       = VarY", "let buildSine(e)                   = Sine(e)", "let buildCosine(e)                 = Cosine(e)", "let buildAverage(e1,e2)            = Average(e1,e2)", "let buildTimes(e1,e2)              = Times(e1,e2)", "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "let pi = 4.0 *. atan 1.0", "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*.eval(e,x,y))\n| Cosine e-> sin(pi*.eval(e,x,y))\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "let _ = eval (sampleExpr,0.5,0.2)", "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "let rec build (rand, depth) = match rand depth with\n|(r,depth)-> match r(0,6) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1))", "let g1 () = failwith \"to be implemented\"", "let g2 () = failwith \"to be implemented\"", "let g3 () = failwith \"to be implemented\"", "let c1 () = failwith \"to be implemented\"", "let c2 () = failwith \"to be implemented\"", "let c3 () = failwith \"to be implemented\"", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type test = unit -> string", "let key = \"\"", "let prefix130 = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")", "let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0", "let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)", "let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))", "let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p", "let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max"], "bad": ["let rec build (rand, depth) = match rand depth with\n|(r,depth)-> match r(0,6) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1))"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type unit\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"], "bad": ["let rec build (rand, depth) = match (rand,depth) with\n|(r,depth)-> match r(0,6) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)", "let rec build (rand, depth) = match (rand,depth) with\n|(r,depth)-> match r(0,7) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)", "let rec build (rand, depth) = match (rand,depth) with\n|(r,depth)-> match r(0,7) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|_->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)", "let rec build (rand, depth) = match (rand,depth) with\n|(r,depth)-> let r = rand(0,7) in match with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|_->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)", "let rec build (rand, depth) = match (rand,depth) with\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|_->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)", "let rec build (rand, depth) = match (rand,depth) with\n|(_,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|_->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)", "let rec build (rand, depth) = match (rand,depth) with\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|_->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1)) in (depth, depth>=0)", "let rec build (rand, depth) = match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|_->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"], "message": ["Error: This expression has type int * int -> int\n       but an expression was expected of type 'a -> (int * int -> int) * 'b\n", "Error: Unbound value depth\n", "Error: Unbound value depth\n", "Error: Unbound value depth\n", "Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         int * int -> int\n", "Error: This expression has type int but an expression was expected of type\n         int * int -> int\n", "Error: Unbound value depth\n"], "problem": "build"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base = h^sep in\nlet l = sl in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = List.rev x^a in\nlet base = sep in\nlet l = sl in\nList.fold_left f base l", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = List.rev t^a in\nlet base = h^sep in\nlet l = sl in\nList.fold_left f base l"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ (x^a)in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ (sepConcat a x)in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l"], "message": ["Error: This expression has type string list\n       but an expression was expected of type string list list\n       Type string is not compatible with type string list \n"], "problem": "sepConcat"}
{"hw": "hw1", "fix": ["let _ = sumList [1; 3; 5; 7; 9; 11];\n\nstring_of_int(32)"], "bad": ["let _ = sumList [1; 3; 5; 7; 9; 11]\n\nint_of_string(32)", "let _ = sumList [1; 3; 5; 7; 9; 11];\n\nint_of_string(32)"], "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int but an expression was expected of type\n         string\n"], "problem": "sumList"}
{"hw": "hw1", "fix": ["let _ = 312/10"], "bad": ["let _ = 312.4/10"], "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ [(n mod 10)]"], "bad": ["let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ (n mod 10)", "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] :: (n mod 10)"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ [(n mod 10)]"], "bad": ["let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ (n mod 10)"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> n mod 10 :: []", "let _ = digitsOfInt 3124"], "bad": ["let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> digitsOfInt(n % 10) :: []", "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> digitsOfInt(n mod 10) :: []", "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> digitsOfInt(n mod 10) :: []"], "message": ["Error: Unbound value %\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let digitsOfInt n = \nlet rec addDigit n acc = \nif n = 0 then []\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "let _ = digitsOfInt 3124"], "bad": ["let digitsOfInt n = \nlet rec addDigit next n = \nif n < 0 then []\nelse addDigit ((n mod 10)::next) (n/10)", ") in \naddDigit [] n", "let _ = digitsOfInt 3124", "let digitsOfInt n = \nlet rec addDigit next n = \nif n < 0 then []\nelse addDigit ((n mod 10)::next) (n/10)", "let _ = digitsOfInt 3124", "let digitsOfInt n = \nlet rec addDigit next n = \nif n < 10 then n::next\nelse addDigit ((n mod 10)::next) (n/10)", "let _ = digitsOfInt 3124", "let digitsOfInt n = \nlet rec addDigit n acc = \nif n = 0 then []\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "let _ = digitsOfInt 3124"], "message": ["Error: Unbound value digitsOfInt\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value digitsOfInt\n", "Error: Syntax error\n", "Error: Unbound value digitsOfInt\n", "Error: Syntax error\n", "Error: Unbound value digitsOfInt\n", "Error: Unbound value loop\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let digitsOfInt n = \nif n <= 0 then []\nelse let rec addDigit n acc = \nif n <= 0 then acc\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "let _ = digitsOfInt -3124"], "bad": ["let _ = digitsOfInt 3124"], "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["let digitsOfInt n = \nlet rec addDigit n acc = \nif n <= 0 then acc\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "let _ = digitsOfInt (-3124)"], "bad": ["let _ = digitsOfInt (-3124)"], "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "problem": "digitsOfInt"}
{"hw": "hw1", "fix": ["lengthOfList [1;2;3] 0"], "bad": ["let rec lengthOfList xs count =\nmatch xs with\n| [] -> 0\n| hd::tl -> lengthOfList tl count+1"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "problem": "???"}
{"hw": "hw1", "fix": ["let rec additivePersistence n = \nmatch n with\n| 0 -> 0\n| _ -> (sumList (digitsOfInt n))"], "bad": ["let rec additivePersistence n = \nmatch n with\n| 0 -> 0\n| _ -> additivePersistence sumList (digitsOfInt n)", "let rec additivePersistence n = \nmatch n with\n| 0 -> 0\n| _ -> additivePersistence (sumList (digitsOfInt n))", "let _ = additivePersistence 9876"], "message": ["Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value sumList\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let rec lengthOfList xs count =\nmatch xs with\n| [] -> 0\n| hd::tl -> lengthOfList tl count+1", "let rec additivePersistence n = \nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList digitsOfInt n = 1)\nthen additivePersistence(sumList (digitsOfInt n))\nelse 4"], "bad": ["let _ = additivePersistence 9876", "let rec additivePersistence n = \nmatch n with\n| _ -> (sumList (digitsOfInt n))", "let _ = additivePersistence 9876", "let rec additivePersistence n = \nmatch n with\n| _ -> additivePersistence(sumList (digitsOfInt n))", "let _ = additivePersistence 9876"], "message": ["Error: Unbound value sumList\n", "Error: Unbound value additivePersistence\n", "Error: Unbound value sumList\n", "Error: Unbound value additivePersistence\n", "Error: Unbound value sumList\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let digitsOfInt n = \nlet rec lastDigit n acc = \nif n <= 0 then acc\nelse lastDigit (n/10) (n mod 10::acc) in\nmatch n with\n| _ -> lastDigit n []", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let digits n = digitsOfInt (abs n)", "let rec lengthOfList xs count =\nmatch xs with\n| [] -> 0\n| hd::tl -> lengthOfList tl count+1", "let sumDigits = fun x -> sumList (digitsOfInt x)", "sumDigits 123", "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additiveSequence (sumDigits n) count+1\nelse count"], "bad": ["let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additivePersistence sumDigits n count+1\nelse count\nin count = 0", "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additivePersistence sumDigits n (count+1)\nelse count\nin count = 0", "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additivePersistence (sumDigits n) count+1\nelse count\nin count = 0", "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additiveSequence sumDigits n count+1\nelse count\nin count = 0", "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additiveSequence (sumDigits n) count+1\nelse count\nin count = 0", "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additiveSequence (sumDigits n) count+1\nelse count"], "message": ["Error: Unbound value sumDigits\n", "Error: Unbound value digitsOfInt\n", "Error: Unbound value digitsOfInt\n", "Error: Unbound value digitsOfInt\n", "Error: Unbound value digitsOfInt\n", "Error: Unbound value digitsOfInt\n"], "problem": "additivePersistence"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4]"], "bad": ["let listReverse l = \nlet rec reverse l acc = \nreverse l acc in\nmatch l with\n| [] -> []\n| hd::tl -> reverse l []"], "message": ["Error: Unbound value digitalRoot\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let digitsOfInt n = \nlet rec lastDigit n accu = \nif n <= 0 then accu\nelse lastDigit (n/10) (n mod 10::accu) in\nmatch n with\n| _ -> lastDigit n []", "let _ = digitsOfInt 3124", "let _ = digitsOfInt 352663", "let digits n = digitsOfInt (abs n)", "let rec lengthOfList xs count =\nmatch xs with\n| [] -> 0\n| hd::tl -> lengthOfList tl count+1", "let additivePersistence n = \nlet rec sequence n i =\nif lengthOfList (digitsOfInt n) 0 = 1 then i\nelse sequence (sumList (digitsOfInt n)) i+1 in\nmatch n with\n| _ -> sequence n 0", "let _ = additivePersistence 9876", "let rec digitalRoot n =\nmatch n with\n| _ -> \nif lengthOfList (digitsOfInt n) 0 = 1 then n\nelse digitalRoot (sumList (digitsOfInt n))", "let _ = digitalRoot 9876", "let listReverse l = \nlet rec accReverse l acc =\nmatch l with\n| [] -> accu\n| hd::tl -> accReverse tl (hd::accu)\nin accReverse l acc"], "bad": ["let rec digitalRoot n =\nmatch n with\n| _ -> \nif lengthOfList (digitsOfInt n) 0 = 1 then n\nelse digitalRoot (sumList (digitsOfInt n))", "let _ = digitalRoot 9876", "let listReverse l = \nlet rec accReverse l acc =\nmatch l with\n| [] -> acc\n| hd::tl -> accReverse tl (hd::acc)"], "message": ["Error: Unbound value additivePersistence\n", "Error: Unbound value digitsOfInt\n", "Error: Unbound value digitalRoot\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = listReverse [1; 2; 3; 4]"], "bad": ["let listReverse l = \nlet rec accReverse l accu =\nmatch l with\n| [] -> accu\n| hd::tl -> accReverse tl (hd::accu)\nin accReverse l []"], "message": ["Error: Unbound value accu\nHint: Did you mean acc?\n"], "problem": "listReverse"}
{"hw": "hw1", "fix": ["let _ = palindrome \"malayalam\"", "let _ = palindrome \"myxomatosis\""], "bad": ["let palindrome w = fun x -> (explode s = listReverse(explode s))", "let palindrome w = fun x -> (explode w = listReverse(explode w))"], "message": ["Error: Unbound value at\n", "Error: Unbound value s\n"], "problem": "palindrome"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif List.mem h seen then\nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif List.mem h seen then\nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "l"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type unit\n", "Error: Unbound value l\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "l"], "message": ["Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: Unbound value l\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif not List.mem seen h then\nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"], "bad": [" _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"], "message": ["Error: Syntax error\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "l"], "bad": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif not (List.mem seen h) then\nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "l", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif not (List.mem seen h) then\nlet seen' = h::rest in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "l"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a list list\n       The type variable 'a occurs inside 'a list list\n", "Error: Unbound value l\n", "Error: This expression has type 'a list list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list list\n", "Error: Unbound value l\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif List.mem h seen then\nlet seen' = seen' in\nlet rest' = t in\nelse\nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"], "bad": ["et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"], "message": ["Error: Syntax error\n"], "problem": "removeDuplicates"}
{"hw": "hw2", "fix": ["let f x = let xx = x*x*x in (xx,xx<100)", "let _ = f 2"], "bad": ["let f x = let xx = x*x*x;\nlet _ = f 2", "let f x = let xx = x*x*x", "let _ = f 2"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Unbound value f\n"], "problem": "???"}
{"hw": "hw2", "fix": ["f 8"], "bad": ["let f 8"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d"], "bad": ["let rec assoc (d,k,l) = match l with\n| (s,i):t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d"], "message": ["Error: Syntax error\n"], "problem": "assoc"}
{"hw": "hw2", "fix": ["let wwhile (f,b) =\nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) (x,y)\n| false -> x\nin helper (f,b) (b, true)"], "bad": ["let wwhile (f,b) =\nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f, x)\n| false -> x\nin (f,b) (b, true)", "let wwhile (f,b) =\nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) (x,y)\n| false -> x\nin (f,b) (b, true)"], "message": ["Error: This expression has type 'a * bool -> 'b\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside 'a * bool -> 'b\n", "Error: This expression has type 'a * 'b\n       This is not a function; it cannot be applied.\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "bad": ["let wwhile (f,b) =\nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) f b\n| false -> x\nin helper (f,b) (b, true)", "let wwhile (f,b) =\nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) f b\n| false -> x\nin helper (f,b) (b, true)", "let wwhile (f,b) =\nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) (f b)\n| false -> x\nin helper (f,b) (b, true)"], "message": ["Error: Unbound value f\n", "Error: This expression has type 'a but an expression was expected of type\n         'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n", "Error: This expression has type 'a but an expression was expected of type\n         'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n"], "problem": "wwhile"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "bad": ["let fixpoint (f,b) = wwhile (f,b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1"], "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((f f b),b)"], "bad": ["let fixpoint (f,b) = wwhile ((f b),b)"], "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((f b),b)"], "bad": ["let fixpoint (f,b) = wwhile ((f (f b)),b)", "let fixpoint (f,b) = wwhile ((f b),b)"], "message": ["Error: This expression has type 'a -> 'b -> 'c\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b -> 'c\n", "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile ((f b),b)"], "bad": ["let fixpoint (f,b) = wwhile (f,b)"], "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile (f,f b)"], "bad": ["let fixpoint (f,b) = wwhile ((wwhile (f b)),b)"], "message": ["Error: Syntax error\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = wwhile (f,b)"], "bad": ["let fixpoint (f,b) = wwhile (f,(f b))", "let fixpoint (f,b) = wwhile (f,b)"], "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = \nwwhile (f, if b = (f b) then b else b)"], "bad": ["let fixpoint (f,b) = \nlet f x = xx = (f x) in (xx, xx != b) in f in\nwwhile (f,b)", "let fixpoint (f,b) = \nlet f x = xx = (f x) in (xx, xx != b) in f\nwwhile (f,b)", "let fixpoint (f,b) = \nlet f x = let xx = (f x) in (xx, xx != b) in f\nwwhile (f,b)", "let fixpoint (f,b) = \nlet f x = let xx = (f x) in (xx, xx != b) in f"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: Syntax error\n", "Error: Unbound value xx\n", "Error: This function has type 'a -> 'b * bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let f b = f -> f;\nlet fixpoint (f,b) = \nwwhile (\n, b)"], "bad": ["let fixpoint (f,b) = \nwwhile (f, if b = (f(b)) then b else b)", "let fixpoint (f,b) = wwhile (f, b)"], "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = \nlet g b = (b, (f b)) in \nwwhile (g, b)"], "bad": ["let fixpoint (f,b) = \nlet g b = b in \nwwhile ((g), b)", "let fixpoint (f,b) = \nlet g b = b in \nwwhile (g, b)", "let fixpoint (f,b) = \nlet g b = b in \nwwhile ((g,true), b)", "let fixpoint (f,b) = \nlet g b = b, (f b) in \nwwhile (g, b)"], "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) = \nif b != f b then\nlet f b = b, (f b) in\nwwhile(f, b)\nelse b"], "bad": ["let fixpoint (f,b) = \nlet g x = b, (f b) in (b = (f b)) in \nwwhile (g, b)", "let fixpoint (f,b) = \nif b != f b then\nlet f x = b, (f b) in\nwwhile(f, b)\nelse b"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b\n", "Error: Unbound value g\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif List.mem h seen then\nlet seen' = seen in\nlet rest' = t in\nhelper (seen', rest')\nelse\nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let wwhile (f,b) =\nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) (f b)\n| false -> x\nin helper (f,b) (b, true)", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) = \nif b != f b then\nlet b = f b in\nwwhile(f, b)\nelse b"], "bad": ["let fixpoint (f,b) = \nif b != f b then\nlet b = f b in\nwwhile(f, b)\nelse b"], "message": ["Error: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "bad": ["let fixpoint (f,b) =\nif b != f b then\nwwhile(f, f b)\nelse\nb", "let fixpoint (f,b) =\nif b != (f b) then\nwwhile(f, f b)\nelse\nb", "let fixpoint (f,b) =\nif b != (f b) then\nlet f = (f, true) in\nwwhile(f, f b)\nelse\nb", "let fixpoint (f,b) =\nif b != (f b) then\nlet f = (f b, true) in\nwwhile(f, f b)\nelse\nb", "let fixpoint (f,b) =\nif b != (f b) then\nlet f b = (b, true) in\nwwhile(f, f b)\nelse\nb", "let fixpoint (f,b) =\nif b != (f b) then\nlet f b = (b, true) in\nwwhile(f, f b)\nelse\nwwhile(f b)", "let fixpoint (f,b) =\nif b = f b then\nf b\nelse\nlet g b = (f b, true) in\nwwhile(g, f b)"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type ('a -> 'a) * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "Error: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a but an expression was expected of type\n         (('a -> 'a * bool) * 'a) * bool\n       The type variable 'a occurs inside (('a -> 'a * bool) * 'a) * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) =\nlet g b = (f b, (b = f b)) in\nwwhile(g, f b)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)", "let _ = fixpoint (collatz, 3)", "let _ = fixpoint (collatz, 48)", "let _ = fixpoint (collatz, 107)", "let _ = fixpoint (collatz, 9001)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "let _ = fixpoint (collatz, 1)"], "bad": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif List.mem h seen then\nlet seen' = seen in\nlet rest' = t in\nhelper (seen', rest')\nelse\nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "let wwhile (f,b) =\nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) (f b)\n| false -> x\nin helper (f,b) (b, true)", "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) =\nlet y x = (f b, (b = f b)) in\nwwhile(y, b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "bad": ["let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "let fixpoint (f,b) =\nlet g x = (f b, (b = f b)) in\nwwhile(g, b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "let fixpoint (f,b) =\nlet g x = (f b, (b != f b)) in\nwwhile(g, b)", "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) =\nlet y = f b in (y, (b = f b)) in\nwwhile(y, b)"], "bad": ["let fixpoint (f,b) =\nlet y x= (f b, (b = f b)) in\nwwhile(y b, b)", "let fixpoint (f,b) =\nlet y x= (f b, (b = f b)) in\nwwhile(y, b)"], "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "bad": ["let fixpoint (f,b) =\nlet y = f b in (y, (b = f b)) in\nwwhile(f, b)", "let fixpoint (f,b) =\nlet y = f b in (y, (b = f b)) in\nwwhile(y, b)", "let fixpoint (f,b) = let y = f b in (y, (b = f b)) in\nwwhile(y, b)", "let fixpoint (f,b) = let y = f b in (y, (b = f b)) in\nwwhile(f b, b)", "let fixpoint (f,b) = let y x = f b in (y, (b = f b)) in\nwwhile(y, b)", "let fixpoint (f,b) =\nlet y x = (f b, (b = f b)) in\nwwhile(y, b)"], "message": ["Error: Unbound value y\n", "Error: Unbound value f\n", "Error: Unbound value y\n", "Error: Unbound value y\n", "Error: Unbound value f\n", "Error: Unbound value y\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "bad": ["let fixpoint (f,b) =\nlet f x = (f b, (b = f b)) in\nwwhile(f, b)"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let fixpoint (f,b) =\nlet f x = (f b, (f b = b)) in\nwwhile(f, b)"], "bad": ["let fixpoint (f,b) =\nlet f x = (f, (f b = b)) in\nwwhile(f, f b)", "let fixpoint (f,b) =\nlet f x = (f, (f b = b)) in\nwwhile(f, x)", "let fixpoint (f,b) =\nlet f x = (f, (f b = b)) in\nwwhile(f b, b)", "let fixpoint (f,b) =\nlet f x = (f x, (f b = b)) in\nwwhile(f, b)"], "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a -> 'a\n       The type variable 'a occurs inside 'a -> 'a\n", "Error: This expression has type ('a -> 'a) * bool\n       but an expression was expected of type 'a -> 'a\n", "Error: Unbound value x\n", "Error: This expression has type ('a -> 'a) * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "problem": "fixpoint"}
{"hw": "hw2", "fix": ["let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi* eval e)\n| Cosine e-> cos(pi* eval e)\n| Average (e1,e2) -> (eval e1 + eval e2) / 2\n| Times (e1,e2) -> eval e1 * eval e2\n| Thresh (e1,e2,e3,e4) -> eval e1 < eval e2 ? eval e3 : eval e4", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval e)\n| Cosine e-> cos(pi*. eval e)\n| Average (e1,e2) -> (eval e1 +. eval e2) /. 2\n| Times (e1,e2) -> eval e1 *. eval e2\n| Thresh (e1,e2,e3,e4) -> if eval e1 < eval e2 then eval e3 else eval e4", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval(e,x,y))\n| Cosine e-> cos(pi*. eval(e,x,y))\n| Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2\n| Times (e1,e2) -> eval(e,x,y) *. eval(e,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e,x,y) < eval(e,x,y) then eval(e,x,y) else eval(e,x,y)", "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval(e,x,y))\n| Cosine e-> cos(pi*. eval(e,x,y))\n| Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2.\n| Times (e1,e2) -> eval(e,x,y) *. eval(e,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e,x,y) < eval(e,x,y) then eval(e,x,y) else eval(e,x,y)"], "message": ["Error: Unbound value eval\n", "Error: Syntax error\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval(e,x,y))\n| Cosine e-> cos(pi*. eval(e,x,y))\n| Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2.\n| Times (e1,e2) -> eval(e,x,y) *. eval(e,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e,x,y) < eval(e,x,y) then eval(e,x,y) else eval(e,x,y)"], "bad": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval(e,x,y))\n| Cosine e-> cos(pi*. eval(e,x,y))\n| Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2.\n| Times (e1,e2) -> eval(e,x,y) *. eval(e,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e,x,y) < eval(e,x,y) then eval(e,x,y) else eval(e,x,y)"], "message": ["Error: This expression has type expr but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw2", "fix": ["let g1 () = failwith \"to be implemented\"", "let g2 () = failwith \"to be implemented\"", "let g3 () = failwith \"to be implemented\"", "let c1 () = failwith \"to be implemented\"", "let c2 () = failwith \"to be implemented\"", "let c3 () = failwith \"to be implemented\"", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rand = makeRand(1,2)"], "bad": ["let rand = makeRand(1,2)"], "message": ["Error: Unbound value rand\nHint: Did you mean land?\n"], "problem": "???"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,7) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"], "bad": ["let build (rand, depth) = \nlet rec helper (e, rand, depth) =\nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,7) in\nmatch r with\n| 2 -> buildSine( helper (e, rand, depth-1))\n| 3 -> buildCosine( helper (e, rand, depth-1 ))\n| 4 -> buildAverage(helper (e, rand, depth-1),helper (e, rand, depth-1))", "let build (rand, depth) = \nlet rec helper (e, rand, depth) =\nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,7) in\nmatch r with\n| 2 -> buildSine( helper (e, rand, depth-1))\n| 3 -> buildCosine( helper (e, rand, depth-1 ))", "let build (rand, depth) = \nlet rec helper (e, rand, depth) =\nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,7) in\nmatch r with\n| 2 -> buildSine( helper (e, rand, depth-1))\n| 3 -> buildCosine( helper (e, rand, depth-1 ))", "let rec build (rand, depth) = \nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,7) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))"], "message": ["Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n", "Error: Syntax error\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let rec build (rand, depth) = \nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,9) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 -> buildSquared(build(rand,depth-1))\n| 8 -> buildRoot(build(rand,depth-1))", "let g1 () = (1, 1, 2)", "let g2 () = (1, 1, 10)", "let g3 () = (1, 1, 10)", "let c1 () = (1, 1, 2)", "let c2 () = (1, 1, 10)", "let c3 () = (1, 1, 10)", "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "let rec rseq g r n =\nif n <= 0 then [] else (g r)::(rseq g r (n-1))", "let toReal (i,n) = (float_of_int i) /. (float_of_int n)", "let toIntensity z = int_of_float (127.5 +. (127.5 *. z))", "let rec ffor (low,high,f) = \nif low > high then () else \nlet _ = f low in \nffor (low+1,high,f)", "let emitGrayscale (f,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_g_\"^name) in\nlet chan = open_out (fname^\".pgm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z = f (x,y) in\n(* Convert the result to a grayscale value *)\nlet iz = toIntensity(z) in\n(* Emit one byte for this pixel *)\noutput_char chan (char_of_int iz))) in \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".pgm \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".pgm\"))", "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "type test = unit -> string", "let key = \"\"", "let prefix130 = \"130\"", "let print130 s = print_string (prefix130^\">>\"^s)", "exception ErrorCode of string", "type result = Pass | Fail | ErrorCode of string", "let score = ref 0", "let max = ref 0", "let timeout = 300", "let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")", "let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0", "let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)", "let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))", "let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p", "let scoreMsg () = \nFormat.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max"], "bad": ["let rec build (rand, depth) = \nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,9) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 -> buildSquared(build(rand,depth-1))\n| 8 -> buildRoot(build(rand,depth-1))"], "message": ["Error: Unbound value buildSquare\nHint: Did you mean buildSquared?\nError: Unbound value buildSquare\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value buildSquare\nHint: Did you mean buildSquared?\n"], "problem": "build"}
{"hw": "hw2", "fix": ["let _ = eval (Sine(VarX),pi,0.)"], "bad": ["let _ = eval (Sine(VarX)),pi,0", ")", "let _ = eval ((Sine(VarX)),pi,0)", "let _ = eval ((Sine(VarX)),pi,0.)"], "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * float * float\nError: Unbound value pi\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "Error: This expression has type expr but an expression was expected of type\n         expr * float * float\nError: Unbound value pi\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "Error: Syntax error\n", "Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value pi\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         float\n"], "problem": "eval"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = (a*x) in\nlet base = 0 in\nList.fold_left f base xs"], "bad": ["let sqsum xs = \nlet f a x = (fun f _ -> a*a) in\nlet base = 0 in\nList.fold_left f base xs"], "message": ["Error: This expression has type int -> 'a -> 'b -> 'c -> int\n       but an expression was expected of type int -> 'a -> int\n       Type 'b -> 'c -> int is not compatible with type int \n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = (a*a) in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]"], "bad": ["let sqsum xs = \nlet f a x = () in\nlet base = 0 in\nList.fold_left f base xs"], "message": ["Error: This expression has type int but an expression was expected of type\n         unit\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let _ = sqsum [(-1); (-2); (-3); (-4)]", "let _ = sqsum [1;2;3]"], "bad": ["let _ = sqsum [(-1); (-2); (-3); (-4)]\nlet_ = sqsum [1;2;3]"], "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = (a+x*x) in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let _ = () 3"], "bad": ["let sqsum xs = \nlet f a x = (a+x*x) in\nlet base = x in\nList.fold_left f base xs"], "message": ["Error: Unbound value x\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let _ = fun f -> f"], "bad": ["let _ = *3"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (a+x) in\nlet base = 0 in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = (a+x) in\nlet base = base in\nList.fold_left f base fs"], "message": ["Error: Unbound value base\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = (a+x) in\nlet base = fs in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (a+x) in\nlet base = fs in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (a+x) in\nlet base = f in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (a+x) in\nlet base = [] in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (a+x) in\nlet base = (fun a->a) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = () in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int -> int -> int\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type unit\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = (a+x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = fun f -> (a x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = (fun x y) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (fun x -> f (a x)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "message": ["Error: Syntax error: operator expected.\n", "Error: Unbound value f\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = (fun f -> f (a x)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (fun f -> f (x)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (fun f -> a(f x)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (a (f x)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (a x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'a) -> 'a -> 'a\n       but an expression was expected of type ('a -> 'a) -> 'a\n       The type variable 'a occurs inside 'a -> 'a\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'c -> ('c -> 'a) -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'c -> 'a -> 'b\n       The type variable 'a occurs inside 'c -> 'a\n", "Error: Unbound value f\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = (a x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (x)a in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = (a x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (a x) in\nlet base = _ in\nList.fold_left f base fs", "let _ = pipe [] 3"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let pipe fs = \nlet f a x = (a x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (a x) in\nlet base = (x) in\nList.fold_left f base fs", "let pipe fs = \nlet f a x = (a x) in\nlet base = () in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let x = fun x -> x"], "bad": ["let x = fun x"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let _ = sqsum [(-1); (-2); (-3); (-4)]", "List.fold_left"], "bad": ["let _ = sqsum [(-1); (-2); (-3); (-4)]\n\nList.fold_left"], "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "sqsum"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (x a) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let pipe fs = \nlet f a x = (x x) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "message": ["Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let o f g = fun x -> f (g x)"], "bad": ["let (o) f g = fun x -> f (g x)"], "message": ["Error: Syntax error\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let o f g = fun x -> f (g x)"], "bad": ["let foo = (fun x -> x + 1) o (fun y -> 2 *y)", "let f o g = fun x -> f (g x)"], "message": ["Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value f\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let pipe fs = \nlet f a x = (fun y -> x (a y)) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "bad": ["let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"], "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "problem": "pipe"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h in\nlet base = \"\" in\nlet l = l in\nList.fold_left f base l"], "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n", "Error: Unbound value l\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = sepConcat sep t in\nList.fold_left f base l"], "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep::sepConcat(sep t) in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep^sepConcat(sep t) in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep^t in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"], "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type string list\n       but an expression was expected of type string\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"], "bad": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = sepConcat(sep t) in\nList.fold_left f base l", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = sepConcat sep t in\nList.fold_left f base l", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sepConcat(h^sep t) in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sepConcat h^sep t in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"], "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n", "Error: This expression has type string but an expression was expected of type\n         string list -> string\n", "Error: This expression has type 'a list -> string\n       but an expression was expected of type string\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let stringOfList f l = List.map sepConcat"], "bad": ["let stringOfList f l = List.map sepConcat \"\""], "message": ["Error: This expression has type string but an expression was expected of type\n         string list\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = List.map (sepConcat) (f l)"], "bad": ["let stringOfList f l = List.map (sepConcat l \"\") f", "let stringOfList f l = List.map (sepConcat \"\" l) f", "let stringOfList f l = List.map (sepConcat \"\" l)", "let stringOfList f l = List.map (sepConcat \"\" (f l))", "let stringOfList f l = List.map (sepConcat \"\" (f l))", "let stringOfList f l = List.map (sepConcat) f l"], "message": ["Error: This expression has type string but an expression was expected of type\n         string list\n", "Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n", "Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = List.map (sepConcat) (f l)"], "bad": ["let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let stringOfList f l = List.map (sepConcat \"\" (f l)) (f l)"], "message": ["Error: This expression has type int -> string\n       but an expression was expected of type int -> string list\n       Type string is not compatible with type string list \n", "Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = List.map (sepConcat) (f l)"], "bad": ["let _ = stringOfList string_of_int [1;2;3;4;5;6]"], "message": ["Error: This expression has type int but an expression was expected of type\n         string\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let _ = sepConcat \"\" [\"foo\"]"], "bad": ["let _ = sepConcat [\"foo\"]"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "problem": "sepConcat"}
{"hw": "hw3", "fix": ["let stringOfList f l = List.map (sepConcat) (l)"], "bad": ["let stringOfList f l = List.map (sepConcat \"\" (f l)) (l)"], "message": ["Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = List.map (sepConcat) (f l)", "let _ = stringOfList string_of_int [1;2;3;4;5;6]"], "bad": ["let _ = stringOfList string_of_int [1;2;3;4;5;6]"], "message": ["Error: This expression has type int but an expression was expected of type\n         string\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = List.map (sepConcat) (l)"], "bad": ["let stringOfList f l = List.map (sepConcat \"\" (f l)) (l)"], "message": ["Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let stringOfList f l = List.map (sepConcat) (f l)"], "bad": ["let stringOfList f l = List.map (sepConcat) f(l)"], "message": ["Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let clone x n = \nlet rec helper x n acc =\nif n <= 0 then acc\nelse helper x (n-1) (x::acc)\nin helper x n []"], "bad": ["let rec clone x n = \nif n <= 0 then []\nelse x :: clone x n-1", "let rec clone x n = \nif n <= 0 then []\nelse x :: clone x n-1", "let rec clone x n = \nif n <= 0 then []\nelse x :: clone (x n-1)", "let rec clone x n = \nif n <= 0 then []\nelse x :: clone x n-1", "let rec clone x n = \nif n <= 0 then []\nelse clone x n-1", "let rec clone x n = \nif n <= 0 then []\nelse then x :: clone x n-1", "let rec clone x n = \nif n <= 0 then []\nelse x :: clone x n-1", "let clone x n = \nlet rec helper x n acc =\nif n <= 0 then acc\nelse helper x n-1 x:acc\nin helper x n []", "let clone x n = \nlet rec helper x n acc =\nif n <= 0 then acc\nelse helper x n-1 x::acc\nin helper x n []"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         int -> int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: Syntax error\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: Syntax error\n", "Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type int\n"], "problem": "clone"}
{"hw": "hw3", "fix": ["List.length([0;0;0;9]);\n[[0;0;9;9]] @ [[1;0;0;2]]"], "bad": ["List.length([0;0;0;9])\n[[0;0;9;9]] @ [[1;0;0;2]]"], "message": ["Error: This function has type 'a list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "???"}
{"hw": "hw3", "fix": ["List.append [[0;0;9;9]] [[1;0;0;2]]"], "bad": ["List.append([[0;0;9;9]], [[1;0;0;2]])"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "problem": "???"}
{"hw": "hw3", "fix": ["List.append [[0;0;9;9]] [[1;0;0;2]]"], "bad": ["List.append [[0;0;9;9]] [[1;0;0;2]] [[1;2]]"], "message": ["Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\nList.append [(clone 0 (List.length l2 - List.length l1)) @ l1] [l2]\nelse\nList.append [l1] [(clone 0 (List.length l1 - List.length l2)) @ l2]"], "bad": ["let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\nList.append [(clone 0 (List.length l2 - List.length l1)) @ l1] [l2]\nelse (List.length l1) > (List.length l2)\nList.append [l1] [(clone 0 (List.length l1 - List.length l2)) @ l2]"], "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\n((clone 0 (List.length l2 - List.length l1)) @ l1, l2)\nelse\n(l1, (clone 0 (List.length l1 - List.length l2)) @ l2)"], "bad": ["let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\n([(clone 0 (List.length l2 - List.length l1)) @ l1], [l2])\nelse\n([l1], [(clone 0 (List.length l1 - List.length l2)) @ [l2])", "let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\n([(clone 0 (List.length l2 - List.length l1)) @ l1], l2)\nelse\n([l1], [(clone 0 (List.length l1 - List.length l2)) @ l2)", "let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\n((clone 0 (List.length l2 - List.length l1)) @ l1, l2)\nelse\n([l1], (clone 0 (List.length l1 - List.length l2)) @ l2)"], "message": ["Error: Syntax error: operator expected.\n", "Error: Syntax error: operator expected.\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\n(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\nelse\n(l1, List.append (clone 0 (List.length l1 - List.length l2)) l2)"], "bad": ["let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\n((List.append clone 0 (List.length l2 - List.length l1)) l1, l2)\nelse\n(l1, List.append (clone 0 (List.length l1 - List.length l2)) l2)"], "message": ["Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let _ = stringOfList string_of_int [9;9]"], "bad": ["let _ = stringOfList [9;9]"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'b -> string\n"], "problem": "stringOfList"}
{"hw": "hw3", "fix": ["let _ = padZero [9;9] [1;0;0;2]"], "bad": ["let _ = List.rev List.combine( padZero([9;9] [1;0;0;2]))", "let _ = List.rev (List.combine( padZero([9;9] [1;0;0;2])))", "let _ = List.rev (List.combine( padZero [9;9] [1;0;0;2]))"], "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list * int list\n       but an expression was expected of type 'a list\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let _ = padZero [9;9] [1;0;0;2]"], "bad": ["let _ = List.combine(padZero [9;9] [1;0;0;2])"], "message": ["Error: This expression has type int list * int list\n       but an expression was expected of type 'a list\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let _ = padZero [9;9] [1;0;0;2]"], "bad": ["let _ = List.rev(padZero [9;9] [1;0;0;2])"], "message": ["Error: This expression has type int list * int list\n       but an expression was expected of type 'a list\n"], "problem": "padZero"}
{"hw": "hw3", "fix": ["let _ = removeZero [0;0;0;0]", "let _ = int_of_list [9;9]"], "bad": ["let _ = removeZero [0;0;0;0]\n\nint_of_list [9;9]"], "message": ["Error: This function has type int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "problem": "removeZero"}
{"hw": "hw3", "fix": ["let _ = List.combine y z"], "bad": ["let _ = List.combine(y, z)"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let p = match o with\n| h::h2::t::(s,i)::t2 -> s+i"], "bad": ["let p = match o with\n| h::h2::t::(s,i) -> s+i", "let p = match o with\n| h::h2::t::(s,i)::t -> s+i"], "message": ["Error: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type\n         (int * int) list\n", "Error: Variable t is bound several times in this matching\n"], "problem": "???"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [(0, [])] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = xin", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (a,b) in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = (0,List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = (0, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = (0, l1) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = (0, []) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error\n", "Error: Unbound value a\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type (int * 'c list) list\n", "Error: This expression has type int * ('a * 'b) list\n       but an expression was expected of type (int * 'c list) list\n", "Error: This expression has type int * 'a\n       but an expression was expected of type (int * 'b list) list\n", "Error: This expression has type int * 'a\n       but an expression was expected of type (int * 'b list) list\n", "Error: This expression has type int * 'a list\n       but an expression was expected of type (int * 'b list) list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [(0, [])] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [(0, [l1,l2])] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type (int list * int list) list\n       but an expression was expected of type int list\n       Type int list * int list is not compatible with type int \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [ (3, [] ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [ (l1+l2, [] ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int list * int list\n       but an expression was expected of type int * int\n       Type int list is not compatible with type int \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| x'::xs -> x' in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [[ (h, l2 ) ]] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| x::xs -> x in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| x'::xs -> x' in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * 'c list) list list\n       Type 'a * 'b is not compatible with type (int * 'c list) list \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * 'c list) list list\n       Type 'a * 'b is not compatible with type (int * 'c list) list \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (c,d) -> (c,d) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (c,d) -> c in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a * 'b -> 'c -> 'a\n       but an expression was expected of type 'a * 'b -> 'c -> 'a * 'b\n       The type variable 'a occurs inside 'a * 'b\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d) -> a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d) -> (c,a) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a -> 'b * 'c -> 'b * 'a\n       but an expression was expected of type 'a -> 'b * 'c -> 'a\n       The type variable 'a occurs inside 'b * 'a\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d) -> a in\nlet base = (0, [1]) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d) -> a in\nlet base = (0, [1,1]) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d) -> c+d::a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> c+d::a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c+d::a,l2) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> c+d::a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int * 'a list\n       but an expression was expected of type int list\n", "Error: This expression has type int * 'a list\n       but an expression was expected of type int list\n", "Error: This expression has type int list -> int * int list -> int list * 'a\n       but an expression was expected of type\n         int list -> int * int list -> int list\n       Type int list * 'a is not compatible with type int list \n", "Error: This expression has type int * 'a list\n       but an expression was expected of type int list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,d::t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> c+d in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c+d)::a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> c in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> c,d in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,d) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int * 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int * 'a list\n       but an expression was expected of type int list\n", "Error: This expression has type int list * int list\n       but an expression was expected of type (int * 'a list) list * 'b list\n       Type int is not compatible with type int * 'a list \n", "Error: This expression has type int list * int list\n       but an expression was expected of type int list * 'a list list\n       Type int is not compatible with type 'a list \n", "Error: This expression has type int list * int list\n       but an expression was expected of type int list * 'a list list\n       Type int is not compatible with type 'a list \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,a) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,[a]) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a -> 'b * 'c list -> 'b * 'a\n       but an expression was expected of type 'a -> 'b * 'c list -> 'a\n       The type variable 'a occurs inside 'b * 'a\n", "Error: This expression has type 'a -> 'b * 'c list -> 'b * 'a list\n       but an expression was expected of type 'a -> 'b * 'c list -> 'a\n       The type variable 'a occurs inside 'b * 'a list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, List.rev l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,d) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, List.rev l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int list * int list\n       but an expression was expected of type int list * 'a list list\n       Type int is not compatible with type 'a list \n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, List.rev l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,c+t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, List.rev l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2) -> (d1+d2, d1+d2::\nmatch a with \n| (a1,a2)->a2) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2) -> (d1+d2, d1+d2::) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2) -> (d1+d2, d1+d2::a) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2) -> (d1+d2, d1+d2::(match a with | (a1,a2)->a2) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "message": ["Error: Syntax error: operator expected.\n", "Error: This expression has type int list -> int * int -> int * int list\n       but an expression was expected of type\n         int list -> int * int -> int list\n       Type int * int list is not compatible with type int list \n", "Characters 79-80:\n  | (d1,d2) -> (d1+d2, d1+d2::(match a with | (a1,a2)->a2) in\n               ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (o,p) = a in\nmatch x with \n| (d1,d2) -> (((d1+d2) mod 10 -(d1+d2))/10, (d1+d2) mod 10+o::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2) -> (((d1+d2) mod 10 -(d1+d2))/10, (d1+d2) mod 10+\nmatch a with \n| (a1,a2)->a1)::a2 in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2) -> (((d1+d2) mod 10 -(d1+d2))/10, (d1+d2) mod 10+\nmatch a with \n| (a1,a2)-> a1::a2 in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "message": ["Error: Unbound value a2\n", "Characters 79-80:\n  | (d1,d2) -> (((d1+d2) mod 10 -(d1+d2))/10, (d1+d2) mod 10+\n               ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (o,p) = a in\nmatch x with \n| (d1,d2) -> ((d1+d2) mod 10 /10, ((d1+d2) mod 10)+o ::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (o,p) = a in\nmatch x with \n| (d1,d2) -> ((d1+d2) mod 10 /10, ((d1+d2) mod 10)+o)::p"], "message": ["Error: Syntax error\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (o,p) = a in\nmatch x with \n| (d1,d2) -> ( (d1+d2+o)/10, ((d1+d2+o) mod 10) ::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (o,p) = a in\nmatch x with \n| (d1,d2) -> ( (d1+d2+a)/10, ((d1+d2+o) mod 10) ::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (o,p) = a in\nlet (d1,d2) = x in ( (d1+d2+o)/10, ((d1+d2+o) mod 10) ::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "bad": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (o,p) = a in\nlet (d1,d2) = x in ( (d1+d2+o)/10, ((d1+d2+o) mod 10) ::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine 0::l1 0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "problem": "bigAdd"}
{"hw": "hw3", "fix": ["let mulByDigit i l = \nlet rec helper i l acc =\nmatch l with\n| [] -> acc\n| h::t -> (h*i) :: acc \nin helper i l []"], "bad": ["let rec mulByDigit i l = let h::t = List.rev l in\nmulByDigit (h*i)"], "message": ["Error: This expression has type int list -> 'a\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside int list -> 'a\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let mulByDigit i l = \nlet rec helper i l acc =\nmatch l with\n| [] -> acc\n| h::t -> h*i :: acc \nin helper i l []"], "bad": ["let mulByDigit i l = \nlet rec helper i l acc =\nmatch l with\n| [] -> acc\n| h::t -> helper(t*i) :: acc \nin helper i l []", "let mulByDigit i l = \nlet rec helper i l acc =\nmatch l with\n| [] -> acc\n| h::t -> helper(h*i) :: acc \nin helper i l []"], "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int list -> 'a list -> 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside int list -> 'a list -> 'a list\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let rec mulByDigit i l = mulByDigit (i-1) (bigAdd l l)"], "bad": ["let rec mulByDigit i l = mulByDigit i-1 (bigAdd l l)"], "message": ["Error: This expression has type 'a -> 'b\n       but an expression was expected of type int\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let sqsum xs = \nlet f a x = (a+x*x) in\nlet base = 0 in\nList.fold_left f base xs", "let _ = sqsum []", "let _ = sqsum [1;2;3;4]", "let _ = sqsum [(-1); (-2); (-3); (-4)]", "let pipe fs = \nlet f a x = fun y -> x (a y) in\nlet base = fun x -> x in\nList.fold_left f base fs", "let _ = pipe [] 3", "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "let _ = sepConcat \"---\" []", "let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]", "let _ = sepConcat \"X\" [\"hello\"]", "let stringOfList f l = \"[\"^sepConcat \"; \" (List.map f l)^\"]\"", "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "let _ = stringOfList (fun x -> x) [\"foo\"]", "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "let clone x n = \nlet rec helper x n acc =\nif n <= 0 then acc\nelse helper x (n-1) (x::acc)\nin helper x n []", "let _ = clone 3 5", "let _ = clone \"foo\" 2", "let _ = clone clone (-3)", "let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\n(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\nelse\n(l1, List.append (clone 0 (List.length l1 - List.length l2)) l2)", "let _ = padZero [9;9] [1;0;0;2]", "let _ = padZero [1;0;0;2] [9;9]", "let _ = padZero [0;0;1;2] [2;2;3;4]", "let rec removeZero l = match l with\n| [] -> []\n| x::xs -> \nif x = 0 then removeZero xs\nelse x::xs", "let _ = removeZero [0;0;0;1;0;0;2]", "let _ = removeZero [9;9]", "let _ = removeZero [0;0;0;0]", "let _ = 18/10", "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (o,p) = a in\nlet (d1,d2) = x in ( (d1+d2+o)/10, ((d1+d2+o) mod 10) ::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine (0::l1) (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "let _ = bigAdd [9;9] [1;0;0;2]", "let _ = bigAdd [9;9;9;9] [9;9;9]", "let _ = bigAdd [3] []", "let _ = bigAdd [9;9;9;9] [9;9;9;9]", "let mulByDigit i l = \nlet rec helper i l hold = \nmatch i with\n| 0 -> hold\n| _ -> helper (i-1) l (bigAdd l hold)\nin helper i l []", "let _ = mulByDigit 9 [9;9;9;9]", "let _ = mulByDigit 3 [3;3;3]"], "bad": ["let a1::a2::t = l1 in\n(mulByDigit a2 (mulByDigit a1 l2))"], "message": ["Error: Unbound value bigAdd\n"], "problem": "mulByDigit"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet h::t = x in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o) )in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet h::t = x in (o+1, bigAdd (mulByDigit h l2) p @ clone 0 o )in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: Unbound value b\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value b\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet (h::t,y) = x in (o+1, bigAdd (mulByDigit h y) (p @ clone 0 o) ) in\nlet base = (0,[]) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres"], "bad": ["let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet h::t = x in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o) ) in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let _ = bigMul [9;9;9;9] [9;9;9;9]"], "bad": ["let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet (h::t,y) = x in (o+1, bigAdd (mulByDigit h y) (p @ clone 0 o) ) in\nlet base = (0,[]) in\nlet args = [(l1, l2)] in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type (int list * int list) list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * 'b\n       but an expression was expected of type (int list * int list) list\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let _ = bigMul [9;9;9;9] [9;9;9;9]"], "bad": ["let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet (h::t) = x in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o)) in\nlet base = (0,[]) in\nlet args = [l1] in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: Unbound value y\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value y\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let _ = bigMul [9;9;9;9] [9;9;9;9]"], "bad": ["let _ = bigMul [[9;9;9;9]] [9;9;9;9]"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "bigMul"}
{"hw": "hw3", "fix": ["let _ = bigMul [9;9;9;9] [9;9;9;9]"], "bad": ["let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet h::t = [x] in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o)) in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "message": ["Error: This expression has type int but an expression was expected of type\n         int list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         int list\n"], "problem": "bigMul"}
