hw1 sumList

fix:
let rec sumList xs = match xs with
| [] -> 0
| x::xs' -> x + sumList xs'

bad:
let rec sumList xs = match xs with
| [] -> []
| h1::h2::t -> h1+h2 sumList t
Error: This expression has type int
       This is not a function; it cannot be applied.


let rec sumList xs = match xs with
| [] -> []
| (x::xs') -> x+1 sumList xs'
Error: This expression has type int
       This is not a function; it cannot be applied.


let rec sumList xs = match xs with
| [] -> []
| (x::xs') -> x sumList xs'
Error: This expression has type ('a -> 'b -> 'c) list -> 'd list
       but an expression was expected of type 'a
       The type variable 'a occurs inside ('a -> 'b -> 'c) list -> 'd list


let rec sumList xs = match xs with
| [] -> []
| (x::xs') -> x + sumList xs'
Error: This expression has type 'a list
       but an expression was expected of type int


let rec sumList xs = match xs with
| [] -> []
| (x::xs') ->  1 sumList xs'
Error: This expression has type int
       This is not a function; it cannot be applied.


let rec sumList xs = match xs with
| [] -> []
| (x::xs') -> x sumList xs'
Error: This expression has type ('a -> 'b -> 'c) list -> 'd list
       but an expression was expected of type 'a
       The type variable 'a occurs inside ('a -> 'b -> 'c) list -> 'd list


let rec sumList xs = match xs with
| [] -> []
| (x::xs') -> x + sumList xs'
Error: This expression has type 'a list
       but an expression was expected of type int


let rec sumList xs = match xs with
| [] -> []
| (x::xs') -> x sumList xs'
Error: This expression has type ('a -> 'b -> 'c) list -> 'd list
       but an expression was expected of type 'a
       The type variable 'a occurs inside ('a -> 'b -> 'c) list -> 'd list


let rec sumList xs = match xs with
| [] -> []
| x::xs' -> x sumList xs'
Error: This expression has type ('a -> 'b -> 'c) list -> 'd list
       but an expression was expected of type 'a
       The type variable 'a occurs inside ('a -> 'b -> 'c) list -> 'd list



hw1 digitsOfInt

fix:
let rec digitsOfInt n = match n with
| _ -> (n mod 10) + digitsOfInt  (n/10)

bad:
let rec digitsOfInt n = match n with
| n < 0 -> []
| _     -> n%10 digitsOfInt  n/10
Error: Syntax error


let rec digitsOfInt n = match n with
| _     -> n%10 digitsOfInt  n/10
Error: Unbound value %


let rec digitsOfInt n = match n with
| _     -> n mod 10 digitsOfInt  n/10
Error: This expression has type int
       This is not a function; it cannot be applied.


let rec digitsOfInt n = match n with
| (n mod 10) + digitsOfInt  (n/10)
Characters 39-40:
  | (n mod 10) + digitsOfInt  (n/10);;
    ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if (n<0) 
then 0
else
(n mod 10) + digitsOfInt  (n/10)

bad:
let rec digitsOfInt n = match true with
| n<0 -> 0
| _ -> (n mod 10) + digitsOfInt  (n/10)
Error: Syntax error



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if (n<=0) 
then []
else
(n mod 10) :: digitsOfInt  (n/10)

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

bad:
let rec digitsOfInt n = 
if (n<=0) 
then []
else
digitsOfInt  (n/10) :: (n mod 10)
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec digitsOfInt n = 
if (n<=0) 
then []
else
digitsOfInt (n/10) :: (n mod 10)
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec digitsOfInt n = 
if (n<=0) 
then []
else
(digitsOfInt (n/10) ):: (n mod 10)
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 digitalRoot

fix:
let rec sum n = 
if n < 0 
then failwith"TBD"
else (n mod 10) + digitalRoot n/10

bad:
let rec digitalRoot n = 
let temp = (sum n) in 
if temp > 10
then digitalRoot temp
Error: Unbound value sum


let rec sum n = 
if n < 0 
then failwith"TBD"
else n%10 + digitalRoot n/10
Error: Unbound value %



hw1 additivePersistence

fix:
let rec additivePersistence n = additivePersistence_helper (n, 0)

bad:
let rec additivePersistence n = additivePersistence (n, 0)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a * 'b



hw1 digitsOfInt

fix:
let rec sum (n, i) = 
if n < 10
then (sumList (digitsOfInt n), i)
else (sumList (digitsOfInt n), 1+1)

bad:
let rec sum (n, i) = 
if n < 10
then sumList (digitsOfInt n) i
else sumList (digitsOfInt n) 1+1
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 digitsOfInt

fix:
let rec sum (n, i) = 
if n < 10
then (sumList (digitsOfInt n), i)
else (sumList (digitsOfInt n), 1+1)

bad:
let rec sum [n;i] = 
if n < 10 || []
then [sumList (digitsOfInt n); i]
else [sumList (digitsOfInt n); 1+1]
Error: This variant expression is expected to have type bool
       The constructor [] does not belong to type bool



hw1 listReverse

fix:
let rec listReverse l = match l with
| [] -> []
| hd::tl ->  hd :: listReverse tl

bad:
let rec listReverse l = match l with
| [] -> []
| hd::tl -> tl :: listReverse hd
Error: This expression has type 'a but an expression was expected of type
         'a list
       The type variable 'a occurs inside 'a list


let rec listReverse l = match l with
| [] -> []
| hd::tl ->  listReverse tl :: hd
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 listReverse

fix:
let rec listReverse l = match l with
| [] -> []
| hd::tl ->  (listReverse tl) @ hd

bad:
let rec listReverse l = match l with
| [] -> []
| hd::tl ->  (listReverse tl) :: hd
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 listReverse

fix:
let rec listReverse l = match l with
| [] -> []
| _::tl -> listReverse tl

let _ = listReverse [1; 2; 3; 4]

bad:
let _ = listReverse [1; 2; 3; 4]
Error: This expression has type int but an expression was expected of type
         'a list


let rec listReverse l = match l with
| [] -> []
| hd::tl ->  
if hd != [] 
then (listReverse tl) :: hd
else hd
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 ???

fix:
let rec last l = match l with 
| [] -> []
| _::tl -> last tl

let _ = last [1; 2; 3; 4]

bad:
let rec last l = match l with 
| [] -> []
| _::tl2::tl -> last tl2
Error: This expression has type 'a but an expression was expected of type
         'a list
       The type variable 'a occurs inside 'a list



hw1 ???

fix:
let rec last l = match l with 
| x::[] -> x
| hd::tl -> last tl
| [] -> failwith "NO ELEMENT"

let _ = last [1; 2; 3; 4]

bad:
let rec last l = match l with 
| [] -> 0
| hd::tl -> last tl :: hd
Error: This expression has type 'a list
       but an expression was expected of type int



hw1 listReverse

fix:
let rec last l = match l with 
| x::[] -> x
| hd::tl -> last tl 
| [] -> failwith "NO ELEMENT"

let _ = last [1; 2; 3; 4]

let rec listReverse l = match l with
| [] -> []
| hd::tl -> let x = last tl

bad:
let rec listReverse l = match l with
| [] -> []
| _ -> let x = last tl
Error: Syntax error



hw1 listReverse

fix:
let rec listReverse l = match l with
| [] -> []
| hd::tl -> listReverse (hd::l)

bad:
let rec listReverse l = match l with
| [] -> []
| hd::tl -> let x = last l
Error: Syntax error


let rec listReverse l = match l with
| [] -> []
| hd::tl -> let x = last l in
if x > 0
then x
else x
Error: This expression has type int but an expression was expected of type
         'a list


let rec listReverse l = match l with
| [] -> []
| hd::tl -> let x = last l in
if x > 0
then x::x
else x::x
Error: This expression has type int but an expression was expected of type
         int list


let rec listReverse l = match l with
| [] -> []
| hd::tl -> listReverse(hd::l) tl
Error: This function has type 'a list -> 'b list
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 listReverse

fix:
let rec listReverse l = match l with
| [] -> []
| hd::tl -> listReverse tl @ hd

bad:
let rec listReverse l = match l with
| [] -> []
| hd::tl -> listReverse tl @ hd
Error: This function has type 'a list -> 'b list
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 listReverse

fix:
let rec listReverse l = match l with
| [] -> []
| hd::tl -> listReverse tl @ [hd]

let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l = match l with
| [] -> []
| hd::tl -> listReverse tl :: [hd]
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let _ = listReverse [1; 2; 3; 4]
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l = match l with
| [] -> []
| hd::tl -> listReverse tl @ [hd]
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 palindrome

fix:
let _ = palindrome "malayalam"

bad:
let palindrome w = 
if explode w = listReverse (explode w)
then true
else false
Error: Unbound value l



hw1 ???

fix:
let a = []

let b = 3

let _ = fun a b

bad:
let f = fun x l -> x::l
Error: Syntax error



hw1 ???

fix:
let b = []

let a = 3

bad:
let _ = f a b
Error: Syntax error



hw1 ???

fix:
let rec last l = match l with 
| x::[] -> x
| hd::tl -> last tl
| [] -> []

bad:
let rec last l = match l with 
| x::[] -> x
| hd::tl -> last tl
| [] -> []
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 listReverse

fix:
let rec sumList xs = match xs with
| []     -> 0
| x::xs' -> x + sumList xs'

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

let rec digitsOfInt n = 
if (n<=0) 
then []
else
(n mod 10) :: digitsOfInt  (n/10)

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

let digits n = digitsOfInt (abs n)

let sum (n, i) = 
if n < 10
then (sumList (digitsOfInt n), i)
else (sumList (digitsOfInt n), i+1)

let rec additivePersistence_helper (n, i) = 
let temp = (sum (n,i)) in
let (num, count) = temp in 
if num >= 10
then additivePersistence_helper (num, count)
else count

let rec additivePersistence n = additivePersistence_helper (n, 0)

let _ = additivePersistence 9876

let rec digitalRoot n = 
let temp = sumList (digitsOfInt n) in
if temp >= 10
then digitalRoot temp
else temp

let _ = digitalRoot 9876

let rec listReverse l = match l with 
| [] -> 0
| hd::tl -> listReverse tl :: hd

bad:
let rec listReverse l = 
failwith "err"
Error: This expression has type int but an expression was expected of type
         'a list



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l = match l with 
| [] -> 0
| hd::tl -> listReverse tl
Error: This expression has type 'a list
       but an expression was expected of type int



hw1 listReverse

fix:
let rec sumList xs = match xs with
| []     -> 0
| x::xs' -> x + sumList xs'

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

let rec last l = match l with 
| x::[]  -> x
| hd::tl -> last tl
| []     ->  failwith "error"

let rec removeLast l = match l with 
| x::[]  -> []
| hd::tl -> hd::removeLast tl
| []     -> []

let rec listReverse l = 
let x = last l in
let y = removeLast l in
if (y=[])
then x::y
else x::listReverse y

let _ = listReverse [1; 2; 3; 4]

let _ = listReverse ["a"; "b"; "c"; "d"]

let rec reversed n = 
if (n<=0) 
then []
else
(n mod 10) :: reversed  (n/10)

let rec digitsOfInt n = 
listReverse (reversed n)

let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
listReverse reversed n
Error: Unbound value rlistReverse
Hint: Did you mean listReverse?
Error: Unbound value rlistReverse
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value rlistReverse
Hint: Did you mean listReverse?


let _ = digitsOfInt 3124
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.



hw2 fixpoint

fix:
let fixpoint (f,b) = 
wwhile (f,b)

bad:
let fixpoint (f,b) = 
let b' = f b in
if b'=b then
b
else 
fixpoint (f,b')
Error: This expression has type 'a * 'b -> 'a * 'b
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a * 'b -> 'a * 'b



hw2 fixpoint

fix:
let fixpoint (f,b) = 
let f b = (f b, b=f b) in
wwhile (f,b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = 
let b' = (b, (f b = b)) in 
wwhile (f,b')
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> 'a * bool
       The type variable 'a occurs inside 'a * bool


let fixpoint (f,b) = 
let b' = (b, (f b < b)) in 
wwhile (f,b')
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> 'a * bool
       The type variable 'a occurs inside 'a * bool


let fixpoint (f,b) = 
let f' = (f b, f'=b ) in
wwhile (f',b)
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> 'a * bool
       The type variable 'a occurs inside 'a * bool


let fixpoint (f,b) = 
let f' = (f b, f b=b ) in
wwhile (f',b)
Error: Unbound value f'


let fixpoint (f,b) = 
let f b = (f b, b=f b) in
wwhile (f,b)
Error: This expression has type 'a * bool
       but an expression was expected of type 'b -> 'b * bool



hw2 fixpoint

fix:
let fixpoint (f,b) =
let f b = (f b, f b = b) in
wwhile (f, b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = 
let f' = f b -> (f b, b=f b) in
wwhile(f',b)
Error: This expression has type int -> int
       but an expression was expected of type int -> int * bool
       Type int is not compatible with type int * bool 


let fixpoint (f,b) = 
let f' = fun f -> fun b -> (f b, b=f b) in
wwhile(f',b)
Error: Syntax error


let fixpoint (f,b) =
failwith "to be d"
Error: This expression has type ('a -> 'a) -> 'a -> 'a * bool
       but an expression was expected of type ('a -> 'a) -> ('a -> 'a) * bool
       Type 'a -> 'a * bool is not compatible with type ('a -> 'a) * bool 



hw2 fixpoint

fix:
let fixpoint (f,b) =
let f b = let b' = f b in b=b' in b'

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) =
let f b = let b' = f b in b=b'
Error: Unbound value b'


let fixpoint (f,b) =
let f b = let b' = f b in b=b' in

let g x = (x-1) in fixpoint (g,8)
Error: Syntax error



hw2 ???

fix:
let a = Succ(Succ(Zero))

bad:
let a = Succ(Zero)
Error: This expression has type nat but an expression was expected of type
         int



hw2 ???

fix:
let b = to_int (Succ(Succ(Zero)))

bad:
let b = to_int (Succ(Zero))
Error: This function has type nat -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw2 exprToString

fix:
let b = exprToString Sine(VarX)

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine m -> "sin"^ exprToString m
Error: This expression has type expr -> string
       but an expression was expected of type string



hw2 exprToString

fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine m -> "sin("^ exprToString m ^ ")"

let b = exprToString (Sine(VarX))

bad:
let b = exprToString (Sine(VarX))
Error: This function has type expr -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw2 exprToString

fix:
let b = exprToString (Cosine(VarX))

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine m -> "sin("^ exprToString m ^ ")"
| Cosine m -> "cos(" ^ exprToString m ^ ")"
| Average (m,n) -> "((" ^ exprToStirng m ^ "+" ^ exprToString n ^ ")/2)"
Error: This pattern matches values of type 'a * 'b
       but a pattern was expected which matches values of type expr


let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine m -> "sin("^ exprToString m ^ ")"
| Cosine m -> "cos(" ^ exprToString m ^ ")"
| Average (m,n) -> "((" ^ exprToString m ^ "+" ^ exprToString n ^ ")/2)"
Error: Unbound value exprToStirng
Hint: Did you mean exprToString?



hw2 exprToString

fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine m -> "sin("^ exprToString m ^ ")"
| Cosine m -> "cos(" ^ exprToString m ^ ")"
| Average (m,n) -> "((" ^ exprToString m ^ "+" ^ exprToString n ^ ")/2)"
| Times (m,n) -> exprToString m ^ "*" ^ exprToString n
| Tresh (m,n,o,p) -> 
"(" ^ exprToString m^ "<" ^exprToString n^"?"^exprToString o^":"^exprToString p

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine m -> "sin("^ exprToString m ^ ")"
| Cosine m -> "cos(" ^ exprToString m ^ ")"
| Average (m,n) -> "((" ^ exprToString m ^ "+" ^ exprToString n ^ ")/2)"
| Times (m,n) -> exprToString m ^ "*" ^ exprToString n
Error: Syntax error



hw2 exprToString

fix:
let b = exprToString (Average(Cosine(VarX),VarY))

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine m -> "sin("^ exprToString m ^ ")"
| Cosine m -> "cos(" ^ exprToString m ^ ")"
| Average (m,n) -> "((" ^ exprToString m ^ "+" ^ exprToString n ^ ")/2)"
| Times (m,n) -> exprToString m ^ "*" ^ exprToString n
| Thresh (m,n,o,p) -> 
"(" ^ exprToString m^ "<" ^exprToString n^"?"^exprToString o^":"^exprToString p
Error: This variant pattern is expected to have type expr
       The constructor Tresh does not belong to type expr
Hint: Did you mean Thresh?



hw2 eval

fix:
let _ = eval(Sine,0.5,0.)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| Sine m -> sin(pi*. (eval m))
| _ -> x
Error: This expression has type expr but an expression was expected of type
         expr * 'a * 'b


let rec eval (e,x,y) = match e with
| VarX -> x
| Sine m -> sin(pi*. (eval (m,x,y)))
| _ -> x
Error: This expression has type expr but an expression was expected of type
         expr * 'a * 'b



hw2 eval

fix:
let _ = eval((Sine(VarX)),0.3,0.)

bad:
let _ = eval((Sine(VarX)),0.5,0.)
Error: The constructor Sine expects 1 argument(s),
       but is applied here to 0 argument(s)



hw2 eval

fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine m -> sin(pi*. (eval (m,x,y)))
| Cosine m -> cos(pi*. (eval (m,x,y)))
| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.
| Times (m, n) -> eval(m,x,y) *. eval(n,x,y)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine m -> sin(pi*. (eval (m,x,y)))
| Cosine m -> cos(pi*. (eval (m,x,y)))
| Average (m,n) -> (eval (m,x,y)+.eval (n,x,y))/2.
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine m -> sin(pi*. (eval (m,x,y)))
| Cosine m -> cos(pi*. (eval (m,x,y)))
| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y))/2.
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine m -> sin(pi*. (eval (m,x,y)))
| Cosine m -> cos(pi*. (eval (m,x,y)))
| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.
Error: This expression has type float but an expression was expected of type
         int



hw2 eval

fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr,0.5,0.2)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine m -> sin(pi*. (eval (m,x,y)))
| Cosine m -> cos(pi*. (eval (m,x,y)))
| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.
| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)
| Thresh (m,n,o,p) -> 
eval (m,x,y) < eval (n,x,y) ? eval (o,x,y) : eval (p,x,y)
Error: Syntax error


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine m -> sin(pi*. (eval (m,x,y)))
| Cosine m -> cos(pi*. (eval (m,x,y)))
| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.
| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)
| Thresh (m,n,o,p) -> 
if eval (m,x,y) < eval (n,x,y) 
then eval (o,x,y)
else eval (p,x,y)
Error: Syntax error



hw2 build

fix:
let rec build (rand, depth) = rand

bad:
let rec build (rand, depth) = rand 1 2
Error: Unbound value i



hw2 build

fix:
let rec build (rand, depth) = let num = rand 4 53 in
match num with
| _ -> VarX

bad:
let rec build (rand, depth) = rand 3 4
Error: Unbound value rand
Hint: Did you mean land?



hw2 build

fix:
let rec build (rand, depth) =
if depth = 0
then
let num = rand in
match num with
| 0 -> VarX
| _ -> VarY
else
let num = rand in
match num with
| 0 -> Sine(build(rand,depth-1))
| _ -> Cosine(build(rand,depth-1))

let y = doRandomGray(5,1,5)

bad:
let rec build (rand, depth) =
if depth = 0
then
let num = rand in
match num with
| 0 -> VarX
| _ -> VarY
else
let num = rand in
match num with
| 0 -> Sine(build(rand,depth-1))
| _ -> Cosine(build(rand,depth-1))
Error: Unbound value x1



hw2 ???

fix:
let g2 () = (5,3,2)

let g3 () = (4,1,5)

bad:
let g1 () = (8,3,4)
Error: This expression has type int * int -> int
       but an expression was expected of type int -> int -> int
       Type int * int is not compatible with type int 
Error: Unbound constructor VarX
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int * int -> int
       but an expression was expected of type int -> int -> int
       Type int * int is not compatible with type int 



hw2 build

fix:
let rec assoc (d,k,l) = match l with 
| []         -> d
| (ki,vi)::t -> 
if ki=k
then vi
else assoc (d,k,t)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then seen else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) = 
let (b',c') = f b in 
if c'
then wwhile (f,b')
else b'

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) =
let f b = (f b, f b != b) in
wwhile (f, b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

type expr = 
VarX
| VarY
| Sine     of expr
| Cosine   of expr
| Average  of expr * expr
| Times    of expr * expr
| Thresh   of expr * expr * expr * expr

let rec exprToString e = match e with
| VarX             -> "x"
| VarY             -> "y"
| Sine m           -> "sin(pi*"^ exprToString m ^ ")"
| Cosine m         -> "cos(pi*" ^ exprToString m ^ ")"
| Average (m,n)    -> "((" ^ exprToString m ^ "+" ^ exprToString n ^ ")/2)"
| Times (m,n)      -> exprToString m ^ "*" ^ exprToString n
| Thresh (m,n,o,p) -> "(" ^ exprToString m^ "<" ^exprToString n^"?"^
exprToString o^":"^exprToString p^")"

let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

let _ = exprToString sampleExpr1

let buildX()                       = VarX

let buildY()                       = VarY

let buildSine(e)                   = Sine(e)

let buildCosine(e)                 = Cosine(e)

let buildAverage(e1,e2)            = Average(e1,e2)

let buildTimes(e1,e2)              = Times(e1,e2)

let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)

let pi = 4.0 *. atan 1.0

let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine m -> sin(pi*. (eval (m,x,y)))
| Cosine m -> cos(pi*. (eval (m,x,y)))
| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.
| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)
| Thresh (m,n,o,p) -> 
if eval (m,x,y) < eval (n,x,y) 
then eval (o,x,y)
else eval (p,x,y)

let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv

let sampleExpr =
buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(
buildX()),buildTimes(buildCosine (buildCosine (buildAverage
(buildTimes (buildY(),buildY()),buildCosine (buildX())))),
buildCosine (buildTimes (buildSine (buildCosine
(buildY())),buildAverage (buildSine (buildX()), buildTimes
(buildX(),buildX()))))))),buildY())))

let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))

let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr,0.5,0.2)

let rec build (rand, depth) =
if depth = 0
then
let num = rand in
match num with
| 0 -> VarX
| _ -> VarY
else
let num = rand in
match num with
| 0 -> Sine(build(rand,depth-1))
| _ -> Cosine(build(rand,depth-1))

let g1 () = (8,3,4)

let g2 () = (5,3,2)

let g3 () = (4,1,5)

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

bad:
let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)
Error: This expression has type int * int -> int
       but an expression was expected of type int
Error: Unbound constructor VarX
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int * int -> int
       but an expression was expected of type int



hw2 build

fix:
let rec build (rand, depth) =
if depth = 0
then
let nums (a,b) = rand in
let num = rand in 
match num with
| 0 -> VarX
| _ -> VarY
else
let nums (a,b) = rand in
let num = rand in
match num with
| 0 -> Sine(build(rand,depth-1))
| _ -> Cosine(build(rand,depth-1))

bad:
let rec build (rand, depth) =
if depth = 0
then
let nums (a,b) = rand in
let num = rand in 
match num with
| 0 -> VarX
| _ -> VarY
else
let nums (a,b) = rand in
let num = rand in
match num with
| 0 -> Sine(build(rand,depth-1))
| _ -> Cosine(build(rand,depth-1))
Error: This pattern matches values of type int
       but a pattern was expected which matches values of type 'a * 'b -> 'c



hw2 build

fix:
let rec build (rand, depth) =
if depth = 0
then
let num  = rand (0, 2) in
match num with
| 0 -> VarX
| _ -> VarY
else
let num = rand (0, 5) in
match num with
| 0 -> Sine(build(rand,depth-1))
| _ -> Cosine(build(rand,depth-1))

bad:
let rec build (rand, depth) =
if depth = 0
then
let num  = rand (0, 2) in
match num with
| 0 -> VarX
| _ -> VarY
else
let num = rand (0, 5) in
match num with
| 0 -> Sine(build(rand,depth-1))
| _ -> Cosine(build(rand,depth-1))
Error: Unbound value rand
Hint: Did you mean land?



hw2 build

fix:
let rec build (rand, depth) =
if depth = 0
then
let num  = rand (0, 2) in
match num with
| 0 -> VarX
| _ -> VarY
else
let num = rand (0, 5) in
match num with
| 0 -> buildSine(build(rand,depth-1))
| _ -> buildCosine(build(rand,depth-1))

bad:
let rec build (rand, depth) =
if depth = 0
then
let num  = rand (0, 2) in
match num with
| 0 -> VarX
| _ -> VarY
else
let num = rand (0, 5) in
match num with
| 0 -> buildSine(build(rand,depth-1))
| _ -> Cosine(build(rand,depth-1))
Error: This variant expression is expected to have type expr
       The constructor BuildSine does not belong to type expr



hw2 build

fix:
let rec build (rand, depth) =
if depth = 0
then
let num  = rand (0, 2) in
match num with
| 0 -> VarX
| _ -> VarY
else
let num = rand (0, 5) in
match num with
| 0 -> buildSine(build(rand,depth-1))
| 1 -> buildAverage(build(rand,depth-1),build(rand,depth-1))
| 2 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
| _ -> buildCosine(build(rand,depth-1))

bad:
let rec build (rand, depth) =
if depth = 0
then
let num  = rand (0, 2) in
match num with
| 0 -> VarX
| _ -> VarY
else
let num = rand (0, 5) in
match num with
| 0 -> buildSine(build(rand,depth-1))
| 1 -> buildAverage(build(rand,depth-1),build(rand,depth-1))
| 2 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
| _ -> buildCosine(build(rand,depth-1))
Error: This expression has type expr but an expression was expected of type
         expr * expr



hw2 exprToString

fix:
let _ = exprToString(Divide(Divide(VarX,VarY),VarX))

bad:
let _ = exprToString(Divide(VarX,VarY))
Error: This expression has type int but an expression was expected of type
         expr



hw2 eval

fix:
let _ = eval (Square(VarX),1.0,0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine m -> sin(pi*. (eval (m,x,y)))
| Cosine m -> cos(pi*. (eval (m,x,y)))
| Square m -> eval(m,x,y)**2
| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.
| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)
| Thresh (m,n,o,p) -> 
if eval (m,x,y) < eval (n,x,y) 
then eval (o,x,y)
else eval (p,x,y)
Error: This variant expression is expected to have type expr
       The constructor Square does not belong to type expr
Error: This variant pattern is expected to have type expr
       The constructor Divide does not belong to type expr
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This variant expression is expected to have type expr
       The constructor Square does not belong to type expr


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine m -> sin(pi*. (eval (m,x,y)))
| Cosine m -> cos(pi*. (eval (m,x,y)))
| Square m -> eval(m,x,y)**2.0
| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.
| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)
| Thresh (m,n,o,p) -> 
if eval (m,x,y) < eval (n,x,y) 
then eval (o,x,y)
else eval (p,x,y)
Error: This expression has type int but an expression was expected of type
         float



hw2 ???

fix:
let _ = max_float

bad:
let _ = max_float(2.0,2.0)
Error: This expression has type float
       This is not a function; it cannot be applied.


let _ = max_float(100.0)
Error: This expression has type float
       This is not a function; it cannot be applied.


let _ = max_float 100.0
Error: This expression has type float
       This is not a function; it cannot be applied.


let _ = max_float 100.0
Error: This expression has type float
       This is not a function; it cannot be applied.


let _ = max_float 100.0
Error: This expression has type float
       This is not a function; it cannot be applied.


let _ = max_float
Error: This expression has type float
       This is not a function; it cannot be applied.



hw2 ???

fix:
let _ = 1.0/max_float

bad:
let _ = max_float -. min_float
Error: This expression has type float but an expression was expected of type
         int



hw2 ???

fix:
let _ = (1.0/.max_float)*.min_float

bad:
let _ = 1.0/.max_float
Error: This expression has type float but an expression was expected of type
         int



hw2 exprToString

fix:
let rec exprToString e = match e with
| VarX             -> "x"
| VarY             -> "y"
| Sine m           -> "sin(pi*"^ exprToString m ^ ")"
| Cosine m         -> "cos(pi*" ^ exprToString m ^ ")"
| Square m         -> "(" ^ exprToString m ^ "^2)"
| Average (m,n)    -> "((" ^ exprToString m ^ "+" ^ exprToString n ^ ")/2)"
| Times (m,n)      -> exprToString m ^ "*" ^ exprToString n
| MyExpr (m,n,o)   -> "(" ^ exprToString m ^ "<" ^ exprToString n ^"?sqrt(|" ^
exprToString o ^ "|)" ^ ":" ^ "(" ^ exprToString o ^ 
"/2)"
| Thresh (m,n,o,p) -> "(" ^ exprToString m^ "<" ^exprToString n^"?"^
exprToString o^":"^exprToString p^")"

let _ = exprToString(MyExpr(VarX,VarY,VarX))

bad:
let rec exprToString e = match e with
| VarX             -> "x"
| VarY             -> "y"
| Sine m           -> "sin(pi*"^ exprToString m ^ ")"
| Cosine m         -> "cos(pi*" ^ exprToString m ^ ")"
| Square m         -> "(" ^ exprToString m ^ "^2)"
| Average (m,n)    -> "((" ^ exprToString m ^ "+" ^ exprToString n ^ ")/2)"
| Times (m,n)      -> exprToString m ^ "*" ^ exprToString n
| MyExpr (m,n,o)   -> "(" ^ exprToString m ^ "<" ^ expToString  ^"?sqrt(|" ^
exprToString o ^ "|)" ^ ":" ^ "(" ^ exprToString o ^ 
"/2)"
| Thresh (m,n,o,p) -> "(" ^ exprToString m^ "<" ^exprToString n^"?"^
exprToString o^":"^exprToString p^")"
NO ERROR FROM MINIMAL PROGRAM!!!
Error: This variant expression is expected to have type expr
       The constructor MyExpr does not belong to type expr


let _ = expToString(MyExpr(VarX,VarY,VarX))
Error: Unbound value expToString
Hint: Did you mean exprToString?


let rec exprToString e = match e with
| VarX             -> "x"
| VarY             -> "y"
| Sine m           -> "sin(pi*"^ exprToString m ^ ")"
| Cosine m         -> "cos(pi*" ^ exprToString m ^ ")"
| Square m         -> "(" ^ exprToString m ^ "^2)"
| Average (m,n)    -> "((" ^ exprToString m ^ "+" ^ exprToString n ^ ")/2)"
| Times (m,n)      -> exprToString m ^ "*" ^ exprToString n
| MyExpr (m,n,o)   -> "(" ^ exprToString m ^ "<" ^ exprToString  ^"?sqrt(|" ^
exprToString o ^ "|)" ^ ":" ^ "(" ^ exprToString o ^ 
"/2)"
| Thresh (m,n,o,p) -> "(" ^ exprToString m^ "<" ^exprToString n^"?"^
exprToString o^":"^exprToString p^")"
Error: Unbound value expToString
Hint: Did you mean exprToString?
Error: Unbound value expToString
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value expToString
Hint: Did you mean exprToString?


let _ = exprToString(MyExpr(VarX,VarY,VarX))
Error: This expression has type expr -> string
       but an expression was expected of type string



hw2 eval

fix:
let _ = eval (MyExpr(VarX,VarY,VarX),1.0, 2.0)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine m -> sin(pi*. (eval (m,x,y)))
| Cosine m -> cos(pi*. (eval (m,x,y)))
| Square m -> eval(m,x,y)**2.0
| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.
| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)
| MyExpr(m,n,o) -> 
if eval(m,x,y) < eval (n,x,y)
then sqrt(abs_float(eval(o,x,y)))
else eval(o,x,y) /. 2.
| Thresh (m,n,o,p) -> 
if eval (m,x,y) < eval (n,x,y) 
then eval (o,x,y)
else eval (p,x,y)
Error: This expression has type int but an expression was expected of type
         float



hw2 eval

fix:
let _ = eval (sampleExpr,0.5,0.2)

bad:
let _ = eval (sampleExpr1,0.5,0.2)
Error: This expression has type expr/2623
       but an expression was expected of type expr/2890
Error: This expression has type expr/2962
       but an expression was expected of type expr/2984
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type expr/2623
       but an expression was expected of type expr/2890



hw1 sumList

fix:
let rec sumList xs = match xs with
h :: t -> h + sumList t
| [] -> 0

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

bad:
let rec sumList [xs] =
Error: Syntax error


let rec sumList xs[] =
Error: Syntax error


let rec sumList xs = (* failwith "TBD:sumList" *) 

let _ = sumList [1; 2; 3; 4]
Error: Syntax error



hw1 digitsOfInt

fix:
let _ = digitsOfInt (-352663)

bad:
let _ = digitsOfInt -352663
Error: This expression has type int -> int list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let rec digits n = digitsOfInt (abs n)

digits (-124074)

bad:
let rec digits n = digitsOfInt (abs n)

digits (-124074)
Error: This function has type int -> int list
       It is applied to too many arguments; maybe you forgot a `;'.



hw2 assoc

fix:
let rec assoc (d,k,l) = 
let acc = l in
let rec helper acc (d,k,l) = 
match acc with
| [] -> d
| h::t -> match h with
| (s,v) ->
if s = k
then 
v
else
helper t (d,k,l)
in helper acc (d,k,l)

uncomment after implementing assoc

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

bad:
let rec assoc (d,k,l) = 
let temp = l in
let rec helper acc (d,k,l) = 
match temp with
| [] -> d
| h::t -> match h with
| (s,v) ->
if s = k
then 
v
else
helper (d,k,l) t
in helper (d,k,l) acc
Error: This expression has type ('a * 'b) list
       but an expression was expected of type 'b * 'a * 'c


uncomment after implementing assoc
Error: Unbound value uncomment


let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])
Error: Unbound value assoc


let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])
Error: Unbound value assoc


let rec assoc (d,k,l) = 
let acc = l in
let rec helper acc (d,k,l) = 
match acc with
| [] -> d
| h::t -> match h with
| (s,v) ->
if s = k
then 
v
else
helper t (d,k,l)
in helper (d,k,l) acc
Error: This expression has type 'a * 'b * 'c
       but an expression was expected of type ('d * 'e) list


uncomment after implementing assoc
Error: Unbound value uncomment


let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])
Error: Unbound value assoc


let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])
Error: Unbound value assoc



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if (List.mem h seen)
then 
seen
else 
h :: seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

bad:
et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]
Error: Unbound value l


let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]
Error: Syntax error



hw2 exprToString

fix:
type expr = 
VarX
| VarY
| Sine     of expr
| Cosine   of expr
| Average  of expr * expr
| Times    of expr * expr
| Thresh   of expr * expr * expr * expr
| Cube     of expr
| Addition of expr * expr

let rec exprToString e = 
match e with
VarX -> "x"
| VarY -> "y"
| Sine a -> "sin(pi*" ^ (exprToString a) ^ ")"
| Cosine a -> "cos(pi*" ^ (exprToString a) ^ ")"
| Average (a,b) -> "((" ^ (exprToString a) ^ "+" ^ (exprToString b) ^ ")/2)"
| Times (a,b) -> (exprToString a) ^ "*" ^ (exprToString b)
| Thresh (a,b,c,d) -> "(" ^ (exprToString a) ^ "<" ^ (exprToString b) ^ "?" ^ (exprToString c) ^ ":" ^ (exprToString d) ^ ")"
| _ -> "_"
| Cube a -> "(" ^ (exprToString a) ^ "*" ^ (exprToString a) ^ "*" ^ (exprToString a) ^ ")"
| Addition (a,b) -> "(" ^ (exprToString a) ^ "+" ^ (exprToString b) ")"

bad:
let rec exprToString e = 
match e with
VarX -> "x"
| VarY -> "y"
| Sine a -> "sin(pi*" ^ (exprToString a) ^ ")"
| Cosine a -> "cos(pi*" ^ (exprToString a) ^ ")"
| Average (a,b) -> "((" ^ (exprToString a) ^ "+" ^ (exprToString b) ^ ")/2)"
| Times (a,b) -> (exprToString a) ^ "*" ^ (exprToString b)
| Thresh (a,b,c,d) -> "(" ^ (exprToString a) ^ "<" ^ (exprToString b) ^ "?" ^ (exprToString c) ^ ":" ^ (exprToString d) ^ ")"
| _ -> "_"
| Cube a -> "(" ^ (exprToString a) ^ "*" ^ (exprToString a) ^ "*" ^ (exprToString a) ^ ")"
Error: This expression has type string
       This is not a function; it cannot be applied.



hw2 eval

fix:
let rec eval (e,x,y) = 
match e with
VarX -> x
| VarY -> y
| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )
| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )
| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)
| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )
| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))
then (eval (c,x,y))
else (eval (d,x,y))
| Cube a -> (eval (a,x,y) ) *. (eval  (a,x,y) ) *. (eval (a,x,y) )
| Addition (a,b) -> eval(a,x,y) +. eval

bad:
let rec eval (e,x,y) = 
match e with
VarX -> x
| VarY -> y
| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )
| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )
| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)
| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )
| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))
then (eval (c,x,y))
else (eval (d,x,y))
| Cube a -> (eval a) * (eval  a) *(eval a)
Error: This expression has type string but an expression was expected of type
         int


let rec eval (e,x,y) = 
match e with
VarX -> x
| VarY -> y
| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )
| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )
| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)
| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )
| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))
then (eval (c,x,y))
else (eval (d,x,y))
| Cube a -> (eval (a,x,y) ) * (eval  (a,x,y) ) * (eval (a,x,y) )
Error: This expression has type expr but an expression was expected of type
         expr * float * float


let rec eval (e,x,y) = 
match e with
VarX -> x
| VarY -> y
| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )
| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )
| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)
| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )
| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))
then (eval (c,x,y))
else (eval (d,x,y))
| Cube a -> (eval (a,x,y) ) *. (eval  (a,x,y) ) *. (eval (a,x,y) )
Error: This expression has type float but an expression was expected of type
         int



hw2 build

fix:
let rec assoc (d,k,l) = 
let acc = l in
let rec helper acc (d,k,l) = 
match acc with
| [] -> d
| h::t -> match h with
| (s,v) ->
if s = k
then 
v
else
helper t (d,k,l)
in helper acc (d,k,l)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if (List.mem h seen)
then 
seen
else 
h :: seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) = 
match f b with
(k,v) -> 
if v
then wwhile (f, k)
else k

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) = wwhile ((let g x = let xx = (f x) in (xx, xx!=x) in g),b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

type expr = 
VarX
| VarY
| Sine     of expr
| Cosine   of expr
| Average  of expr * expr
| Times    of expr * expr
| Thresh   of expr * expr * expr * expr
| Cube     of expr
| Addition of expr * expr

let rec exprToString e = 
match e with
VarX -> "x"
| VarY -> "y"
| Sine a -> "sin(pi*" ^ (exprToString a) ^ ")"
| Cosine a -> "cos(pi*" ^ (exprToString a) ^ ")"
| Average (a,b) -> "((" ^ (exprToString a) ^ "+" ^ (exprToString b) ^ ")/2)"
| Times (a,b) -> (exprToString a) ^ "*" ^ (exprToString b)
| Thresh (a,b,c,d) -> "(" ^ (exprToString a) ^ "<" ^ (exprToString b) ^ "?" ^ (exprToString c) ^ ":" ^ (exprToString d) ^ ")"
| _ -> "_"
| Cube a -> "(" ^ (exprToString a) ^ "*" ^ (exprToString a) ^ "*" ^ (exprToString a) ^ ")"
| Addition (a,b) -> "(" ^ (exprToString a) ^ "+" ^ (exprToString b) ^ ")"

let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

let _ = exprToString sampleExpr1

let buildX()                       = VarX

let buildY()                       = VarY

let buildSine(e)                   = Sine(e)

let buildCosine(e)                 = Cosine(e)

let buildAverage(e1,e2)            = Average(e1,e2)

let buildTimes(e1,e2)              = Times(e1,e2)

let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)

let buildCube(e)                   = Cube(e)

let buildAddition(e1,e2)           = Addition(e1,e2)

let pi = 4.0 *. atan 1.0

let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )
| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )
| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)
| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )
| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))
then (eval (c,x,y))
else (eval (d,x,y))
| Cube a -> (eval (a,x,y) ) *. (eval  (a,x,y) ) *. (eval (a,x,y) )
| Addition (a,b) -> eval(a,x,y) +. eval(b,x,y)

sin 0.3

let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr1,0.5,0.2)

let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv

let sampleExpr =
buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(
buildX()),buildTimes(buildCosine (buildCosine (buildAverage
(buildTimes (buildY(),buildY()),buildCosine (buildX())))),
buildCosine (buildTimes (buildSine (buildCosine
(buildY())),buildAverage (buildSine (buildX()), buildTimes
(buildX(),buildX()))))))),buildY())))

let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))

let rec build (rand,depth) =
if depth = 0 
then
match rand(1,3) with
| 1 -> buildX()
| 2 -> buildY()
else 
match rand(1,10) with
| 3 -> buildSine( build(rand,depth-1) ) 
| 4 -> buildCosine( build(rand,depth-1) )
| 5 -> buildAverage( (build(rand,depth-1)), build(rand,depth-1) )
| 6 -> buildTimes( (build(rand,depth-1)), build(rand,depth-1) )
| 7 -> buildThresh( build(rand,depth-1), build(rand,depth-1), build(rand,depth-1), build(rand,depth-1) )
| 8 -> buildCube( build(rand,depth-1) )
| 9 -> buildAddition ( build(rand,depth-1),  build(rand,depth-1) )
| _ -> build(rand,depth)

let g1 () = (0, 1, 9)

let g2 () = (8, 3, 5)

let g3 () = (110, 0, 10)

let c1 () = (6, 1, 7)

let c2 () = (4, 0, 4)

let c3 () = (2, 6, 9)

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

let emitColor (f1,f2,f3,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_c_"^name) in
let chan = open_out (fname^".ppm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P6 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z1 = f1 (x,y) in
let z2 = f2 (x,y) in
let z3 = f3 (x,y) in

(* Convert the result to a grayscale value *)
let iz1 = toIntensity(z1) in
let iz2 = toIntensity(z2) in
let iz3 = toIntensity(z3) in

(* Emit one byte per color for this pixel *)
output_char chan (char_of_int iz1);
output_char chan (char_of_int iz2);
output_char chan (char_of_int iz3);
)) in  
close_out chan;
ignore(Sys.command ("convert "^fname^".ppm  "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".ppm"))

let doRandomColor (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand (seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e1 = build (g, depth) in
let e2 = build (g, depth) in
let e3 = build (g, depth) in

let _ = Format.printf "red   = %s \n" (exprToString e1) in
let _ = Format.printf "green = %s \n" (exprToString e2) in
let _ = Format.printf "blue  = %s \n" (exprToString e3) in

let f1 = eval_fn e1 in
let f2 = eval_fn e2 in
let f3 = eval_fn e3 in

(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitColor (f1,f2,f3,n,name)

type test = unit -> string

let key = ""

let prefix130 = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)); ErrorCode "exception")

let explode s = 
let rec _exp i = 
if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in
_exp 0

let implode cs = 
String.concat "" (List.map (String.make 1) cs)

let drop_paren s = 
implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))

let eq_real p (r1,r2) = 
(r1 -. r2) < p || (r2 -. r1) < p

let scoreMsg () = 
Format.sprintf "Results: Score/Max = %d / %d \n" !score !max

bad:
let rec build (rand,depth) =
if depth = 0 
then
match rand(1,3) with
| 1 -> buildX()
| 2 -> buildY()
else 
match rand(1,10) with
| 3 -> buildSine( build(rand,depth-1) ) 
| 4 -> buildCosine( build(rand,depth-1) )
| 5 -> buildAverage( (build(rand,depth-1)), build(rand,depth-1) )
| 6 -> buildTimes( (build(rand,depth-1)), build(rand,depth-1) )
| 7 -> buildThresh( build(rand,depth-1), build(rand,depth-1), build(rand,depth-1), build(rand,depth-1) )
| 8 -> buildCube( build(rand,depth-1) )
| 9 -> buildAddition ( build(rand,depth-1),  build(rand,depth-1) )
| _ -> build(rand,depth)
Error: Unbound value buildX
Hint: Did you mean build?



hw2 exprToString

fix:
type expr = 
VarX
| VarY
| Sine     of expr
| Cosine   of expr
| Average  of expr * expr
| Times    of expr * expr
| Thresh   of expr * expr * expr * expr
| Tan      of expr
| Sin_Avg  of expr * expr * expr

let rec exprToString e = 
match e with
VarX -> "x"
| VarY -> "y"
| Sine a -> "sin(pi*" ^ (exprToString a) ^ ")"
| Cosine a -> "cos(pi*" ^ (exprToString a) ^ ")"
| Average (a,b) -> "((" ^ (exprToString a) ^ "+" ^ (exprToString b) ^ ")/2)"
| Times (a,b) -> (exprToString a) ^ "*" ^ (exprToString b)
| Thresh (a,b,c,d) -> "(" ^ (exprToString a) ^ "<" ^ (exprToString b) ^ "?" ^ (exprToString c) ^ ":" ^ (exprToString d) ^ ")"
| _ -> "_"
| Tan a -> "tan(pi*" ^ (exprToString a) ^ ")"
| Arc (a,b,c) -> "sin(pi*(" ^ (exprToString  a) ^ "+" ^ (exprToString  b) ^ (exprToString c) ^ ")"

bad:
let rec exprToString e = 
match e with
VarX -> "x"
| VarY -> "y"
| Sine a -> "sin(pi*" ^ (exprToString a) ^ ")"
| Cosine a -> "cos(pi*" ^ (exprToString a) ^ ")"
| Average (a,b) -> "((" ^ (exprToString a) ^ "+" ^ (exprToString b) ^ ")/2)"
| Times (a,b) -> (exprToString a) ^ "*" ^ (exprToString b)
| Thresh (a,b,c,d) -> "(" ^ (exprToString a) ^ "<" ^ (exprToString b) ^ "?" ^ (exprToString c) ^ ":" ^ (exprToString d) ^ ")"
| _ -> "_"
| Tan a -> "tan(pi*" ^ (exprToString a) ^ ")"
| Arc (a,b,c) -> "sin(pi*" ^ (exprToString (a (b,c)) ) ^ ")"
Error: This function has type expr -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw2 exprToString

fix:
exprToString Sin_Avg(1,2,3)

bad:
let rec exprToString e = 
match e with
VarX -> "x"
| VarY -> "y"
| Sine a -> "sin(pi*" ^ (exprToString a) ^ ")"
| Cosine a -> "cos(pi*" ^ (exprToString a) ^ ")"
| Average (a,b) -> "((" ^ (exprToString a) ^ "+" ^ (exprToString b) ^ ")/2)"
| Times (a,b) -> (exprToString a) ^ "*" ^ (exprToString b)
| Thresh (a,b,c,d) -> "(" ^ (exprToString a) ^ "<" ^ (exprToString b) ^ "?" ^ (exprToString c) ^ ":" ^ (exprToString d) ^ ")"
| _ -> "_"
| Tan a -> "tan(pi*" ^ (exprToString a) ^ ")"
| Sin_Avg (a,b,c) -> "sin(pi*(" ^ (exprToString  a) ^ "+" ^ (exprToString  b) ^ (exprToString c) ^ ")/3)"
Error: This variant pattern is expected to have type expr
       The constructor Arc does not belong to type expr



hw2 exprToString

fix:
exprToString (Tan VarX)

bad:
exprToString (Sin_Avg (VarX, VarY, VarX))
Error: The constructor VarX expects 0 argument(s),
       but is applied here to 1 argument(s)



hw3 ???

fix:
let f a b = a + b

bad:
let f a b - a + b
Error: Syntax error



hw3 sqsum

fix:
let rec sqsum xs = 
match xs with
[] -> 0
| h::t -> (h*h) + (sqsum t)

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

bad:
let rec sqsum xs = 
match xs with
[] -> []
| h::t -> (h*h) + (sqsum t)
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 sqsum

fix:
let sqsum xs = 
let f a x = (a*a) in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = (a*a) in
let base = [] in
List.fold_left f base xs
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a + (x*x) in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a + (x*x) in
let base = a + 1 in
List.fold_left f base xs
Error: Unbound value a



hw3 pipe

fix:
let pipe fs = 
let f a x = a + x in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = match a with
[] -> x
| h::t -> h x in 
let base = fs in
List.fold_left f base fs
Error: This expression has type ('a -> 'a) list -> 'a -> 'a
       but an expression was expected of type
         ('a -> 'a) list -> 'a -> ('a -> 'a) list
       The type variable 'a occurs inside ('a -> 'a) list


let pipe fs = 
let f a x = match a with
[] -> x
| h::t -> h x in 
let base = 0 in
List.fold_left f base fs
Error: This expression has type ('a -> 'a) list -> 'a -> 'a
       but an expression was expected of type
         ('a -> 'a) list -> 'a -> ('a -> 'a) list
       The type variable 'a occurs inside ('a -> 'a) list



hw3 pipe

fix:
let _ = pipe []

bad:
let _ = pipe [] 3
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe fs = 
let f a x = match a with
[] -> []
| h::t -> h::[] in
let base = [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = match a with
[] -> []
| h::t -> (h x) 
in
let base = 3 in
List.fold_left f base fs
Error: This expression has type ('a -> 'b list) list -> 'a -> 'b list
       but an expression was expected of type
         ('a -> 'b list) list -> 'a -> ('a -> 'b list) list
       Type 'b list is not compatible with type ('a -> 'b list) list 


let pipe fs = 
let f a x = match a with
[] -> x
| h::t -> (h x) in
let base = failwith "to be implemented" in
List.fold_left f base fs
Error: This expression has type ('a -> 'a) list -> 'a -> 'a
       but an expression was expected of type
         ('a -> 'a) list -> 'a -> ('a -> 'a) list
       The type variable 'a occurs inside ('a -> 'a) list



hw3 ???

fix:
let rec myFunc f a b = 
match b with
[] -> a
| h::t -> myFunc f (f a h) t

myFunc (fun x y -> x + y) 0 [1;2;3]

bad:
let myFunc f a b = 
match b with
[] -> a
| h::t -> myFunc f (f a h) t
Error: Unbound value myFunc


myFunc (fun x y -> x + y) 0 [1;2;3]
Error: Unbound value myFunc



hw3 ???

fix:
myFunc (fun x y -> fun x -> y )  (fun g -> g) [1;2;3]

bad:
myFunc (fun x y -> x y)  (fun x -> x) [1;2;3]
Error: This expression has type 'a but an expression was expected of type
         'b -> 'a
       The type variable 'a occurs inside 'b -> 'a


myFunc (fun x y -> x (y) )  (fun x -> x) [1;2;3]
Error: This expression has type 'a but an expression was expected of type
         'b -> 'a
       The type variable 'a occurs inside 'b -> 'a


myFunc (fun x y -> x y )  (fun g -> g) [1;2;3]
Error: This expression has type 'a but an expression was expected of type
         'b -> 'a
       The type variable 'a occurs inside 'b -> 'a



hw3 pipe

fix:
let _ = pipe [fun x -> x*x] 3

bad:
let _ = pipe [fun x -> x; fun x -> x*x] 3
Error: This expression has type int but an expression was expected of type
         int -> int



hw3 pipe

fix:
let pipe fs = 
let f a x = (fun x -> x) in
let base = (fun x -> x) in
List.fold_left f base fs

let _ = pipe [] 3

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'b



hw3 pipe

fix:
let _ = pipe [(fun x -> x + 1); (fun x -> x*x)] 3

bad:
let _ = pipe [fun x -> x + 1; fun x -> x*x] 3
Error: This expression should not be a function, the expected type is
int



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = (fun x -> x) in
List.fold_left f base fs

let _ = pipe [(fun x -> x*x); (fun x -> x + 1)] 3

bad:
let _ = pipe [(fun x -> x*x); (fun x -> x + 1)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 ???

fix:
let _ = myFunc (fun x y -> x) 0 [1;2;3;4]

bad:
let _ = myFunc (fun x y -> x) [1;2;3;4]
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ " " ^ x in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ " " x in
let base = [] in
let l = t in
List.fold_left f base l
Error: This expression has type string
       This is not a function; it cannot be applied.


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ " " ^ x in
let base = [] in
let l = t in
List.fold_left f base l
Error: This expression has type 'a list
       but an expression was expected of type string



hw3 stringOfList

fix:
let stringOfList f l = sepConcat (f l)

bad:
let stringOfList f l = ssepConcat (f l)
Error: Unbound value ssepConcat
Hint: Did you mean sepConcat?
Error: Unbound value ssepConcat
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value ssepConcat
Hint: Did you mean sepConcat?



hw3 stringOfList

fix:
let stringOfList f l = List.map f l

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: This expression has type 'a list
       but an expression was expected of type int


let _ = stringOfList (fun x -> x) ["foo"]
Error: This expression has type 'a list
       but an expression was expected of type string


let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]
Error: This expression has type int -> string list -> string
       but an expression was expected of type int -> string
       Type string list -> string is not compatible with type string 



hw3 stringOfList

fix:
let stringOfList f l = "[" ^ ( sepConcat ";" (List.map f l) ) ^ "]"

bad:
let stringOfList f l = List.map f (sepConcat l)
Error: This expression has type string list -> string
       but an expression was expected of type 'a list


let stringOfList f l = "[" ^ sepConcat ^ ";" ^ List.map f l ^ "]"
Error: This expression has type string -> string list -> string
       but an expression was expected of type string


let stringOfList f l = "[" ^ (sepConcat ";" List.map f l) ^ "]"
Error: This function has type string -> string list -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 stringOfList

fix:
let _ = stringOfList string_of_int [1;2;3;4;5;6]

bad:
let _ = stringOfList float_of_int [1;2;3;4;5;6]
Error: This expression has type int -> float
       but an expression was expected of type int -> string
       Type float is not compatible with type string 



hw3 clone

fix:
let rec clone x n = let i = 0 in
if i < n
then x :: ( clone x (n-1) )
else []

bad:
let rec clone x n = let i = 0 in
if i < n
then x :: (clone x n-1)
else []
Error: This expression has type 'a list
       but an expression was expected of type int


let rec clone x n = let i = 0 in
if i < n
then (clone x n-1) :: x :: []
else []
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 padZero

fix:
let padZero l1 l2 = if List.length l1 < List.length l2
then true
else false

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

bad:
let padZero l1 l2 = let length_diff = (List.length l1 - List.length l2) in 
if length_diff < 0
then 
length_diff = (List.length l1 - List.length l2)
else 
length_diff
Error: This expression has type int but an expression was expected of type
         bool



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = (fun x -> x) in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'b


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'b


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = (fun x a -> x a) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let _ = pipe [fun x -> x + 3] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let pipe fs = 
let f a x = (fun x a) in
let base = (fun x -> x) in
List.fold_left f base fs
Error: Syntax error: operator expected.



hw3 pipe

fix:
let pipe fs = 
let f a x = (fun x a -> x a) x a in
let base = (fun x -> x) in
List.fold_left f base fs

let _ = pipe [] 3

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = (fun y -> x a) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun -> x a) in
let base = (fun x -> x) in
List.fold_left f base fs
Error: Syntax error: operator expected.



hw3 pipe

fix:
let pipe fs = 
let f a x = (fun x a -> x a) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun a x -> x a) in
let base = (fun x -> x) in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> ('a -> 'b) -> 'b
       The type variable 'a occurs inside ('a -> 'b) -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x =  (fun x -> x) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = function x a  in
let base = (fun x -> x) in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = function x  in
let base = (fun x -> x) in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x =  (x (a) ) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 ???

fix:
List.split [(1, "hello")]

bad:
List.split ([1], [2])
Error: This expression has type 'a * 'b
       but an expression was expected of type ('c * 'd) list


List.combine ([1], [2])
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


List.split ([1], [2])
Error: This expression has type 'a * 'b
       but an expression was expected of type ('c * 'd) list


List.split [[1], "hello"
Error: Syntax error


)
Error: Syntax error


]
Error: Syntax error


List.split [[1], "hello"
Error: Syntax error


)
Error: Syntax error


]
Error: Syntax error


List.split [[1], "hello"
Error: Syntax error


)
Error: Syntax error


]
Error: Syntax error



hw3 mulByDigit

fix:
let rec mulByDigit i l = 
match l with
| []   -> 0
| h::t -> h*i

let _ = mulByDigit 9 [9;9;9;9]

bad:
let rec mulByDigit i l = 
match l with
| []   -> []
| h::t -> h*i
Error: This expression has type int but an expression was expected of type
         'a list


let _ = mulByDigit 9 [9;9;9;9]
Error: This expression has type int but an expression was expected of type
         'a list



hw3 mulByDigit

fix:
let rec mulByDigit i l = 
match (List.rev l) with
| []   -> []
| h::m::t -> (mulByDigit m::t) @ ( (h*i)/10 ) + (m*i) mod 10 :: ( (h*i) mod 10 ) :: []

let _ = mulByDigit 9 [9;8;9;9]

bad:
let rec mulByDigit i l = 
match (List.rev l) with
| []   -> []
| h::m::t -> (mulByDigit m::t) :: ( (h*i)/10 ) + (m*i) mod 10 :: ( (h*i) mod 10 ) :: []
Error: This expression has type 'a list -> 'b list list
       but an expression was expected of type 'b
       The type variable 'b occurs inside 'a list -> 'b list list



hw3 ???

fix:
List.combine [0; 0; 9;9] [1;0;0;2]

bad:
List.split [0; 0; 9;9] [1;0;0;2]
Error: This function has type ('a * 'b) list -> 'a list * 'b list
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 bigAdd

fix:
List.map (fun x -> x + 1) [1;2;3]

let sqsum xs = 
let f a x = a + (x*x) in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let _ = sqsum [10;9;8;]

let pipe fs = 
let f a x = x in
let base = (fun x -> x) in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + 1)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat " ---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = "[" ^ ( sepConcat ";" (List.map f l) ) ^ "]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n =
if n > 0
then x :: ( clone x (n-1) )
else []

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let _ = clone 0 2

let padZero l1 l2 = if List.length l1 < List.length l2
then
( List.append ( clone 0 (List.length l2 - List.length l1) ) l1, l2)
else
(l1, List.append ( clone 0 (List.length l1 - List.length l2) ) l2)

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

let rec removeZero l =
match l with
| [] -> []
| h :: t -> 
if h = 0
then removeZero t
else l

let _ = removeZero [0;0;0;1;0;0;2]

let _ = removeZero [9;9]

let _ = removeZero [0;0;0;0]

let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
(list1, list2) -> match list1 with
[] -> match x with
(h1,h2) -> ((h1+h2)::list1, list2)

in
let base = ([],[]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
(h1,h2)-> (h1 + h2, a)
in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a -> int * int -> int * 'a
       but an expression was expected of type 'a -> int * int -> 'a
       The type variable 'a occurs inside int * 'a


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
(h1,h2)-> h1 + h2
in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type int


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
(h1,h2)-> h1 + h2
in
let base = 0 in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
(h1,h2)-> h1 + h2
in
let base = 0 in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
(h1,h2)-> (a, h1 + h2)
in
let base = 0 in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a -> int * int -> 'a * int
       but an expression was expected of type 'a -> int * int -> 'a
       The type variable 'a occurs inside 'a * int


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
(h1,h2)-> a
in
let base = 0 in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
(h1,h2)-> match a with (v1,v2) -> (v1+h1+v2+h2)
in
let base = (0,0) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int * int -> int * int -> int
       but an expression was expected of type
         int * int -> int * int -> int * int
       Type int is not compatible with type int * int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
(h1,h2)-> match a with (v1,v2) -> (v1+h1, v2+h2)
in
let base = (0,0) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
(h1,h2)-> match a with (v1,v2) -> [(v1+h1, v2+h2)]
in
let base = (0,0) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int * int -> int * int -> (int * int) list
       but an expression was expected of type
         int * int -> int * int -> int * int
       Type (int * int) list is not compatible with type int * int 



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
(list1, list2) -> (list1, list2)
in
let base = ([0],[0]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
(list1, list2) -> list1
in
let base = ([0],[0]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b -> 'c -> 'a
       but an expression was expected of type 'a * 'b -> 'c -> 'a * 'b
       The type variable 'a occurs inside 'a * 'b



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([],[]) -> ([],[])
| (list1, list2) -> (list1, list2)
in
let base = ([0],[0]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
(list1, list2) -> match (list1, list2) with
[] -> ([], [])
in
let base = ([0],[0]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This pattern matches values of type 'a list
       but a pattern was expected which matches values of type 'b * 'c



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([],[]) -> match x with
| ([],[]) -> a
| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])
in
let base = ([],[]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([],[]) -> match x with
| [] -> ([], [])
| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])
| (list1, list2) -> ([1], [1])
in
let base = ([],[]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This pattern matches values of type 'a * 'b
       but a pattern was expected which matches values of type 'c list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (lh1::lt1, lh2::lt2) -> (lh1::lt1, lh2::lt2)
| ([],[]) -> match x with
| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])
in
let base = ([],[]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (lh1::lt1, lh2:;lt2) -> (lh1::lt1, lh2:;lt2)
| ([],[]) -> match x with
| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])
in
let base = ([],[]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error: type expected.


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (lh1::lt1, lh2::lt2) -> (lh1::lt1, lh2:;lt2)
| ([],[]) -> match x with
| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])
in
let base = ([],[]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
(v1,v2) -> match a with
(h1::t1, h2::t2) -> (v1 :: h1::t1, v2::h2::t2)
in
let base = ([],[]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
(v1,v2) -> ( ( v1::a), (v2::a) )
in
let base = ([],[]) in
let args = (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list -> 'a * 'a -> 'a list * 'a list
       but an expression was expected of type 'a list -> 'a * 'a -> 'a list
       Type 'a list * 'a list is not compatible with type 'a list 



hw3 ???

fix:
List.rev (List.combine [0;0; 9;9] [1;0;0;2])

bad:
List.rev List.combine [0;0; 9;9] [1;0;0;2]
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 ???

fix:
List.rev (List.combine  [9;9;9;9] [0; 9;9;9])

bad:
List.rev (List.combine  [9;9;9;9] [0; 9;9;9]) :: (0,0)
Error: This expression has type 'a * 'b
       but an expression was expected of type (int * int) list list



hw3 ???

fix:
(List.rev (List.combine  [9;9;9;9] [0; 9;9;9])) @ [(0,0)]

bad:
(List.rev (List.combine  [9;9;9;9] [0; 9;9;9])) :: (0,0)
Error: This expression has type 'a * 'b
       but an expression was expected of type (int * int) list list


(List.rev (List.combine  [9;9;9;9] [0; 9;9;9])) @ (0,0)
Error: This expression has type 'a * 'b
       but an expression was expected of type (int * int) list



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = match x with
(v1,v2) -> match a with
(list1, list2) -> match list1 with
| [] -> ( (v1*v2)/10::list1, (v1*v2) mod 10::list2 )
| (h::t) -> (((v1*v2)+h)/10::list1, ((v1*v2)+h) mod 10 :: list2) in
let base = ([], []) in
let args = List.append (List.rev (List.combine l1 l2))  [(0,0)] in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = match x with
(v1,v2) -> match a with
(list1, list2) -> match list1 with
| [] -> ( (v1*v2)/10::list1, (v1*v2) mod 10::list2 )
| (h::t) -> (((v1*v2)+h)/10::list1, ((v1*v2)+h) mod 10 :: list2) in
let base = ([]. []) in
let args = List.append (List.rev (List.combine l1 l2))  [(0,0)] in
let (_, res) = List.fold_left f base args in
res
Error: Syntax error: operator expected.



hw3 bigAdd

fix:
let _ = bigAdd [8;1] [8;1;0]

bad:
let _ = bigAdd [8;1] [8;1;0]

List.map (fun x -> x*10 ) [1;2;3]
Error: This function has type int list -> int list -> int list
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 mulByDigit

fix:
let _ = bigAdd [0] [81000; 8100; 810; 81]

List.map (fun x -> x*10 ) [1;2;3]

let rec mulByDigit i l = match (List.rev l) with
| []   -> 0
| h::t -> (mulByDigit i (List.rev t) * 10 ) + h*i

let _ = mulByDigit 9 [9;9;9;9]

bad:
let rec mulByDigit i l = match (List.rev l) with
| []   -> false
| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with 
| [] -> []
| h1::t1 -> let rec helper acc v = [v] = [0]
(* if v = 0 
then 
acc 
else 
helper ( (v mod 10) :: acc) (v/10) *)
in helper [] h1
Error: This expression has type bool but an expression was expected of type
         'a list



hw3 mulByDigit

fix:
let rec mulByDigit i l = match (List.rev l) with
| []   -> 0
| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i )

bad:
let rec mulByDigit i l = match (List.rev l) with
| []   -> []
| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i ) :: []
Error: This expression has type 'a list
       but an expression was expected of type int


let rec mulByDigit i l = match (List.rev l) with
| []   -> []
| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i )
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 mulByDigit

fix:
List.map (fun x -> x + 1) [1;2;3]

let sqsum xs = 
let f a x = a + (x*x) in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let _ = sqsum [10;9;8;]

let pipe fs = 
let f a x = x in
let base = (fun x -> x) in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + 1)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat " ---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = "[" ^ ( sepConcat ";" (List.map f l) ) ^ "]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n =
if n > 0
then x :: ( clone x (n-1) )
else []

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let _ = clone 0 2

let padZero l1 l2 = if List.length l1 < List.length l2
then
( List.append ( clone 0 (List.length l2 - List.length l1) ) l1, l2)
else
(l1, List.append ( clone 0 (List.length l1 - List.length l2) ) l2)

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

let rec removeZero l =
match l with
| [] -> []
| h :: t -> 
if h = 0
then removeZero t
else l

let _ = removeZero [0;0;0;1;0;0;2]

let _ = removeZero [9;9]

let _ = removeZero [0;0;0;0]

(0,0) :: (List.rev (List.combine  [9;9;9;9] [0; 9;9;9]))

let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
(v1,v2) -> match a with
(list1, list2) -> match list1 with
| [] -> ( (v1+v2)/10::list1, (v1+v2) mod 10::list2 )
| (h::t) -> ((v1+v2+h)/10::list1, (v1+v2+h) mod 10 :: list2)
in
let base = ([],[]) in
let args = List.append (List.rev (List.combine l1 l2))  [(0,0)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

let _ = bigAdd [0] [81000; 8100; 810; 81]

List.map (fun x -> x*10 ) [1;2;3]

let rec mulByDigit i l = match l with
[] -> []
| h::t -> let helper acc v = 
if v = 0
then
acc
else 
helper (v mod 10)::acc (v/10)
in helper [] h

bad:
let rec mulByDigit i l = match (List.rev l) with
| []   -> []
| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i )
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 mulByDigit

fix:
let rec mulByDigit i l = match l with
[] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10)
in helper [] h

bad:
let rec mulByDigit i l = match l with
[] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper (v mod 10)::acc (v/10)
in helper [] h
Error: This expression has type int but an expression was expected of type
         'a list



hw3 mulByDigit

fix:
let rec mulByDigit i l = match (List.rev l) with
| [] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) in
let rec adder x = match x with
[] -> []
| h::t -> [h]
in 
adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )

bad:
let rec mulByDigit i l = match (List.rev l) with
[] -> int list []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) in
let rec adder x = match x with
[] -> int list []
| h::t -> bigAdd h (adder t)
in 
adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )
Error: Unbound value int


let rec mulByDigit i l = match (List.rev l) with
[] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) in
let rec adder x = match x with
[] -> []
| h::t -> bigAdd h (adder t)
in 
adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )
Error: This expression has type int list
       but an expression was expected of type int list list
       Type int is not compatible with type int list 


let rec mulByDigit i l = match (List.rev l) with
| [] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) in
let rec adder x = match x with
[] -> []
| h::t -> h
in 
adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )
Error: This expression has type int list
       but an expression was expected of type int list list



hw3 mulByDigit

fix:
let rec mulByDigit i l = match (List.rev l) with
| [] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) in
let rec adder x = match x with
| [] -> []
| h::t -> ( bigAdd h (adder t) )
in 
adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )

let _ = mulByDigit 9 [9;9;9;9]

bad:
let rec mulByDigit i l = match (List.rev l) with
| [] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) in
let rec adder x = match x with
| [] -> []
| h::t -> [( bigAdd h (adder t) )]
in 
adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )
Error: This expression has type int list
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs = 
let f a x = (x(a)) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let pipe fs = 
let f a x = f(x(a)) in
let base = (fun x -> x) in
List.fold_left f base fs
Error: This expression has type int -> int
       but an expression was expected of type int -> int -> int
       Type int is not compatible with type int -> int 


let pipe fs = 
let f a x = fun -> (x(a)) in
let base = (fun x -> x) in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = fun a x -> (x(a)) in
let base = (fun x -> x) in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> ('a -> 'b) -> 'b
       The type variable 'a occurs inside ('a -> 'b) -> 'b



hw3 mulByDigit

fix:
let rec mulByDigit i l = match (List.rev l) with
| [] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) 
in ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: [])

bad:
let rec mulByDigit i l = match (List.rev l) with
| [] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) in
match ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with
[] -> []
| x::y -> let rec adder w = match w with
| [] -> []
| a::b -> ( bigAdd a (adder b) )
in 
adder (h::t)
Error: This expression has type int but an expression was expected of type
         int list



hw3 mulByDigit

fix:
let rec mulByDigit i l = match (List.rev l) with
| [] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) 
in
match ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with
| [] -> []
| x::y -> let rec adder w = match w with
| [] -> []
| a::b -> ( bigAdd a (adder b) )
in 
[adder (x::y)]

bad:
let rec mulByDigit i l = match (List.rev l) with
| [] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) 
in
match ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with
| [] -> []
| x::y -> let rec adder w = match w with
| [] -> []
| a::b -> ( bigAdd a (adder b) )
in 
adder (h::t)
Error: This expression has type int but an expression was expected of type
         int list


let rec mulByDigit i l = match (List.rev l) with
| [] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else 
helper ( (v mod 10) :: acc ) (v/10) 
in
match ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with
| [] -> []
| x::y -> let rec adder w = match w with
| [] -> []
| a::b -> ( bigAdd a (adder b) )
in 
adder (x::y)
Error: This expression has type int list
       but an expression was expected of type int list list
       Type int is not compatible with type int list 



hw3 mulByDigit

fix:
let rec mulByDigit i l = 
match l with
[] -> []
| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []
with 
[] -> []
| h::t -> let rec helper acc v = 
if v = 0
then 
acc
else 
v mod 10 :: []
in helper [] h

bad:
let rec mulByDigit i l = 
match l with
[] -> []
| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []
with 
[] -> []
| h::t -> let rec helper acc v = 
if v = 0
then 
acc
else 
v mod 10
in helper [] h
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 mulByDigit

fix:
let rec mulByDigit i l =
match (List.rev l) with
| [] -> []
| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with
| [] -> []
| h::t -> let rec helper acc v = 
if v = 0
then
acc
else
helper (v mod 10 :: acc) (v/10)
in helper [] h

let _ = mulByDigit 9 [1;2;3;4]

bad:
let rec mulByDigit i l =
match (List.rev l) with
| [] -> []
| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with
| [] -> []
| h::t -> if v = 0
then
acc
else
helper (v mod 10 :: acc) (v/10)
in helper [] h
Error: Unbound value v



hw3 mulByDigit

fix:
let rec mulByDigit i l =
match (List.rev l) with
| [] -> []
| h::t -> 
let f a x = a + x in
let base = 0 in
let rec helper acc v = 
if v = 0
then
acc
else
helper (v mod 10 :: acc) (v/10)
in helper [] ([List.fold_left f base ((mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [])])

let _ = mulByDigit 9 [1;2;3;4]

bad:
let rec mulByDigit i l =
match (List.rev l) with
| [] -> []
| h::t -> 
let f a x = a + x in
let base = 0 in
let rec helper acc v = 
if v = 0
then
acc
else
helper (v mod 10) :: acc (v/10)
in helper [] ([List.fold_left f base ((mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [])])
Error: This expression has type int but an expression was expected of type
         'a list



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = match x with
(k,v) -> ([k],v) in 
let base = ([], [0]) in
let args = let rec helper acc l1 l2 = 
match l1 with 
| [] -> acc
| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2
in helper [] (List.rev l1) l2
in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = match x with
{k,v} -> ([k],v) in 
let base = ([], [0]) in
let args = let rec helper acc l1 l2 = 
match l1 with 
| [] -> acc
| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2
in helper [] (List.rev l1) l2
in
let (_, res) = List.fold_left f base args in
res
Error: Syntax error



hw3 mulByDigit

fix:
let somef i l = match (List.rev l) with
| [] -> []
| h::t ->
let rec helper acc v =  
if v = 0
then 
acc
else
helper (v mod 10 :: acc) (v/10)
in bigAdd (mulByDigit i (List.rev (List.map (fun x -> x*10) t ) )) (helper [] (h*i))

somef 90000 [9;9]

bad:
let somef i l = match (List.rev l) with
| [] -> []
| h::t ->
let rec helper acc v =  
if v = 0
then 
acc
else
helper (v mod 10 :: acc) (v/10)
in bigAdd (mulByDigit i (List.rev (List.map (fun x -> x*10) t ) )) (helper [] (h*i)) *
Error: Syntax error


)

somef 90000 [9;9]
Error: Syntax error



hw3 clone

fix:
[1;0] @ (clone 0 1)

bad:
[1,0] @ clone 0 1
Error: This expression has type int list
       but an expression was expected of type (int * int) list
       Type int is not compatible with type int * int 


[1,0] @ (clone 0 1)
Error: This expression has type int list
       but an expression was expected of type (int * int) list
       Type int is not compatible with type int * int 



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = match a with
(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ((mulByDigit x l1) @ (clone 0 numZeroes)) (prevRes) )  in
let base = (1, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = match a with
(numZeroes, prevRes) -> (numZeroes+1, bigAdd ( (mulByDigit x l1) @ (clone 0 numZeroes) prevRes))
Error: Syntax error


let base = (1, []) in
let args = l2
in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value l2


let bigMul l1 l2 = 
let f a x = match a with
(numZeroes, prevRes) -> (numZeroes+1, bigAdd ( (mulByDigit x l1) @ (clone 0 numZeroes) prevRes)) in
let base = (1, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list
       This is not a function; it cannot be applied.
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int list
       This is not a function; it cannot be applied.


let bigMul l1 l2 = 
let f a x = match a with
(numZeroes, prevRes) -> (numZeroes+1, bigAdd ( ( (mulByDigit x l1) @ (clone 0 numZeroes) ) prevRes)) in
let base = (1, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list
       This is not a function; it cannot be applied.
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int list
       This is not a function; it cannot be applied.


let bigMul l1 l2 = 
let f a x = match a with
(numZeroes, prevRes) -> (numZeroes+1, bigAdd ( ( (mulByDigit x l1) @ (clone 0 numZeroes) ) (prevRes) )) in
let base = (1, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list
       This is not a function; it cannot be applied.
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int list
       This is not a function; it cannot be applied.



hw3 mulByDigit

fix:
let rec mulByDigit i l = 
let f a x = match a with
(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( [i*x] @ (clone 0 numZeroes) ) (prevRes) ) in
let base = (0, []) in
let (_,res) = List.fold_left f base (List.rev l) in
res

bad:
let rec mulByDigit i l = 
let f a x = match a with
(numZeroes, prevRes) -> ( numZeroes+1, bigAdd (i*x @ (clone 0 numZeroes)) (prevRes) ) in
let base = (0, []) in
let (_,res) = List.fold f base (List.rev l) in
res
Error: This expression has type int but an expression was expected of type
         'a list
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int but an expression was expected of type
         'a list


let rec mulByDigit i l = 
let f a x = match a with
(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( (i*x) @ (clone 0 numZeroes)) (prevRes) ) in
let base = (0, []) in
let (_,res) = List.fold f base (List.rev l) in
res
Error: This expression has type int but an expression was expected of type
         'a list
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int but an expression was expected of type
         'a list


let rec mulByDigit i l = 
let f a x = match a with
(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( [i*h] @ (clone 0 numZeroes) ) (prevRes) ) in
let base = (0, []) in
let (_,res) = List.fold f base (List.rev l) in
res
Error: Unbound value h
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value h


let rec mulByDigit i l = 
let f a x = match a with
(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( [i*x] @ (clone 0 numZeroes) ) (prevRes) ) in
let base = (0, []) in
let (_,res) = List.fold f base (List.rev l) in
res
Error: Unbound value List.fold
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value List.fold



hw1 digitalRoot

fix:
let digitalRoot n = (*failwith "TBD"*)

let rec loop x =
sumList (digitsOfInt (abs n))

let _ = digitalRoot 9876

bad:
let digitalRoot n = (*failwith "TBD"*)

let rec loop x = function
sumList digitsOfInt (abs x)
Error: Syntax error


let digitalRoot n = (*failwith "TBD"*)

let rec loop x = function
sumList (digitsOfInt (abs x))
Error: Syntax error


let digitalRoot n = (*failwith "TBD"*)

let rec loop x = match n with
sumList (digitsOfInt (abs x))
Error: Syntax error



hw1 listReverse

fix:
let listReverse l = (*failwith "TBD"*)
let rec rev x l = match x with
| [] -> x
| h::t -> rev (h::x) t in
rev[] l

bad:
let listReverse l = (*failwith "TBD"*)
let rec rev x = match l with
| [] -> x
| h::t -> rev (h::x) t in
rev[] l
Error: This expression has type 'a list
       but an expression was expected of type 'b -> 'c


let listReverse l = (*failwith "TBD"*)
let rec rev x = match x with
| [] -> x
| h::t -> rev (h::x) t in
rev[] l
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 listReverse

fix:
let listReverse l = (*failwith "TBD"*)
let rec rev x = function
| [] -> x
| h::t -> rev (h::x) t in
rev[] l

let _ = listReverse [1; 2; 3; 4]

bad:
let listReverse l = (*failwith "TBD"*)
let rec rev x l = function
| [] -> x
| h::t -> rev (h::x) t in
rev[] l
Error: This expression has type 'a list -> 'a list
       but an expression was expected of type 'a list



hw1 digitalRoot

fix:
let digitalRoot n = (*failwith "TBD"*)
let x = n in
let rec loop x =
if x < 10 then x
else loop( sumList (digitsOfInt ( abs x ) ) )

;;

bad:
let digitalRoot n = (*failwith "TBD"*)
let x = n in
let rec loop x =
if x < 10 then x
else loop( sumList (digitsOfInt ( abs x ) ) )
Error: Syntax error



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = (*failwith "to be written" in*)
if List.mem h seen then
seen
else 
h::seen
in (*list of seen elts*)
let rest' = (*failwith "to be written" in *)
t
in (*orig list*)
helper (seen',rest')

in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = (*failwith "to be written" in*)

in (*list of seen elts*)
let rest' = (*failwith "to be written" in *)
t
in (*orig list*)
if List.mem h seen then
helper (seen',rest')
else 
h::seen'
helper (seen', rest')

in
List.rev (helper ([],l))
Error: Syntax error


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(*let seen' = failwith "to be written" in*)

(*in list of seen elts*)
let rest' = (*failwith "to be written" in *)
t
in (*orig list*)
if List.mem h seen then
helper (seen',rest')
else 
h::seen'
helper (seen', rest')

in
List.rev (helper ([],l))
Error: Unbound value seen'
Hint: Did you mean seen?



hw2 wwhile

fix:
let rec assoc (d,k,l) = (*failwith "to be written"*)
match l with
|[] -> d
|(ki,vi)::l -> if k = ki then vi
else assoc (d,k,l)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = (*failwith "to be written" in*)
if List.mem h seen then
seen
else 
h::seen
in (*list of seen elts*)
let rest' = (*failwith "to be written" in *)
t
in (*orig list*)
helper (seen',rest')

in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) = (* failwith "to be written" *)
let c' = f b in
if c' = b 
then c'
else wwhile (f, c')

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)
Error: This expression has type int -> int * bool
       but an expression was expected of type int -> int
       Type int * bool is not compatible with type int 



hw2 wwhile

fix:
let rec wwhile (f,b) = (* failwith "to be written" *)
let c' = f b in
(*let b' = in*)
if c' = b 
then c'
else wwhile (f, c')

bad:
let rec wwhile (f,b) = (* failwith "to be written" *)
let c' = f b in
let b' = b in
if c' = b 
then c'
else wwhile (c', b')
Error: This expression has type 'a but an expression was expected of type
         'a -> 'a
       The type variable 'a occurs inside 'a -> 'a



hw2 wwhile

fix:
let rec wwhile (f,b) = (* failwith "to be written" *)
let helper = f b in
match helper with
| (x, y) -> if y 
then wwhile (f, x)
else x

bad:
let rec wwhile (f,b) = (* failwith "to be written" *)
let helper f b = 
(b', bool c') in
match c' with
| false -> b'
| true -> wwhile (f, b')
Error: Unbound value b'


let rec wwhile (f,b) = (* failwith "to be written" *)
let helper f b = 
(b', bool c') in
match helper with
| (int, bool) -> if c' = false then b'
else wwhile (f, b')
Error: Unbound value b'


let rec wwhile (f,b) = (* failwith "to be written" *)
let helper f b = 
(int b', bool c') in
match helper with
| false -> if c' = false then b'
| true -> wwhile (f, b')
Error: Unbound value int


let rec wwhile (f,b) = (* failwith "to be written" *)
let b' f b = 
(b', bool c') in
match helper with
| false -> if c' = false then b'
| true -> wwhile (f, b')
Error: Unbound value b'


let rec wwhile (f,b) = (* failwith "to be written" *)
let b' = f b in
let p = (b', bool c') in
match c' with
| false -> b'
| true  -> wwhile (f, b')
Error: Unbound value bool


let rec wwhile (f,b) = (* failwith "to be written" *)
let f b = (b', c') in
match c' with
| false -> b'
| true  -> wwhile (f, b')
Error: Unbound value b'


let rec wwhile (f,b) = (* failwith "to be written" *)
let b' = int in
let c' = bool in
let f b = (b', c') in
match c' with
| false -> b'
| true  -> wwhile (f, b')
Error: Unbound value int



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((*(failwith "to be written")*)
let g b =
let self = f b in
match self with
| b -> (self, true)
| _ -> (self, false)
in g
,b)

bad:
let fixpoint (f,b) = wwhile ((*(failwith "to be written")*)
let g b =
let self = f b in
match  with
| b -> (self, true)
| _ -> (self, false)
in g
,b)
Error: Syntax error: operator expected.



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((*(failwith "to be written")*)
let g =
let self = f b in
match self with
| b -> (self, true)
| _ -> (self, false)
in g
,b)
Error: This expression has type 'a * bool
       but an expression was expected of type 'b -> 'b * bool



hw2 fixpoint

fix:
let rec wwhile (f,b) = (* failwith "to be written" *)
let helper = f b in
match helper with
| (x, y) -> if y = false
then x
else wwhile (f, x)

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) = wwhile ((*(failwith "to be written")*)
let g b =
let self = f b in
match b with
| self -> (self, false)
| _ -> (self, true)
in g
,b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let _ = fixpoint (collatz, 1)
Error: Unbound value fixpoint


let _ = fixpoint (collatz, 3)
Error: Unbound value fixpoint


let _ = fixpoint (collatz, 48)
Error: Unbound value fixpoint


let _ = fixpoint (collatz, 107)
Error: Unbound value fixpoint


let _ = fixpoint (collatz, 9001)
Error: Unbound value fixpoint


let _ = fixpoint (collatz, 3)
Error: Unbound value fixpoint



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((*(failwith "to be written")*)
let g b = 
let helper = f b in
match helper with
| b -> if f = b
then (f, false)
else (f, true)
in g
,b)
Error: This expression has type 'a -> ('a -> 'a * 'b) * bool
       but an expression was expected of type 'a -> 'a * bool
       The type variable 'a occurs inside 'a -> 'a * 'b


let fixpoint (f,b) = wwhile ((*(failwith "to be written")*)
let g b = 
let helper = f b in
match helper with
| f-> if f = b
then (f, false)
else (f, true)
in g
,b)
Error: This expression has type 'a but an expression was expected of type
         'b -> 'a
       The type variable 'a occurs inside 'b -> 'a



hw2 eval

fix:
let rec eval (e,x,y) = (*failwith "to be written"*)
match e with
VarX           -> x
| VarY           -> y
| Sine e         -> sin(pi*. eval (e,x,y))
| Cosine e       -> cos(pi*. eval (e,x,y))
| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.
| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)
(*Thresh = e1<e2?e3:e4*)
| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)
then eval (e3,x,y)
else eval (e4,x,y)

let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let _ = eval (sampleExpr,0.5,0.2)
Error: Unbound value sampleExpr
Hint: Did you mean sampleExpr1?
Error: Unbound value sampleExpr
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value sampleExpr
Hint: Did you mean sampleExpr1?


let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)
Error: Unbound value sampleExpr
Hint: Did you mean sampleExpr1?
Error: Unbound value sampleExpr
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value sampleExpr
Hint: Did you mean sampleExpr1?



hw2 eval

fix:
let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

bad:
let _ = eval (sampleExpr1,0.5,0.2)
Error: Unbound value sampleExpr
Hint: Did you mean sampleExpr1?
Error: Unbound value sampleExpr
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value sampleExpr
Hint: Did you mean sampleExpr1?



hw2 build

fix:
let rec assoc (d,k,l) = (*failwith "to be written"*)
match l with
|[] -> d
|(ki,vi)::l -> if k = ki then vi
else assoc (d,k,l)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = (*failwith "to be written" in*)
if List.mem h seen then
seen
else 
h::seen
in (*list of seen elts*)
let rest' = (*failwith "to be written" in *)
t
in (*orig list*)
helper (seen',rest')

in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) = (* failwith "to be written" *)
let helper = f b in
match helper with
| (x, y) -> if y = false
then x
else wwhile (f, x)

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) = wwhile ((*(failwith "to be written")*)
let g b = 
let helper = f b in
match helper with
| f-> if f = b
then (f, false)
else (f, true)
in g
,b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

type expr = 
VarX
| VarY
| Sine     of expr
| Cosine   of expr
| Average  of expr * expr
| Times    of expr * expr
| Thresh   of expr * expr * expr * expr

let rec exprToString e = (*failwith "to be written"*)
match e with
VarX           -> "x"
| VarY           -> "y"
| Sine e         -> "sin(pi*" ^ exprToString e ^ ")"
| Cosine e       -> "cos(pi*" ^ exprToString e ^ ")"
| Average (e1,e2)-> "((" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ ")" ^ "/" ^ "2" ^")"
| Times (e1,e2)  -> exprToString e1 ^ "*" ^ exprToString e2
(*Thresh = e1<e2?e3:e4*)
| Thresh (e1,e2,e3,e4)-> "(" ^exprToString e1^ "<" ^exprToString e2^ "?" ^exprToString e3^ ":" ^exprToString e4^ ")"

let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

let _ = exprToString sampleExpr1

let buildX()                       = VarX

let buildY()                       = VarY

let buildSine(e)                   = Sine(e)

let buildCosine(e)                 = Cosine(e)

let buildAverage(e1,e2)            = Average(e1,e2)

let buildTimes(e1,e2)              = Times(e1,e2)

let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)

let pi = 4.0 *. atan 1.0

let rec eval (e,x,y) = (*failwith "to be written"*)
match e with
VarX           -> x
| VarY           -> y
| Sine e         -> sin(pi*. eval (e,x,y))
| Cosine e       -> cos(pi*. eval (e,x,y))
| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.
| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)
(*Thresh = e1<e2?e3:e4*)
| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)
then eval (e3,x,y)
else eval (e4,x,y)

let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr,0.5,0.2)

let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv

let sampleExpr =
buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(
buildX()),buildTimes(buildCosine (buildCosine (buildAverage(buildTimes (buildY(),buildY()),buildCosine (buildX())))),buildCosine (buildTimes (buildSine (buildCosine(buildY())),buildAverage (buildSine (buildX()), buildTimes(buildX(),buildX()))))))),buildY())))

let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))

let rec build (rand, depth) = (*failwith "to be implemented"*)
let rng = rand(0,9) in
if depth >= 0 then 
match rand (0,2) with
| 0 -> buildX()
| 1 -> buildY()
else 
match rng with
| 0 -> build(rand,depth-1)
| 1 -> build(rand,depth-1)
| 2 -> buildSine(build(rand, depth-1))
| 3 -> buildCosine(build(rand, depth-1))
| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))
| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))
| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))
| 7 -> buildExpwn(build(rand, depth-1))
| 8 -> buildLogTen(build(rand, depth-1))

bad:
let rec build (rand, depth) = (*failwith "to be implemented"*)
let rng = rand(0,9) in
if depth >= 0 then 
match rand 0 2 with
| 0 -> buildX()
| 1 -> buildY()
else 
match rng with
| 0 -> build(rand,depth-1)
| 1 -> build(rand,depth-1)
| 2 -> buildSine(build(rand, depth-1))
| 3 -> buildCosine(build(rand, depth-1))
| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))
| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))
| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))
| 7 -> buildExpwn(build(rand, depth-1))
| 8 -> buildLogTen(build(rand, depth-1))
Error: Unbound value emitGrayscale


let rec build (rand, depth) = (*failwith "to be implemented"*)
let rng = rand(0,9) in
if depth >= 0 then 
match rand (0,2) with
| 0 -> buildX()
| 1 -> buildY()
else 
match rng with
| 0 -> build(rand,depth-1)
| 1 -> build(rand,depth-1)
| 2 -> buildSine(build(rand, depth-1))
| 3 -> buildCosine(build(rand, depth-1))
| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))
| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))
| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))
| 7 -> buildExpwn(build(rand, depth-1))
| 8 -> buildLogTen(build(rand, depth-1))
Error: This expression has type int but an expression was expected of type
         int * int



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n < 0 then []
else match n with
| 0 -> []
| _ -> digitsOfInt (n/10)@[n mod 10]

bad:
let rec digitsOfInt n = 
if n < 0 then []
else match n with
| digitsOfInt(n/10)::(n mod 10)
Error: Syntax error


let rec digitsOfInt n = 
if n < 0 then []
else match n with
| 0 -> [0]
| digitsOfInt(n/10)::(n mod 10)
Error: Syntax error


let rec digitsOfInt n = 
if n < 0 then []
else match n with
| digitsOfInt (n/10)::(n mod 10)
Error: Syntax error


let rec digitsOfInt n = 
if n < 0 then []
else match n with
| digitsOfInt n/10::(n mod 10)
Error: Syntax error


let rec digitsOfInt n = 
if n < 0 then []
else match n with
| digitsOfInt (n/10)::(n mod 10)
Error: Syntax error


let rec digitsOfInt n = 
if n < 0 then []
else match n with
| _ -> digitsOfInt (n/10)::(n mod 10)
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec digitsOfInt n = 
if n < 0 then []
else match n with
| 0 -> []
| _ -> digitsOfInt (n/10)::(n mod 10)
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec digitsOfInt n = 
if n < 0 then []
else match n with
| 0 -> []
| _ -> digitsOfInt (n/10)@(n mod 10)
Error: This expression has type int but an expression was expected of type
         'a list



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n = 0 then [0]
else let rec getDigits n = match n with
| 0 -> []
| _ -> myAppend (getDigits (n/10)) (n mod 10)

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

bad:
let rec digitsOfInt n = 
if n = 0 then [0]
else let rec getDigits n = match n with
| 0 -> []
| _ -> myAppend (getDigits (n/10) (n mod 10))
Error: Syntax error



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n = 0 then [0]
else let rec getDigits n = 
if n > 0 then myAppend (getDigits (n/10)) (n mod 10)
else []

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

bad:
let rec digitsOfInt n = 
if n = 0 then [0]
else let rec getDigits m = match m with
| 0 -> []
| _ -> myAppend (getDigits (m/10)) (m mod 10)
Error: Syntax error



hw1 additivePersistence

fix:
let rec additivePersistence n = match n with
| 0 -> 1
| _ -> 1 + additivePersistence (sumList digits n)

let _ = additivePersistence 9876

bad:
let rec additivePersistence n = match n with
| 0 -> 1
| _ -> 1 + additivePersistence sumList digits n
Error: This function has type int -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 ???

fix:
let rec listCompare l k = 
if (List.hd l) = [] && (List.hd k) = [] then true
else if (List.hd l) != (List.hd k) then false
else listCompare (List.tl l) (List.tl k)

bad:
let rec listCompare l k = 
if List.hd l = [] && List.hd k = [] then true
else if List.hd l != List.hd k then false
else listCompare List.tl l List.tl k
Error: This function has type 'a list list -> 'a list list -> bool
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 palindrome

fix:
let rec sumList xs = match xs with 
| [] -> 0
| h::t -> h + sumList t

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

let rec digitsOfInt n = 
if n = 0 then [0]
else getDigits n

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

let digits n = digitsOfInt (abs n)

let rec additivePersistence n = 
if (n/10) = 0 then 0
else 1 + additivePersistence (sumList (digits n))

let _ = additivePersistence 9876

let rec digitalRoot n = 
if (n/10) = 0 then n
else digitalRoot (sumList (digits n))

let _ = digitalRoot 9876

let rec listReverse l = match l with
| [] -> []
| h::t -> myAppend (listReverse t) h

let _ = listReverse [1; 2; 3; 4]

let _ = listReverse ["a"; "b"; "c"; "d"]

let explode s = 
let rec go i = 
if i >= String.length s 
then [] 
else (s.[i]) :: (go (i+1)) 
in
go 0

let palindrome w = (explode w) = (listReverse (explode w))

type test = unit -> string

let key        = ""

let prefix130  = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)); ErrorCode "exception")

let scoreMsg () = 
Printf.sprintf "Results: Score/Max = %d / %d \n" !score !max

bad:
let palindrome w = listCompare (explode w) (listReverse (explode w))
Error: This expression has type char list
       but an expression was expected of type 'a list list
       Type char is not compatible with type 'a list 



hw2 wwhile

fix:
let rec wwhile (f,b) = 
let helper (b', c') = 
if c' then wwhile (f, b')
else b'
in f b

bad:
let rec wwhile (f,b) = 
let helper (b', c') = 
if c' then wwhile (f, b')
else b'
in f b'
Error: Unbound value b'



hw2 wwhile

fix:
let rec wwhile (f,b) = match f b with
| (b', c') -> if c' then wwhile (f, b')
else b'

bad:
let rec wwhile (f,b) = 
let (b', c') = 
if c' then wwhile (f, b')
else b'
in f b
Error: Unbound value c'


let rec wwhile (f,b) = 
if c' then wwhile (f, b')
else b'
in f b(b', c')
Error: Unbound value c'



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((fun f' -> (f b, b != (f b))),b)

bad:
let fixpoint (f,b) = wwhile ((let f' = (f b, b != (f b))),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ((let fun f' = (f b, b != (f b))),b)
Error: Syntax error: operator expected.



hw2 eval

fix:
et _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr,0.5,0.2)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e' -> sin(pi *. (eval (e'(e', x, y))))
| Average (e1, e2) -> (((eval (e1, x, y)) +. (eval (e2, x, y)))/2)
| Times (e1, e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y)))
| Thresh (e1, e2, e3, e4) -> (if ((eval (e1, x, y))<(eval (e2, x, y))) then (eval (e3, x, y)) else (eval (e4, x, y)))
Error: Syntax error


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e' -> sin(pi *. (eval (e', x, y)))
| Average (e1, e2) -> (((eval (e1, x, y)) +. (eval (e2, x, y)))/2)
| Times (e1, e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y)))
| Thresh (e1, e2, e3, e4) -> (if ((eval (e1, x, y))<(eval (e2, x, y))) then (eval (e3, x, y)) else (eval (e4, x, y)))
Error: This expression has type expr
       This is not a function; it cannot be applied.


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e' -> sin(pi *. (eval (e', x, y)))
| Average (e1, e2) -> (((eval (e1, x, y)) +. (eval (e2, x, y)))/.(2.0))
| Times (e1, e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y)))
| Thresh (e1, e2, e3, e4) -> (if ((eval (e1, x, y))<(eval (e2, x, y))) then (eval (e3, x, y)) else (eval (e4, x, y)))
Error: This expression has type float but an expression was expected of type
         int



hw3 stringOfList

fix:
let stringOfList f l = "[" ^ (sepConcat "; " (List.map f l)) ^ "]"

bad:
let stringOfList f l = "[" ^ (List.map f "; " l) ^ "]"
Error: This function has type ('a -> 'b) -> 'a list -> 'b list
       It is applied to too many arguments; maybe you forgot a `;'.


let stringOfList f l = "[" ^ (List.map f ("; " l)) ^ "]"
Error: This expression has type string
       This is not a function; it cannot be applied.


let stringOfList f l = "[" ^ (List.map (f "; ") l) ^ "]"
Error: This expression has type 'a list
       but an expression was expected of type string



hw3 padZero

fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = (fun y -> x (a y)) in
let base = (fun x -> x) in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = "[" ^ (sepConcat "; " (List.map f l)) ^ "]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n = 
if n < 1 then []
else x::(clone x (n-1))

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let padZero l1 l2 = 
let len1 = List.length l1 in
let len2 = List.length l2 in
if (len1 < len2) then ((List.append (clone 0 (len2-len1)) l1), l2)
else (l1, (List.append (clone 0 (len1-len2)) l2))

bad:
let padZero l1 l2 = 
let len1 = List.length l1 in
let len2 = List.length l2 in
(len1 < len2) ? ((List.append (clone 0 (len2-len1)) l1), l2) : (l1, (List.append (clone 0 (len1-len2)) l2))
Error: Syntax error


let padZero l1 l2 = 
let len1 = List.length l1 in
let len2 = List.length l2 in
(len1 < len2) ? ((List.append (clone 0 (len2-len1)) l1), l2) : (l1, (List.append (clone 0 (len1-len2)) l2))
Error: Syntax error



hw3 mulByDigit

fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = (fun y -> x (a y)) in
let base = (fun x -> x) in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = "[" ^ (sepConcat "; " (List.map f l)) ^ "]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n = 
if n < 1 then []
else x::(clone x (n-1))

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let padZero l1 l2 = 
let len1 = List.length l1 in
let len2 = List.length l2 in
((List.append (clone 0 (len2-len1)) l1), (List.append (clone 0 (len1-len2)) l2))

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

let rec removeZero l = match l with
| [] -> []
| h::t -> 
if h = 0 then removeZero t
else h::t

let _ = removeZero [0;0;0;1;0;0;2]

let _ = removeZero [9;9]

let _ = removeZero [0;0;0;0]

let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (i, l) -> match x with
| (x1, x2) -> (((x1+x2+i)/10), (((x1+x2+i) mod 10)::l))
in
let base = (0, []) in
let args = (List.rev (List.combine (0::l1) (0::l2))) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

let rec mulByDigit i l = 
if i = 0 then l
else mulByDigit ((i-1), (bigAdd l l))

bad:
let rec mulByDigit i l = 
let (i', l') = (0, (List.rev l)) in
match l' with
| [] -> []
| h::t -> (((h*i)+i') mod 10)::(mulByDigit ((((h*i)+i')/10), t))
in
List.rev (mulByDigit i l)
Error: This expression has type 'a * 'b
       but an expression was expected of type int



hw3 mulByDigit

fix:
let rec mulByDigit i l = bigAdd l (mulByDigit (i-1) l)

bad:
let rec mulByDigit i l = 
if i > 0 then mulByDigit ((i-1), (bigAdd l l))
else l
Error: This expression has type 'a * 'b
       but an expression was expected of type int



hw3 mulByDigit

fix:
let rec mulByDigit i l = match i with
| 0 -> l
| _ -> bigAdd l (mulByDigit (i-1) l)

bad:
let rec mulByDigit i l = if i > 0 then bigAdd l (mulByDigit (i-1) l)
Error: This expression has type int list
       but an expression was expected of type unit



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x =  match a with
| (i, l) -> match x with
| [] -> (i, [0])
| h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i))) 
in
let base = (0, []) in
let args =  List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x =  match a with
| (i, l) -> match x with
| [] -> []
| h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i) 
in
let base = (0, []) in
let args =  List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Characters 109-110:
  | h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i) 
                             ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let bigMul l1 l2 = 
let f a x =  match a with
| (i, l) -> match x with
| [] -> []
| h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i)) 
in
let base = (0, []) in
let args =  List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Characters 92-93:
  | h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i)) 
            ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let bigMul l1 l2 = 
let f a x =  match a with
| (i, l) -> match x with
| [] -> []
| h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i))) 
in
let base = (0, []) in
let args =  List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x =  match a with
| (i, l) -> ((i+1), bigAdd l (List.append (mulByDigit x l1) (clone 0 i))) 
in
let base = (0, []) in
let args =  List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let _ = bigMul [9;9;9;9] [9;9;9;9]
Error: This expression has type int but an expression was expected of type
         int list
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int but an expression was expected of type
         int list


let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]
Error: This expression has type int but an expression was expected of type
         int list
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int but an expression was expected of type
         int list



hw1 additivePersistence

fix:
let _ = additivePersistence 0

bad:
let _ additivePersistence 0
Error: Syntax error


let _ additivePersistence 10
Error: Syntax error



hw1 listReverse

fix:
let _ = listReverse [(1,2); (3,4)]

bad:
let _ = listReverse [(a,b); (c,d)];



(* explode : string -> char list 
* (explode s) is the list of characters in the string s in the order in 
*   which they appear
* e.g.  (explode "Hello") is ['H';'e';'l';'l';'o']
*)
let explode s = 
let rec go i = 
if i >= String.length s 
then [] 
else (s.[i]) :: (go (i+1)) 
in
go 0
Error: Syntax error


let _ = listReverse [(a,b); (c,d)]
Error: Unbound value a



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
wwhile (f, 3)
Error: Unbound value wwhile


let fixpoint (f,b) =
let b' = f b in
if b' = b
then b
else fixpoint (f, b')
Error: Unbound value wwhile


let rec fixpoint (f,b) =
let b' = f b in
if b' = b
then b
else fixpoint (f, b')
Error: Unbound value fixpoint



hw2 fixpoint

fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 ???

fix:
g 0.739085

bad:
g 0
Error: Unbound value fixpoint



hw2 exprToString

fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

let _ = exprToString sampleExpr1

bad:
let rec exprToString e = match e with
| VarX      -> "x"
| VarY      -> "y"
| Sin e'    -> "sin (pi*"^expr e'^")"
| Cos e'    -> "cos (pi*"^expr e'^")"
| Average e1, e2  -> "(("^esprToString e1^" + "^exprToString e2^"/2)"
| Times e1, e2    -> (exprToString e1)^" * "^exprToString e2
| Thresh e1, e2, e3, e4    ->
"("^exprToString e1^"<"^exprToString e2^" ? "^exprToString e3^" : "^exprToString e4^")"
Error: Unbound constructor Varx
Hint: Did you mean VarX or VarY?


let rec exprToString e = match e with
| VarX      -> "x"
| VarY      -> "y"
| Sine e'    -> "sin (pi*"^expr e'^")"
| Cosine e'    -> "cos (pi*"^expr e'^")"
| Average e1, e2  -> "(("^esprToString e1^" + "^exprToString e2^"/2)"
| Times e1, e2    -> (exprToString e1)^" * "^exprToString e2
| Thresh e1, e2, e3, e4    ->
"("^exprToString e1^"<"^exprToString e2^" ? "^exprToString e3^" : "^exprToString e4^")"
Error: This variant pattern is expected to have type expr
       The constructor Sin does not belong to type expr
Hint: Did you mean Sine?


let rec exprToString e = match e with
| VarX      -> "x"
| VarY      -> "y"
| Sine e'    -> "sin (pi*"^expr e'^")"
| Cosine e'    -> "cos (pi*"^expr e'^")"
| Average (e1, e2)  -> "(("^esprToString e1^" + "^exprToString e2^"/2)"
| Times   (e1, e2)  -> (exprToString e1)^" * "^exprToString e2
| Thresh (e1, e2, e3, e4)    ->
"("^exprToString e1^"<"^exprToString e2^" ? "^exprToString e3^" : "^exprToString e4^")"
Error: This pattern matches values of type 'a * 'b
       but a pattern was expected which matches values of type expr


let rec exprToString e = match e with
| VarX      -> "x"
| VarY      -> "y"
| Sine e'    -> "sin (pi*"^exprToString e'^")"
| Cosine e'    -> "cos (pi*"^exprToString e'^")"
| Average (e1, e2)  -> "(("^esprToString e1^" + "^exprToString e2^"/2)"
| Times   (e1, e2)  -> (exprToString e1)^" * "^exprToString e2
| Thresh (e1, e2, e3, e4)    ->
"("^exprToString e1^"<"^exprToString e2^" ? "^exprToString e3^" : "^exprToString e4^")"
Error: Unbound value expr
Hint: Did you mean exp?


let rec exprToString e = match e with
| VarX      -> "x"
| VarY      -> "y"
| Sine e'    -> "sin (pi*"^exprToString e'^")"
| Cosine e'    -> "cos (pi*"^exprToString e'^")"
| Average (e1, e2)  -> "(("^exprToString e1^" + "^exprToString e2^"/2)"
| Times   (e1, e2)  -> (exprToString e1)^" * "^exprToString e2
| Thresh (e1, e2, e3, e4)    ->
"("^exprToString e1^"<"^exprToString e2^" ? "^exprToString e3^" : "^exprToString e4^")"
Error: Unbound value esprToString
Hint: Did you mean exprToString?



hw2 build

fix:
let _ = buildX()

bad:
let _ = buildSine(0.5)
Error: Syntax error: operator expected.


let _ = buildSine(Sine 0.5)
Error: This expression has type float but an expression was expected of type
         expr


let _ = buildSine(Sine VarX)
Error: This expression has type float but an expression was expected of type
         expr



hw2 eval

fix:
let _ = eval (Average(VarX,VarY), 0.5, 0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX	  -> x
| VarY    -> y
| Average (x', y') -> (eval x'+ eval y')/2
Error: This expression has type expr but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| VarX	  -> x
| VarY    -> y
| Average (x', y') -> (eval x' y + eval x y')/2
Error: This expression has type expr but an expression was expected of type
         expr * 'a * 'a


let rec eval (e,x,y) = match e with
| VarX	  -> x
| VarY    -> y
| Average (x', y') -> (eval VarX x' y + eval VarY x y')/2
Error: This expression has type expr but an expression was expected of type
         expr * ('a -> 'b) * ('a -> 'b)


let rec eval (e,x,y) = match e with
| VarX	  -> x
| VarY    -> y
| Average (x', y') -> (eval (VarX, x', y) + eval (VarY, x, y'))/2
Error: This expression has type expr but an expression was expected of type
         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)


let rec eval (e,x,y) = match e with
| VarX	  -> x
| VarY    -> y
| Average (x', y') -> (x'+y')/2
Error: This expression has type expr but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| VarX	  -> x
| VarY    -> y
| Average (x', y') -> (x+y)/2
Error: This expression has type expr but an expression was expected of type
         int



hw2 eval

fix:
let _ = eval (Average(VarX,VarY), 0.5, 0.5)

bad:
let rec eval (e,x,y) = match e with
| Average (x', y') -> (x+y)/2
Error: This expression has type float but an expression was expected of type
         int



hw2 eval

fix:
let _ = eval (Average(VarX,VarY), 0.5, 0.5)

bad:
let rec eval (e,x,y) = match e with
| Average (x', y') -> (x +. y)/2
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| Average (x', y') -> (x .+ y)/2
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| Average (x', y') -> (x +. y)/2
Error: Syntax error: operator expected.


let rec eval (e,x,y) = match e with
| Average (x', y') -> (x +. y) ./ 2
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| Average (x', y') -> (x +. y) /. 2
Error: Syntax error


let rec eval (e,x,y) = match e with
| Average (x', y') -> (x +. y) /. 2.0
Error: This expression has type int but an expression was expected of type
         float



hw2 eval

fix:
let _ = eval (Sine(VarX, VarY), 0.5,0.5)

bad:
let rec eval (e,x,y) = match e with
| Sine e'		-> sin (pi *. eval(e'))
| Cosine e'		-> cos (pi *. eval(e'))
| Average (x', y')      -> (x +. y) /. 2.0
| Times (x', y')	-> x *. y
Error: This expression has type expr but an expression was expected of type
         expr * 'a * 'b


let rec eval (e,x,y) = match e with
| Sine e'		-> sin (pi *. eval(e', x, y))
| Cosine e'		-> cos (pi *. eval(e', x, y))
| Average (x', y')      -> (x +. y) /. 2.0
| Times (x', y')	-> x *. y
Error: This expression has type expr but an expression was expected of type
         expr * 'a * 'b



hw2 eval

fix:
let _ = eval (Sine(Average(VarX,VarY)), 1.0, 1.0)

bad:
let _ = eval (Sine(Average(VarX,VarY)), 0.5, 0.5)
Error: This expression has type expr but an expression was expected of type
         expr * float * float



hw2 eval

fix:
let rec eval (e,x,y) = match e with
| Sine     e'		-> sin (pi *. eval(e', x, y))
| Cosine   e'		-> cos (pi *. eval(e', x, y))
| Average (x', y')      -> (x +. y) /. 2.0
| Times   (x', y')	-> x *. y

bad:
let _ = eval (Cosine(Average(VarX,VarY)), 0.0, 0.0)
Error: This expression has type int but an expression was expected of type
         float



hw2 eval

fix:
let _ = eval (Thresh(VarX,VarY,Sine(VarY),Cosine(VarX)), 1.0, 2.0)

bad:
let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cos(VarY), 1.0, 2.0))
Characters 13-14:
  let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cos(VarY), 1.0, 2.0);;
               ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cos(VarY)), 1.0, 2.0)
Error: The constructor Thresh expects 4 argument(s),
       but is applied here to 6 argument(s)


let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cosine(VarY)), 1.0, 2.0)
Error: This variant expression is expected to have type expr
       The constructor Cos does not belong to type expr



hw2 eval

fix:
let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cosine(VarX)), 0.5, 1.0)

let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cosine(VarX)), 1.0, 0.5)

bad:
)
Error: This expression has type expr but an expression was expected of type
         expr * float * float


let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cosine(VarX)), 1.0, 0.5)
Error: Syntax error



hw2 eval

fix:
let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

bad:
let _ = eval (sampleExpr1,0.5,0.2)
Error: Unbound value sampleExpr
Hint: Did you mean sampleExpr1?
Error: Unbound value sampleExpr
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value sampleExpr
Hint: Did you mean sampleExpr1?



hw2 eval

fix:
let _ = eval (Cosine(Average),0.5,0.2)

bad:
let _ = eval (Sine(VarX),0.5,0.0)
Error: This expression has type int but an expression was expected of type
         float



hw2 ???

fix:
let trand = makeRand(10,39)

bad:
let trand = makeRand(10,39)
Error: Syntax error



hw2 ???

fix:
let x = trand(1,4)

bad:
let x = trand(1,4)
Error: Unbound value rand
Hint: Did you mean land or trand?
Error: Unbound value rand
Hint: Did you mean land?
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value rand
Hint: Did you mean land or trand?



hw2 ???

fix:
let _ = doRandomGray(2,12,12321)

bad:
let _ = doRandomGray(2,12,45)
Error: Syntax error



hw2 ???

fix:
let _ = doRandomColor(8, -8168564, 9342315)

bad:
let _ = doRandomColor(8, -81685634, 9342315)
Error: This expression has type float but an expression was expected of type
         int
Error: Unbound constructor VarX
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type float but an expression was expected of type
         int



hw2 ???

fix:
acos 1.0

bad:
tan 1.0
Error: This expression has type int but an expression was expected of type
         float



hw2 ???

fix:
exp 1.0

bad:
acos (-1.0)
Error: This expression has type float -> float
       but an expression was expected of type int



hw2 ???

fix:
log (-.5)

bad:
log (-1.0)
Error: This expression has type float -> float
       but an expression was expected of type int



hw2 ???

fix:
log10 (1.0)

bad:
log (-0.5)
Error: This expression has type int but an expression was expected of type
         float



hw2 ???

fix:
log10 (-0.5)

bad:
log10 (0.5)
Error: Syntax error: operator expected.



hw2 exprToString

fix:
let temp1 = FunckyCube(SquareRoot(VarY),SquareRoot(VarX),SquareRoot(VarY))

let _ = exprToString temp1

bad:
let _ = exprToString FunckyCube(SquareRoot(VarY),SquareRoot(VarX),SquareRoot(VarY))
Error: This function has type expr -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw2 exprToString

fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

let _ = exprToString sampleExpr1

let temp1 = FunckyRoot(SquareRoot(VarY),SquareRoot(VarX),SquareRoot(VarY))

bad:
let rec exprToString e = match e with
| VarX         -> "x"
| VarY         -> "y"
| Sine e'      -> "sin(pi*"^exprToString e'^")"
| Cosine e'    -> "cos(pi*"^exprToString e'^")"
| Average (e1, e2)  -> "(("^exprToString e1^"+"^exprToString e2^"/2)"
| Times   (e1, e2)  -> (exprToString e1)^"*"^exprToString e2
| Thresh (e1, e2, e3, e4)    ->
"("^exprToString e1^"<"^exprToString e2^"?"^
exprToString e3^":"^exprToString e4^")"
| SquareRoot e'		  -> "sqrt("^exprToString e'^")"
| FunckyRoot (e1,e2,e3)   -> 
"sqrt(sqrt("^exprToString e1^")+sqrt("^exprToString e2^")+sqrt("^exprToString e3^"))"
Error: This variant pattern is expected to have type expr
       The constructor FunckyCube does not belong to type expr



hw2 build

fix:
let rec build (rand, depth) =
if depth = 0
then 
let num = rand(0,1) in
match num with
| 0 -> buildX()
| 1 -> buildY()
else
let num = rand(0,7) in
match num with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build(rand, depth-1))
| 3 -> buildCosine(build(rand, depth-1))
| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))
| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))
| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))
| 7 -> buildSquareRoot(build(rand, depth-1))

bad:
let rec build (rand, depth) =
if depth = 0
then 
let num = rand(0,1) in
match num with
| 0 -> buildX()
| 1 -> buildY()
else
let num = rand(0,8) in
match num with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build(rand, depth-1))
| 3 -> buildCosine(build(rand, depth-1))
| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))
| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))
| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))
| 7 -> buildSquareRoot(build(rand, depth-1))
Error: This expression has type expr/4327
       but an expression was expected of type expr/3809
Error: This expression has type expr/4495
       but an expression was expected of type expr/4485
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type expr/4327
       but an expression was expected of type expr/3809



hw2 build

fix:
let rec build (rand, depth) =
if depth = 0
then 
let num = rand(0,1) in
match num with
| 0 -> buildX()
| 1 -> buildY()
else
let num = rand(0,7) in
match num with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build(rand, depth-1))
| 3 -> buildCosine(build(rand, depth-1))
| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))
| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))
| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))
| 7 -> buildSquareRoot(build(rand, depth-1))
| 8 -> buildFunckySine(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))

bad:
let rec build (rand, depth) =
if depth = 0
then 
let num = rand(0,1) in
match num with
| 0 -> buildX()
| 1 -> buildY()
else
let num = rand(0,7) in
match num with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build(rand, depth-1))
| 3 -> buildCosine(build(rand, depth-1))
| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))
| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))
| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))
| 7 -> buildSquareRoot(build(rand, depth-1))
| 8 -> buildFunckySine(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))
Error: Syntax error



hw2 build

fix:
let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

let emitColor (f1,f2,f3,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_c_"^name) in
let chan = open_out (fname^".ppm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P6 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z1 = f1 (x,y) in
let z2 = f2 (x,y) in
let z3 = f3 (x,y) in

(* Convert the result to a grayscale value *)
let iz1 = toIntensity(z1) in
let iz2 = toIntensity(z2) in
let iz3 = toIntensity(z3) in

(* Emit one byte per color for this pixel *)
output_char chan (char_of_int iz1);
output_char chan (char_of_int iz2);
output_char chan (char_of_int iz3);
)) in  
close_out chan;
ignore(Sys.command ("convert "^fname^".ppm  "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".ppm"))

let doRandomColor (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand (seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e1 = build (g, depth) in
let e2 = build (g, depth) in
let e3 = build (g, depth) in

let _ = Format.printf "red   = %s \n" (exprToString e1) in
let _ = Format.printf "green = %s \n" (exprToString e2) in
let _ = Format.printf "blue  = %s \n" (exprToString e3) in

let f1 = eval_fn e1 in
let f2 = eval_fn e2 in
let f3 = eval_fn e3 in

(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitColor (f1,f2,f3,n,name)

let _ = doRandomGray(9,1000,-12)

let _ = doRandomGray(10,-1000,-2000)

let _ = doRandomGray(12,-1000,5768713)

let _ = doRandomColor(8, 245234, 471265)

let _ = doRandomColor(11, -1021271, 65601173)

let _ = doRandomColor(10, 934541, -34112173)

let g1 () = (9,1000,-12)

let g2 () = (10,-1000,-2000)

let g3 () = (12,-1000,5768713)

let c1 () = (8, 245234, 471265)

let c2 () = (11, -1021271, 65601173)

let c3 () = (10, 934541, -34112173)

bad:
let rec build (rand, depth) =
if depth = 0
then 
let num = rand(0,1) in
match num with
| 0 -> buildX()
| 1 -> buildY()
else
let num = rand(0,7) in
match num with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build(rand, depth-1))
| 3 -> buildCosine(build(rand, depth-1))
| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))
| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))
| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))
| 7 -> buildSquareCosine(build(rand, depth-1))
Error: This expression has type expr/6967
       but an expression was expected of type expr/6204
Error: This expression has type expr/7094
       but an expression was expected of type expr/7085
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type expr/6967
       but an expression was expected of type expr/6204



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a ** x in
let base = 0.0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = 
match x with 
| []    -> a
| h::t  -> f (a + h**2) t in
let base = 0 in
List.fold_left f base xs
Error: Unbound value f


let sqsum xs = 
let f a x = a ** x in
let base = 0 in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         float



hw3 sqsum

fix:
let _ = sqsum [(-1);(-2)]

bad:
let _ = sqsum [(-1);(-2)e]
Error: This expression has type int
       This is not a function; it cannot be applied.



hw3 ???

fix:
(|>) 0 (fun x -> x + 1)

bad:
|> 0 (fun x -> x + 1)
Error: Syntax error



hw3 ???

fix:
let foldl f b xs =
let rec helper res = function
| []   -> res
| h::t -> helper (f res h) t
in helper b xs

bad:
let foldl f b xs =
let rec helper res = function
| []   -> res
| h::t -> helper (f res h) t
Error: Syntax error



hw3 ???

fix:
let foo xs = 
match xs with
| [] -> fun x -> x
| h::t -> h

bad:
foo [(fun x -> x+1); (fun y -> y-1)]
Error: This expression should not be a function, the expected type is
'a list


let foo xs = 
match xs with
| [] -> xs
| h::t -> h
Error: This expression has type 'a but an expression was expected of type
         'a list
       The type variable 'a occurs inside 'a list



hw3 pipe

fix:
let pipe fs = 
let f a x = 
match x with 
| a   -> fun x -> x
| h::t -> h
in

let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = 
match x with 
| a   -> fun x -> x
| h::t -> h
in

let base = [] in
List.fold_left f base fs
Error: This expression has type 'a list
       but an expression was expected of type 'b -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = 
match x with 
| []   -> a
| h::t -> h
in

let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = 
match x with 
| []   -> b
| h::t -> h
in

let base = (fun x -> x) in
List.fold_left f base fs
Error: Unbound value b



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression should not be a function, the expected type is
('a -> 'a) list


let pipe fs = 
let f a x = x a in
let base = 'a in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = 
match x with 
| [] -> a 
| h::t -> t
in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'b list



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = [] in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 ???

fix:
let temp = List.fold_left (fun x y-> x+1) 0 []

bad:
let temp = List.fold_left (fun x -> x + 1) 0 []
Error: This expression has type int but an expression was expected of type
         'a -> int



hw3 ???

fix:
let temp = List.fold_left (fun x y-> y x) 1 [(fun y -> y+1)]

bad:
let temp = List.fold_left (fun x y-> x+y) 1 [(fun y -> y+1)]
Error: This expression should not be a function, the expected type is
int



hw3 pipe

fix:
let pipe fs = 
let f a x = fun xs -> x (a xs) in  (* a fun that takes xs as input
for fun 'a' and take that output
as input for fun 'x' *)
let base = (fun b -> b) in (* a fun that takes 'b as input, and 
return 'b as output *)
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun xs -> x (a xs) in  (* a fun that takes xs as input
for fun 'a' and take that output
as input for fun 'x' *)
let base = (fun 'b -> b') in (* a fun that takes 'b as input, and 
return 'b as output *)
List.fold_left f base fs
Error: Syntax error: operator expected.



hw3 stringOfList

fix:
let _ = stringOfList (fun x -> string_of_int (x+1)) [1;2;3;4]

bad:
let _ = stringOfList (fun x -> x+1) [1;2;3;4]
Error: This expression has type int but an expression was expected of type
         string


let _ = stringOfList (fun x -> int_of_string x+1) [1;2;3;4]
Error: This expression has type int but an expression was expected of type
         string


let _ = stringOfList (fun x -> string_of_int x+1) [1;2;3;4]
Error: This expression has type string but an expression was expected of type
         int



hw3 clone

fix:
let rec clone x n = 
let f a x = List.append a x in
let base = [] in
List.fold_right f x base

bad:
let rec clone x n = 
let f a x = List.append a x in
let base = [] in
List.fold_right f x b
Error: Unbound value b



hw3 clone

fix:
let rec clone x n = 
let aux acc n = 
if n  <= 0
then acc
else clone (List.append x acc) (n-1)
in
aux [] n

bad:
let _ = clone 3 5
Error: This expression has type int but an expression was expected of type
         'a list


let _ = clone "foo" 2
Error: This expression has type string but an expression was expected of type
         'a list


let _ = clone clone (-3)
Error: This expression has type 'a list -> int -> 'a list
       but an expression was expected of type 'b list



hw3 clone

fix:
let rec clone x n = 
let aux acc n = 
if n  <= 0
then acc
else clone (List.append acc x) (n-1)
in
aux [] n

bad:
let _ = clone 3 5
Error: This expression has type int but an expression was expected of type
         'a list


let _ = clone "foo" 2
Error: This expression has type string but an expression was expected of type
         'a list



hw3 clone

fix:
let rec clone x n = 
let aux acc n = 
if n  <= 0
then acc
else clone (List.append x acc ) (n-1)
in
aux [] n

bad:
let rec clone x n = 
let aux acc n = 
if n  <= 0
then acc
else clone (List.append [x] acc ) (n-1)
in
aux [] n
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw3 ???

fix:
List.append ["a"] []

bad:
List.append [a] []
Error: Unbound value a



hw3 clone

fix:
let rec clone x n = 
let rec aux acc n = 
if n  <= 0
then acc
else aux (List.append [x] acc ) (n-1)
in
aux [] n

bad:
let rec clone x n = 
let aux acc n = 
if n  <= 0
then acc
else clone (List.append [x] acc ) (n-1)
in
aux [] n
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec clone x n = 
let aux acc n = 
if n  <= 0
then acc
else aux (List.append [x] acc ) (n-1)
in
aux [] n
Error: Unbound value aux



hw3 clone

fix:
let _ = clone 2 (-1)

bad:
let _ = clone 2 -1
Error: This expression has type int -> int list
       but an expression was expected of type int



hw3 padZero

fix:
let padZero l1 l2 = 
let len1 = List.length l1 in
let len2 = List.length l2 in
if l1 < l2
then ((List.append (clone 0 (len2-len1)) l1), l2)
else (l1, (List.append (clone 0 (len1-len2)) l2))

bad:
let padZero l1 l2 = 
let len1 = List.length l1 in
let len2 = List.length l2 in
if l1 < l2
then ((List.append (clone 0 (len2-len1)) l1), l2)
else (l1, (List.append (clone 0 (len1-len2) l2)))
Error: This function has type 'a -> int -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 clone

fix:
let _ = clone 4 (-12)

bad:
let _ = List.append((clone 0 3) [1;2;3])
Error: This expression has type int list
       This is not a function; it cannot be applied.



hw3 ???

fix:
let _ =  List.length [9;9]

bad:
let _ len1 = List.length [9;9]
Error: Syntax error



hw3 ???

fix:
let (x,y,z) = p

bad:
let p = (1,"john", 0.1)
Error: Unbound value padZero



hw3 ???

fix:
let _ = List.rev (List.combine [0;0;9;9] [1;0;0;2])

bad:
let _ = List.combine [0;0;9;9] [1;0;0;2]
Error: Unbound value bigAdd



hw3 ???

fix:
let _ = 11 mod 10

bad:
let _ = 11/ 10
Error: Unbound value bigAdd



hw3 ???

fix:
let _ = foo [] [1;2;3;4;5] [1;0;1;0]

bad:
let rec foo acc t1 t2 = 
match t2 with
| [] -> acc
| h::t -> foo (List.append [(t1,h)] acc) t
Error: Syntax error


let _ = foo [1;2;3;4;5] [1;0;1;0]
Error: This expression has type 'a list -> ('a list * 'a) list
       but an expression was expected of type ('a list * 'a) list


let rec foo acc t1 t2 = 
match t2 with
| [] -> acc
| h::t -> foo (List.append [(t1,h)] acc) t
Error: This expression has type int but an expression was expected of type
         'a -> 'a


let _ = foo [] [1;2;3;4;5] [1;0;1;0]
Error: This expression has type 'a list -> ('a list * 'a) list
       but an expression was expected of type ('a list * 'a) list


let rec foo acc t1 t2 = 
match t2 with
| [] -> acc
| h::t -> foo (List.append [(t1,h)] acc) t1 t
Error: This expression has type 'a list
       but an expression was expected of type 'b -> 'c



hw3 bigMul

fix:
let rec removeZero l = 
match l with
| []   -> []
| h::t ->
if h == 0
then removeZero t
else l

let _ = removeZero [0;0;0;1;0;0;2]

let _ = removeZero [9;9]

let _ = removeZero [0;0;0;0]

let _ = 11/ 10

let _ = 11 mod 10

let _ = 10 mod 10

let _ = List.rev (List.combine [0;0;9;9] [1;0;0;2])

let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (n1, n2) = x in
let (cin, l) = a in
let result   = n1+n2+cin in
let cout     = result / 10 in
let r        = result mod 10 in
match l with 
| []   -> (cout, List.append [cout] (List.append [r] []))
| h::t -> (cout, List.append [cout] (List.append [r] t)) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

let rec mulByDigit i l = 
let rec aux acc n = 
match n with
| 0 -> acc
| _ -> aux (bigAdd acc l) (n-1) in
aux [0] i

let _ = mulByDigit 9 [9;9;9;9]

let rec foo acc t1 t2 = 
match t2 with
| [] -> acc
| h::t -> foo (List.append [(t1, h)] acc) t1 t

let _ = foo [] [9;9;9] [1;2;3;4]

let bigMul l1 l2 = 
let f a x =  
let (l, i) = x in
let (m, s) = a in
let result = bigAdd s (List.append (mulByDigit i l) (clone 0 m) in
(m*10, result)
in
let base = (1, []) in
let args = 
let rec helper acc l1 l2 = 
match l2 with
| []   -> acc
| h::t -> helper (List.append [(l1,h)] acc) l1 t in
helper [] l1 l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x =  
let (l, i) = x in
let (m, s) = a in
let result = bigAdd s ((mulByDigit i l)*m) in
(m*10, result)
in
let base = (1, []) in
let args = 
let rec helper acc l1 l2 = 
match l2 with
| []   -> acc
| h::t -> helper (List.append [(l1,h)] acc) l1 t in
helper [] l1 l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a * int list
       but an expression was expected of type int



hw3 bigMul

fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x =  
let (l, i) = x in
let (m, s) = a in
let result = bigAdd s (List.append (mulByDigit i l) (clone 0 m)) in
(m*10, result)
in
let base = (1, []) in
let args = 
let rec helper acc l1 l2 = 
match l2 with
| []   -> acc
| h::t -> helper (List.append [(l1,h)] acc) l1 t in
helper [] l1 l2 in
let (_, res) = List.fold_left f base args in
res
Characters 92-93:
  let result = bigAdd s (List.append (mulByDigit i l) (clone 0 m) in
                        ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw2 assoc

fix:
let rec assoc (d,k,l) = (*failwith "to be written"*)
match l with
| [] -> d
| h::t -> if h = k then h else assoc(d,k,t)

bad:
let rec assoc (d,k,l) = (*failwith "to be written"*)
match l with
| [] -> d
| h::t -> if h = k then return h else assoc(d,k,t)
Error: Unbound value return



hw2 assoc

fix:
let rec assoc (d,k,l) = (*failwith "to be written"*)
match l with
| [] -> d
| h::t -> if h = k then h else assoc(d,k,t)

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])
Error: This expression has type string but an expression was expected of type
         int


let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])
Error: This expression has type string but an expression was expected of type
         int



hw2 assoc

fix:
let rec assoc (d,k,l) = (*failwith "to be written"*)
match l with
| [] -> d
| (ki,vi)::t -> if ki = k then vi else assoc(d,k,t)

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])
Error: This expression has type string but an expression was expected of type
         int


let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])
Error: This expression has type string but an expression was expected of type
         int



hw2 build

fix:
let buildOp2(a,b,a_less,b_less)    = Op2(a,b,a_less)

bad:
let buildOp2()                     = Op2(e1,e2,e3)
Error: Unbound value e1


let buildOp2(a,b,a_less,b_less)    = Op2(a,b,a_less,b_less)
Error: The constructor Op2 expects 3 argument(s),
       but is applied here to 4 argument(s)



hw2 build

fix:
let rec build (rand, depth) = (*failwith "to be implemented" *) if depth = -1
then 
let randNum = rand(1,2) in
let randNum2 = rand(3,4) in
if (randNum = 1 && randNum2 = 3) then buildSine(buildOp1(buildX())) else
if (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(  build(rand, depth - 1), 
build(rand, depth - 1),
build(rand, depth - 1))  )

) else
if (randNum = 2 && randNum2 = 3) then buildCosine(buildOp1(buildX())) else
buildCosine(buildOp2(build(rand, depth - 1), 
build(rand, depth - 1),
build(rand, depth - 1))
)

let g1 () = (1,2,3)

let g2 () = (1,2,3)

let g3 () = (1,2,3)

let c1 () = (1,2,3)

let c2 () = (1,2,3)

let c3 () = (1,2,3)

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

let emitColor (f1,f2,f3,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_c_"^name) in
let chan = open_out (fname^".ppm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P6 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z1 = f1 (x,y) in
let z2 = f2 (x,y) in
let z3 = f3 (x,y) in

(* Convert the result to a grayscale value *)
let iz1 = toIntensity(z1) in
let iz2 = toIntensity(z2) in
let iz3 = toIntensity(z3) in

(* Emit one byte per color for this pixel *)
output_char chan (char_of_int iz1);
output_char chan (char_of_int iz2);
output_char chan (char_of_int iz3);
)) in  
close_out chan;
ignore(Sys.command ("convert "^fname^".ppm  "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".ppm"))

let doRandomColor (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand (seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e1 = build (g, depth) in
let e2 = build (g, depth) in
let e3 = build (g, depth) in

let _ = Format.printf "red   = %s \n" (exprToString e1) in
let _ = Format.printf "green = %s \n" (exprToString e2) in
let _ = Format.printf "blue  = %s \n" (exprToString e3) in

let f1 = eval_fn e1 in
let f2 = eval_fn e2 in
let f3 = eval_fn e3 in

(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitColor (f1,f2,f3,n,name)

type test = unit -> string

let key = ""

let prefix130 = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)); ErrorCode "exception")

let explode s = 
let rec _exp i = 
if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in
_exp 0

let implode cs = 
String.concat "" (List.map (String.make 1) cs)

let drop_paren s = 
implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))

let eq_real p (r1,r2) = 
(r1 -. r2) < p || (r2 -. r1) < p

let scoreMsg () = 
Format.sprintf "Results: Score/Max = %d / %d \n" !score !max

bad:
let rec build (rand, depth) = (*failwith "to be implemented" *)
let randNum = rand(1,2) in
let randNum2 = rand(3,4) in
if (randNum = 1 && randNum2 = 3) then buildSine(buildOp1(buildX())) else
if (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(buildX(),buildY(),buildX())) else
if (randNum = 2 && randNum2 = 3) then buildCosine(buildOp1(buildX())) else
buildCosine(buildOp2(buildY(),buildX(),buildY()))
Error: This expression has type 'a * 'b * 'c
       but an expression was expected of type expr * expr * expr * 'd



hw2 build

fix:
let rec build (rand, depth) = (*failwith "to be implemented" *) if depth > -1
then 
let randNum = rand(1,2) in
let randNum2 = rand(3,4) in
if (randNum = 1 && randNum2 = 3) then buildX() else
if (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(  build(rand, depth - 1), 
build(rand, depth - 1),
build(rand, depth - 1))  )

) else
if (randNum = 2 && randNum2 = 3) then buildCosine(buildOp1(buildX())) else
buildCosine(buildOp2(build(rand, depth - 1), 
build(rand, depth - 1),
build(rand, depth - 1))
)

let g1 () = (1,2,3)

let g2 () = (1,2,3)

let g3 () = (1,2,3)

let c1 () = (1,2,3)

let c2 () = (1,2,3)

let c3 () = (1,2,3)

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

let emitColor (f1,f2,f3,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_c_"^name) in
let chan = open_out (fname^".ppm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P6 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z1 = f1 (x,y) in
let z2 = f2 (x,y) in
let z3 = f3 (x,y) in

(* Convert the result to a grayscale value *)
let iz1 = toIntensity(z1) in
let iz2 = toIntensity(z2) in
let iz3 = toIntensity(z3) in

(* Emit one byte per color for this pixel *)
output_char chan (char_of_int iz1);
output_char chan (char_of_int iz2);
output_char chan (char_of_int iz3);
)) in  
close_out chan;
ignore(Sys.command ("convert "^fname^".ppm  "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".ppm"))

let doRandomColor (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand (seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e1 = build (g, depth) in
let e2 = build (g, depth) in
let e3 = build (g, depth) in

let _ = Format.printf "red   = %s \n" (exprToString e1) in
let _ = Format.printf "green = %s \n" (exprToString e2) in
let _ = Format.printf "blue  = %s \n" (exprToString e3) in

let f1 = eval_fn e1 in
let f2 = eval_fn e2 in
let f3 = eval_fn e3 in

(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitColor (f1,f2,f3,n,name)

type test = unit -> string

let key = ""

let prefix130 = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)); ErrorCode "exception")

let explode s = 
let rec _exp i = 
if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in
_exp 0

let implode cs = 
String.concat "" (List.map (String.make 1) cs)

let drop_paren s = 
implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))

let eq_real p (r1,r2) = 
(r1 -. r2) < p || (r2 -. r1) < p

let scoreMsg () = 
Format.sprintf "Results: Score/Max = %d / %d \n" !score !max

bad:
let rec build (rand, depth) = (*failwith "to be implemented" *) if depth = -1
then 
let randNum = rand(1,2) in
let randNum2 = rand(3,4) in
if (randNum = 1 && randNum2 = 3) then buildX() else
if (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(  build(rand, depth - 1), 
build(rand, depth - 1),
build(rand, depth - 1))  )
Error: This expression has type expr but an expression was expected of type
         unit



hw2 build

fix:
let rec build (rand, depth) = 
if depth = 0
then 
buildSine(buildX())
else
let randNum = rand(1,2) in
let randNum2 = rand(1,2) in
let randNum3 = rand(1,2) in
match (randNum, randNum2) with
| (1,1) -> buildSine(build(rand, depth -1))
| (2,2) -> buildCosine(build(rand, depth - 1))
| _     -> match randNum3 with
| 1 -> buildSine(buildOp2(  build(rand, depth - 1), 
build(rand, depth - 1),
build(rand, depth - 1))  )
| 2 -> buildCosine(buildOp2(build(rand, depth - 1), 
build(rand, depth - 1),
build(rand, depth - 1))  )

let g1 () = (1,2,3)

let g2 () = (1,2,3)

let g3 () = (1,2,3)

let c1 () = (1,2,3)

let c2 () = (1,2,3)

let c3 () = (1,2,3)

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

let emitColor (f1,f2,f3,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_c_"^name) in
let chan = open_out (fname^".ppm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P6 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z1 = f1 (x,y) in
let z2 = f2 (x,y) in
let z3 = f3 (x,y) in

(* Convert the result to a grayscale value *)
let iz1 = toIntensity(z1) in
let iz2 = toIntensity(z2) in
let iz3 = toIntensity(z3) in

(* Emit one byte per color for this pixel *)
output_char chan (char_of_int iz1);
output_char chan (char_of_int iz2);
output_char chan (char_of_int iz3);
)) in  
close_out chan;
ignore(Sys.command ("convert "^fname^".ppm  "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".ppm"))

let doRandomColor (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand (seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e1 = build (g, depth) in
let e2 = build (g, depth) in
let e3 = build (g, depth) in

let _ = Format.printf "red   = %s \n" (exprToString e1) in
let _ = Format.printf "green = %s \n" (exprToString e2) in
let _ = Format.printf "blue  = %s \n" (exprToString e3) in

let f1 = eval_fn e1 in
let f2 = eval_fn e2 in
let f3 = eval_fn e3 in

(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitColor (f1,f2,f3,n,name)

type test = unit -> string

let key = ""

let prefix130 = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)); ErrorCode "exception")

let explode s = 
let rec _exp i = 
if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in
_exp 0

let implode cs = 
String.concat "" (List.map (String.make 1) cs)

let drop_paren s = 
implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))

let eq_real p (r1,r2) = 
(r1 -. r2) < p || (r2 -. r1) < p

let scoreMsg () = 
Format.sprintf "Results: Score/Max = %d / %d \n" !score !max

bad:
let rec build (rand, depth) = 
if depth = 0
then 
buildSine(buildX())
else
let randNum = rand(1,2) in
let randNum2 = rand(1,2) in
let randNum3 = rand(1,2) in
match (randNum, randNum2) with
| (1,1) -> buildSine(buildX())
| (2,2) -> buildCosine(buildX())
| _     -> match randNum3 with
| 1 -> buildSine(buildOp2(  build(rand, depth - 1), 
build(rand, depth - 1),
build(rand, depth - 1))  )
| 2 -> buildCosine(buildOp2(build(rand, depth - 1), 
build(rand, depth - 1),
build(rand, depth - 1))  )
Error: Syntax error



hw2 assoc

fix:
let rec assoc (d,k,l) = 
match l with 
| [] -> d
| h::t -> let(s, x) = h in
if (s = k) then x else assoc(d,k,t)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

bad:
let rec assoc (d,k,l) = 
match l with 
| [] -> d
| h::t -> let(s, x) = h
if s = k then x else assoc(d,k,t)
Error: Syntax error


let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])
Error: Unbound value assoc


let rec assoc (d,k,l) = 
match l with 
| [] -> d
| h::t -> let(s, x) = h
if (s = k) then x else assoc(d,k,t)
Error: Syntax error


let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])
Error: Unbound value assoc



hw2 fixpoint

fix:
let fixpoint (f,b) = 
let f x = let xx = f(x) in (xx, xx = x) in 
wwhile (f,b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile (((*failwith "to be written"*)fun x -> f(x), x = f(x)),b)

(* uncomment after implementing fixpoint *)
*
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value fixpoint


let fixpoint (f,b) = wwhile ((let f x = let xx = f(x) in (xx, xx = x)),b)
Error: Syntax error: operator expected.


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value fixpoint



hw2 fixpoint

fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

bad:
let fixpoint (f,b) = 
let g x = let xx = f(x) in (xx, xx = x) in 
wwhile (g,b)
Error: Syntax error


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

bad:
let fixpoint (f,b) = 
let g x = let xx = (f x) in (xx, xx = x)
wwhile (g,b)
Error: Unbound value fixpoint


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Syntax error


let fixpoint (f,b) = 
let g x = let xx = (f x) in (xx, xx = x) in
wwhile (g,b)
Error: Unbound value fixpoint


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

bad:
let fixpoint (f,b) = 
let g x = let xx = (f x) in (xx, xx != x) in
wwhile (g,b)
Error: Syntax error


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 eval

fix:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y 
| Sine a -> sin(pi *. eval(a))
| Cosine (a) -> cos(pi *. eval(a))
| Average (a, b) -> ((eval(a) +. eval(b)) / 2)
| Times (a, b) -> eval(a) *. eval(b)
| Thresh (a, b, c, d) -> if(eval(a) < eval(b)) then  eval(c) else eval(d)

let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y 
| Sine (a) -> sin(pi *. eval(a))
| Cosine (a) -> cos(pi *. eval(a))
| Average (a, b) -> (((eval(a) +. eval(b)) / 2)
| Times (a, b) -> eval(a) *. eval(b)
| Thresh (a, b, c, d) -> if(eval(a) < eval(b)) then  eval(c) else eval(d)
(*failwith "to be written"*)


(* uncomment after implementing eval*)
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)
Error: Syntax error


let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y 
| Sine (a) -> sin(pi *. eval(a))
| Cosine (a) -> cos(pi *. eval(a))
| Average (a, b) -> ((eval(a) +. eval(b)) / 2)
| Times (a, b) -> eval(a) *. eval(b)
| Thresh (a, b, c, d) -> if(eval(a) < eval(b)) then  eval(c) else eval(d)
Characters 151-152:
  | Average (a, b) -> (((eval(a) +. eval(b)) / 2)
                      ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)
Error: This expression has type expr but an expression was expected of type
         expr * 'a * 'a



hw2 build

fix:
let g1 () = failwith "to be implemented"

let g2 () = failwith "to be implemented"

let g3 () = failwith "to be implemented"

let c1 () = failwith "to be implemented"

let c2 () = failwith "to be implemented"

let c3 () = failwith "to be implemented"

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

bad:
let rec build (rand, depth) = 
if(depth = 0) then if(rand(0, 2) < 1) then buildX() else buildY() else let x = rand(0, 5) in
if( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1))) else if( x = 4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))
Error: This expression has type unit -> expr
       but an expression was expected of type expr


let rec build (rand, depth) = 
if(depth = 0) then if(rand(0, 2) < 1) then buildX() else buildY() else let x = rand(0, 5) in
if( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1))) else if( x = 4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))
Error: This expression has type expr but an expression was expected of type
         unit


let rec build (rand, depth) = 
if(depth = 0) then if(rand(0, 2) < 1) then buildX() else buildY() else let x = rand(0, 5) in
if( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1)))
Error: This expression has type expr but an expression was expected of type
         unit


let rec build (rand, depth) = 
if(depth = 0) then if(rand(0, 2) < 1) then buildX() else buildY() else let x = rand(0, 5) in
(*if( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1))) else if( x = 4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))*)
match x with
| 0 -> buildSine(build(rand, (depth - 1)))
| 1 -> buildCosine(build(rand, (depth -1)))
| 2 -> buildAverage(build(rand, (depth -1)), build(rand, (depth -1)))
| 3 -> buildTimes(build(rand, (depth -1)), build(rand, (depth -1)))
| 4 -> buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))
Error: This expression has type expr but an expression was expected of type
         unit



hw2 ???

fix:
let _ = doRandomGray(9, 0, 5)

bad:
let _ = doRandomGray(8, 0, 5)
Error: Unbound value doRandomGrey
Hint: Did you mean doRandomGray?
Error: Unbound value doRandomGrey
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value doRandomGrey
Hint: Did you mean doRandomGray?



hw1 sumList

fix:
let _ = sumList []

bad:
let _ = sumList 1
Error: This expression has type int but an expression was expected of type
         int list



hw1 ???

fix:
let _ = 12 mod 10

bad:
let _ = div(12, 10)
Error: Unbound value div


let _ = mod 12 10
Error: Syntax error


let _ = (mod 12 10)
Characters 8-9:
  let _ = (mod 12 10);;
          ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let _ = mod(12 10)
Error: Syntax error


let _ = mod(12, 10)
Error: Syntax error


let _ = 12 % 10
Error: Unbound value %


let _ = 12 % 10
Error: Unbound value %


let _ = Mod(12, 10)
Error: Unbound constructor Mod


let _ = mod(12, 10)
Error: Syntax error


let _ = mod 12 10
Error: Syntax error


let _ = Mod 12 10
Error: Syntax error



hw1 ???

fix:
let _ = 12 / 10

bad:
let _ = 12 div 10
Error: This expression has type int
       This is not a function; it cannot be applied.


let _ = 12.0 div 10
Error: This expression has type float
       This is not a function; it cannot be applied.


let _ = 12 div 10
Error: This expression has type int
       This is not a function; it cannot be applied.


let _ = 12 div 10
Error: This expression has type int
       This is not a function; it cannot be applied.


let _ = 12  10
Error: This expression has type int
       This is not a function; it cannot be applied.



hw1 sumList

fix:
let rec additivePersAndRoot xs pers =
let theSum = sumList xs in
if theSum < 10 then (pers, theSum)
else additivePersAndRoot (digits theSum) (pers + 1)

bad:
let rec additivePersAndRoot xs pers =
let theSum = sumList xs;
let nextArr = digits theSum in 
if (sumList xs) < 10 then (pers, theSum)
else additivePersAndRoot(nextArr (pers + 1))
Error: Syntax error


let _ = additivePersAndRoot [1, 1] 0
Error: This function has type int -> int * int
       It is applied to too many arguments; maybe you forgot a `;'.


let rec additivePersAndRoot xs pers =
let theSum = sumList xs
Error: Syntax error


let nextArr = digits theSum in 
if (sumList xs) < 10 then (pers, theSum)
else additivePersAndRoot(nextArr (pers + 1))
Error: Unbound value theSum


let rec additivePersAndRoot xs pers =
let theSum = sumList xs;
let nextArr = digits theSum in 
if (sumList xs) < 10 then (pers, theSum)
else additivePersAndRoot(nextArr (pers + 1))
Error: Syntax error


let rec additivePersAndRoot xs pers =
let theSum = sumList xs in
if theSum < 10 then (pers, theSum)
else additivePersAndRoot((digits theSum) (pers + 1))
Error: This expression has type int list
       This is not a function; it cannot be applied.



hw1 ???

fix:
let _ = additivePersAndRoot [1] 0

bad:
let _ = additivePersAndRoot [1, 1] 0
Error: This expression has type 'a * 'b
       but an expression was expected of type int



hw1 ???

fix:
let _ = additivePersAndRoot (2::[1]) 0

bad:
let _ = additivePersAndRoot 2::[1] 0
Error: This expression has type int but an expression was expected of type
         int list



hw1 ???

fix:
let _ = additivePersAndRoot (9::(8::(7::[6]))) 0

bad:
let _ = additivePersAndRoot ([9, 8, 7, 6]) 0
Error: This expression has type 'a * 'b * 'c * 'd
       but an expression was expected of type int


let _ = additivePersAndRoot (9::(8::(7::(6)))) 0
Error: This expression has type int but an expression was expected of type
         int list


let _ = additivePersAndRoot (9::(8::(7::(6)))) 0
Error: This expression has type int but an expression was expected of type
         int list



hw1 ???

fix:
let (l, r) = additivePersAndRoot (abs (-2)) 0

bad:
let (l, r) = additivePersAndRoot abs(-2) 0
Error: This function has type int -> int -> int * int
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 listReverse

fix:
let rec listReverse l = 
match l with
[] -> []
| r::h ->
(listReverse h) @ [r]

bad:
let rec listReverse l = 
match l with
[] -> []
| r:h ->
(listReverse h) @ [r]
Error: Syntax error


let rec listReverse l = 
match l with
[] -> []
| r:h ->
(listReverse h) @ [r]
Error: Syntax error



hw1 palindrome

fix:
let rec lasts w =
let l::h = w in
match h with
[] -> l
| r::h ->
lasts h

let palindrome w = 
let ex = explode w in
ex[0] && ex[_end]

bad:
let palindrome w = 
let ex = explode w in
ex[0] && ex[
Error: Syntax error


end
Error: Syntax error


]
Error: Syntax error


let palindrome w = 
let ex = explode w in
ex[0] && ex[_end]
Error: This expression has type char list
       This is not a function; it cannot be applied.



hw1 palindrome

fix:
let palindrome w = 
let ex = explode w in
let revex = listReverse ex in
ex = revex

bad:
let palindrome w = 
let ex = explode w in
let revex = listReverese ex in
ex = revex
Error: Unbound value listReverese
Hint: Did you mean listReverse?
Error: Unbound value listReverese
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value listReverese
Hint: Did you mean listReverse?


let palindrome w = 
let ex = explode w in
let revex = listReverese ex in
ex = revex
Error: Unbound value listReverese
Hint: Did you mean listReverse?
Error: Unbound value listReverese
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value listReverese
Hint: Did you mean listReverse?



hw1 digitsOfInt

fix:
let rec digitsOfInt n =
if n <= 0 then []
else 
digitsOfInt (n / 10) @ (n mod 10)

let _ = digitsOfInt 0

let _ = digitsOfInt (-3)

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

bad:
let rec digitsOfInt n =
if n <= 0 then []
else 
let next_tail = digitsOfInt (n / 10) in
match next_tail with
x::xs -> 
xs @ [x :: (n mod 10)]
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 digitsOfInt

fix:
let rec digitsOfInt n =
if n <= 0 then []
else (digitsOfInt (n / 10)) @ [n mod 10]

let _ = digitsOfInt 0

let _ = digitsOfInt (-3)

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

bad:
let rec digitsOfInt n =
if n <= 0 then []
else (digitsOfInt (n / 10)) :: (n mod 10)
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 ???

fix:
let rec backCons xs x =
match xs with
[] -> x
| y::ys ->
y :: x

let _ = backCons [1; 2] 3

bad:
let rec backCons xs x =
match xs with
[] -> x
| y::ys ->
(backCons ys) :: y :: x
Error: This expression has type 'a list -> 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list -> 'a list


let _ = backCons [1; 2] 3
Error: Unbound value backCons



hw1 ???

fix:
let rec backCons xs x =
match xs with
[] -> [x]
| y::ys ->
y :: [x]

let _ = backCons [1; 2] 3

bad:
let _ = backCons ([1; 2] 3)
Error: This expression has type int list
       This is not a function; it cannot be applied.


let _ = backCons [1; 2] 3
Error: This expression has type int but an expression was expected of type
         int list


let rec backCons xs x =
match xs with
[] -> x
| y::ys ->
y :: [x]
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let _ = backCons [1; 2] 3
Error: This expression has type int but an expression was expected of type
         int list



hw1 additivePersistence

fix:
let _ = additivePersistence (-9876)

bad:
let _ = additivePersistence -9860
Error: This expression has type int -> int
       but an expression was expected of type int



hw1 additivePersistence

fix:
let _ = additivePersistence (abs (-9876))

bad:
let _ = additivePersistence abs (-9876)
Error: This function has type int -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw2 ???

fix:
char_of_int(2)

bad:
int_to_char(2)
Error: Unbound value int_to_char
Hint: Did you mean int_of_char?



hw2 ???

fix:
let long_list = 
let rec assemble n l = 
if n < 1000000 then
assemble (n+1) ((n, string_of_int(n)) :: l)
else
l
in
assemble 1 []

bad:
let long_list = 
let rec assemble n l = 
if n < 1000000 then
assemble (n+1) (n, string_of_char(n)) :: l
else
l
in
assemble 1 []
Error: Unbound value string_of_char


let long_list = 
let rec assemble n l = 
if n < 1000000 then
assemble (n+1) (n, string_of_int(n)) :: l
else
l
in
assemble 1 []
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw2 assoc

fix:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

bad:
let rec assoc (d,k,l) = 
match l with
| (ki, vi)::tl  -> 
if ki = k then
vi
else
assoc (d,k,tl)
| _		-> d
Error: Unbound value assoc_tl
Hint: Did you mean assoc?



hw2 assoc

fix:
let _ = assoc (-1,123, [(123, 1)])

bad:
let _ = assoc (-1,"d", [("d", 1)])
Error: This expression has type string but an expression was expected of type
         char



hw2 assoc

fix:
let _ = assoc ([], 123, [(123, "sad"); (321, "happy")])

bad:
let _ = assoc ("null",123, [(123, "sad"; (321, "happy")])
Characters 28-29:
  let _ = assoc ("null",123, [(123, "sad", (321, "happy")]);;
                              ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let _ = assoc ("null", 123, [(123, "sad"); (321, "happy")])
Characters 28-29:
  let _ = assoc ("null",123, [(123, "sad"; (321, "happy")]);;
                              ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw2 assoc

fix:
let _ = assoc ('c', 123, [(123, "sad"); (321, "happy")])

bad:
let _ = assoc ("null", 123, [(123, "sad"); (321, "happy")])
Error: This expression has type string but an expression was expected of type
         'a list



hw2 assoc

fix:
let long_list = 
let rec assemble n l = 
if n < 10000000 then
assemble (n+1) ((string_of_int(n), n) :: l)
else
l
in
assemble 1 []

let _ = assoc(-1, "13", long_list)

bad:
let _ = assoc ("null", 123, [(123, "sad"); (321, "happy")])
Error: This expression has type string but an expression was expected of type
         char



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

bad:
let fixpoint (f,b) = wwhile ((f),b)
Error: This expression has type 'a -> bool
       but an expression was expected of type 'a -> 'a * bool
       Type bool is not compatible with type 'a * bool 



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((f b),b)

bad:
let fixpoint (f,b) = wwhile ((f (=)),b)
Error: This expression has type int -> int
       but an expression was expected of type int -> int * bool
       Type int is not compatible with type int * bool 



hw2 ???

fix:
let g f b = (b, (b = (f b)))

bad:
let g f b = (b = (f b))
Error: Syntax error: operator expected.



hw2 ???

fix:
let g b = (b, (b = (f b)))

bad:
let _ = f
Error: Unbound value f


let f x = let xx = x*x*x in (xx, xx < 100)
Error: Unbound value f



hw2 ???

fix:
let f x = x + x

let g (f, x) = let xx = f x in (xx, xx = f x)

bad:
let h = g f
Error: This expression has type 'a * bool
       but an expression was expected of type 'b -> 'b * bool


let h = g f 1
Error: This expression has type int -> int * bool
       but an expression was expected of type ('a -> 'a) * 'a



hw2 fixpoint

fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value fixpoint



hw2 fixpoint

fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let fixpoint (f,b) = wwhile ((let g h x = let xx = h x in (xx, x != xx) in g f),b)
Error: Syntax error: operator expected.



hw2 eval

fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr,0.5,0.2)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e') -> sin(pi *. eval(e', x, y))
| Cosine(e') -> cos(pi *. eval(e', x, y))
| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)
| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)
| Thresh(e1, e2, e3, e4) -> if (eval(e1, x, y) < eval(e2, x, y)) then eval(e3, x, y) else eval(e4, x, y)
Error: Syntax error



hw2 build

fix:
let rec build (rand, depth) = 
if depth <= 0 then
let bin_rand = rand(1, 2) in
if bin_rand = 1 then buildX()
else buildY()   (* bin_rand = 2 *)
else 
let exp_rand = rand(1, 5) in
let first_forced = build(rand, depth - 1) in
match exp_rand with
| 1 -> buildSine(first_forced)
| 2 -> buildCosine(first_forced)
| 3 -> buildAverage(first_forced, build(rand, depth - 1))
| 4 -> buildTimes(first_forced, build(rand, depth - 1))
| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))
| _ -> randX()

bad:
let rec build (rand, depth) = 
if depth <= 0 then
let bin_rand = rand(1, 2) in
if bin_rand = 1 then buildX()
else buildY()   (* bin_rand = 2 *)
else 
let exp_rand = rand(1, 5) in
let first_forced = build(rand, depth - 1) in
match exp_rand with
| 1 -> buildSine(first_forced)
| 2 -> buildCosine(first_forced)
| 3 -> buildAverage(first_forced, build(rand, depth - 1))
| 4 -> buildTimes(first_forced, build(rand, depth - 1))
| 5 -> buildAverage(first_forced, build(rand, depth - 1), build(rand, depth - 1))
Error: This expression has type 'a * 'b * 'c
       but an expression was expected of type expr * expr


let rec build (rand, depth) = 
if depth <= 0 then
let bin_rand = rand(1, 2) in
if bin_rand = 1 then buildX()
else buildY()   (* bin_rand = 2 *)
else 
let exp_rand = rand(1, 5) in
let first_forced = build(rand, depth - 1) in
match exp_rand with
| 1 -> buildSine(first_forced)
| 2 -> buildCosine(first_forced)
| 3 -> buildAverage(first_forced, build(rand, depth - 1))
| 4 -> buildTimes(first_forced, build(rand, depth - 1))
| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1))
Error: This expression has type 'a * 'b * 'c
       but an expression was expected of type expr * expr


let rec build (rand, depth) = 
if depth <= 0 then
let bin_rand = rand(1, 2) in
if bin_rand = 1 then buildX()
else buildY()   (* bin_rand = 2 *)
else 
let exp_rand = rand(1, 5) in
let first_forced = build(rand, depth - 1) in
match exp_rand with
| 1 -> buildSine(first_forced)
| 2 -> buildCosine(first_forced)
| 3 -> buildAverage(first_forced, build(rand, depth - 1))
| 4 -> buildTimes(first_forced, build(rand, depth - 1))
| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))
Error: This expression has type 'a * 'b * 'c
       but an expression was expected of type expr * expr * expr * expr



hw2 build

fix:
set _ = build(rand, 5)

bad:
let rec build (rand, depth) = 
if depth <= 0 then
let bin_rand = rand(1, 2) in
if bin_rand = 1 then buildX()
else buildY()   (* bin_rand = 2 *)
else 
let exp_rand = rand(1, 5) in
let first_forced = build(rand, depth - 1) in
match exp_rand with
| 1 -> buildSine(first_forced)
| 2 -> buildCosine(first_forced)
| 3 -> buildAverage(first_forced, build(rand, depth - 1))
| 4 -> buildTimes(first_forced, build(rand, depth - 1))
| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))
| _ -> randX()
Error: Unbound value randX
Hint: Did you mean rand?


let rec build (rand, depth) = 
if depth <= 0 then
let bin_rand = rand(1, 2) in
if bin_rand = 1 then buildX()
else buildY()   (* bin_rand = 2 *)
else 
let exp_rand = rand(1, 5) in
let first_forced = build(rand, depth - 1) in
match exp_rand with
| 1 -> buildSine(first_forced)
| 2 -> buildCosine(first_forced)
| 3 -> buildAverage(first_forced, build(rand, depth - 1))
| 4 -> buildTimes(first_forced, build(rand, depth - 1))
| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))
| _ -> buildX()
Error: Unbound value randX
Hint: Did you mean rand?



hw2 build

fix:
let _ = build(makeRand, 5)

let g1 () = failwith "to be implemented"

let g2 () = failwith "to be implemented"

let g3 () = failwith "to be implemented"

let c1 () = failwith "to be implemented"

let c2 () = failwith "to be implemented"

let c3 () = failwith "to be implemented"

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let emitColor (f1,f2,f3,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_c_"^name) in
let chan = open_out (fname^".ppm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P6 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z1 = f1 (x,y) in
let z2 = f2 (x,y) in
let z3 = f3 (x,y) in

(* Convert the result to a grayscale value *)
let iz1 = toIntensity(z1) in
let iz2 = toIntensity(z2) in
let iz3 = toIntensity(z3) in

(* Emit one byte per color for this pixel *)
output_char chan (char_of_int iz1);
output_char chan (char_of_int iz2);
output_char chan (char_of_int iz3);
)) in  
close_out chan;
ignore(Sys.command ("convert "^fname^".ppm  "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".ppm"))

let doRandomColor (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand (seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e1 = build (g, depth) in
let e2 = build (g, depth) in
let e3 = build (g, depth) in

let _ = Format.printf "red   = %s \n" (exprToString e1) in
let _ = Format.printf "green = %s \n" (exprToString e2) in
let _ = Format.printf "blue  = %s \n" (exprToString e3) in

let f1 = eval_fn e1 in
let f2 = eval_fn e2 in
let f3 = eval_fn e3 in

(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitColor (f1,f2,f3,n,name)

type test = unit -> string

let key = ""

let prefix130 = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)); ErrorCode "exception")

let explode s = 
let rec _exp i = 
if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in
_exp 0

let implode cs = 
String.concat "" (List.map (String.make 1) cs)

let drop_paren s = 
implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))

let eq_real p (r1,r2) = 
(r1 -. r2) < p || (r2 -. r1) < p

let scoreMsg () = 
Format.sprintf "Results: Score/Max = %d / %d \n" !score !max

bad:
let _ = build(rand, 5)
Error: Syntax error


let _ = build(makeRand, 5)
Error: Unbound value rand
Hint: Did you mean land?



hw2 ???

fix:
let _ = acos(pi)

bad:
let _ = acos(1.0)
Error: This expression has type int but an expression was expected of type
         float



hw2 ???

fix:
let _ = acos(0)

bad:
let _ = acos(1.0)
Error: This expression has type int but an expression was expected of type
         float



hw2 build

fix:
let pi = 4.0 *. atan 1.0

let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e') -> sin(pi *. eval(e', x, y))
| Cosine(e') -> cos(pi *. eval(e', x, y))
| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)
| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)
| Thresh(e1, e2, e3, e4) -> 
if (eval(e1, x, y) < eval(e2, x, y)) then 
eval(e3, x, y) 
else 
eval(e4, x, y)
| Accossin(e1, e2) -> (acos(eval(e1)) *. asin(eval(e2))) *. 2.0 /. (pi *. pi)

let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv

let rec build (rand, depth) = 
if depth <= 0 then
let bin_rand = rand(0, 2) in
if bin_rand = 0 then buildX()
else buildY()   (* bin_rand = 2 *)
else 
let exp_rand = rand(0, 6) in
let first_forced = build(rand, depth - 1) in
match exp_rand with
| 0 -> buildSine(first_forced)
| 1 -> buildCosine(first_forced)
| 2 -> buildAverage(first_forced, build(rand, depth - 1))
| 3 -> buildTimes(first_forced, build(rand, depth - 1))
| 4 -> buildThresh(first_forced, build(rand, depth - 1), 
build(rand, depth - 1), build(rand, depth - 1))
| _ -> buildAcossin(first_forced, build(rand, depth - 1))

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

bad:
let buildAcossin(e1,e2)		   = Acossin(e1,e2)
Error: Unbound value buildAcossin



hw2 eval

fix:
let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e') -> sin(pi *. eval(e', x, y))
| Cosine(e') -> cos(pi *. eval(e', x, y))
| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)
| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)
| Thresh(e1, e2, e3, e4) -> 
if (eval(e1, x, y) < eval(e2, x, y)) then 
eval(e3, x, y) 
else 
eval(e4, x, y)
| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)
Error: This expression has type expr but an expression was expected of type
         expr * float * float



hw2 ???

fix:
doRandomGray(1, 111, 1005)

bad:
doRandomGray(1, 111, 1005)
Error: Unbound value doRandomGray


doRandomGray(8, 111, 1005)
Error: Unbound value doRandomGray


doRandomGray(3, 111, 1005)
Error: Unbound value doRandomGray


doRandomGray(4, 111, 1005)
Error: Unbound value doRandomGray


doRandomGray(5, 111, 1005)
Error: Unbound value doRandomGray


doRandomGray(10, 111, 1005)
Error: Unbound value doRandomGray



hw2 ???

fix:
doRandomGray(12, 6543, 35241)

bad:
doRandomGray(2, 111, 1005)
Error: Unbound value doRandomGray


doRandomGray(6, 1315, 666)
Error: Unbound value doRandomGray


doRandomGray(13, 6543, 35241)
Error: Unbound value doRandomGray



hw3 pipe

fix:
let pipe fs = 
let f a x = (+) (x a) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (+) (x a) in
let base = 0 in
List.fold_left f base fs
Error: This expression has type int but an expression was expected of type
         int -> int


let pipe fs = 
let f a x = (+) (a x) in
let base = 0 in
List.fold_left f base fs
Error: This expression has type int but an expression was expected of type
         int -> int



hw3 pipe

fix:
let pipe fs = 
let f a x = a in
let base =  0 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3
Error: This expression has type int -> int
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs = 
let f a x = (fun a -> a) in
let base =  (fun x -> x) in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This function has type 'a list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let pipe fs = 
let f a x = (fun a -> a) in
let base =  0 in
List.fold_left f base fs
Error: This expression has type int but an expression was expected of type
         'a -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base =  0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun r s -> a) in
let base =  (fun r s -> 0) in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'c -> 'd -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base =  0 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base =  (fun x -> []) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  (fun) in
List.fold_left f base fs
Error: Syntax error: operator expected.


let pipe fs = 
let f a x = x a in
let base =  (fun n -> ) in
List.fold_left f base fs
Error: Syntax error: operator expected.



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base =  (fun n -> n) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  (fun x -> ) in
List.fold_left f base fs
Error: Syntax error: operator expected.


let pipe fs = 
let f a x = x a in
let base =  (fun -> y) in
List.fold_left f base fs
Error: Syntax error: operator expected.


let pipe fs = 
let f a x = x a in
let base =  (fun y) in
List.fold_left f base fs
Error: Syntax error: operator expected.


let pipe fs = 
let f a x = a x in
let base =  (fun n -> n) in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = (fun y -> x a) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun y -> x a) in
let base =  in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = (fun y -> x a) in
let base = 0 in
List.fold_left f base fs
Error: This expression has type int but an expression was expected of type
         'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = (fun _ -> x a) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun -> x a) in
let base = (fun y -> y) in
List.fold_left f base fs
Error: Syntax error: operator expected.



hw3 pipe

fix:
let pipe fs = 
let f a x = (fun _ -> x a) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun _ -> x a) in
let base = (fun _ -> _) in
List.fold_left f base fs
Error: Syntax error: operator expected.



hw3 pipe

fix:
let pipe fs = 
let f a x = (fun _ -> x a) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun _ -> x a) in
let base = [] in
List.fold_left f base fs
Error: This expression has type 'a list
       but an expression was expected of type 'b -> 'c


let pipe fs = 
let f a x = (fun _ -> x a) in
let base = 0 in
List.fold_left f base fs
Error: This expression has type int but an expression was expected of type
         'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = (fun _ -> x) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun _ -> a) in
let base = (fun y -> y) in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'c -> 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'c -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x = (fun y -> x y) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         int -> int



hw3 ???

fix:
fun x -> 3

bad:
fun -> 3
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = (let myfun = x a) in
let base = (fun y -> y) in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

bad:
let pipe fs = 
let f a x = (let rec = x a) in
let base = (fun y -> y) in
List.fold_left f base fs
Error: Syntax error: operator expected.


let pipe fs = 
let f a x = (let myfun = x a) in
let base = (fun y -> y) in
List.fold_left f base fs
Error: Syntax error: operator expected.


let pipe fs = 
let f a x = (let myfun _ = x a) in
let base = (fun y -> y) in
List.fold_left f base fs
Error: Syntax error: operator expected.


let pipe fs = 
let f a x = (let myfun = (x a)) in
let base = (fun y -> y) in
List.fold_left f base fs
Error: Syntax error: operator expected.


let pipe fs = 
let f a x = (let myfun x a = x a) in
let base = (fun y -> y) in
List.fold_left f base fs
Error: Syntax error: operator expected.


let pipe fs = 
let f a x = (let myfun x a -> x a) in
let base = (fun y -> y) in
List.fold_left f base fs
Error: Syntax error: operator expected.


let pipe fs = 
let f a x = (let myfun = x a) in
let base = (fun y -> y) in
List.fold_left f base fs
Error: Syntax error: operator expected.



hw3 pipe

fix:
let pipe fs = 
let f a x = (let myfun = x a in myfun) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (let rec myfun = x a) in
let base = (fun y -> y) in
List.fold_left f base fs
Error: Syntax error: operator expected.



hw3 pipe

fix:
let pipe fs = 
let f a x = (x a) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (a x) in
let base = (fun y -> y) in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = (fun y -> x) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun y -> (y a)) in
let base = (fun y -> y) in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside ('a -> 'c) -> 'c


let pipe fs = 
let f a x = (fun y -> a) in
let base = (fun y -> y) in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'c -> 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'c -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x = (fun _ -> (x a)) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun y -> x -> (x a)) in
let base = (fun y -> y) in
List.fold_left f base fs
Characters 27-28:
  let f a x = (fun y -> x -> (x a)) in
              ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let pipe fs = 
let f a x = (fun _ x -> (x a)) in
let base = (fun y -> y) in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'c -> ('a -> 'd) -> 'd
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'c -> ('a -> 'd) -> 'd



hw3 pipe

fix:
let pipe fs = 
let f a x = (x a) in
let base = (fun _ -> 0) in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let pipe fs = 
let f a x = (x a) in
let base = (fun) in
List.fold_left f base fs
Error: Syntax error: operator expected.


let pipe fs = 
let f a x = (x a) in
let base = (fun _ -> base) in
List.fold_left f base fs
Error: Unbound value base



hw3 pipe

fix:
let pipe fs = 
let f a x = (x a) in
let base = (fun y -> y ) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (x a) in
let base = (fun y -> y -> 0) in
List.fold_left f base fs
Characters 47-48:
  let base = (fun y -> y -> 0) in
             ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw3 pipe

fix:
let _ = pipe [] 3

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         int -> int


let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         int -> int


let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         int -> int



hw3 pipe

fix:
let pipe fs = 
let f a x = (x (x a)) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (x (a a)) in
let base = (fun y -> y) in
List.fold_left f base fs
Error: This expression has type 'a -> 'b
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'b


let pipe fs = 
let f a x = (x (a x)) in
let base = (fun y -> y) in
List.fold_left f base fs
Error: This expression has type (('a -> 'b) -> 'a) -> ('a -> 'b) -> 'b
       but an expression was expected of type
         (('a -> 'b) -> 'a) -> ('a -> 'b) -> ('a -> 'b) -> 'a
       The type variable 'b occurs inside ('a -> 'b) -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x = (x (a)) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (x (a)) in
let base = (fn y -> y) in
List.fold_left f base fs
Characters 49-50:
  let base = (fn y -> y) in
             ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw3 pipe

fix:
let pipe fs = 
let f a x = (x a) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs = 
let f a x = (x a) in
let base = (f) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (x a) in
let base = (fun _ -> y) in
List.fold_left f base fs
Error: Unbound value y


let pipe fs = 
let f a x = (x a) in
let base = (f a) in
List.fold_left f base fs
Error: Unbound value a



hw3 pipe

fix:
let pipe fs = 
let f a x = (x a) in
let base = (fun y -> y) in
List.fold_left f base fs

let _ = pipe []

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)]
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs = 
let f a x = (fun _ -> x a) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs = 
let f a x = (fun z -> a z) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun z -> z a) in
let base = (fun y -> y) in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside ('a -> 'c) -> 'c



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x a in
let base = "" in
let l = [fun x -> x ^ sep] in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x a in
let base = "" in
let l = (^) sep in
List.fold_left f base l
Error: This expression has type string -> string
       but an expression was expected of type (string -> string) list


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x a in
let base = "" in
let l = fun x -> x ^ sep in
List.fold_left f base l
Error: This expression has type string -> string
       but an expression was expected of type (string -> string) list



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x ^ a in
let base = "" in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x ^ a in
let base = "" in
let l = [fun x -> x ^ sep] in
List.fold_left f base l
Error: This expression has type (string -> string) list
       but an expression was expected of type string list
       Type string -> string is not compatible with type string 



hw3 stringOfList

fix:
let stringOfList f l = 
match l with
| []    -> "[]"
| x::xs ->
let g a x = a ^ "; " ^ (f x) in
let base = f x in
List.fold_left g base xs

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: This expression has type int but an expression was expected of type
         string


let stringOfList f l = 
match l with
| []    -> "[]"
| x::xs ->
let g a x = a ^ "; " ^ (f x) in
let base = f x in
List.fold_left f base xs
Error: This expression has type 'a -> string
       but an expression was expected of type 'a -> 'b -> 'a
       Type string is not compatible with type 'b -> 'a 



hw3 clone

fix:
let rec clone x n =
let rec clone_RT acc n =
if n <= 0 then 
acc
else 
clone_RT (x::acc) (n-1)
in
clone_RT [] n

bad:
let rec clone x n =
let rec clone_RT acc n =
if n <= 0 then acc
else clone (x::acc) (n-1)
in
clone_RT [] n
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec clone x n =
let rec clone_RT acc n =
if n <= 0 then 
acc
else 
clone (x::acc) (n-1)
in
clone_RT [] n
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw3 padZero

fix:
let padZero l1 l2 = 
let len1 = List.length l1 in
let len2 = List.length l2 in
let diff = len1 - len2 in
if diff < 0 then
(List.append (clone 0 (-diff)) l1, l2)
else
(List.append (clone 0 diff) l2, l1)

bad:
let padZero l1 l2 = 
let len1 = List.length l1 in
let len2 = List.length l2 in
let diff = len1 - len2 in
if diff < 0 then
List.append (List.append ((clone 0 (-diff)), len1), len2)
else
List.append (List.append (clone 0 (diff), len2), len1)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let padZero l1 l2 = 
let len1 = List.length l1 in
let len2 = List.length l2 in
let diff = len1 - len2 in
if diff < 0 then
List.append (List.append ((clone 0 (-diff)), len1), len2)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


)
else
List.append (List.append (clone 0 (diff), len2), len1)
Error: Syntax error


let padZero l1 l2 = 
let len1 = List.length l1 in
let len2 = List.length l2 in
let diff = len1 - len2 in
if diff < 0 then
(List.append (clone 0 (-diff), len1), len2)
else
(List.append (clone 0 (diff), len2), len1)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let padZero l1 l2 = 
let len1 = List.length l1 in
let len2 = List.length l2 in
let diff = len1 - len2 in
if diff < 0 then
(List.append (clone 0 (-diff)) len1, len2)
else
(List.append (clone 0 diff) len2, len1)
Error: This expression has type int but an expression was expected of type
         int list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = ([0], [0]) in
let base = ([0], [0]) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 0 in
let base = 0 in
let args = (l1, l1) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'a
       but an expression was expected of type 'b list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (1,2) in
let base = 0 in
let args = (l1, l1) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         int * int


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (0, 0) in
let base = (0, 0) in
let args = (l1, l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (0, 0) in
let base = (0, 0) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         int list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (0, []) in
let base = (0, []) in
let args = (clone 0 (List.length l1)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = ([0], [0]) in
let base = ([0], [0]) in
let args = (l1, 2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * int
       but an expression was expected of type 'b list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = ([0], [0]) in
let base = ([0], [0]) in
let args = (l1, l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = ([0], [0]) in
let base = (0, 0) in
let args = (0, clone 0 List.length l1) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This function has type 'a -> int -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = ([0], [0]) in
let base = (0, []) in
let args = (0, clone 0 List.length l1) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This function has type 'a -> int -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (0, []) in
let base = (0, []) in
let args = (0, clone 0 List.length l1) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This function has type 'a -> int -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (0, []) in
let base = (0, []) in
let args = (0, clone 0 (List.length l1)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int * int list
       but an expression was expected of type 'a list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
(t, (h + x)::y)
in
let base = (List.rev l1, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
let sum = h + x in
(t, sum::y)
Error: Syntax error


let base = (List.reverse l1, []) in
let args = List.reverse l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
let sum = h + x in
(t, sum::y)
Error: Syntax error


let base = (List.reverse l1, []) in
let args = List.reverse l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
let sum =  in
(t, (h + x)::y) in
let base = (List.reverse l1, []) in
let args = List.reverse l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
let sum = 
(t, (h + x)::y) in
let base = (List.reverse l1, []) in
let args = List.reverse l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
let sum = 
(t, (h + x)::y) in
let base = (List.reverse l1, []) in
let args = List.reverse l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
(t, (h + x)::y)
in
let base = (List.reverse l1, []) in
let args = List.reverse l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value List.reverse


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| ([], y) -> ([], y) 
| (h::t, y) -> 
(t, (h + x)::y)
in
let base = (List.rev l1, []) in
let args = List.reverse l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value List.reverse



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([], _), y) -> (([], 0), y) 
| ((h::t, carry), y) -> 
let sum = h + x in
((t, sum / 10), (sum mod 10)::y)
in
let base = ((List.rev l1, 0), []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([], _), y) -> (([], 0), y) 
| ((h::t, carry), y) -> 
let sum = h + x in
((t, sum / 10), (sum mod 10)::y)
in
let base = ((List.rev l1, carry), []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value carry



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([], _), y) -> (([], 0), y) 
| ((h::t, carry), y) -> 
let sum = h + x + carry in
((t, sum / 10), (sum mod 10)::y)
in
let base = ((0::(List.rev l1), 0), []) in
let args = 0::(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([], _), y) -> (([], 0), y) 
| ((h::t, carry), y) -> 
let sum = h + x + carry in
((t, sum / 10), (sum mod 10)::y)
in
let base = (0::(List.rev l1, 0), []) in
let args = 0::(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([], _), y) -> (([], 0), y) 
| ((h::t, carry), y) -> 
let sum = h + x + carry in
((t, sum / 10), (sum mod 10)::y)
in
let base = (0::(List.rev l1), 0), []
Error: Syntax error



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([], _), y) -> (([], 0), y) 
| ((h::t, carry), y) -> 
let sum = h + x + carry in
((t, sum / 10), (sum mod 10)::y)
in
let base = ((List.rev (0::l1), 0), []) in
let args = List.rev (0::l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([], _), y) -> (([], 0), y) 
| ((h::t, carry), y) -> 
let sum = h + x + carry in
((t, sum / 10), (sum mod 10)::y)
in
let base = ((List.rev 0::l1, 0), []) in
let args = List.rev 0::l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a list



hw3 bigAdd

fix:
let _ = bigAdd [-1] [-2; -3]

bad:
let _ = bigAdd [-1] [-2, -3]
Error: This expression has type 'a * 'b
       but an expression was expected of type int



hw3 mulByDigit

fix:
let rec mulByDigit i l = 
let rec mulByDigit_RT i acc =
if i = 1 then acc
else mulByDigit_RT (i-1) (bigAdd acc l)
in
mulByDigit_RT i []

bad:
let rec mulByDigit i l = 
let mulByDigit_RT i acc =
if i = 1 then acc
else mulByDigit_RT (i-1) (bigAdd acc l)
in
mulByDigit_RT i []
Error: Unbound value mulByDigit_RT
Hint: Did you mean mulByDigit?



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = match a with
| (i, acc) -> 
let digmul = mulByDigit (i * x) l2 in
(i * 10, bigAdd digmul acc)
| _ -> failwith "wtf" in
let base = (1, []) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = match a with
| (i, acc) -> ([], acc) 
| _ -> failwith "wtf" in
let base = (0, []) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int * 'a list
       but an expression was expected of type 'b list * 'c
       Type int is not compatible with type 'b list 



hw3 sepConcat

fix:
let _ = sepConcat "X" ["hello"]

(sepConcat "; ")

bad:
let _ = sepConcat "X" ["hello"]


(sepConcat "; ")
Error: This function has type string -> string list -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 ???

fix:
List.map string_of_int

bad:
List.map string_of_in
Error: Unbound value string_of_in
Hint: Did you mean string_of_int?



hw3 stringOfList

fix:
let stringOfList f l = 
"[" ^ (stringOfList f (List.map f l)) ^ "]"

bad:
let stringOfList f l = 
"[" ^ List map f (List.map f l) ^ "]"
Error: Syntax error


let stringOfList f l = 
"[" ^ stringOfList (List.map f l) ^ "]"
Error: This expression has type 'a list
       but an expression was expected of type 'b -> string



hw3 sepConcat

fix:
let _ = sepConcat ", " ["foo";"bar";"baz"]

bad:
sepConcat "; " [[1;0];[2];[3]]
Error: This expression has type 'a list
       but an expression was expected of type string


List.map string_of_int [[1;0];[2];[3]]
Error: This expression has type 'a list
       but an expression was expected of type int


sepConcat "; " [[1;0];[2];[3]]
Error: This expression has type 'a list
       but an expression was expected of type string



hw3 ???

fix:
List.map

bad:
List.map f l
Error: Unbound value f


let R f l =
List.map f l
Error: Syntax error


let R f l =
List.map f l
Error: Syntax error


let R f l =
List.map f l
Error: Syntax error


let Rr f l =
List.map f l
Error: Syntax error


let Rr f l =
List.map f
Error: Syntax error



hw3 stringOfList

fix:
let stringOfList f l = (List.map f l);

bad:
let stringOfList f l = "[" ^ (List.map f l) ^ "]"
Error: This expression has type 'a list
       but an expression was expected of type string



hw3 bigMul

fix:
let _ = bigMul [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9] []

bad:
let _ = bigMul [1] [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9]
Error: Unbound value bigMul


let _ = bigMul [10] [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9]
Error: Unbound value bigMul


let _ = bigMul [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9] [10]
Error: Unbound value bigMul



hw3 bigMul

fix:
let sqsum xs = 
let f a x = a + x * x in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = (fun z -> x (a z)) in
let base = (fun y -> y) in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 10

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 10

let _ = pipe [(fun x -> x ^ " is the best");(fun x-> x ^ " student. "); (fun x -> x ^ x)] "Idan"

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "; " ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = "[" ^ (sepConcat "; " (List.map f l)) ^ "]"

let _ = stringOfList string_of_int []

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n =
let rec clone_TR acc n =
if n <= 0 then 
acc
else 
clone_TR (x::acc) (n-1)
in
clone_TR [] n

let _ = clone [] 2

let _ = clone 1 10000

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let _ = clone clone (3)

let padZero l1 l2 = 
let len1 = List.length l1 in
let len2 = List.length l2 in
let diff = len1 - len2 in
if diff < 0 then
(List.append (clone 0 (-diff)) l1, l2)
else
(l1, List.append (clone 0 diff) l2)

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

let rec removeZero l = 
match l with 
| [] -> []
| x::xs -> 
if x = 0 then
removeZero xs
else
l

let _ = removeZero [0;0;0;1;0;0;2]

let _ = removeZero [9;9]

let _ = removeZero [0;0;0;0]

let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([], _), y) -> (([], 0), y) 
| ((h::t, carry), y) -> 
let sum = h + x + carry in
((t, sum / 10), (sum mod 10)::y)
in
let base = ((List.rev (0::l1), 0), []) in
let args = List.rev (0::l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [] []

let _ = bigAdd [0] []

let _ = bigAdd [] [0]

let _ = bigAdd [1] []

let _ = bigAdd [] [1]

let _ = bigAdd [-1] [1]

let _ = bigAdd [-1] [-2; -3]

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [1;0;0;2] [4;4]

let _ = bigAdd [9;9;9;9] [9;9;9]

let _ = bigAdd (clone 1 100000) (clone 1 100000)

let rec mulByDigit i l = 
let rec mulByDigit_RT i acc =
if i = 0 then acc
else mulByDigit_RT (i-1) (bigAdd acc l)
in
mulByDigit_RT i []

let _ = mulByDigit 9 [9;9;9;9]

let bigMul l1 l2 = 
let f a x = 
let (i, acc) = a in
let digmul = mulByDigit (i * x) l2 in
(i * 10, bigAdd digmul acc) in
let base = (1, []) in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res

let _ = bigMul [9;9;9;9] [9;9;9;9]

let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

let _ = bigMul [1;2] [3;4]

let _ = bigMul [1;2;3] [9;9]

let _ = bigMul [4;1;3] [4;2;4;5;0;8;9]

let _ = bigMul [] [0]

let _ = bigMul [0] []

let _ = bigMul [] []

let _ = bigMul [1;2;3] [0]

let _ = bigMul [0] [2;3;4]

let _ = bigMul [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9] []

let _ = bigMul [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9] [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9]

let _ = bigMul [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9;1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9;1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9] [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9;1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9;1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9;1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9]

bad:
let _ = mulByDigit 9 [9;9;9;9]
Error: Unbound value mulByDigit


let bigMul l1 l2 = 
let f a x = 
let (i, acc) = a in
let digmul = mulByDigit (i * x) l2 in
(i * 10, bigAdd digmul acc) in
let base = (1, []) in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value mulByDigit


let _ = bigMul [9;9;9;9] [9;9;9;9]
Error: Unbound value mulByDigit


let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]
Error: Unbound value bigMul


let _ = bigMul [1;2] [3;4]
Error: Unbound value bigMul


let _ = bigMul [1;2;3] [9;9]
Error: Unbound value bigMul


let _ = bigMul [4;1;3] [4;2;4;5;0;8;9]
Error: Unbound value bigMul


let _ = bigMul [] [0]
Error: Unbound value bigMul


let _ = bigMul [0] []
Error: Unbound value bigMul


let _ = bigMul [] []
Error: Unbound value bigMul


let _ = bigMul [1;2;3] [0]
Error: Unbound value bigMul


let _ = bigMul [0] [2;3;4]
Error: Unbound value bigMul


let _ = bigMul [1;9;4;5;2;3] []
Error: Unbound value bigMul


let _ = bigMul [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6] []
Error: Unbound value bigMul



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n <= 0 then []
else n mod 10 :: digitsOfInt (n / 10)

bad:
let rec digitsOfInt n myList = 
if (n <= 0)
then myList
else digitsOfInt (n/10)  (n mod 10 ::myList)
match n with 
| 0 -> [0]
| _ -> digitsOfInt n []
Error: Syntax error


let rec digitsOfInt n myList = match n with
| n <= 0 -> []
| _      -> n mod 10 :: digitsOfInt (n / 10)
Error: Syntax error


let rec digitsOfInt n = match n with
| n <= 0 -> []
| _      -> n mod 10 :: digitsOfInt (n / 10)
Error: Syntax error



hw1 additivePersistence

fix:
let rec additivePersistence n = 
if (n < 10) 
then 0
else 
let myList = digits n in
let num = sumList myList in
num + additivePersistence num

bad:
let rec additivePersistence n = 
if (n < 10) 
then 0
else 
let myList = digits n in
let num = sumList n in
num + additivePersistence num
Error: This expression has type int but an expression was expected of type
         int list



hw1 additivePersistence

fix:
let rec additivePersistence n = 
if (n < 10) 
then counter
else 
let myList = digits n in
let num = sumList myList in
num + additivePersistence num

bad:
let rec additivePersistence n = 
if (n < 10) 
then counter
else 
let myList = digits n in
let num = sumList myList in
let counter = counter + 1 
num + additivePersistence num
Error: Syntax error


let rec additivePersistence n = 
if (n < 10) 
then counter
else 
let myList = digits n in
let num = sumList myList in
let counter = counter + 1
Error: Syntax error


let rec additivePersistence n = 
if (n < 10) 
then counter
else 
let myList = digits n in
let num = sumList myList in
let counter = counter + 1
Error: Syntax error



hw1 additivePersistence

fix:
let rec additivePersistence n = 
if (n < 10) 
then 0
else 
let myList = digits n in
let num = sumList myList in
num + additivePersistence num

bad:
let rec additivePersistence n = 
if (n < 10) 
then counter
else 
let myList = digits n in
let num = sumList myList in
let counter = 0 in
counter = counter + 1
num + additivePersistence num
Error: This expression has type int
       This is not a function; it cannot be applied.


let rec additivePersistence n = 
if (n < 10) 
then 
else 
let myList = digits n in
let num = sumList myList in
num + additivePersistence num
Error: Syntax error



hw1 additivePersistence

fix:
let rec additivePersistence n = 
if (n < 10) 
then []
else 
let myList = digits n in
(*let num = sumList myList in*)
myList

bad:
let rec additivePersistence n = 
if (n < 10) 
then []
else 
let myList = digits n in
let num = sumList myList in
num + additivePersistence num
Error: This expression has type 'a list
       but an expression was expected of type int



hw1 additivePersistence

fix:
let rec additivePersistence n = 
if (n < 10) 
then 0
else 
1 + additivePersistence (sumList (digits n))

bad:
let rec additivePersistence n = 
if (n < 10) 
then 0
else 
1 + additivePersistence sumList (digits n)
Error: This function has type int -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 digitalRoot

fix:
let rec digitalRoot n = 
if (n < 10)
then n
else
additivePersistence ( sumList (digits n))

bad:
let rec digitalRoot n = 
if (n < 10)
then digRoot = n
else
additivePersistence ( sumList (digits n))
Error: Unbound value digRoot
Error: Unbound value sumList
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value digRoot


let rec digitalRoot n = 
if (n < 10)
then root = n
else
additivePersistence ( sumList (digits n))
Error: Unbound value root
Error: Unbound value sumList
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value root


let rec digitalRoot n = 
if (n < 10)
then root = n
else
additivePersistence ( sumList (digits n))
Error: Unbound value root
Error: Unbound value sumList
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value root



hw1 listReverse

fix:
let rec listReverse l = match l with 
| [] -> []
| h::t -> []

let _ = "a" :: "b" :: "c"

bad:
let rec listReverse l = match l with 
| [] -> []
| h::t ->
Error: Syntax error


let _ = "a" :: "b" :: "c"
Error: This expression has type string but an expression was expected of type
         string list


let rec listReverse l = match l with 
| [] -> []
| h::t -> 0
Error: This expression has type int but an expression was expected of type
         'a list


let _ = "a" :: "b" :: "c"
Error: This expression has type string but an expression was expected of type
         string list



hw1 ???

fix:
let _ = "a" :: "b" :: "c" :: ["d"]

bad:
let _ = "a" :: "b" :: ["c"] :: ["d"]
Error: This expression has type 'a list
       but an expression was expected of type string



hw1 ???

fix:
let rec append list1 list2 = match list1 with 
| [] -> []
| h::t -> h :: list2

bad:
let rec append list1 list2 = match list1 with 
| [] -> []
| h::t -> h :: append list2
Error: This expression has type 'a list -> 'a list
       but an expression was expected of type 'a list



hw1 ???

fix:
let _ = append ["a"] ["b"]

bad:
let _ = append [a] [b]
Error: Unbound value a



hw1 listReverse

fix:
let rec listReverse l = match l with 
| [] -> []
| h::[] -> l
| h::t -> listReverse (append t [h] )

bad:
let rec listReverse l = match l with 
| [] -> []
| h::[] -> l
| h::t -> listReverse ( append ( t [h] ) )
Error: This expression has type 'a list
       This is not a function; it cannot be applied.


let rec listReverse l = match l with 
| [] -> []
| h::[] -> l
| h::t -> listReverse append ( t [h] )
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.


let rec listReverse l = match l with 
| [] -> []
| h::[] -> l
| h::t -> listReverse (append ( t [h] ))
Error: This expression has type 'a list
       This is not a function; it cannot be applied.



hw1 ???

fix:
let append list1 list2 = match list1 with 
| [] -> list2
| h::t -> h :: append t list2

bad:
let append list1 list2 = match list1 with 
| [] -> list2
| h::t -> h :: append [] t
Error: Unbound value listReverse



hw1 listReverse

fix:
let rec listReverse l = match l with 
| [] -> l
| h::t -> listReverse (append t [h])

bad:
let rec listReverse l = match l with 
| [] -> []
| h::t -> append ( t [h])
Error: Unbound value append


let rec listReverse l = match l with 
| [] -> []
| h::t -> append t [h]
Error: Unbound value append


let _ = listReverse [1; 2; 3; 4]
Error: Unbound value append


let rec listReverse l = match l with 
| [] -> []
| h::t -> listReverse (append t [h])
Error: Unbound value listReverse


let _ = listReverse [1; 2; 3; 4]
Error: Unbound value append



hw1 listReverse

fix:
let rec listReverse l = match l with 
| [] -> l
| h::t -> append t [h]

let _ = listReverse [1; 2; 3; 4]

bad:
let _ = listReverse [1; 2; 3; 4]
Error: Unbound value append



hw1 listReverse

fix:
let rec digitsOfInt n = 
if n <= 0 then []
else 
listReverse ([(n mod 10)] append digitsOfInt (n/10) )

bad:
let _ = listReverse ["a"; "b"; "c"; "d"]
Error: Unbound value listReverse


let rec digitsOfInt n = 
if n <= 0 then []
else 
listReverse ([n mod 10] append digitsOfInt (n/10) )
Error: Unbound value listReverse


let _ = digitsOfInt 3124
Error: Unbound value listReverse



hw1 listReverse

fix:
let rec digitsOfInt n = 
if n <= 0 then []
else 
listReverse (append [n mod 10] (digitsOfInt (n/10)) )

let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n <= 0 then []
else 
listReverse (append [n mod 10] digitsOfInt (n/10) )
Error: Unbound value listReverse


let _ = digitsOfInt 3124
Error: Unbound value listReverse



hw1 palindrome

fix:
let _ = palindrome "a"

let _ = palindrome "malayalam"

let _ = palindrome "myxomatosis"

type test = unit -> string

let key        = ""

let prefix130  = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)); ErrorCode "exception")

let scoreMsg () = 
Printf.sprintf "Results: Score/Max = %d / %d \n" !score !max

bad:
let palindrome w = match w with 
| "" -> true
| _ -> 
let myString = explode w in
let reverseString = listReverse myString in
if myString = reverseString
then true
else false
Error: Unbound value reverseList


let _ = palindrome "malayalam"
Error: Unbound value listReverse


let _ = palindrome "myxomatosis"
Error: Unbound value palindrome


let _ = palindrome ""
Error: Unbound value palindrome


let _ = palindrome "a"
Error: Unbound value palindrome



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)

bad:
let fixpoint (f,b) = wwhile (fun x -> let b = (f x) in (b, b != x),b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a



hw2 exprToString

fix:
let rec exprToString e = 
let expr = exprToString in
match e with
| VarX		  -> "x"
| VarY		  -> "y"
| Sine(t)	  -> ("sin(pi*"^(expr t)^")")
| Cosine(t)	  -> ("cos(pi*"^(expr t)^")")
| Average(s, t) -> ("(("^(expr s)^"+"^(expr t)^")/2)" )
| Times(s, t) -> ((expr s)^"*"^(expr t))
| Thresh(s, t, u, v) -> ("("^(expr s)^"<"^(expr t)^"?"^(expr u)^":"^(expr v)^")")

bad:
let rec exprToString e = 
let expr = exprToString in
match e with
| VarX		  -> "x"
| VarY		  -> "y"
| Sine(t)	  -> ("sin(pi*"^(expr t)^")")
| Cosine(t)	  -> ("cos(pi*"^(expr t)^")")
| Average(s, t) -> ("(("^(ex s)^"+"^(ex t)^")/2)" )
| Times(s, t) -> ((ex s)^"*"^(ex t))
| Thresh(s, t, u, v) -> ("("^(ex s)^"<"^(ex t)^"?"^(ex u)^":"^(ex v)^")")
Error: Unbound value ex


let rec exprToString e = 
let expr = exprToString in
match e with
| VarX		  -> "x"
| VarY		  -> "y"
| Sine(t)	  -> ("sin(pi*"^(expr t)^")")
| Cosine(t)	  -> ("cos(pi*"^(expr t)^")")
| Average(s, t) -> ("(("^(expr s)^"+"^(expr t)^")/2)" )
| Times(s, t) -> ((ex s)^"*"^(expr t))
| Thresh(s, t, u, v) -> ("("^(expr s)^"<"^(expr t)^"?"^(expr u)^":"^(expr v)^")")
Error: Unbound value ex



hw2 exprToString

fix:
let rec exprToString e = 
let expr = exprToString in
match e with
| VarX		      -> "x"
| VarY		      -> "y"
| Sine a	      -> ("sin(pi*"^(expr a)^")")
| Cosine a	      -> ("cos(pi*"^(expr a)^")")
| Average (a, b)      -> ("(("^(expr a)^"+"^(expr b)^")/2)" )
| Times (a, b)	      -> ((expr a)^"*"^(expr b))
| Thresh (a, b, c, d) -> ("("^(expr a)^"<"^(expr b)^"?"^(expr c)^":"^(expr d)^")")

bad:
let rec exprToString e = 
let expr = exprToString in
match e with
| VarX		      -> "x"
| VarY		      -> "y"
| Sine a	      -> ("sin(pi*"^(expr a)^")")
| Cosine a	      -> ("cos(pi*"^(expr a)^")")
| Average a, b        -> ("(("^(expr a)^"+"^(expr b)^")/2)" )
| Times a, b	      -> ((expr a)^"*"^(expr b))
| Thresh a, b, c, d   -> ("("^(expr a)^"<"^(expr b)^"?"^(expr c)^":"^(expr d)^")")
Error: This pattern matches values of type 'a * 'b
       but a pattern was expected which matches values of type expr



hw2 wwhile

fix:
let rec wwhile (f,b) = 
match (f, b) with
| (b', y) -> 
if y = false
then b'
else wwhile (f, b')

bad:
let rec wwhile (f,b) = 
let check = (f, b') in
match check with
| (b', y) -> 
if y = false
then b'
else wwhile (f, b')
Error: Unbound value b'


let rec wwhile (f,b) = 
let check = (f b') in
match check with
| (b', y) -> 
if y = false
then b'
else wwhile (f, b')
Error: Unbound value b'


let rec wwhile (f,b) = 
let check = (f b') in
match check with
| (b', y) -> 
if y = false
then b'
else wwhile (f, b')
Error: Unbound value b'



hw2 wwhile

fix:
let rec wwhile (f,b) = 
match (f, b) with
| (x, y) -> 
if y = false
then x
else wwhile (f, x)

bad:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)
Error: This expression has type int -> int * bool
       but an expression was expected of type bool



hw2 wwhile

fix:
let rec wwhile (f,b) = 
let check = (f b) in
match check with
| (x, y) -> 
if y = false
then x
else wwhile (f, x)

bad:
let rec wwhile (f,b) = 
let check = (f b) in
match (f, b) with
| (x, y) -> 
if y = false
then x
else wwhile (f, x)
Error: This expression has type bool -> 'a
       but an expression was expected of type bool



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((fun x ->
let b = (f x) in
(b, b != x)),b)

bad:
let fixpoint (f,b) = wwhile (fun x 
let b = (f x) in
(b, b != x),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile (fun x ->
let b = (f x) in
(b, b != x),b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a


let fixpoint (f,b) = wwhile (fun x ->
let b = (f x) in
(b, b != x),b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a



hw2 fixpoint

fix:
let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
 _ = fixpoint (collatz, 3)
Error: Syntax error



hw2 exprToString

fix:
let rec exprToString e = 
let expr = exprToString in
match e with
| VarX		      -> "x"
| VarY		      -> "y"  
| Sine a	      -> "sin(pi*"^(expr a)^")"
| Cosine a	      -> "cos(pi*"^(expr a)^")"
| Average (a, b)      -> "(("^(expr a)^"+"^(expr b)^")/2)"
| Times (a, b)	      -> (expr a)^"*"^(expr b)
| Thresh (a, b, c, d) -> 
"("^(expr a)^"<"^(expr b)^"?"^(expr c)^":"^(expr d)^")"

bad:
let rec exprToString e = 
(*let expr = exprToString in*)
match e with
| VarX		      -> "x"
| VarY		      -> "y"  
| Sine a	      -> "sin(pi*"^(expr a)^")"
| Cosine a	      -> "cos(pi*"^(expr a)^")"
| Average (a, b)      -> "(("^(expr a)^"+"^(expr b)^")/2)"
| Times (a, b)	      -> (expr a)^"*"^(expr b)
| Thresh (a, b, c, d) -> 
"("^(expr a)^"<"^(expr b)^"?"^(expr c)^":"^(expr d)^")"
Error: Unbound value expr
Hint: Did you mean exp?



hw2 fixpoint

fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

bad:
 _ = fixpoint (collatz, 9001)
Error: Syntax error


 _ = fixpoint (collatz, 9001)
Error: Syntax error


 g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Syntax error



hw2 assoc

fix:
let rec assoc (d,k,l) = 
if l = [] then d else
match l with h::t ->
match h with (a, b) ->
if a = k then b
else assoc (d, k, t)

bad:
let rec assoc (d,k,l) = 
match dkl with (d, k, l) ->
if l = [] then d else
matchl
Error: Unbound value dkl


with h::t ->
match h with (a, b) ->
if a = k then b
else assoc (d, k, t)
Error: Syntax error


let rec assoc (d,k,l) = 
if l = [] then d else
matchl
Error: Unbound value matchl


with h::t ->
match h with (a, b) ->
if a = k then b
else assoc (d, k, t)
Error: Syntax error



hw2 assoc

fix:
let rec assoc (d,k,l) =
match (d, k, l) with
| (d, k, l) ->
if l = [] 
then d
else
match l with h::t ->
match h with (a, b) ->
if a = k 
then b
else assoc (d, k, t)

bad:
let rec assoc (d,k,l) =
match (d, k, l) with
| [] -> 0
| (d, k, l) ->
if l = [] 
then d
else
match l with h::t ->
match h with (a, b) ->
if a = k 
then b
else assoc (d, k, t)
Error: This pattern matches values of type 'a list
       but a pattern was expected which matches values of type 'b * 'c * 'd



hw2 wwhile

fix:
let rec wwhile (f,b) = 
let check = (f b) in
match check with
| (x', y) -> 
if y = false
then x'
else wwhile (f, x')

bad:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)
Error: This expression has type int -> int * bool
       but an expression was expected of type bool



hw2 build

fix:
let rec build (rand, depth) = if depth > 0 then 

let r = (rand (0, 5)) in 
let d = (depth - 1) in 

match r with
| 0 -> buildSine((build (rand, d)))
| 1 -> buildCosine((build (rand, d)))
| 2 -> buildAverage((build (rand, d)), (build (rand, d)))
| 3 -> buildTimes((build (rand, d)), (build (rand, d)))
| 4 -> buildThresh((build (rand, d)), (build (rand, d)), (build (rand, d)), (build (rand, d)))

else 

let r = (rand (0, 2)) in 

match r with
| 0 -> buildX()
| 1 -> buildY()

bad:
let g1 () = build (2, 2)
Error: This expression has type int but an expression was expected of type
         int * int -> int


let g2 () = build (2, 5)
Error: This expression has type int but an expression was expected of type
         int * int -> int


let g1 () = build (rand(0, 5), 2)
Error: Unbound value rand
Hint: Did you mean land?



hw2 eval

fix:
let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine a -> sin (pi*.eval (a, x, y))
| Cosine a -> cos (pi*.eval (a, x, y))
| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0
| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)
| Thresh (a, b, c, d) -> 
if eval (a, x, y) < eval (b, x, y) 
then eval (c, x, y) 
else eval (d, x, y)
| Poly (a, b, c) ->
(eval(a, x, y) *. eval(a, x, y)) +. (eval(b, x, y) *. eval(c, x, y))
| Tan a -> sin (pi *. eval(a, x, y)) /. cos (pi *. eval(a, x, y))

bad:
let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine a -> sin (pi*.eval (a, x, y))
| Cosine a -> cos (pi*.eval (a, x, y))
| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0
| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)
| Thresh (a, b, c, d) -> 
if eval (a, x, y) < eval (b, x, y) 
then eval (c, x, y) 
else eval (d, x, y)
| Poly (a, b, c) ->
(eval(a, x, y) *. eval(a, x, y)) + (eval(b, x, y) *. eval(c, x, y))
Error: This expression has type 'a * 'b * 'c
       but an expression was expected of type float


let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine a -> sin (pi*.eval (a, x, y))
| Cosine a -> cos (pi*.eval (a, x, y))
| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0
| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)
| Thresh (a, b, c, d) -> 
if eval (a, x, y) < eval (b, x, y) 
then eval (c, x, y) 
else eval (d, x, y)
| Poly (a, b, c) ->
(eval(a, x, y) * eval(a, x, y)) + (eval(b, x, y) *. eval(c, x, y))
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine a -> sin (pi*.eval (a, x, y))
| Cosine a -> cos (pi*.eval (a, x, y))
| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0
| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)
| Thresh (a, b, c, d) -> 
if eval (a, x, y) < eval (b, x, y) 
then eval (c, x, y) 
else eval (d, x, y)
| Poly (a, b, c) ->
(eval(a, x, y) *. eval(a, x, y)) +. (eval(b, x, y) *. eval(c, x, y))
Error: This expression has type float but an expression was expected of type
         int



hw2 build

fix:
let rec build (rand, depth) = 
if depth < 0 
then 
let r = (rand (0, 2)) in 
match r with
| 0 -> buildX()
| 1 -> buildY()
| _ -> failwith "Make the non-exhaustve pattern match warning shut up"
else 
let d = depth - 1 in 
match rand(0, 7) with
| 0 -> buildSine(build (rand, d))
| 1 -> buildCosine(build (rand, d))
| 2 -> buildAverage(build (rand, d), build (rand, d))
| 3 -> buildTimes(build (rand, d), build (rand, d))
| 4 -> buildThresh(build (rand, d),
build (rand, d),
build (rand, d),
build (rand, d))
| 5 -> buildPoly(build (rand, d),
build (rand, d),
build (rand, d))
| 6 -> buildTan( build (rand, d))
| _ -> failwith "Make the non-exhaustve pattern match warning shut up "

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let g1 () =  (1 ,4, 16)

let g2 () =  (3 ,9,27)

let g3 () =  (4,16, 64)

let c1 () = (5,7,10)

let c2 () = (6,7,8)

let c3 () = (6,7,8)

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let emitColor (f1,f2,f3,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_c_"^name) in
let chan = open_out (fname^".ppm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P6 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z1 = f1 (x,y) in
let z2 = f2 (x,y) in
let z3 = f3 (x,y) in

(* Convert the result to a grayscale value *)
let iz1 = toIntensity(z1) in
let iz2 = toIntensity(z2) in
let iz3 = toIntensity(z3) in

(* Emit one byte per color for this pixel *)
output_char chan (char_of_int iz1);
output_char chan (char_of_int iz2);
output_char chan (char_of_int iz3);
)) in  
close_out chan;
ignore(Sys.command ("convert "^fname^".ppm  "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".ppm"))

let doRandomColor (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand (seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e1 = build (g, depth) in
let e2 = build (g, depth) in
let e3 = build (g, depth) in

let _ = Format.printf "red   = %s \n" (exprToString e1) in
let _ = Format.printf "green = %s \n" (exprToString e2) in
let _ = Format.printf "blue  = %s \n" (exprToString e3) in

let f1 = eval_fn e1 in
let f2 = eval_fn e2 in
let f3 = eval_fn e3 in

(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitColor (f1,f2,f3,n,name)

type test = unit -> string

let key = ""

let prefix130 = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)); ErrorCode "exception")

let explode s = 
let rec _exp i = 
if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in
_exp 0

let implode cs = 
String.concat "" (List.map (String.make 1) cs)

let drop_paren s = 
implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))

let eq_real p (r1,r2) = 
(r1 -. r2) < p || (r2 -. r1) < p

let scoreMsg () = 
Format.sprintf "Results: Score/Max = %d / %d \n" !score !max

bad:
let rec build (rand, depth) = 
if depth < 0 
then 
let r = (rand (0, 2)) in 
match r with
| 0 -> buildX()
| 1 -> buildY()
| _ -> failwith "Make the non-exhaustve pattern match warning shut up"
else 
let d = depth - 1 in 
match rand(0, 7) with
| 0 -> buildSine(build (rand, d))
| 1 -> buildCosine(build (rand, d))
| 2 -> buildAverage(build (rand, d), build (rand, d))
| 3 -> buildTimes(build (rand, d), build (rand, d))
| 4 -> buildThresh(build (rand, d),
build (rand, d),
build (rand, d),
build (rand, d))
| 5 -> buildPoly(build (rand, d),
build (rand, d),
build (rand, d))
| 6 -> buildTan( build (rand, d))
| _ -> failwith "Make the non-exhaustve pattern match warning shut up "
Error: This expression has type 'a * 'b
       but an expression was expected of type expr



hw3 pipe

fix:
let pipe fs = 
let f a x = fun b -> x(a b) in
let base = fun x -> x in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

bad:
let pipe fs = 
let f a x = fun b -> x(a y) in
let base = fun x -> x in
List.fold_left f base fs
Error: Unbound value y


let _ = pipe [] 3
Error: Unbound value pipe


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: Unbound value pipe


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: Unbound value pipe



hw3 stringOfList

fix:
let stringOfList f l = "[" ^ (sepConcat "; " (List.map f l)) ^ "]"

bad:
let stringOfList f l = "[" ^ (sep "; " (List.map f l)) & "]"
Error: Unbound value sep


let stringOfList f l = "[" ^ (sepConcat "; " (List.map f l)) & "]"
Error: This expression has type string but an expression was expected of type
         bool



hw3 padZero

fix:
let padZero l1 l2 = 
let a = List.length l1 in
let b = List.length l2 in
if a = b
then (l1, l2)
else if a < b
then (clone 0 (b - a) @ l1, l2)
else (l1, clone 0 (a - b) @ l2)

bad:
let padZero l1 l2 = 
let a = List.length l1 in
let b = List.length l2 in
if a = b
then (a, b)
else if a < b
then (clone 0 (a - b) @ l1, l2)
else (l1, clone 0 (a - b) @ l2)
Error: This expression has type int list
       but an expression was expected of type int


let padZero l1 l2 = 
let a = List.length l1 in
let b = List.length l2 in
if a = b
then (a, b)
else if a < b
then ((clone 0 (a - b) @ l1), l2)
else (l1, clone 0 (a - b) @ l2)
Error: This expression has type int list
       but an expression was expected of type int


let padZero l1 l2 = 
let a = List.length l1 in
let b = List.length l2 in
if a = b
then (a, b)
else if a < b
then (clone 0 (b - a) @ l1, l2)
else (l1, clone 0 (a - b) @ l2)
Error: This expression has type int list
       but an expression was expected of type int


let padZero l1 l2 = 
let a = List.length l1 in
let b = List.length l2 in
if a = b
then (a, b)
else if a < b
then (clone 0 (b - a) @ l1, l2)
else (l1, clone 0 (a - b) @ l2)
Error: This expression has type int list
       but an expression was expected of type int



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, result) = a in
let (x1, x2) = x in
let res = x1 + x2 + carry in
let newCarry = res / 10 in
match result with 
| [] -> (newCarry, newCarry :: res mod 10 :: [])
| h::t -> (newCarry, newCarry :: res mod 10 :: t) 
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let c = fst x + snd x in
match a with
| h::t -> (h+c)/10::(h+c mod 10) :: t
| _ -> (c/10)::[c mod 10] in
let base = [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list
       but an expression was expected of type 'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, result) = a in
let (x1, x2) = x in
let res = x1 + x2 + carry in
let newCarry = res / 10 in
match result with 
| [] -> (newCarry, newCarry : res mod 10 : [])
|h::t -> (newCarry, newCarry :: res mod 10 :: t) in
let base = [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, result) = a in
let (x1, x2) = x in
let res = x1 + x2 + carry in
let newCarry = res / 10 in
match result with 
| [] -> (newCarry, newCarry :: res mod 10 : [])
|h::t -> (newCarry, newCarry :: res mod 10 :: t) in
let base = [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, result) = a in
let (x1, x2) = x in
let res = x1 + x2 + carry in
let newCarry = res / 10 in
match result with 
| [] -> (newCarry, newCarry :: res mod 10 :: [])
|h::t -> (newCarry, newCarry :: res mod 10 :: t) in
let base = [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type int * int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, result) = a in
let (x1, x2) = x in
let res = x1 + x2 + carry in
let newCarry = res / 10 in
match result with 
| [] -> (newCarry, newCarry :: res mod 10 :: [])
| h::t -> (newCarry, newCarry :: res mod 10 :: t) 
in
let base = [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type int * int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, result) = a in
let (x1, x2) = x in
let res = x1 + x2 + carry in
let newCarry = res / 10 in
match result with 
| [] -> (newCarry, newCarry :: res mod 10 :: [])
| h::t -> (newCarry, newCarry :: res mod 10 :: t) 
in
let base = [] in
let args = List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type int * int list



hw3 padZero

fix:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if List.length l1 < List.length l2
then (clone 0 (List.length l2 - List.length l1)) @ l1, l2
else l1, (clone 0 (List.length l1 - List.length l2)) @ l2

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if List.length l1 < List.length l2
then clone 0 (List.length l2 - List.length l1) @ l1, l2
else l1, clone 0 (List.length l1 - List.length l2 @ l2)
Error: This expression has type int but an expression was expected of type
         'a list


let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if List.length l1 < List.length l2
then (clone 0 (List.length l2 - List.length l1) @ l1, l2)
else l1, clone 0 (List.length l1 - List.length l2 @ l2)
Error: This expression has type int but an expression was expected of type
         'a list


let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if List.length l1 < List.length l2
then (clone 0 (List.length l2 - List.length l1)) @ l1, l2
else l1, clone 0 (List.length l1 - List.length l2 @ l2)
Error: This expression has type int but an expression was expected of type
         'a list



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = let (b, c) = a in
let (_, d) = x in
let res = bigAdd (mulByDigit d l1 @ clone 0 b) c in
(b + 1, res)
in
let base = (0, []) in
let args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = let a = (b, c)  in
let x = (_, d) in
let y = bigAdd (mulByDigit d l1 @ clone c b) c in
(b + 1, c)
in
let base = (0, []) in
let args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in
let (_, res) = List.fold_left f base args in
res
Error: Syntax error: operator expected.


let bigMul l1 l2 = 
let f a x = let a = (b, c)  in
let  (_, d) = x in
let y = bigAdd (mulByDigit d l1 @ clone c b) c in
(b + 1, c)
in
let base = (0, []) in
let args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value b
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value b


let bigMul l1 l2 = 
let f a x = let (b, c) = a in
let  (_, d) = x in
let y = bigAdd (mulByDigit d l1 @ clone c b) c in
(b + 1, c)
in
let base = (0, []) in
let args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int but an expression was expected of type
         int list
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int but an expression was expected of type
         int list



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = let (b, c) = a in
let (_, d) = x in
let e = bigAdd (mulByDigit d l1 @ clone 0 b) c in
(b + 1, e)
in
let base = (0, []) in
let args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = let a = (b, c) in
let x = (_, d) in
let e = bigAdd (mulByDigit d l1 @ clone 0 b) c in
(b + 1, e)
in
let base = (0, []) in
let args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in
let (_, res) = List.fold_left f base args in
res
Error: Syntax error: operator expected.



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, result) = a in
let (b, c) = x in
let res = b + c + carry in
let newCarry = res / 10 in
match result with 
| [] -> (newCarry, newCarry :: res mod 10 :: [])
| h::t -> (newCarry, newCarry :: res mod 10 :: t) 
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, result) = a in
let (b, c) = x in
let res = x + x + carry in
let newCarry = res / 10 in
match result with 
| [] -> (newCarry, newCarry :: res mod 10 :: [])
| h::t -> (newCarry, newCarry :: res mod 10 :: t) 
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type int



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (addC, resOfAdd) = a in
let (i1, i2) = x in
let result = i1 + i2 + addC in
let nextCarry = result / 10 in
match resOfAdd with 
| [] -> (nextCarry, [nextCarry] @ [result mod 10] @ [])
| h::t -> (nextCarry, [nextCarry] @ [result mod 10] @ t) 
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (addC, resOfAdd) = a in
let (i1, i2) = x in
let result = i1 + i2 + addC in
let nextCarry = result / 10 in
match resOfAdd with 
| [] -> (nextCarry, nextCarry @ [result mod 10] @ [])
| h::t -> (nextCarry, nextCarry @ [result mod 10] @ t) 
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a list



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = let (b, c) = a in
let (_, d) = x in
let e = bigAdd (mulByDigit d l1 @ clone 0 b) c in
(b + 1, e)
in
let base = (0, []) in
let args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in
let (_, res) = List.fold_left f base args in
res

let _ = bigMul [9;9;9;9] [9;9;9;9]

let _ = bigMul [] [0]

let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = let (b, c) = a in
let (_, d) = x in
let e = bigAdd (mulByDigit d l1 @ clone 0 b) c in
(b + 1, e)
in
let base = (0, []) in
let args = List.combine (clone l1 (List.length l2)) List.rev l2  in
let (_, res) = List.fold_left f base args in
res
Error: This function has type 'a list -> 'b list -> ('a * 'b) list
       It is applied to too many arguments; maybe you forgot a `;'.
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This function has type 'a list -> 'b list -> ('a * 'b) list
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 sumList

fix:
let rec sumList xs = match xs with
[] ->0
| h::t -> h + t

let _ = sumList [1; 2; 3; 4]

bad:
let rec sumList xs = function [] -> int
Error: Unbound value int


let rec sumList xs = 
[] -> 0
| h::t -> h + t
Error: Syntax error


let rec sumList xs = [] -> 0
| h::t -> h + t
Error: Syntax error


let rec sumList xs = [] -> 0
| h::t -> h + t
Error: Syntax error



hw1 sumList

fix:
let rec sumList xs = 
List.fold_left (+) xs

bad:
let rec sumList xs = match xs with
[] ->0
| h::t -> h + t in xs
Error: This expression has type int list
       but an expression was expected of type int


let rec sumList xs = function (*failwith "TBD:sumList"*)
List.fold_left (+) xs
Error: Syntax error



hw1 sumList

fix:
let rec sumList xs = match xs with
[] -> 0

bad:
let rec sumList xs = match xs with
| [] -> 0
| x :: xs -> List.fold_left x + xs
Error: This expression has type 'a -> 'b list -> 'a
       but an expression was expected of type int



hw1 sumList

fix:
let rec sumList xs = match xs with
[] -> 0
| h::t -> 1

bad:
let rec sumList xs = match xs with
[] -> 0
| h::t -> h + sum t
Error: Unbound value sum


let rec sumList xs = match xs with
[] -> 0
| h::t in xs -> h + sum t
Error: Syntax error: pattern expected.



hw1 sumList

fix:
let rec sumList xs = match xs with 
[] -> 0
| x :: xs -> x + sumList xs

bad:
let rec sumList xs = match xs with
[] -> int
| h::t -> 1
Error: Unbound value int


let rec sumList xs = 
[] -> res + 0
| x :: xs -> x + sumList xs
Error: Syntax error


let rec sumList xs = 
[] -> 0
| x :: xs -> x + sumList xs
Error: Syntax error


let rec sumList xs = 
[] -> 0
| x :: xs -> x + sumList xs
Error: Syntax error


let rec sumList xs = 
[] -> 0
| x :: xs -> x + sumList xs
Error: Syntax error



hw1 digitsOfInt

fix:
let rec digitsOfInt n = match n with
0 -> []
| n -> n / 10 :: digitsOfInt n

bad:
let rec digitsOfInt n = match n with
0 -> []
| n -> n / 10 ::[] digitsOfInt n
Error: Syntax error



hw1 digitsOfInt

fix:
let rec digitsOfInt n =
if n < 0 then []
else match n /10 with
0 -> [0]
| _ -> digitsOfInt n

bad:
let rec digitsOfInt n =
if n < 0 then -> []
else n -> n / 10 ::[] digitsOfInt n
Error: Syntax error


let rec digitsOfInt n =
if n < 0 then []
else n / 10 ::[] digitsOfInt n
Error: Syntax error


let rec digitsOfInt n =
if n < 0 then []
else match n /10 with
0 -> [0]
| _ -> digitsOfIn n []
Error: Unbound value digitsOfIn
Hint: Did you mean digitsOfInt?


let rec digitsOfInt n =
if n < 0 then []
else match n /10 with
0 -> [0]
| _ -> digitsOfInt n []
Error: This function has type int -> int list
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 digitsOfInt

fix:
let _ = digitsOfInt (-1)

bad:
let _ = digitsOfInt 0
Error: This expression has type int -> int list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let _ = digitsOfInt 0

let _ = digitsOfInt (-1)

let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n =
if n < 0 then []
else match (n mod 10) with
_ -> _::[] digitsOfInt (n / 10)
Error: Syntax error


let rec digitsOfInt n =
if n < 0 then []
else match (n mod 10) with
_ -> digitsOfInt (n/10)::[]
Error: Syntax error


let rec digitsOfInt n =
if n < 0 then []
else match (n mod 10) with
_ -> digitsOfInt (n/10) ::[]
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec digitsOfInt n =
if n < 0 then []
else digitOfInt (n/10) :: []
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec digitsOfInt n =
if n < 0 then []
else digitsOfInt (n/10) :: []
Error: Unbound value digitOfInt
Hint: Did you mean digitsOfInt?


let rec digitsOfInt n =
if n < 0 then []
else digitsOfInt (n/10)
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 digitsOfInt

fix:
let _ = digitsOfInt 0

bad:
let rec digitsOfInt n =
if n < 0 then []
else let rec loop n x = match n with
0 -> [0]
| _ -> loop (n/10) (n mod 10)
Error: Syntax error


let rec digitsOfInt n =
if n < 0 then []
else let rec loop n x = 
if n = 0 then x
else
(n mod 10)::x
match n with 
0 -> [0]
| x -> loop n []
Error: Syntax error


let rec digitsOfInt n =
if n < 0 then []
else let rec loop n x = 
if n = 0 then x
else loop (n/10) (n mod 10::x) in match n with
0 -> [0]
| _ -> loop n []
Error: Syntax error



hw1 digitsOfInt

fix:
let _ = sumList [1; 3; 5; 7; 9; 11]

let rec digitsOfInt n =
if n < 0 then []
else let rec loop n x = 
if n = 0 then x
else match n with
0 -> [0]
| _ -> loop (n/10) (n mod 10::[])

bad:
let _ = sumList [1; 3; 5; 7; 9; 11]


(* `digitsOfInt n` should return `[]` if `n` is not positive,
and otherwise returns the list of digits of `n` in the 
order in which they appear in `n`. *)

(* digitsOfInt : int -> int list  *)
(1 mod 10 ::4)
Error: This expression has type int but an expression was expected of type
         int list


let rec digitsOfInt n =
if n < 0 then []
else let rec loop n x = 
if n = 0 then x
else match n with
0 -> [0]
| _ -> loop (n/10) (n mod 10::[])
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 additivePersistence

fix:
let rec additivePersistence n = 
if n = 0 then 0
else let rec addPersist n x =
if n = 0 then x
else addPersist (n/10 + n mod 10) (1+x) in match n with 
0 -> 0
| _ -> 1

bad:
let rec additivePersistence n = 
if n = 0 then 0
else let rec addPersist n x =
if n = 0 then x
else addPersist (n/10 + n mod 10) x in match n with
0 -> 0
_ -> x + 1
Error: Syntax error


let rec additivePersistence n = 
if n = 0 then 0
else let rec addPersist n x =
if n = 0 then x
else addPersist (n/10 + n mod 10) (1+x) in match n with 
0 -> 0
_ -> 1
Error: Syntax error


let rec additivePersistence n = 
if n = 0 then 0
else let rec addPersist n x =
if n = 0 then x
else addPersist (n/10 + n mod 10) (1+x) in match n with 
0 -> 0
| _ -> 1
Error: Syntax error



hw1 additivePersistence

fix:
let _ = additivePersistence 12

bad:
let _ additivePersistence 0
Error: Syntax error


let _ = additivePersistence 0
Error: Syntax error



hw1 digitalRoot

fix:
let rec sumList xs = match xs with 
[] -> 0
| x :: xs -> x + sumList xs

let _ = sumList []

let _ = sumList [1]

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

let rec digitsOfInt n =
if n < 0 then []
else let rec r_digitsOfInt n x = 
if n = 0 then x
else r_digitsOfInt (n/10) (n mod 10::x) 
in match n with
0 -> [0]
| _ -> r_digitsOfInt n []

let _ = digitsOfInt 0

let _ = digitsOfInt (-1)

let _ = digitsOfInt 1

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

let digits n = digitsOfInt (abs n)

let _ = digits (-1234)

let _ = digits 0

let rec additivePersistence n = 
if n = 0 then 0
else let rec r_addPersist n x =
if n = 0 then x
else r_addPersist (n/10) (1+x) 
in match n with 
0 -> 0
| _ -> r_addPersist n (-1)

let _ = additivePersistence 0

let _ = additivePersistence 12

let _ = additivePersistence 9876

let rec digitalRoot n = 
if n = 0 then 0
else let rec r_digitalRoot n m = 
if n < 9 then n
else r_digitalRoot (n/10) (n mod 10 + m) in match n with
0 -> 0
| _ -> r_digitalRoot n 0

bad:
let rec digitalRoot n = 
if n = 0 then 0
else let rec r_digitalRoot n m = 
if n = 0 then m
else r_digitalRoot (n/10) (n mod 10 + m) in match n with
0 -> m
| - -> r_digitalRoot n 0
Error: Syntax error


let rec digitalRoot n = 
if n = 0 then 0
else let rec r_digitalRoot n m = 
if n = 0 then m
else r_digitalRoot (n/10) (n mod 10 + m) in match n with
0 -> m
| _ -> r_digitalRoot n 0
Error: Syntax error


let rec digitalRoot n = 
if n = 0 then 0
else let rec r_digitalRoot n m = 
if n = 0 then m
else r_digitalRoot (n/10) (n mod 10 + m) in match n with
0 -> r_digital root m 0
| _ -> r_digitalRoot n 0
Error: Unbound value m


let rec digitalRoot n = 
if n = 0 then 0
else let rec r_digitalRoot n m = 
if n = 0 then m
else r_digitalRoot (n/10) (n mod 10 + m) in match n with
0 -> r_digitalRoot m 0
| _ -> r_digitalRoot n 0
Error: Unbound value r_digital


let rec digitalRoot n = 
if n = 0 then 0
else let rec r_digitalRoot n m = 
if n < then n
else r_digitalRoot (n/10) (n mod 10 + m) in match n with
0 -> 0
| _ -> r_digitalRoot n m
Error: Unbound value m


let rec digitalRoot n = 
if n = 0 then 0
else let rec r_digitalRoot n m = 
if n < 9 then n
else r_digitalRoot (n/10) (n mod 10 + m) in match n with
0 -> 0
| _ -> r_digitalRoot n m
Error: Syntax error



hw1 digitalRoot

fix:
let _ = digitalRoot 0

let _ = digitalRoot 1

bad:
let rec digitalRoot n = 
if n <= 9 then n
else let rec r_digitalRoot n m = 
if n <= 9 then n
else r_digitalRoot (n/10) (n mod 10 + m) in match n with
0 -> 123
| _ -> r_digitalRoot n (-1)
Error: This expression has type int -> int
       but an expression was expected of type int



hw1 listReverse

fix:
let rec sumList xs = 
match xs with 
[] -> 0
| x :: xs -> x + sumList xs

let _ = sumList []

let _ = sumList [1]

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

let rec digitsOfInt n =
if n < 0 then []
else let rec r_digitsOfInt n x = 
if n = 0 then x
else r_digitsOfInt (n / 10) (n mod 10 :: x) 
in match n with
0 -> [0]
| _ -> r_digitsOfInt n []

let _ = digitsOfInt 0

let _ = digitsOfInt (-1)

let _ = digitsOfInt 1

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

let digits n = digitsOfInt (abs n)

let _ = digits (-1234)

let _ = digits 0

let rec additivePersistence n = 
if n <= 9 then 0
else let rec r_addPersist n m x =
if (n + m) <= 9 then x
else if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)
else r_addPersist (n / 10) (n mod 10 + m) x
in match n with 
0 -> 0
| _ -> r_addPersist n 0 1

let _ = additivePersistence 0

let _ = additivePersistence 1

let _ = additivePersistence 12

let _ = additivePersistence 8888

let _ = additivePersistence 9876

let rec digitalRoot n = 
if n <= 9 then n
else let rec r_digitalRoot n m = 
if (n + m) <= 9 then n + m
else if (n = 0) && (m > 9) then r_digitalRoot m 0
else r_digitalRoot (n / 10) (n mod 10 + m)
in match n with
0 -> 0
| _ -> r_digitalRoot n 0

let _ = digitalRoot 0

let _ = digitalRoot 1

let _ = digitalRoot 12

let _ = digitalRoot 66

let _ = digitalRoot 9876

let _ = digitalRoot 8888

let rec listReverse l = 
match l with
[] -> []
| h::t -> listReverse t @ h

bad:
let rec listReverse l =
if l = [] then []
else let rec r_listReverse l x = match l with
[] -> []
| h::t -> r_listReverse t []::h
Error: Syntax error


let rec listReverse l =
if l = [] then []
else let rec r_listReverse l x = match l with
[] -> []
| h::t -> r_listReverse t h::[]
Error: Syntax error


let rec listReverse l = match l with
[] -> []
| h::t -> listReverse t ::h
Error: Syntax error


let rec listReverse l = 
match l with
[] -> []
| h::t -> listReverse t @ h
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l = 
match l with
[] -> []
| h::t -> listReverse t @ h::[]
Error: This expression has type int but an expression was expected of type
         'a list



hw1 digitsOfInt

fix:
let _ = digitsOfInt 0

bad:
let rec digitsOfInt n = 
if n < 0 then []
else
match n with 
0 -> [0]
| _ -> digitsOfInt (n / 10) @ (n mod 10)::[]
Error: This pattern matches values of type 'a list
       but a pattern was expected which matches values of type int



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n < 0 then []
else let rec r_digitsOfInt n x = 
if n = 0 then x
else r_digitsOfInt (n / 10) (n mod 10 :: [])

let _ = digitsOfInt 0

let _ = digitsOfInt (-1)

let _ = digitsOfInt 1

bad:
let rec digitsOfInt n = 
if n < 0 then []
else if n = 0 then []
else digitsOfInt (n / 10) @ (n mod 10)::[]
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n < 0 then []
else digitsOfInt (n / 10) @ (n mod 10)::[] 
in match n with 
0 -> [0]
| _ -> digitsOfInt n @ []

let _ = digitsOfInt 0

let _ = digitsOfInt (-1)

let _ = digitsOfInt 1

bad:
let rec digitsOfInt n = 
if n < 0 then []
else if n = 0 then []
else digitsOfInt (n / 10) @ (n mod 10)::[]
Error: Syntax error



hw1 palindrome

fix:
let rec sumList xs = 
match xs with 
[] -> 0
| h::t -> h + sumList t

let _ = sumList []

let _ = sumList [1]

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

let rec digitsOfInt n = 
if n < 0 then []
else let rec r_digitsOfInt n x = 
if n = 0 then x
else r_digitsOfInt (n / 10) (n mod 10 :: x) 
in match n with
0 -> [0]
| _ -> r_digitsOfInt n []

let _ = digitsOfInt 0

let _ = digitsOfInt (-1)

let _ = digitsOfInt 1

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

let digits n = digitsOfInt (abs n)

let _ = digits (-1234)

let _ = digits 0

let rec additivePersistence n = 
if n <= 9 then 0
else let rec r_addPersist n m x =
if (n + m) <= 9 then x
else if (n = 0) && (m > 9) then r_addPersist m 0 (1 + x)
else r_addPersist (n / 10) (n mod 10 + m) x
in match n with 
0 -> 0
| _ -> r_addPersist n 0 1

let _ = additivePersistence 0

let _ = additivePersistence 1

let _ = additivePersistence 12

let _ = additivePersistence 8888

let _ = additivePersistence 9876

let rec digitalRoot n = 
if n <= 9 then n
else let rec r_digitalRoot n m = 
if (n + m) <= 9 then n + m
else if (n = 0) && (m > 9) then r_digitalRoot m 0
else r_digitalRoot (n / 10) (n mod 10 + m)
in match n with
0 -> 0
| _ -> r_digitalRoot n 0

let _ = digitalRoot 0

let _ = digitalRoot 1

let _ = digitalRoot 12

let _ = digitalRoot 66

let _ = digitalRoot 9876

let _ = digitalRoot 8888

let rec listReverse l = 
match l with
[] -> []
| h::t -> listReverse t @ h::[]

let _ = listReverse []

let _ = listReverse ["a"]

let _ = listReverse [1; 2; 3; 4]

let _ = listReverse ["a"; "b"; "c"; "d"]

let _ = listReverse [1; 2]

let explode s = 
let rec go i = 
if i >= String.length s 
then [] 
else (s.[i]) :: (go (i+1)) 
in
go 0

let palindrome w = match w with
[] -> true
| _ -> false

type test = unit -> string

let key        = ""

let prefix130  = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)); ErrorCode "exception")

let scoreMsg () = 
Printf.sprintf "Results: Score/Max = %d / %d \n" !score !max

bad:
let palindrome w = 
let orig_Esplode = esplode w and
let reverse_Esplode = explode reverseList w
Error: Syntax error


let palindrome w = 
orig_Esplode = esplode w
Error: Syntax error


let palindrome w = 
if w = [] then true
else
let orig_Esplode = esplode w and
let reverse_Esplode = explode reverseList w in 
let rec r_palindrome orig_Esplode revserse_Esplode = 
let h1 = h::orig_Esplode 
and h2 = h::reverse_Esplode
if h1 = h2 then r_panlindrome orig_Esplode reverse_Esplode
else false
Error: Unbound value orig_Esplode


let palindrome w = 
if w = [] then true
else
let rec r_palindrome esplode w esplode reverseList w = true
Error: Syntax error


let palindrome w = 
if w = [] then true
Error: Syntax error


let palindrome w = match w with
[] -> true
| _ -> false
Error: This variant expression is expected to have type unit
       The constructor true does not belong to type unit



hw1 digitsOfInt

fix:
let _ = digitsOfInt 0

bad:
let rec digitsOfInt n = 
match n with
| [] -> []
| 0 -> [0]
| _ -> digitsOfInt (n / 10) @ (n mod 10)
Error: Syntax error


let rec digitsOfInt n = 
if n < 0 then []
else
match n with 
| 0 -> [0]
| _ -> digitsOfInt (n / 10) @ (n mod 10)
Error: This pattern matches values of type int
       but a pattern was expected which matches values of type 'a list


let rec digitsOfInt n = 
if n < 0 then []
else
match n with 
| 0 -> [0]
| _ -> digitsOfInt (n / 10) :: (n mod 10)
Error: This expression has type int but an expression was expected of type
         int list


let rec digitsOfInt n = 
if n < 0 then []
else
match n with 
| 0 -> [0]
| _ -> digitsOfInt (n / 10) :: (n mod 10 ::[])
Error: This expression has type int list
       but an expression was expected of type int


let rec digitsOfInt n = 
if n < 0 then []
else
match n with 
| 0 -> [0]
| _ -> digitsOfInt (n / 10) @ (n mod 10 ::[])
Error: This expression has type int list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n < 0 then []
else match n with 
| 0 -> [0]
| _ -> 
if (n /10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])
else []

bad:
let rec digitsOfInt n = 
if n < 0 then []
else match n with 
| 0 -> [0]
| _ -> 
if (n /10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])
else []
Error: This expression has type int list
       but an expression was expected of type unit



hw1 additivePersistence

fix:
let _ = additivePersistence 0

let _ = additivePersistence 1

bad:
let rec additivePersistence n = 
if sumList (digitsOfInt n) < 9 then 0
else 1 + additivePersistence sumList n
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let rec additivePersistence n = 
if sumList (digitsOfInt n) < 9 then 0
else 1 + additivePersistence (sumList n)
Error: This function has type int -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let rec additivePersistence n = 
if sumList (digitsOfInt n) < 9 then 0
else 1 + additivePersistence (sumList (digitsOfInt n))
Error: This expression has type int but an expression was expected of type
         int list



hw1 digitalRoot

fix:
let _ = digitalRoot 0

let _ = digitalRoot 1

let _ = digitalRoot 12

let _ = digitalRoot 66

let _ = digitalRoot 9876

let _ = digitalRoot 8888

bad:
let rec digitalRoot n = 
if n <= 9 then n
else if sumList (digitsOfInt n) < 9 then sumList (digitsOfInt n)
else digitalRoot (sumList (digitsOfInt n))
Error: Syntax error



hw1 palindrome

fix:
let palindrome w = 
match w with 
| [] -> true
| _  -> 
let ex = esplode w in 
let rec r_palindrome ex = match ex with
| [] -> true
| h1::t1 -> false

bad:
let palindrome w = 
match w with 
| [] -> true
| _  -> 
let rec r_palindrome w = 
match w with
| [] -> true
| h1::t1 -> 
match reverseList t1 with
| h2::t2 ->
if h1 = h2 then r_palindrome t2
else false
Error: Syntax error


let palindrome w = 
match w with 
| [] -> true
| _  -> 
let rec r_palindrome w = 
match w with
| [] -> true
| h1::t1 -> 
match reverseList t1 with
| h2::t2 ->
if h1 = h2 then r_palindrome t2
else false
| _ -> false
Error: Syntax error


let palindrome w = 
match w with 
| [] -> true
| _  -> 
let ex = esplode w in 
let rec r_palindrome ex = match ex with
| [] -> true
| h1::t1 -> 
match reverseList t1 with
| [] -> true
| h2::t2 ->
if h1 = h2 then r_palindrome t2
else false
Error: Syntax error


let palindrome w = 
match w with 
| [] -> true
| _  -> false
Error: Syntax error



hw1 palindrome

fix:
let _ = palindrome "malayalam"

let _ = palindrome "myxomatosis"

bad:
let palindrome w = 
let ex = esplode w in
let rev_ex = reverseList ex in
let rec r_palindrome ex rev_ex = match (ex, rev_ex) with
| ([],[]) -> true
| (h1::t1, h2::t2) ->
if h1 = h2 then r_palindrome t1 t2
else false
| (ex, rev_ex) -> false
Error: Syntax error


let palindrome w = 
let rec r_palindrome ex rev_ex = match (ex, rev_ex) with
| ([],[]) -> true
| (h1::t1, h2::t2) ->
if h1 = h2 then r_palindrome t1 t2
else false
| (ex, rev_ex) -> false in
let ex = esplode w in
let rev_ex = reverseList ex
Error: Syntax error


let palindrome w = 
let rec r_palindrome ex rev_ex = match (ex, rev_ex) with
| ([],[]) -> true
| (h1::t1, h2::t2) ->
if h1 = h2 then r_palindrome t1 t2
else false
| (ex, rev_ex) -> false in
let rev_ex = reverseList ex in 
let ex = esplode w
Error: Syntax error


let palindrome w = 
let rec r_palindrome ex rev_ex = match (ex, rev_ex) with
| ([],[]) -> true
| (h1::t1, h2::t2) ->
if h1 = h2 then r_palindrome t1 t2
else false
| (ex, rev_ex) -> false in
r_palindrome (esplode w) (reverseList (esplode w))
Error: Syntax error


let palindrome w = 
let rec r_palindrome ex rev_ex = match (ex, rev_ex) with
| ([],[]) -> true
| (h1::t1, h2::t2) ->
if h1 = h2 then r_palindrome t1 t2
else false
| (ex, rev_ex) -> false in
r_palindrome (esplode w) (reverseList (explode w))
Error: Unbound value esplode
Hint: Did you mean explode?
Error: Unbound value esplode
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value esplode
Hint: Did you mean explode?


let palindrome w = 
let rec r_palindrome ex rev_ex = match (ex, rev_ex) with
| ([],[]) -> true
| (h1::t1, h2::t2) ->
if h1 = h2 then r_palindrome t1 t2
else false
| (ex, rev_ex) -> false in
r_palindrome (explode w) (reverseList (explode w))
Error: Unbound value esplode
Hint: Did you mean explode?


let palindrome w = 
let rec r_palindrome ex rev_ex = match (ex, rev_ex) with
| ([],[]) -> true
| (h1::t1, h2::t2) ->
if h1 = h2 then r_palindrome t1 t2
else false
| (ex, rev_ex) -> false 
in
r_palindrome (explode w) (reverseList (explode w))
Error: Unbound value reverseList


let palindrome w = 
let rec r_palindrome ex rev_ex = match (ex, rev_ex) with
| ([],[]) -> true
| (h1::t1, h2::t2) ->
if h1 = h2 then r_palindrome t1 t2
else false
| (ex, rev_ex) -> false 
in
r_palindrome (explode w) (listReverse (explode w))
Error: Unbound value reverseList



hw1 ???

fix:
let append x l = match l with
| [] -> x::[]
| _ -> x :: l

bad:
let rec append x l = match l with
| [] -> []
| h::t -> h :: (append t l)
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 ???

fix:
let _ = append [0] [1;2]

bad:
let _ = append [0] [1;2]
Error: This expression has type int but an expression was expected of type
         'a list


let append x l = match l with
| [] -> x :: []
| h::t -> x ::h::t
Error: This expression has type int but an expression was expected of type
         int list



hw1 ???

fix:
let append x l = 
let helper x l acc =
match x with 
| [] -> l
| h::t -> helper t l h::acc in
helper x l []

bad:
let append x l = 
match x with 
| [] -> l
| h::t -> h::t::l
Error: This expression has type int but an expression was expected of type
         int list


let rec append x l = 
match x with 
| [] -> l
| h::t -> h::(rec t l)
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec append x l = 
match x with 
| [] -> l
| h::t -> h::(append t l)
Error: Syntax error: operator expected.



hw1 ???

fix:
let _ = append [0] [1;2]

bad:
let append x l = 
let rec helper x acc =
match x with 
| [] -> acc
| h::t -> (helper t (h::acc)) in
helper x l
Error: This expression has type 'a list -> 'b
       but an expression was expected of type 'a list



hw1 listReverse

fix:
let _ = listReverse []

let _ = listReverse ["a"]

let _ = listReverse [1; 2; 3; 4]

let _ = listReverse ["a"; "b"; "c"; "d"]

let _ = listReverse [1; 2]

bad:
let rec listReverse l = 
match l with
| [] -> []
| h::t -> append (listReverse t) [h]
Error: This function has type 'a list -> 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 ???

fix:
let _ = append [0] [1;2]

let _ = append [] [1]

let _ = append [1;2;3] [1]

bad:
let rec append x l = match x with
| [] -> l
| h::t -> h::(append t l)
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw2 assoc

fix:
let rec assoc (d,k,l) = match l with 
| []   -> d
| h::t -> match h with
| (k1,v1) -> if k = k1 then v1
else assoc (d,k,t)

bad:
let rec assoc (d,k,l) = match l with 
| []   -> d
| h::t -> match h with
| (k1,v1) -> if k = k1 then 
else assoc (d,k,t)
Error: Syntax error



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = 
if List.mem h seen 
then helper (seen, t) 
else helper (h::seen, t) in
let rest' = helper (seen', t) in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = if List.mem (h, seen) then helper (h::seen, t) in
let rest' = helper (seen', t) in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This expression has type ('a * 'b) list -> bool
       but an expression was expected of type bool


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = if List.mem h seen
Error: Syntax error


) then helper (h::seen, t) in
let rest' = helper (seen', t) in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: Syntax error


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = if List.mem h seen then helper (h::seen, t) in
let rest' = helper (seen', t) in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This expression has type 'a list
       but an expression was expected of type unit



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = 
if List.mem h seen then
seen
else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = 
if List.mem h seen then
seen
else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This expression has type 'a list -> bool
       but an expression was expected of type bool



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = 
if List.mem h seen then seen
else seen in 
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = 
if List.mem h seen then seen
Error: Unbound value seen'
Hint: Did you mean seen?


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = 
if List.mem h seen then h::seen
Error: Syntax error


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = 
if List.mem h seen then seen
else seen
Error: Syntax error


let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: Syntax error


let _ = removeDuplicates [1,1,2]
Error: Syntax error



hw2 removeDuplicates

fix:
let _ = removeDuplicates [1,1,2]

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = 
if List.mem h seen then h::seen
else seen
Error: Syntax error


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = 
if List.mem h seen 
then h::seen
else seen
Error: Syntax error


let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: Syntax error


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = seen
Error: Syntax error


let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: Syntax error


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = seen
Error: Syntax error


let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: Syntax error


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: Syntax error



hw2 removeDuplicates

fix:
let _ = removeDuplicates [1,1,2]

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' = if List.mem h seen then seen 
else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This expression has type 'a list
       but an expression was expected of type unit



hw2 wwhile

fix:
let f x = 
let xx = x*x*x in (xx,xx<100)

let _  = wwhile (f,2)

bad:
let rec wwhile (f,b) =
let (b', c') = f b in 
match c' with
| False -> b'
| True  -> while (f, b')
Error: Syntax error


let rec wwhile (f,b) =
let (b', c') = f b in 
match c' with
| False -> b'
| True  -> wwhile (f, b')
Error: Syntax error


let rec wwhile (f,b) =
let (b', c') = f b in 
match c' with
| false -> b'
| true  -> wwhile (f, b')
Error: Unbound constructor False
Hint: Did you mean false?



hw2 exprToString

fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

let _ = exprToString sampleExpr1

bad:
let rec exprToString e = match e with
| VarX                       -> "x"
| VarY                       -> "y"
| Sine  (ex)                 -> "sin (pi*)" ^ exprToString ex ^ ")"
| Cosine  (ex)               -> "cos (pi*)" ^ exprToString ex ^ ")"
| Average (ex1, ex2)         -> "((" ^ exprToSring ex1 ^ " + " ^ exprToString ex2 ^ ")/2)" 
| Times (ex1, ex2)           -> exprToString expr1 ^ " * " ^ exprToString expr2
| Thresh (ex1, ex2, ex3, ex4) -> "(" ^ exprToString expr1 ^ "<" ^ exprToString expr2 ^ " ? " ^ exprToString expr3 ^ " : " ^ exprToString expr4 ^ ")"
Error: This variant pattern is expected to have type expr
       The constructor Tresh does not belong to type expr
Hint: Did you mean Thresh?


let rec exprToString e = match e with
| VarX                       -> "x"
| VarY                       -> "y"
| Sine  (ex)                 -> "sin (pi*)" ^ exprToString ex ^ ")"
| Cosine  (ex)               -> "cos (pi*)" ^ exprToString ex ^ ")"
| Average (ex1, ex2)         -> "((" ^ exprToString ex1 ^ " + " ^ exprToString ex2 ^ ")/2)" 
| Times (ex1, ex2)           -> exprToString expr1 ^ " * " ^ exprToString expr2
| Thresh (ex1, ex2, ex3, ex4) -> "(" ^ exprToString expr1 ^ "<" ^ exprToString expr2 ^ " ? " ^ exprToString expr3 ^ " : " ^ exprToString expr4 ^ ")"
Error: Unbound value exprToSring
Hint: Did you mean exprToString?


let rec exprToString e = match e with
| VarX                       -> "x"
| VarY                       -> "y"
| Sine  (ex)                 -> "sin (pi*)" ^ exprToString ex ^ ")"
| Cosine  (ex)               -> "cos (pi*)" ^ exprToString ex ^ ")"
| Average (ex1, ex2)         -> "((" ^ exprToString ex1 ^ " + " ^ exprToString ex2 ^ ")/2)" 
| Times (ex1, ex2)           -> exprToString ex1 ^ " * " ^ exprToString ex2
| Thresh (ex1, ex2, ex3, ex4) -> "(" ^ exprToString expr1 ^ "<" ^ exprToString expr2 ^ " ? " ^ exprToString expr3 ^ " : " ^ exprToString expr4 ^ ")"
Error: Unbound value expr1
Hint: Did you mean expm1?


let rec exprToString e = match e with
| VarX                       -> "x"
| VarY                       -> "y"
| Sine  (ex)                 -> "sin (pi*)" ^ exprToString ex ^ ")"
| Cosine  (ex)               -> "cos (pi*)" ^ exprToString ex ^ ")"
| Average (ex1, ex2)         -> "((" ^ exprToString ex1 ^ " + " ^ exprToString ex2 ^ ")/2)" 
| Times (ex1, ex2)           -> exprToString ex1 ^ " * " ^ exprToString ex2
| Thresh (ex1, ex2, ex3, ex4) -> "(" ^ exprToString ex1 ^ "<" ^ exprToString ex2 ^ " ? " ^ exprToString ex3 ^ " : " ^ exprToString ex4 ^ ")"
Error: Unbound value expr1
Hint: Did you mean expm1?



hw2 eval

fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr,0.5,0.2)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine (ex) -> sin(pi * (eval (ex,x,y)))
| Cosine (ex) -> cos(pi * eval (ex,x,y))
| Average (ex1, ex2) -> (eval (ex1,x,y) + eval (ex2,x,y) )/ 2
| Times (ex1, ex2) -> eval (ex1,x,y) * eval (ex2,x,y)
| Thresh (ex1, ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)
Error: Syntax error


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine (ex)   -> let ex1 = eval(ex,x,y) in sin(pi * ex1)
| Cosine (ex) -> cos(pi * eval (ex,x,y))
| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y) )/ 2
| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)
| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine (ex)   -> sin(pi * (eval (ex,x,y)))
| Cosine (ex) -> cos(pi * eval (ex,x,y))
| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y)) / 2
| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)
| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))
| Cosine (ex) -> cos(pi *. eval (ex,x,y))
| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y)) / 2
| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)
| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))
| Cosine (ex) -> cos(pi *. eval (ex,x,y))
| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y)) / 2
| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)
| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))
| Cosine (ex) -> cos(pi *. eval (ex,x,y))
| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) / 2
| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)
| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))
| Cosine (ex) -> cos(pi *. eval (ex,x,y))
| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) /. 2
| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)
| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))
| Cosine (ex) -> cos(pi *. eval (ex,x,y))
| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) / 2.
| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)
| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)
Error: This expression has type int but an expression was expected of type
         float


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))
| Cosine (ex) -> cos(pi *. eval (ex,x,y))
| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) /. 2.
| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)
| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))
| Cosine (ex) -> cos(pi *. eval (ex,x,y))
| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) /. 2.
| Times (ex1,ex2)   -> eval (ex1,x,y) *. eval (ex2,x,y)
| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)
Error: This expression has type float but an expression was expected of type
         int



hw2 build

fix:
let rec build (rand, depth) = 
if depth = 0 then 
let x = rand(0,1) in
match x with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand (0,4) in match r with
| 0 -> buildSine(build (rand, depth-1))
| 1 -> buildCosine( build (rand, depth-1))
| 2 -> buildAverage( build (rand, depth -1), build (rand, depth -1))
| 3 -> buildTimes( build (rand, depth-1), build(rand, depth-1))
| 4 -> buildThresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))

bad:
let rec build (rand, depth) = 
if depth = 0 then 
let x = rand(0,1) in
match x with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand (1,5) in match r with
| 1 -> buildSine(build (rand, depth-1))
| 2 -> buildCosine( build (rand, depth-1))
| 3 -> buildAverage( build (rand, depth -1), build (rand, depth -1))
| 4 -> buildTimes( build (rand, depth-1), build(rand, depth-1))
| 5 -> buildTresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))
Error: Syntax error


let rec build (rand, depth) = 
if depth = 0 then 
let x = rand(0,1) in
match x with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand (1,5) in match r with
| 1 -> buildSine(build (rand, depth-1))
| 2 -> buildCosine( build (rand, depth-1))
| 3 -> buildAverage( build (rand, depth -1), build (rand, depth -1))
| 4 -> buildTimes( build (rand, depth-1), build(rand, depth-1))
| 5 -> buildThresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))
Error: Unbound value buildTresh
Hint: Did you mean buildThresh?
Error: Unbound value buildTresh
Hint: Did you mean buildTimes?
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value buildTresh
Hint: Did you mean buildThresh?



hw2 assoc

fix:
assoc
(-1, "bob", [("ranjit",85);("william",23);("moose",44)])

bad:
assoc
(-1, "william", [("ranjit",85);("william",23);("moose",44)])
Error: This expression has type int but an expression was expected of type
         'a -> 'b



hw2 build

fix:
let rec assoc (d,k,l) = match l with 
| []   -> d
| h::t -> match h with
| (k1,v1) -> 
if k = k1 then v1
else assoc (d,k,t)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then seen 
else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) = 
let (b', c') = f b in 
match c' with
| false -> b'
| true  -> wwhile (f, b')

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) = 
let f x = 
let c = f x in (c, c != x) in
wwhile (f, b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

type expr = 
VarX
| VarY
| Sine     of expr
| Cosine   of expr
| Average  of expr * expr
| Times    of expr * expr
| Thresh   of expr * expr * expr * expr

let rec exprToString e = match e with
| VarX                      -> "x"
| VarY                      -> "y"
| Sine (e)                 -> "sin(pi*" ^ exprToString e ^ ")"
| Cosine (e)               -> "cos(pi*" ^ exprToString e ^ ")"
| Average (e1, e2)        -> "((" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ ")/2)" 
| Times (e1, e2)          -> exprToString e1 ^ "*" ^ exprToString e2
| Thresh (e1, e2, e3, e4) -> "(" ^ exprToString e1 ^ "<" ^ exprToString e2 ^ "?" ^ exprToString e3 ^ ":" ^ exprToString e4 ^ ")"

let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

let _ = exprToString sampleExpr1

let buildX()                       = VarX

let buildY()                       = VarY

let buildSine(e)                   = Sine(e)

let buildCosine(e)                 = Cosine(e)

let buildAverage(e1,e2)            = Average(e1,e2)

let buildTimes(e1,e2)              = Times(e1,e2)

let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)

let pi = 4.0 *. atan 1.0

let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine (e)   -> sin(pi *. (eval (e,x,y)))
| Cosine (e) -> cos(pi *. eval (e,x,y))
| Average (e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.
| Times (e1,e2)   -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2, e3, e4) -> if eval (e1,x,y) < eval (e2,x,y) then eval (e3,x,y) else eval (e4,x,y)

let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv

let sampleExpr =
buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(
buildX()),buildTimes(buildCosine (buildCosine (buildAverage
(buildTimes (buildY(),buildY()),buildCosine (buildX())))),
buildCosine (buildTimes (buildSine (buildCosine
(buildY())),buildAverage (buildSine (buildX()), buildTimes
(buildX(),buildX()))))))),buildY())))

let _ = eval (sampleExpr,0.5,0.2)

let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))

let rec build (rand, depth) = 
if depth = 0 then 
let x = rand(0,2) in
match x with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand (0,5) in match r with
| 0 -> buildSine(build (rand, depth-1))
| 1 -> buildCosine( build (rand, depth-1))
| 2 -> buildAverage( build (rand, depth -1), build (rand, depth -1))
| 3 -> buildTimes( build (rand, depth-1), build(rand, depth-1))
| 4 -> buildThresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))

let g1 () = (3, 1, 8)

let g2 () = (11, 2, 13)

let g3 () = (4, 1, 2)

let c1 () = (9, 3, 9)

let c2 () = (9, 2, 3)

let c3 () = (10, 1, 12)

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

let emitColor (f1,f2,f3,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_c_"^name) in
let chan = open_out (fname^".ppm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P6 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z1 = f1 (x,y) in
let z2 = f2 (x,y) in
let z3 = f3 (x,y) in

(* Convert the result to a grayscale value *)
let iz1 = toIntensity(z1) in
let iz2 = toIntensity(z2) in
let iz3 = toIntensity(z3) in

(* Emit one byte per color for this pixel *)
output_char chan (char_of_int iz1);
output_char chan (char_of_int iz2);
output_char chan (char_of_int iz3);
)) in  
close_out chan;
ignore(Sys.command ("convert "^fname^".ppm  "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".ppm"))

let doRandomColor (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand (seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e1 = build (g, depth) in
let e2 = build (g, depth) in
let e3 = build (g, depth) in

let _ = Format.printf "red   = %s \n" (exprToString e1) in
let _ = Format.printf "green = %s \n" (exprToString e2) in
let _ = Format.printf "blue  = %s \n" (exprToString e3) in

let f1 = eval_fn e1 in
let f2 = eval_fn e2 in
let f3 = eval_fn e3 in

(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitColor (f1,f2,f3,n,name)

type test = unit -> string

let key = ""

let prefix130 = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)); ErrorCode "exception")

let explode s = 
let rec _exp i = 
if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in
_exp 0

let implode cs = 
String.concat "" (List.map (String.make 1) cs)

let drop_paren s = 
implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))

let eq_real p (r1,r2) = 
(r1 -. r2) < p || (r2 -. r1) < p

let scoreMsg () = 
Format.sprintf "Results: Score/Max = %d / %d \n" !score !max

bad:
let rec build (rand, depth) = 
if depth = 0 then 
let x = rand(0,1) in
match x with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand (0,4) in match r with
| 0 -> buildSine(build (rand, depth-1))
| 1 -> buildCosine( build (rand, depth-1))
| 2 -> buildAverage( build (rand, depth -1), build (rand, depth -1))
| 3 -> buildTimes( build (rand, depth-1), build(rand, depth-1))
| 4 -> buildThresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))
Error: Unbound value rand
Hint: Did you mean land?



hw2 exprToString

fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

let _ = exprToString sampleExpr1

let _ = exprToString (NewExprA(VarX,VarY), 1, 1)

bad:
let rec exprToString e = match e with
| VarX                      -> "x"
| VarY                      -> "y"
| Sine (e)                 -> "sin(pi*" ^ exprToString e ^ ")"
| Cosine (e)               -> "cos(pi*" ^ exprToString e ^ ")"
| Average (e1, e2)        -> "((" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ ")/2)" 
| Times (e1, e2)          -> exprToString e1 ^ "*" ^ exprToString e2
| Thresh (e1, e2, e3, e4) -> "(" ^ exprToString e1 ^ "<" ^ exprToString e2 ^ "?" ^ exprToString e3 ^ ":" ^ exprToString e4 ^ ")"
| NewExprA (e1,e2) -> "(" ^ exprToString e1 ^ ">" ^exprToString e2 ^ "?" exprToString e1 ^ ":" exprToString e2
| NewExprB (e1,e2,e3) -> "(" exprToString e1 ^ "+" ^ exprToString e2 ^ "+" ^ exprToString ex ^ ")"
Error: This expression has type float but an expression was expected of type
         int


let rec exprToString e = match e with
| VarX                      -> "x"
| VarY                      -> "y"
| Sine (e)                 -> "sin(pi*" ^ exprToString e ^ ")"
| Cosine (e)               -> "cos(pi*" ^ exprToString e ^ ")"
| Average (e1, e2)        -> "((" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ ")/2)" 
| Times (e1, e2)          -> exprToString e1 ^ "*" ^ exprToString e2
| Thresh (e1, e2, e3, e4) -> "(" ^ exprToString e1 ^ "<" ^ exprToString e2 ^ "?" ^ exprToString e3 ^ ":" ^ exprToString e4 ^ ")"
| NewExprA (e1,e2) -> "(" ^ exprToString e1 ^ ">" ^exprToString e2 ^ "?" ^ exprToString e1 ^ ":" exprToString e2
| NewExprB (e1,e2,e3) -> "(" exprToString e1 ^ "+" ^ exprToString e2 ^ "+" ^ exprToString ex ^ ")"
Error: This expression has type string
       This is not a function; it cannot be applied.


let rec exprToString e = match e with
| VarX                      -> "x"
| VarY                      -> "y"
| Sine (e)                 -> "sin(pi*" ^ exprToString e ^ ")"
| Cosine (e)               -> "cos(pi*" ^ exprToString e ^ ")"
| Average (e1, e2)        -> "((" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ ")/2)" 
| Times (e1, e2)          -> exprToString e1 ^ "*" ^ exprToString e2
| Thresh (e1, e2, e3, e4) -> "(" ^ exprToString e1 ^ "<" ^ exprToString e2 ^ "?" ^ exprToString e3 ^ ":" ^ exprToString e4 ^ ")"
| NewExprA (e1,e2) -> "(" ^ exprToString e1 ^ ">" ^exprToString e2 ^ "?" ^ exprToString e1 ^ ":" ^ exprToString e2
| NewExprB (e1,e2,e3) -> "(" exprToString e1 ^ "+" ^ exprToString e2 ^ "+" ^ exprToString ex ^ ")"
Error: This expression has type string
       This is not a function; it cannot be applied.


let rec exprToString e = match e with
| VarX                      -> "x"
| VarY                      -> "y"
| Sine (e)                 -> "sin(pi*" ^ exprToString e ^ ")"
| Cosine (e)               -> "cos(pi*" ^ exprToString e ^ ")"
| Average (e1, e2)        -> "((" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ ")/2)" 
| Times (e1, e2)          -> exprToString e1 ^ "*" ^ exprToString e2
| Thresh (e1, e2, e3, e4) -> "(" ^ exprToString e1 ^ "<" ^ exprToString e2 ^ "?" ^ exprToString e3 ^ ":" ^ exprToString e4 ^ ")"
| NewExprA (e1,e2) -> "(" ^ exprToString e1 ^ ">" ^exprToString e2 ^ "?" ^ exprToString e1 ^ ":" ^ exprToString e2
| NewExprB (e1,e2,e3) -> "(" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ "+" ^ exprToString ex ^ ")"
Error: This expression has type string
       This is not a function; it cannot be applied.


let rec exprToString e = match e with
| VarX                      -> "x"
| VarY                      -> "y"
| Sine (e)                 -> "sin(pi*" ^ exprToString e ^ ")"
| Cosine (e)               -> "cos(pi*" ^ exprToString e ^ ")"
| Average (e1, e2)        -> "((" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ ")/2)" 
| Times (e1, e2)          -> exprToString e1 ^ "*" ^ exprToString e2
| Thresh (e1, e2, e3, e4) -> "(" ^ exprToString e1 ^ "<" ^ exprToString e2 ^ "?" ^ exprToString e3 ^ ":" ^ exprToString e4 ^ ")"
| NewExprA (e1,e2) -> "(" ^ exprToString e1 ^ ">" ^exprToString e2 ^ "?" ^ exprToString e1 ^ ":" ^ exprToString e2
| NewExprB (e1,e2,e3) -> "(" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ "+" ^ exprToString e3 ^ ")"
Error: Unbound value ex



hw2 exprToString

fix:
let rec exprToString e = match e with
| VarX                      -> "x"
| VarY                      -> "y"
| Sine (e)                 -> "sin(pi*" ^ exprToString e ^ ")"
| Cosine (e)               -> "cos(pi*" ^ exprToString e ^ ")"
| Average (e1, e2)        -> "((" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ ")/2)" 
| Times (e1, e2)          -> exprToString e1 ^ "*" ^ exprToString e2
| Thresh (e1, e2, e3, e4) -> "(" ^ exprToString e1 ^ "<" ^ exprToString e2 ^ "?" ^ exprToString e3 ^ ":" ^ exprToString e4 ^ ")"
| NewExprA (e1,e2) -> "(" ^ exprToString e1 ^ ">" ^exprToString e2 ^ "?" ^ exprToString e1 ^ ":" ^ exprToString e2 ^ ")"s
| NewExprB (e1,e2,e3) -> "(" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ "+" ^ exprToString e3 ^ ")"

bad:
let _ = exprToString (NewExprA(VarX,VarY))
Error: This expression has type 'a * 'b * 'c
       but an expression was expected of type expr



hw2 eval

fix:
let _ = eval (NewExprA(VarX, VarY), -1., 1.)

bad:
let _ = eval (NewExprA(VarX, VarY), 1., -1.)
Error: This variant expression is expected to have type expr
       The constructor Vary does not belong to type expr
Hint: Did you mean VarX or VarY?



hw2 eval

fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine (e)   -> sin(pi *. (eval (e,x,y)))
| Cosine (e) -> cos(pi *. eval (e,x,y))
| Average (e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.
| Times (e1,e2)   -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2, e3, e4) -> if eval (e1,x,y) < eval (e2,x,y) then eval (e3,x,y) else eval (e4,x,y)
| NewExprA (e1,e2) -> if eval(e1,x,y) > eval(e2,x,y) then eval (e1,x,y) else eval(e2,x,y)
| NewExprB (e1,e2,e3) -> eval(e1,x,y) +. eval(e2,x,y) -. eval(e3,x,y)

let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (NewExprA(VarX, VarY), -0.5, -1.)

let _ = eval (NewExprB(VarX, VarY, VarX), 1.,-1.)

bad:
let _ = eval (NewExprB(VarX, VarY, VarX), -1.,-1.,-1.)
Error: This expression has type 'a * 'b * 'c * 'd
       but an expression was expected of type expr * float * float


let _ = eval (NewExprB(VarX, VarY, VarX), -1.,-1.)
Error: This expression has type 'a * 'b * 'c * 'd
       but an expression was expected of type expr * float * float



hw3 sqsum

fix:
let sqsum xs = 
let f a x = x*x + a in
let base = 0 in
List.fold_left f base xs

bad:
let _ = sqsum []
Error: Unbound value sqsum



hw3 pipe

fix:
let pipe fs = 
let f a x = fun a -> x in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = f a in
let base = x in
List.fold_left f base fs
Error: Unbound value f


let pipe fs = 
let f a x = a x in
let base = x in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = a x in
let base = [] in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = fun a - x in
let base = fun y -> y in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let _ = pipe [] 3

bad:
let pipe fs = 
let f a x = a -> x in
let base =  y in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = fun f a -> f x in
let base = fun y -> y in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         int -> int



hw3 pipe

fix:
let pipe fs = 
let f a x = fun f a -> x in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun f x -> f a in
let base = fun y -> y in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'd -> 'c
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside ('a -> 'c) -> 'd -> 'c



hw3 pipe

fix:
let pipe fs = 
let f a x = fun f x -> fun f a -> f a x in
let base = fun y -> y in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'b


let pipe fs = 
let f a x = fun f x -> f a in
let base = fun y -> y in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'd -> 'c
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside ('a -> 'c) -> 'd -> 'c


let pipe fs = 
let f a x = fun f a -> fun f x -> f z in
let base = fun y -> fun y in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = fun f a -> fun f x -> f z in
let base = fun y in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = fun f a -> fun f x -> f z in
let base = fun y -> z in
List.fold_left f base fs
Error: Unbound value z


let pipe fs = 
let f a x = fun f a -> fun f x -> f w in
let base = fun y -> z in
List.fold_left f base fs
Error: Unbound value w


let pipe fs = 
let f a x = fun f a -> fun f x  in
let base = fun y -> z in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = fun f a -> fun f x in
let base = fun y -> z in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = fun f x -> fun f a in
let base = fun y -> z in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = fun f x -> fun f a -> f a x in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun f x -> fun f a -> fun f a x in
let base = fun y -> y in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = fun z -> x (a z) in
let base = fun z -> z in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         'a -> ('b -> 'a -> 'c) -> 'b -> 'c


let pipe fs = 
let f a x = fun f x -> fun f a -> f a x in
let base = fun y z-> z in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'b
       but an expression was expected of type
         'a -> 'b -> ('c -> 'b -> 'd) -> 'c -> 'd
       The type variable 'b occurs inside ('c -> 'b -> 'd) -> 'c -> 'd


let pipe fs = 
let f a x = fun f x -> f (x a) in
let base = fun z -> z in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> ('c -> 'd) -> ('a -> 'c) -> 'd
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside ('c -> 'd) -> ('a -> 'c) -> 'd


let pipe fs = 
let f a x = fun z -> f (x a) in
let base = fun z -> z in
List.fold_left f base fs
Error: Unbound value f



hw3 sepConcat

fix:
let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ x in
let base = h in
let l = "" in
List.fold_left f base l
Error: This expression has type string but an expression was expected of type
         string list



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x in
let base = "" in
let l = h in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a x in
let base = "" in
let l = h in
List.fold_left f base l
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep in
let base = "" in
let l = h in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep in
let base = h ^ sep in
let l = h in
List.fold_left f base l
Error: This expression has type string but an expression was expected of type
         'a list



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = "" in
let l = h in
List.fold_left f base l

bad:
let _ = sepConcat ", " ["foo";"bar";"baz"]
Error: This expression has type string but an expression was expected of type
         'a list



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = h in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = h in
let l = "" in
List.fold_left f base l
Error: This expression has type string but an expression was expected of type
         string list



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = sep in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = t in
let l = sl in
List.fold_left f base l
Error: This expression has type 'a list
       but an expression was expected of type string



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = sep ^ a in
let base = "" in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = sep ^ x in
let base = "" in
let l = sl in
List.fold_left f base 
Error: This expression has type string list -> string
       but an expression was expected of type string



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h ^ sep ^ a in
let base = sep in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h ^ sep ^ a in
let base = a in
let l = sl in
List.fold_left f base l
Error: Unbound value a



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x ^ sep ^ a in
let base = "" in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x ^ sep ^ a in
let base =  in
let l = sl in
List.fold_left f base l
Error: Syntax error



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = [] in
let l = sl in
List.fold_left f base l
Error: This expression has type 'a list
       but an expression was expected of type string



hw3 stringOfList

fix:
let stringOfList f l = List.map sepConcat l

bad:
let stringOfList f l = List.map "[" ^ sepConcat l ^ "]"
Error: This expression has type string but an expression was expected of type
         'a -> 'b



hw3 stringOfList

fix:
let sqsum xs = 
let f a x = x*x + a in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = fun z -> x (a z) in
let base = fun z -> z in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = List.map (f (sepConcat "" l))

bad:
let stringOfList f l = List.map sepConcat "" l
Error: This function has type ('a -> 'b) -> 'a list -> 'b list
       It is applied to too many arguments; maybe you forgot a `;'.


let stringOfList f l = List.map f (sepConcat "" l)
Error: This expression has type string but an expression was expected of type
         'a list


let stringOfList f l = List.map f (sepConcat l)
Error: This expression has type string list -> string
       but an expression was expected of type 'a list


let stringOfList f l = List.map f (sepConcat "" l)
Error: This expression has type string but an expression was expected of type
         'a list



hw3 stringOfList

fix:
let stringOfList f l = (List.map f l)

bad:
let stringOfList f l = sepConcat (List.map f l)
Error: This expression has type 'a list
       but an expression was expected of type string



hw3 ???

fix:
let _ = string_of_int

bad:
string_of_int [1;2;3;4;5;6]
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 clone

fix:
let rec clone x n = 
if n <= 0 then []
else
clone (x) (n-1)

bad:
let rec clone x n = 
if x <= 0 then []
else
clone x::[] (n-1)
Error: This expression has type 'a -> 'b list
       but an expression was expected of type 'b
       The type variable 'b occurs inside 'a -> 'b list


let rec clone x n = 
if x <= 0 then []
else
clone (x::[]) (n-1)
Error: This expression has type 'a list
       but an expression was expected of type int


let rec clone x n = 
if n <= 0 then []
else
clone (x::[]) (n-1)
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec clone x n = 
if n <= 0 then x
else
clone (x::[]) (n-1)
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw3 clone

fix:
let rec clone x n = 
if n <= 0 then []
else match x with
| [] -> x
| h::t -> h::clone t (n-1)

bad:
let rec clone x n = 
if n <= 0 then []
else
clone (x) (n-1)
in clone [] n
Error: Unbound value n


let rec clone x n = 
if n <= 0 then []
else match x with
| [] -> x
| h::t -> clone h::x (n-1)
Error: This expression has type 'a but an expression was expected of type
         'a list
       The type variable 'a occurs inside 'a list



hw3 clone

fix:
let rec clone x n = 
if n <= 0 then []
else match x with
| [] -> x
| h::t -> h :: clone t (n-1)

bad:
let _ = clone 3 5
Error: This expression has type int but an expression was expected of type
         'a list


let rec clone x n = 
if n <= 0 then []
else match x with
| [] -> x
| h::t -> clone t (n-1) :: h
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec clone x n = 
if n <= 0 then []
else match x with
| [] -> x
| h::t -> clone t (n-1) :: h ::[]
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw3 clone

fix:
let rec clone x n = 
if n <= 0 then []
else x :: clone x (n-1)

bad:
let _ = clone 3 5
Error: This expression has type int but an expression was expected of type
         'a list



hw3 clone

fix:
let rec clone x n = 
if n <= 0 then []
else x :: clone x (n-1)

bad:
let rec clone x n = 
Error: Syntax error



hw3 padZero

fix:
let padZero l1 l2 = 
let l = List.length l1 - List.length l2 in
if l < 0 then ((clone 0 ((-1)*l) @ l2), l2)
else (l1, clone 0 l @ l2)

bad:
let padZero l1 l2 = 
let l = List.length l1 - List.length l2 in
if l < 0 then ((clone 0 ((-1)*l) @ l2), l2)
else (l1, clone 0 l :: l2)
Error: This expression has type int list
       but an expression was expected of type int



hw3 padZero

fix:
let sqsum xs = 
let f a x = x*x + a in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = fun z -> x (a z) in
let base = fun z -> z in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = "[" ^ sepConcat ";" (List.map f l) ^ "]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n = 
if n <= 0 then []
else x :: clone x (n-1)

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let padZero l1 l2 = 
let l = List.length l1 - List.length l2 in
if l < 0 then ((clone 0 ((-1)*l) @ l1), l2)
else (l1, clone 0 l @ l2)

bad:
let padZero l1 l2 = 
let l = List.length l1 - List.length l2 in
if l < 0 then ((clone 0 ((-1)*l) @ l1), l2)
else (l1, clone 0 l @ l2)
Error: Unbound value clone



hw3 bigAdd

fix:
let sqsum xs = 
let f a x = x*x + a in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = fun z -> x (a z) in
let base = fun z -> z in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = "[" ^ sepConcat ";" (List.map f l) ^ "]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n = 
if n <= 0 then []
else x :: clone x (n-1)

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let padZero l1 l2 = 
let l = List.length l1 - List.length l2 in
if l < 0 then ((clone 0 ((-1)*l) @ l1), l2)
else (l1, clone 0 l @ l2)

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

let rec removeZero l = match l with
| [] -> []
| h::t-> 
if h = 0 then removeZero t
else h::t

let _ = removeZero [0;0;0;1;0;0;2]

let _ = removeZero [9;9]

let _ = removeZero [0;0;0;0]

let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x + a in
let base = 0 in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x + a in
let base = 0 in
let args = x mod 10 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value a


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x + a in
let base = 0 in
let args = (l1, l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value x



hw3 bigAdd

fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| _ -> a mod 10 :: []
| h::t -> (a+h) mod 10 :: t in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type int


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| _ -> a mod 10
| h::t -> (a+h) mod 10 in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int -> int list -> int list
       but an expression was expected of type int -> int list -> int
       Type int list is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| _ -> a mod 10 :: []
| h::t -> (a+h) mod 10 :: [] in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type int


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| _ -> a mod 10 :: []
| h::t -> (a+h) mod 10 :: (a+h)/10 in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int -> int list -> int list
       but an expression was expected of type int -> int list -> int
       Type int list is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| _ -> a mod 10 :: []
| h::t -> (a+h) mod 10 :: (a+h)/10 in
let base = (0,0) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| _ -> a mod 10
| h::t -> (a+h) mod 10 in
let base = (0,0) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| _ -> a mod 10
| h::t -> (a+h) mod 10 in
let base = [] in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int * int
       but an expression was expected of type int


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| _ -> a mod 10
| h::t -> (a+h) mod 10 in
let base = [0] in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type int


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (c,d) -> c in macth x
Error: This expression has type int list
       but an expression was expected of type int


with
| (add1, add2) -> ((c + add1 + add2) mod 10, (c + add1 + add2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (x,y) -> x in macth x
Error: Syntax error


with
| (add1, add2) -> ((x + add1 + add2) mod 10, (x + add1 + add2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (x,y) -> x in match x with
| (add1, add2) -> ((x + add1 + add2) mod 10, (x + add1 + add2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (x,y) -> x in match x with
| (add1, add2) -> (x + add1 + add2) mod 10
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let carry = match a with
| (x,y) -> x in 
match x with
| (add1, add2) -> 
let new_carry = (carry + add1 + add2) / 10 in
let digit = (carry + add1 + add2) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error



hw3 bigAdd

fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = match a with
| (carry, rest) -> match x with 
| (add1, add2) -> ((add1 + add2 + a)/ 10, ((add1 + add2 + a) mod 10)::reest)  in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = match a with
| (carry, rest) -> match x with 
| (add1, add2) -> ((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::reest)  in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type int


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = match a with
| (carry, rest) -> match x with 
| (add1, add2) -> ((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)  in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value reest
Hint: Did you mean rest?



hw3 bigAdd

fix:
let _ = removeZero [0;0;0;0]

let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = match a with
| (carry, rest) -> match x with 
| (x,y) -> ((carry/10), (carry mod 10)::rest)
| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)  in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let _ = removeZero [


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = match a with
| (carry, rest) -> match x with 

| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)  in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let _ = removeZero [


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = match a with
| (carry, rest) -> match x with 

| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)  in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let _ = bigAdd [9;9] [9;9]
Error: Syntax error



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = match a with
| (carry, rest) -> match x with 
| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)

let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [9;9]

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

let _ = 10/10

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = match a with
| (carry, rest) -> match x with 
| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)
| (_,_) -> ((carry/10), (carry mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This pattern matches values of type unit
       but a pattern was expected which matches values of type 'a * 'b



hw3 removeZero

fix:
let _ = removeZero [0;0;0;0]

bad:
let _ = removeZero [9;9]
Error: Syntax error



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
if x = [] then a
else
match a with
| (carry, rest) -> match x with 
| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [9;9]

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = match a with
| (carry, rest) -> match x with 
| (_,_) -> (carry::rest)
| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error: operator expected.


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
if x = () then a
else
match a with
| (carry, rest) -> match x with 
| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =
let carry = 
match a with
| (x,y) -> x in
match x with 
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
if x = (Nil,Nil) then a
else
match a with
| (carry, rest) -> match x with 
| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error: operator expected.


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
if x = (,) then a
else
match a with
| (carry, rest) -> match x with 
| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound constructor Nil


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
match a with
| (carry, rest) -> match x with 
| (add1, add2) -> 
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error: operator expected.



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
match a with
| (carry, rest) -> match x with 
| (add1, add2) -> 
if List.length rest = List.length l1 || List.length rest = List.length l2 then
(0, carry::rest)
else
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
match a with
| (carry, rest) -> match x with 
| (add1, add2) -> 
if List.length rest = List.length l1 or List.length rest = List.length l2 then
carry::rest
else
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
match a with
| (carry, rest) -> match x with 
| (add1, add2) -> 
if List.length rest = List.length l1 or List.length rest = List.length l2 then
(0, carry::rest)
else
((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list



hw3 bigAdd

fix:
let _ = bigAdd [9;9] [9;9]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
match a with
| (carry, rest) -> 
if List.length rest >= List.length l1 || 
List.length rest >= List.length l2 
then
(0, carry::rest)
else match x with 
| (add1, add2) ->
((add1 + add2 + carry)/ 10, 
((add1 + add2 + carry) mod 10)::rest) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value =>



hw3 bigAdd

fix:
let _ = bigAdd [9;9] [9;9]

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
match a with
| (carry, rest) -> match x with 
| (add1, add2) ->
((add1 + add2 + carry)/ 10, 
((add1 + add2 + carry) mod 10)::rest) in
if List.length rest >= List.length l1 || 
List.length rest >= List.length l2 
then
(0, ((add1 + add2 + carry)/ 10,)::rest)in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
match a with
| (carry, rest) -> match x with 
| (add1, add2) ->
((add1 + add2 + carry)/ 10, 
((add1 + add2 + carry) mod 10)::rest) in
if List.length rest >= List.length l1 || 
List.length rest >= List.length l2 
then
(0, ((add1 + add2 + carry)/ 10)::rest)in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error: operator expected.


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
match a with
| (carry, rest) -> match x with 
| (add1, add2) ->
let new_carry = (add1 + add2 + carry) / 10 in
let result = (add1 + add2 + carry) mod 10 :: rest in
if(List.length result >= List.length l1 ||
List.length result >= List.length l2) then
(0, carry::result)
else
(new_carry, result) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value rest



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
match a with
| (carry, rest) -> match x with 
| (add1, add2) ->
let new_carry = (add1 + add2 + carry) / 10 in
let result = (add1 + add2 + carry) mod 10 :: rest in
if(List.length result >= List.length l1 ||
List.length result >= List.length l2) && new_carry > 0 then
(0, carry::result)
else
(new_carry, result) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let _ = bigAdd [5;0] [5;0]
Error: Syntax error



hw3 mulByDigit

fix:
let rec mulByDigit i l = 
let f a x = match a with
| (carry, rest) -> 
let new_carry = ((i * x) + carry) / 10 in
let result = (((i * x) + carry) mod 10) :: rest in
if List.length result = List.length l && new_carry = 1 then
(0, new_carry::result)
else
(new_carry, result) in
let base = (0,[]) in
List.fold_left f base (List.rev l)

bad:
let rec mulByDigit i l = 
let f a x = match a with
| (carry, rest) -> match x with 
| (mul1, mul2) ->
let new_carry = ((mul1 * mul2) + carry) / 10 in
let result = (((mul1 * mul2) + carry) mod 10) :: rest in
if(List.length result = List.length l1 ||
List.length result = List.length l2) && new_carry = 1 then
(0, new_carry::result)
else
(new_carry, result) in
let base = (0,[]) in
List.fold_left f base (List.rev l)
Error: Unbound value add1


let rec mulByDigit i l = 
let f a x = match a with
| (carry, rest) -> match x with 
| (mul1, mul2) ->
let new_carry = ((mul1 * mul2) + carry) / 10 in
let result = (((mul1 * mul2) + carry) mod 10) :: rest in
if(List.length result = List.length l) && new_carry = 1 then
(0, new_carry::result)
else
(new_carry, result) in
let base = (0,[]) in
List.fold_left f base (List.rev l)
Error: Unbound value l1



hw3 bigMul

fix:
let sqsum xs = 
let f a x = x*x + a in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = fun z -> x (a z) in
let base = fun z -> z in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = "[" ^ sepConcat ";" (List.map f l) ^ "]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n = 
if n <= 0 then []
else x :: clone x (n-1)

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let padZero l1 l2 = 
let l = List.length l1 - List.length l2 in
if l < 0 then ((clone 0 ((-1)*l) @ l1), l2)
else (l1, clone 0 l @ l2)

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

let _ = padZero [] [1;0;0]

let rec removeZero l = match l with
| [] -> []
| h::t-> 
if h = 0 then removeZero t
else h::t

let _ = removeZero [0;0;0;1;0;0;2]

let _ = removeZero [9;9]

let _ = removeZero [0;0;0;0]

let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
match a with
| (carry, rest) -> match x with 
| (add1, add2) ->
let new_carry = (add1 + add2 + carry) / 10 in
let result = ((add1 + add2 + carry) mod 10) :: rest in
if(List.length result = List.length l1 ||
List.length result = List.length l2) && new_carry = 1 then
(0, new_carry::result)
else
(new_carry, result) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [9;9]

let _ = bigAdd [1] [9;9]

let _ = bigAdd [5;0] [5;0]

let _ = bigAdd [9;0;0] [1;0;0]

let _ = bigAdd [1;2] [1;3]

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

let _ = bigAdd [] []

let _ = bigAdd [0] []

let _ = bigAdd [3] []

let _ = bigAdd [0] [0]

let rec mulByDigit i l = 
let f a x = match a with
| (carry, rest) -> 
let new_carry = ((i * x) + carry) / 10 in
let result = (((i * x) + carry) mod 10) :: rest in
if List.length result = List.length l && new_carry > 0 then
(0, new_carry::result)
else
(new_carry, result) in
let base = (0,[]) in
let (_, res) = List.fold_left f base (List.rev l) in res

let _ = mulByDigit 9 [9;9;9;9]

let _ = mulByDigit 1 [0]

let bigMul l1 l2 = 
let f a x = match a with
| (index, rest) -> (index + 1, 
bigAdd rest ((mulByDigit x l1)@clone 0 index)) in
let base = (0,[]) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res

let _ = bigMul [9;9;9;9] [9;9;9;9]

let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

let _ = bigMul [0] [0]

let _ = bigMul [1;1;1;1;1] [9;9;9]

let key = ""

let prefix130 = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)^"\n"); ErrorCode "exception")

let explode s = 
let rec _exp i = 
if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in
_exp 0

let implode cs = 
String.concat "" (List.map (String.make 1) cs)

let drop_paren s = 
implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))

let eq_real p (r1,r2) = 
(r1 -. r2) < p || (r2 -. r1) < p

let wrap_curried_2 f (a,b) = f a b

bad:
let bigMul l1 l2 = 
let f a x = match a with
| (index, rest) -> 
let new_index = index + 1 in
let results = bigAdd rest ((mulByDigit x l1)@clone 0 index)
Error: Unbound value l1


) in
(new_index, result) in
let base = (0,[]) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res
Error: Syntax error



hw3 bigMul

fix:
let _ = bigMul [1;5] [1;5]

bad:
let _ = bigMul [1;5] [1;5]
Error: This expression has type int list
       This is not a function; it cannot be applied.



hw1 sumList

fix:
let rec sumList xs = 
match xs with
[] -> 0
| xs -> List.hd xs + (sumList (List.tl xs))

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

bad:
let rec sumList xs = 
match xs with
[] -> 0
| xs -> List.hd xs + (sumList List.tl xs)
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = sumList [1; 2; 3; 4]
Error: Unbound value sumList


let _ = sumList [1; -2; 3; 5]
Error: Unbound value sumList


let _ = sumList [1; 3; 5; 7; 9; 11]
Error: Unbound value sumList



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n < 0 then []
else  digitsOfInt (n/10) @ [n mod 10]

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

bad:
let rec digitsOfInt n = 
if n < 0 then []
else  digitsOfInt (n/10) @ n mod 10
Error: This expression has type int but an expression was expected of type
         'a list


let _ = digitsOfInt 3124
Error: Unbound value digitsOfInt


let _ = digitsOfInt 352663
Error: Unbound value digitsOfInt



hw1 additivePersistence

fix:
let rec additiveHelper n acc = 
if n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)
else acc

let additivePersistence n = additiveHelper n 0

let _ = additivePersistence 9876

bad:
let additivePersistence n =
if n > 9 then additivePersistence (List.fold_left (+) (digitsOfInt n))
else n
Error: Unbound value additivePersistence


let _ = additivePersistence 9876
Error: Unbound value additivePersistence


let additiveHelper n acc = 
if n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)
else acc
Error: Unbound value additiveHelper


let additivePersistence n = additiveHelper n 0
Error: Unbound value additiveHelper


let _ = additivePersistence 9876
Error: Unbound value additivePersistence


let additiveHelper n acc = 
if n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)
else acc
Error: Unbound value additiveHelper


let additivePersistence n = additiveHelper n 0
Error: Unbound value additiveHelper


let _ = additivePersistence 9876
Error: Unbound value additivePersistence



hw1 ???

fix:
append [2;3;4] [1]

bad:
append [2,3,4] [1]
Error: This expression has type int but an expression was expected of type
         int * int * int


append [2,3,4] [1]
Error: This expression has type int but an expression was expected of type
         int * int * int



hw2 assoc

fix:
let rec assoc (d,k,l) = 
match k with
| [] -> d
| (lk, lv)::ls -> if k = lk then lv else assoc d k ls

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

bad:
let rec assoc (d,k,l) = 
match k with
| [] -> d
| (lk, lv)::ls -> if k = lk then lv else 



let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])
Error: Syntax error


let rec assoc (d,k,l) = 
match k with
| [] -> d
| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)
Error: This expression has type 'a but an expression was expected of type
         ('a * 'b) list
       The type variable 'a occurs inside ('a * 'b) list


let rec assoc (d,k,l) = 
match k with
| [] -> d
| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)
Error: This expression has type 'a but an expression was expected of type
         ('a * 'b) list
       The type variable 'a occurs inside ('a * 'b) list



hw2 assoc

fix:
let rec assoc (d,k,l) = 
match k with
| [] -> d
| (lk, lv)::ls -> if lk = lk then lv else assoc (d,k,ls)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

bad:
let rec assoc (d,k,l) = 
match k with
| [] -> d
| (lk, lv)::ls -> if lk = lk then lv else assoc d k ls
Error: This expression has type 'a -> 'b -> 'c
       but an expression was expected of type
         ('a -> 'b -> 'c) * ('d * ('a -> 'b -> 'c)) list * 'e



hw2 assoc

fix:
let rec assoc (d,k,l) = 
match l with
| [] -> d
| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

bad:
let rec assoc (d,k,l) = 
match k with
| [] -> d
| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)
Error: This expression has type 'a but an expression was expected of type
         ('a * 'b) list
       The type variable 'a occurs inside ('a * 'b) list



hw2 wwhile

fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile2 (f, 2)

bad:
let f x = let xx = x*x*x in (xx, xx < 100 in
wwhile2 (f, 2)
Characters 28-29:
  let f x = let xx = x*x*x in (xx, xx < 100 in
                              ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((f (f b)),b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let fixpoint (f,b) = wwhile ((fun (f b) -> if f b = b then b else f b),b)
Characters 34-35:
  let fixpoint (f,b) = wwhile ((fun (f b) -> if f b = b then b else f b),b);;
                                    ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let fixpoint (f,b) = wwhile ((fun -> if f b = b then b else f b),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ((fun (f b)-> if f b = b then b else f b),b)
Characters 34-35:
  let fixpoint (f,b) = wwhile ((fun (f b)-> if f b = b then b else f b),b);;
                                    ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let fixpoint (f,b) = wwhile ((fun (f, b)-> if f b = b then b else f b),b)
Error: This expression has type 'a but an expression was expected of type
         (('a -> 'a) * 'a) * bool
       The type variable 'a occurs inside (('a -> 'a) * 'a) * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((fun f' -> if f b = b then (b,false) else (f b, true)),b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((fun f' -> if f b != b then (b,true) else (f b, false)),b)
Error: Unbound value fixpoint


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((fun rec f'-> if f b = b then (b,false) else (f b, true)),b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

bad:
let fixpoint (f,b) = wwhile ((fun f'-> if f b = b then (b,false) else (f b, true)),b)
Error: This expression has type 'a but an expression was expected of type
         ('a -> 'a) * 'a
       The type variable 'a occurs inside ('a -> 'a) * 'a



hw2 wwhile

fix:
let rec wwhile (f,b) = 
let (b',c') = f b in match c' with
| false -> b'
|     _ -> wwhile (f, b')

let rec wwhile2 (f,b) = let (b', c') = f b in if not c' then b' else wwhile2(f,b')

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile2 (f, 2)

bad:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile2 (f, 2)
Error: Unbound value wwhile2


let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile2 (f, 2)
Error: Unbound value wwhile2


let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)
Error: Unbound value wwhile2


let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let rec assoc (d,k,l) = 
match l with
| [] -> d
| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| []   -> seen
| h::t -> 
let seen' =  if not (List.mem h seen) then h::seen else seen in
let rest' =  t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) = 
let (b',c') = f b in match c' with
| false -> b'
|     _ -> wwhile (f, b')

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) = wwhile ((fun (f,b) -> match f b with | b -> (b, false) | _ -> (f b, true)),b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((fun (f,b) -> if f b = b then (f b, false) else (f b, true)),b)
Error: This expression has type 'a but an expression was expected of type
         ('a -> 'a) * 'a
       The type variable 'a occurs inside ('a -> 'a) * 'a


let fixpoint (f,b) = wwhile ((fun (f,b) -> match b with | f b -> (f b, false) | _ -> (f b, true)),b)
Error: This expression has type 'a but an expression was expected of type
         ('a -> 'a) * 'a
       The type variable 'a occurs inside ('a -> 'a) * 'a


let fixpoint (f,b) = wwhile ((fun (f,b) -> match b with | (f b) -> (f b, false) | _ -> (f b, true)),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ((fun (f,b) -> match b with | f b = b -> (f b, false) | _ -> (f b, true)),b)
Characters 58-59:
  let fixpoint (f,b) = wwhile ((fun (f,b) -> match b with | (f b) -> (f b, false) | _ -> (f b, true)),b);;
                                                            ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let fixpoint (f,b) = wwhile ((fun (f,b) -> match b with | (f b) = b -> (f b, false) | _ -> (f b, true)),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ((fun (f,b) -> match f b with | b -> (f b, false) | _ -> (f b, true)),b)
Characters 58-59:
  let fixpoint (f,b) = wwhile ((fun (f,b) -> match b with | (f b) = b -> (f b, false) | _ -> (f b, true)),b);;
                                                            ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile ((fun a -> if b = (f b) then (b,false) else ((f b),true)),b)
Error: Unbound value fixpoint



hw2 eval

fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr,0.5,0.2)

bad:
let rec eval (e,x,y) = 
match e with
| Thresh (w,t,u,z) -> if eval(w) < eval(t) then eval(u) else eval(z)
| Times (t,u) -> eval(t) * eval(u)
| Average (t,u) -> (eval(t) * eval(u)) / 2
| Cosine t -> cos(pi * eval(t))
| Sine t -> sin(pi * eval(t))
| VarX -> x
| VarY -> y
Error: This expression has type expr but an expression was expected of type
         expr * 'a * 'b


let rec eval (e,x,y) = 
match e with
| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)
| Times (t,u) -> eval(t,x,y) * eval(u,x,y)
| Average (t,u) -> (eval(t,x,y) * eval(u,x,y)) / 2
| Cosine t -> cos(pi * eval(t,x,y))
| Sine t -> sin(pi * eval(t,x,y))
| VarX -> x
| VarY -> y
Error: This expression has type expr but an expression was expected of type
         expr * 'a * 'b


let rec eval (e,x,y) = 
match e with
| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)
| Times (t,u) -> eval(t,x,y) * eval(u,x,y)
| Average (t,u) -> (eval(t,x,y) * eval(u,x,y)) / 2
| Cosine t -> cos(pi *. eval(t,x,y))
| Sine t -> sin(pi *. eval(t,x,y))
| VarX -> x
| VarY -> y
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = 
match e with
| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)
| Times (t,u) -> eval(t,x,y) * eval(u,x,y)
| Average (t,u) -> (eval(t,x,y) * eval(u,x,y)) / 2
| Cosine t -> cos(pi *. eval(t,x,y))
| Sine t -> sin(pi *. eval(t,x,y))
| VarX -> x
| VarY -> y
Error: This expression has type int but an expression was expected of type
         float


let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv
Error: This expression has type int but an expression was expected of type
         float


let rec eval (e,x,y) = 
match e with
| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)
| Times (t,u) -> eval(t,x,y) *. eval(u,x,y)
| Average (t,u) -> (eval(t,x,y) *. eval(u,x,y)) /. 2.0
| Cosine t -> cos(pi *. eval(t,x,y))
| Sine t -> sin(pi *. eval(t,x,y))
| VarX -> x
| VarY -> y
Error: Unbound value eval



hw2 build

fix:
let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec buildHelper rand max_depth curr_depth = 
if curr_depth < max_depth then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))
| 3 -> buildCosine(buildHelper(rand, max_depth, curr_depth + 1))
| 4 -> buildAverage(buildHelper(rand, max_depth, curr_depth + 1), 
buildHelper(rand, max_depth, curr_depth + 1))
| 5 -> buildTimes(buildHelper(rand, max_depth, curr_depth + 1 ), 
buildHelper(rand, max_depth, curr_depth + 1))
| 6 -> buildThresh(buildHelper(rand, max_depth, curr_depth + 1),
buildHelper(rand, max_depth, curr_depth + 1),
buildHelper(rand, max_depth, curr_depth + 1),
buildHelper(rand, max_depth, curr_depth + 1))
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()
Error: This expression has type 'a * 'b * 'c
       but an expression was expected of type int * int -> int


let rec buildHelper rand max_depth curr_depth = 
if curr_depth < max_depth then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))
| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))
| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), 
buildHelper rand max_depth (curr_depth + 1))
| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))
| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
Error: This expression has type 'a * 'b * 'c
       but an expression was expected of type int * int -> int


)
else match rand(0,1) with
| 0 -> buildX
| 1 -> buildY
Error: This expression has type expr but an expression was expected of type
         unit


let rec buildHelper rand max_depth curr_depth = 
if curr_depth < max_depth then match rand(0,6) with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))
| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))
| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), 
buildHelper rand max_depth (curr_depth + 1))
| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))
| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
Error: Syntax error


let rec buildHelper rand max_depth curr_depth = 
if curr_depth < max_depth then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))
| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))
| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), 
buildHelper rand max_depth (curr_depth + 1))
| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))
| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
Error: This expression has type unit -> expr
       but an expression was expected of type unit


)
else match rand(0,1) with
| 0 -> buildX
| 1 -> buildY
Error: This expression has type expr but an expression was expected of type
         unit


let rec buildHelper rand max_depth curr_depth = 
if curr_depth < max_depth then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))
| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))
| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), 
buildHelper rand max_depth (curr_depth + 1))
| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))
| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
Error: Syntax error


)
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()
Error: This expression has type expr but an expression was expected of type
         unit


let rec buildHelper rand max_depth curr_depth = 
if curr_depth < max_depth then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))
| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))
| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))
| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))
| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
Error: Syntax error


)
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()
Error: This expression has type expr but an expression was expected of type
         unit


let rec buildHelper rand max_depth curr_depth = 
if curr_depth < max_depth then match rand(0,6) with
| 0 -> buildX ()
| 1 -> buildY ()
| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))
| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))
| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))
| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))
| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
Error: Syntax error


)
else match rand(0,1) with
| 0 -> buildX ()
| 1 -> buildY ()
Error: This expression has type expr but an expression was expected of type
         unit


let rec buildHelper rand max_depth curr_depth = 
if curr_depth < max_depth then match rand(0,6) with
| 0 -> buildX 
| 1 -> buildY 
| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))
| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))
| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))
| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))
| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
Error: Syntax error


)
else match rand(0,1) with
| 0 -> buildX 
| 1 -> buildY
Error: This expression has type unit -> expr
       but an expression was expected of type unit


let rec buildHelper rand max_depth curr_depth = 
if curr_depth < max_depth then match rand(0,6) with
| 0 -> VarX
| 1 -> VarY 
| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))
| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))
| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))
| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))
| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
(buildHelper rand max_depth (curr_depth + 1))
Error: Syntax error


let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()
Error: This variant expression is expected to have type unit
       The constructor VarX does not belong to type unit



hw2 build

fix:
let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build(rand,(depth - 1)))
| 3 -> buildCosine(build(rand,(depth - 1)))
| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))

else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,(depth - 1))
| 3 -> buildCosine(build rand (depth - 1))
else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()
Error: This function has type (int * int -> int) * int -> expr
       It is applied to too many arguments; maybe you forgot a `;'.


let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build(rand,(depth - 1)))
| 3 -> buildCosine(build(rand,(depth - 1)))

else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()
Characters 118-119:
  | 2 -> buildSine(build (rand,(depth - 1))
                  ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw2 build

fix:
let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build(rand,(depth - 1)))
| 3 -> buildCosine(build(rand,(depth - 1)))
| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))
| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))
| 6 -> buildThresh(build(rand, (depth - 1)),
build(rand, (depth - 1)),
build(rand, (depth - 1)),
build(rand, (depth - 1)))

else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()
| _ -> buildX()

bad:
let rec build (rand, depth) = 
if depth > 0 then match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build(rand,(depth - 1)))
| 3 -> buildCosine(build(rand,(depth - 1)))
| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))

else match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()
| _ -> buildX()
Error: Syntax error



hw2 eval

fix:
let rec eval (e,x,y) = 
match e with
| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)
| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) (eval(u,x,y))))
| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))
| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)
| Cosine t -> cos(pi *. eval(t,x,y))
| Sine t -> sin(pi *. eval(t,x,y))
| Tan t -> tan(pi *. eval(t,x,y))
| VarX -> x
| VarY -> y

bad:
let rec eval (e,x,y) = 
match e with
| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)
| TimesMod (w,t,u) -> (eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) eval(u,x,y) )
| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))
| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)
| Cosine t -> cos(pi *. eval(t,x,y))
| Sine t -> sin(pi *. eval(t,x,y))
| VarX -> x
| VarY -> y
Error: This expression has type expr but an expression was expected of type
         float


let rec eval (e,x,y) = 
match e with
| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)
| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) eval(u,x,y)))
| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))
| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)
| Cosine t -> cos(pi *. eval(t,x,y))
| Sine t -> sin(pi *. eval(t,x,y))
| VarX -> x
| VarY -> y
Error: This function has type float -> float -> float
       It is applied to too many arguments; maybe you forgot a `;'.


let rec eval (e,x,y) = 
match e with
| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)
| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) (eval(u,x,y))))
| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))
| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)
| Cosine t -> cos(pi *. eval(t,x,y))
| Sine t -> sin(pi *. eval(t,x,y))
| VarX -> x
| VarY -> y
Error: This function has type float -> float -> float
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 bigAdd

fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base =  0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = fun y -> x(a y) in
let base = fun x -> x in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x  in
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = "[" ^ sepConcat "; " (List.map f l) ^ "]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n = 
if n <= 0 then []
else x::(clone x (n-1))

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let padZero l1 l2 = 
let dl = (List.length l1) - (List.length l2)
in match dl with
| 0 -> (l1,l2)
| _ -> 
if dl > 0 then (l1, ((clone 0 dl) @ l2))
else (((clone 0 (dl / -1)) @ l1), l2)

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

let rec removeZero l = match l with
| [] -> []
| h::t -> if h == 0 then removeZero t else h::t

let _ = removeZero [0;0;0;1;0;0;2]

let _ = removeZero [9;9]

let _ = removeZero [0;0;0;0]

let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| [] -> []
| (x,y)::t -> ((x+y)/10)::((x+y)mod 10)::t

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| [] -> []
| (x,y)::t -> ((x+y)/10)::((x+y)%10)
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| [] -> []
| (x,y)::t -> ((x+y)/10)::((x+y)%10)::t
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| [] -> []
| (x,y)::t -> ((x+y)/10)::((x+y)%10)::a
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| [] -> []
| (x,y)::t -> ((x+y)/10)::((x+y)%10) @ a
Error: Syntax error



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| [] -> []
| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t
| _ -> []
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t
| _ -> a
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t in
let base = [] in
let args =  List.rev ((List.combine l1 l2) @ (0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type (int * int) list
       but an expression was expected of type int list
       Type int * int is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2) @ (0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type (int * int) list
       but an expression was expected of type int list
       Type int * int is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::t
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2) @ (0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type (int * int) list
       but an expression was expected of type int list
       Type int * int is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::t
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2) @ (0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type (int * int) list
       but an expression was expected of type int list
       Type int * int is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2) @ (0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type ('c * 'd) list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type ('a * 'b) list
       but an expression was expected of type (int * int) list list
       Type 'a * 'b is not compatible with type (int * int) list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2)::(0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type ('c * 'd) list list


let bigAdd l1 l2 = 
let add l1 l2 = 
let f a x = match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2)::(0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type ('c * 'd) list list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (w,y)::t -> ((w+y)/10)::a::((w+y) mod 10)
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2)::(0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2)::(0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type ('c * 'd) list list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in
let base = [] in
let args =  List.rev ((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type ('a * 'b) list
       but an expression was expected of type (int * int) list list
       Type 'a * 'b is not compatible with type (int * int) list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (*match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in *)
let base = [] in
let args =  List.rev ((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (*match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in *)in
let base = [] in
let args =  List.rev ((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD"(*match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in *)in
let base = [] in
let args =  List.rev ((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type 'b * 'c


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD"(*match x with
| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a
| _ -> a  in *)in
let base = [] in
let args =  (0, List.rev ((List.combine l1 l2))) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int * ('a * 'b) list
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = [] in
let args =  List.rev ((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type 'b * 'c


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = [] in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type 'b * 'c


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = [] in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type 'b * 'c



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  List.rev( List.combine l1 l2 ) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = [] in
let args =  failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type 'b * 'c



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  List.rev((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  List.rev((List.combine l1 l2) @ (0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type ('c * 'd) list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  List.rev((List.combine l1 l2)::(0,0)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type ('c * 'd) list list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = failwith "TBD" in
let args =  List.rev((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base = [(0,0)] in
let args =  List.rev((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type (int * int) list
       but an expression was expected of type 'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "TBD" in
let base =  in
let args =  List.rev((List.combine l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = failwith "TBD" in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)
Error: Syntax error


)::t
| [] -> [] in
let base = (_, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)
Error: Syntax error


) @ t
| [] -> [] in
let base = (_, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)
Error: Syntax error


)
| [] -> [] in
let base = (_, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t
| [] -> [] 
in
let base = (_, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error: operator expected.


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t
| [] -> [] 
in
let base = (c, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type (int * int) list
       but an expression was expected of type int list
       Type int * int is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10)::((w+y+z) mod 10)::t
| [] -> [] 
in
let base = (c, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type (int * int) list
       but an expression was expected of type int list
       Type int * int is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match x with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t
| [] -> [] 
in
let base = (c, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This pattern matches values of type 'a list
       but a pattern was expected which matches values of type int * int


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t
| [] -> [] 
in
let base = (c, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type (int * int) list
       but an expression was expected of type int list
       Type int * int is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)
| [] -> [] 
in
let base = (c, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type int * int


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)
| [] -> (0,0)
in
let base = (c, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value c


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)
| [] -> (0,0)
in
let base = (_, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error: operator expected.


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)
| [] -> (0,0)
in
let base = (0, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type (int * int) list -> int * int -> int * int
       but an expression was expected of type
         (int * int) list -> int * int -> (int * int) list
       Type int * int is not compatible with type (int * int) list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let z = (fst x + snd x) in 
match a with
| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t
| [] -> (0,0)
in
let base = (0, 0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type (int * int) list
       but an expression was expected of type int list
       Type int * int is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| h::t -> ((h+z)/10)::((h+z) mod 10):: t 
| _ -> (z/10)::(z mod 10)in
let base = [] in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| h::t -> ((h+z)/10)::((h+z) mod 10):: t 
| _ -> ((z/10),[z mod 10])in
let base = [] in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| h::t -> ((h+z)/10)::((h+z) mod 10):: t 
| _ -> (z/10)::[z mod 10] in
let base = [] in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list
       but an expression was expected of type 'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| h::t -> (((h+z)/10), ((h+z) mod 10)):: t 
| _ -> ((z/10),(z mod 10)) in
let base = [] in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list
       but an expression was expected of type (int * int) list
       Type int is not compatible with type int * int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| h::t -> (((h+z)/10), ((h+z) mod 10))::t 
| _ -> ((z/10),(z mod 10)) in
let base = [] in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list
       but an expression was expected of type (int * int) list
       Type int is not compatible with type int * int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y)
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y)
in 
let base = [] in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type int * int list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,0) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int * int
       but an expression was expected of type int * int list
       Type int is not compatible with type int list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0, _ ) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error: operator expected.


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0, l) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value l


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = [] in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type int * int list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
| _ -> ( ((z)/10), [z mod 10])
in 
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
| _ -> ( ((w+z)/10), ((w+z) mod 10))
in 
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value w


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
| _ -> ( ((z)/10), ((z) mod 10))
in 
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         int list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,[]) in
let args =  List.rev( (List.combine l1 l2) )in
let (_, res) = List.fold_left f base args in
res
in 
add (padZero l1 l2)

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,[]) in
let args =  List.rev( (List.combine l1 l2) @ (0,0))in
let (_, res) = List.fold_left f base args in
res
in 
add (padZero l1 l2)
Error: This expression has type 'a * 'b
       but an expression was expected of type ('c * 'd) list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,[]) in
let args =  List.rev( (List.combine l1 l2)::(0,0))in
let (_, res) = List.fold_left f base args in
res
in 
add (padZero l1 l2)
Error: This expression has type 'a * 'b
       but an expression was expected of type ('c * 'd) list list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,[]) in
let args =  List.rev( (List.combine l1 l2)::([0],[0]))in
let (_, res) = List.fold_left f base args in
res
in 
add (padZero l1 l2)
Error: This expression has type 'a * 'b
       but an expression was expected of type ('c * 'd) list list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w, [])   -> (w, (z/10)::(z mod 10))
| (w, h::t) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,[]) in
let args =  List.rev( (List.combine l1 l2) )in
let (_, res) = List.fold_left f base args in
res
in 
add (padZero l1 l2)

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = [] in
let args =  List.rev( (List.combine l1 l2) )in
let (_, res) = List.fold_left f base args in
res
in 
add (padZero l1 l2)
Error: This expression has type 'a list
       but an expression was expected of type int * int list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,[]) -> ( ((w+z)/10), 0::((w+z)mod 10)::[])
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,[]) in
let args =  List.rev( (List.combine l1 l2) )in
let (_, res) = List.fold_left f base args in
res
in 
add (padZero l1 l2)

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,[]) -> ( ((w+z)/10), 0::((w+z)mod 10)::y
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,[]) in
let args =  List.rev( (List.combine l1 l2) )in
let (_, res) = List.fold_left f base args in
res
in 
add (padZero l1 l2)
Characters 104-105:
  | (w,[]) -> ( ((w+z)/10), 0::((w+z)mod 10)::y
              ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let z = (fst x + snd x) in match a with
| (w,[]) -> ( ((w+z)/10), 0::((w+z)mod 10)::y)
| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )
in 
let base = (0,[]) in
let args =  List.rev( (List.combine l1 l2) )in
let (_, res) = List.fold_left f base args in
res
in 
add (padZero l1 l2)
Error: Unbound value y



hw3 mulByDigit

fix:
let rec mulByDigit i l = 
let l1 = List.rev l in
let l2 = [i] in
let mul (l1, l2) = 
let f a x = let z = fst x * snd x in 
match a with
| (w,y) -> (((w+z)/10), ((w+z) mod 10)::y)
in 
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) @ [(0,0)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero(mul (padZero l1 l2))

bad:
let rec mulByDigit i l = 
let l1 = List.reverse l in
let l2 = [i] in
let mul (l1, l2) = 
let f a x = let z = fst x * snd x in 
match a with
| (w,y) -> (((w+z)/10), ((w+z) mod 10)::y)
in 
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) @ [(0,0)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero(mul (padZero l1 l2))
Error: Unbound value List.reverse



hw3 mulByDigit

fix:
let rec mulByDigit i l = 
let rec helper i l acc = match i with
| 0 -> [0]
| 1 -> l
| _ -> helper (i-1) l (bigAdd acc l)
in 
helper i l [0]

bad:
let rec mulByDigit i l = 
let rec helper acc n lis = match n with
| 1 -> lis + acc
| _ -> helper (n - 1) (bigAdd l lis)
Error: Syntax error


let rec mulByDigit i l = 
let rec helper acc n lis = match n with
| 1 -> lis + acc
| _ -> helper (n - 1) (bigAdd l lis)
in 
helper [] i l
Error: This expression has type int but an expression was expected of type
         int list


let rec mulByDigit i l = 
let rec helper acc n lis = match n with
| 1 -> lis + acc
| _ -> helper (n - 1) (bigAdd l lis)
in 
helper [0] i l
Error: This expression has type int but an expression was expected of type
         int list


let rec mulByDigit i l = 
let rec helper acc n lis = match n with
| 1 -> bigAdd lis acc
| _ -> helper (n - 1) (bigAdd l lis)
in 
helper [0] i l
Error: This expression has type int but an expression was expected of type
         int list



hw3 mulByDigit

fix:
let rec mulByDigit i l = 
let rec helper w y acc = match i with
| 0 -> [0]
| 1 -> l
| _ -> helper (w-1) y (bigAdd acc y)
in 
helper i l [0]

let _ = mulByDigit 9 [9;9;9;9]

bad:
let rec mulByDigit i l = 
let rec helper w y acc = match i with
| 0 -> [0]
| 1 -> l
| _ -> helper (w-1) y (bigAdd acc y)
in 
helper i l [10
Error: Syntax error



hw3 mulByDigit

fix:
let rec mulByDigit i l = 
let rec adder n li acc = match n with
| 0 -> [0]
| 1 -> bigAdd li acc
| _ -> adder (n-1) li (bigAdd acc li) 
in 
adder i l [0]

let _ = mulByDigit 9 [9;9;9;9]

let _ = mulByDigit 0 [1;2;3]

bad:
let _ = mulByDigit 0 [1;2;3]
Characters 17-18:
  let _ = print130 ("Compile";;
                   ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw3 mulByDigit

fix:
let _ = mulByDigit 999999999 [9;9;9;9]

bad:
let _ = mulByDigit 5 [6;9;8;9]
Error: Unbound value mulByDigit


let _ = mulByDigit 3 [9;9;9;9]
Error: Unbound value mulByDigit


let _ = mulByDigit 0 [1;2;3]
Error: Unbound value mulByDigit


let _ = mulByDigit 9999999 [9;9;9;9;9;9;9;9;9;9;]
Error: Unbound value mulByDigit



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = match a with
| (w,y) -> ( w, bigAdd a (mulByDigit (clone x (List.length y)) l1)) in 
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = let z = fst x * snd x in
match a with
| (w,y) -> ((w+z)/10), ((w+z) mod 10)::y
Error: Syntax error


)
in 
let base = (0,[]) in
let args = failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
Error: Syntax error


let bigMul l1 l2 = 
let f a x = let z = fst x * snd x in
match a with
| (w,y) -> (((w+z)/10), ((w+z) mod 10)::y)
in 
let base = (0,[]) in
let args = failwith "TBD" in
let (_, res) = List.fold_left f base args in
res
Error: Syntax error



hw3 bigMul

fix:
let rec bigCombiner l1 l2 acc = 
match l1 with
| [] -> acc
| h::t -> mulByDigit h l2

let _ = bigMul [9;9;9;9] [9;9;9;9]

let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = match a with
| (w,y) -> ( w, bigAdd y (mulByDigit (clone x (List.length y)) l1)) in 
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a * 'b
       but an expression was expected of type int list
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type 'a * 'b
       but an expression was expected of type int list


let bigMul l1 l2 = 
let f a x = match a with
| (w,y) -> ( w, bigAdd y (mulByDigit (x * (List.length y)) l1)) in 
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a list
       but an expression was expected of type int
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 bigMul

fix:
;;

let _ = bigMul [9;9;9;9] [9;9;9;9]

let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

let key = ""

let prefix130 = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)^"\n"); ErrorCode "exception")

let explode s = 
let rec _exp i = 
if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in
_exp 0

let implode cs = 
String.concat "" (List.map (String.make 1) cs)

let drop_paren s = 
implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))

let eq_real p (r1,r2) = 
(r1 -. r2) < p || (r2 -. r1) < p

let wrap_curried_2 f (a,b) = f a b

bad:
let bigMul l1 l2 = 
let f a x = x in 
let base = (0, []) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res
Error: Syntax error



hw3 bigMul

fix:
let rec mulByTen n = match n with
| 0 -> 0
| 1 -> 10
| _ -> 10 * (mulByTen (n-1))

let bigMul l1 l2 = 
let f a x =  
let (la, lb) = x in
let (i, acc) = a in
match l1 with
| [] -> (i, acc)
| h::t -> let temp = mulByDigit h lb 
in (i + 1, ( bigAdd acc (temp * (mulByTen i))))

bad:
let bigMul l1 l2 = 
let f a x =  x in 
let base = (0, []) in
let args = ( List.rev l1 , List.rev l2 ) in
let (_, res) = List.fold_left f base args in
res
Error: Syntax error



hw1 additivePersistence

fix:
let _ = additivePersistence 9876

bad:
let rec additivePersistence (a, n) = 
if n < 10
then (n, 0)
else let (a', n') = (additivePersistence (a+1, sumList(digits n)))
Error: Syntax error


let rec additivePersistence (a, n) = 
if n < 10
then (n, 0)
else additivePersistence (a+1, sumList(digits n))
Error: Unbound value sumList


)
Error: Syntax error


let rec additivePersistence (a, n) = 
if n < 10
then (n, 0)
else additivePersistence (a+1, sumList(digits n))
Error: Unbound value sumList



hw1 additivePersistence

fix:
let _ = additivePersistence (0,9876)

bad:
let rec additivePersistence (a, n) = 
if n < 10
then (a, n)
else additivePersistence (a+1, sumList(digits n))
Error: Unbound value sumList



hw1 digitalRoot

fix:
let rec sumList xs = match xs with
[] -> 0
| x :: xs -> x + sumList xs

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

let rec digitsOfInt n =
if n < 0
then []
else if n >= 10 
then (digitsOfInt (n/10)) @ [n mod 10]
else [n]

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

let _ = digitsOfInt (0-1)

let digits n = digitsOfInt (abs n)

let rec additivePersistence (a, n) = 
let intFun ((a,n) : int * int) : (a,n)
if n < 10
then (a, n)
else additivePersistence (a+1, sumList(digits n))

let _ = additivePersistence (0,9876)

let rec digitalRoot n = 
if n < 10
then n
else (digitalRoot (sumList (digits n)))

let _ = digitalRoot 9876

bad:
let _ = digitalRoot 9876
Error: Unbound value digitalRoot



hw1 additivePersistence

fix:
let rec additivePersistenceDigitalRoot (a, n) = 
if n < 10
then (a, n)
else additivePersistenceDigitalRoot (a+1, sumList(digits n))

let rec additivePersistence (n) = 
let (a, b) = additivePersistenceDigitalRoot (0, n)
in a

let _ = additivePersistence 9876

bad:
let rec additivePersistence (a, n) = 
let intFun (a, n) = 
if n < 10
then (a, n)
else intFun (a+1, sumList(digits n))
in (4,5)
Error: Unbound value intFun



hw1 digitsOfInt

fix:
let _ = digitsOfInt 03124

bad:
let _ = digitsOfInt o3124
Error: Unbound value o3124



hw1 ???

fix:
let _ = List.nth ['a']  3

bad:
let _ = head ['asd']
Error: Syntax error


let _ = list.head ['asd']
Error: Syntax error


let _ = List.head ['asd']
Error: Syntax error


let _ = List.nth (['asd'], 3)
Error: Syntax error: operator expected.


let _ = List.nth ['asd'], 3
Error: Syntax error


let _ = List.nth ['asd']  3
Error: Syntax error



hw1 palindrome

fix:
let palindrome (w, p) = 
if (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))
then true
else palindrome (w, p + 1)

bad:
let palindrome (w, p) = 
if (List.length w) > (2 * p) and ((List.nth w p) = (List.nth w (List.length w - 1 - p)))
then true
else palindrome (w, p + 1)
Error: Syntax error



hw1 palindrome

fix:
let rec palindromeA (w, p) = 
if (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))
then true
else palindromeA (w, p + 1)

let _ = palindromeA (['a'], 0)

bad:
let _ = palindrome (['a'], 0);

let palindrome w = failwith "TBD"
Error: Syntax error


let palindromeA (w, p) = 
if (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))
then true
else palindromeA (w, p + 1)
Error: Unbound value palindromeA
Hint: Did you mean palindrome?
Error: Unbound value palindromeA
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value palindromeA
Hint: Did you mean palindrome?


let _ = palindromeA (['a'], 0)
Error: Unbound value palindromeA
Hint: Did you mean palindrome?
Error: Unbound value palindromeA
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value palindromeA
Hint: Did you mean palindrome?


let palindromeA (w, p) = 
if (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))
then true
else palindromeA (w, p + 1)
Error: Unbound value palindromeA
Hint: Did you mean palindrome?
Error: Unbound value palindromeA
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value palindromeA
Hint: Did you mean palindrome?


let _ = palindromeA (['a'], 0)
Error: Unbound value palindromeA
Hint: Did you mean palindrome?
Error: Unbound value palindromeA
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value palindromeA
Hint: Did you mean palindrome?



hw1 palindrome

fix:
let rec palindromeA (w, p) = 
if ((List.length w) > (2 * p)) && (((List.nth w p) = (List.nth w (List.length w - 1 - p))))
then true
else palindromeA (w, p + 1)

let _ = palindromeA (['a','b', 'c'], 0)

bad:
let _ = palindromeA (['a','b', 'c'], 0)
Error: Unbound value palindromeA



hw1 palindrome

fix:
let rec palindromeA (w, p) = 
if (List.length w) <= (2 * p)
then if ((List.nth w p) = (List.nth w (List.length w - 1 - p)))
then true
else false
else palindromeA (w, p + 1)

let _ = palindromeA ([], 0)

bad:
let rec palindromeA (w, p) = 
if (List.length w) <= (2 * p)
if ((List.nth w p) = (List.nth w (List.length w - 1 - p)))
then true
else false
else palindromeA (w, p + 1)
Error: Syntax error



hw2 fixpoint

fix:
let fixpoint (f,b) =
wwhile (if f b = b then (f b, false) else (f b, true),b)

bad:
let fixpoint (f,b) =
wwhile ((f, (f b) != b),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) =
wwhile ((f, f b = b),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) =
wwhile ((f, true),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) =
wwhile ((failwith "asd", true),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) =
wwhile ((failwith "asd", failwith "asd"),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) =
wwhile ((failwith "asd", undefined),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) =
wwhile ((failwith "Asd"),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool



hw2 fixpoint

fix:
let fixpoint (f,b) =
wwhile ((if f b = b then (failwith "asd") else failwith "asd") ,b)

bad:
let fixpoint (f,b) =
wwhile (if f b = b then (f b, false) else failwith "asd" ,b)
Error: This expression has type 'a * 'b
       but an expression was expected of type bool -> bool * bool


let fixpoint (f,b) =
wwhile ((if f b = b then (f b, false) else failwith "asd") ,b)
Error: This expression has type bool -> bool * bool
       but an expression was expected of type bool


let fixpoint (f,b) =
wwhile ((if f b = b then failwith "asd" else failwith "asd") ,b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool



hw2 fixpoint

fix:
let fixpoint (f,b) =
wwhile ((if f b = b then (fun b''
-> (f b, false)) else failwith "asd") ,b)

bad:
let fixpoint (f,b) =
wwhile ((if f b = b then (true, failwith "asd") else failwith "asd") ,b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) =
wwhile ((if f b = b then (b, failwith "asd") else failwith "asd") ,b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) =
wwhile ((if f b = b then (failwith "Asd", failwith "asd") else failwith "asd") ,b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) =
wwhile ((if f b = b then (fun b''
-> (failwith "Asd", failwith "asd")) else failwith "asd") ,b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool



hw2 fixpoint

fix:
let fixpoint (f,b) =
wwhile ((if f b = b 
then (fun b'' -> (f b, false)) 
else (fun b'' -> (f b, true))), b)

bad:
let fixpoint (f,b) =
wwhile ((if f b = b 
then (fun b''
-> (f b, false)) 
else (fun b'' -> (f b, true) ,b)
Characters 28-29:
  wwhile ((if f b = b 
         ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let fixpoint (f,b) =
wwhile ((if f b = b 
then (fun b''
-> (f b, false)) 
else (fun b'' -> (f b, true))) ,b)
Characters 29-30:
  wwhile ((if f b = b 
          ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw2 fixpoint

fix:
let fixpoint (f,b) =
wwhile ((fun b' -> if f b' = b' 
then (f b', false)
else (f b', true)), b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 eval

fix:
let rec eval (e,x,y) = match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)
| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))
| Thresh (i1, i2, i3, i4) -> 
if (eval (i1, x, y)) <. (eval (i2, x, y)) 
then eval (i3, x, y)
else eval (i4, x, y)

bad:
let rec eval (e,x,y) = match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi * eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0)
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0)
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) / 2.0)
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)
Error: This expression has type float but an expression was expected of type
         int



hw2 eval

fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)
| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))
| Thresh (i1, i2, i3, i4) -> 
if (eval (i1, x, y)) < (eval (i2, x, y)) 
then eval (i3, x, y)
else eval (i4, x, y)
Error: Unbound value <.



hw2 build

fix:
let g1 () = failwith "to be implemented"

let g2 () = failwith "to be implemented"

let g3 () = failwith "to be implemented"

let c1 () = failwith "to be implemented"

let c2 () = failwith "to be implemented"

let c3 () = failwith "to be implemented"

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let emitColor (f1,f2,f3,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_c_"^name) in
let chan = open_out (fname^".ppm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P6 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z1 = f1 (x,y) in
let z2 = f2 (x,y) in
let z3 = f3 (x,y) in

(* Convert the result to a grayscale value *)
let iz1 = toIntensity(z1) in
let iz2 = toIntensity(z2) in
let iz3 = toIntensity(z3) in

(* Emit one byte per color for this pixel *)
output_char chan (char_of_int iz1);
output_char chan (char_of_int iz2);
output_char chan (char_of_int iz3);
)) in  
close_out chan;
ignore(Sys.command ("convert "^fname^".ppm  "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".ppm"))

let doRandomColor (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand (seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e1 = build (g, depth) in
let e2 = build (g, depth) in
let e3 = build (g, depth) in

let _ = Format.printf "red   = %s \n" (exprToString e1) in
let _ = Format.printf "green = %s \n" (exprToString e2) in
let _ = Format.printf "blue  = %s \n" (exprToString e3) in

let f1 = eval_fn e1 in
let f2 = eval_fn e2 in
let f3 = eval_fn e3 in

(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitColor (f1,f2,f3,n,name)

type test = unit -> string

let key = ""

let prefix130 = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)); ErrorCode "exception")

let explode s = 
let rec _exp i = 
if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in
_exp 0

let implode cs = 
String.concat "" (List.map (String.make 1) cs)

let drop_paren s = 
implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))

let eq_real p (r1,r2) = 
(r1 -. r2) < p || (r2 -. r1) < p

let scoreMsg () = 
Format.sprintf "Results: Score/Max = %d / %d \n" !score !max

bad:
let rec build (rand, depth) = 
let r = rand (if depth = 0 then (6, 7) else (1, 5)) in
match r with
1 -> buildSine (build (rand, depth - 1))
| 2 -> buildCosine (build (rand, depth - 1))
| 3 -> buildAverage ((build (rand, depth - 1)), (build (rand, depth - 1)))
| 4 -> buildTimes (build (rand, depth - 1)) (build (rand, depth - 1))
| 5 -> buildThresh (build (rand, depth - 1)) (build (rand, depth - 1)) (build (rand, depth - 1)) (build (rand, depth - 1))
| 6 -> VarX
| 7 -> VarY
Error: This function has type expr * expr -> expr
       It is applied to too many arguments; maybe you forgot a `;'.


let rec build (rand, depth) = 
let r = rand (if depth = 0 then (6, 7) else (1, 5)) in
match r with
1 -> buildSine (build (rand, depth - 1))
| 2 -> buildCosine (build (rand, depth - 1))
| 3 -> buildAverage ((build (rand, depth - 1)), (build (rand, depth - 1)))
| 4 -> buildTimes ((build (rand, depth - 1)), (build (rand, depth - 1)))
| 5 -> buildThresh ((build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)))
| 6 -> VarX
| 7 -> VarY
Error: This function has type expr * expr -> expr
       It is applied to too many arguments; maybe you forgot a `;'.



hw2 ???

fix:
let _ = log (0.0-1.0)

bad:
let _ = log 1.0
Error: This expression has type float -> float
       but an expression was expected of type int



hw2 ???

fix:
let _ = log (1.5-.2.0)

bad:
let _ = log (0.5-1.0)
Error: This expression has type float but an expression was expected of type
         int


let _ = log (1.5-1.0)
Error: This expression has type float but an expression was expected of type
         int


let _ = log (1.5-.1.0)
Error: This expression has type float but an expression was expected of type
         int



hw2 ???

fix:
fabs

bad:
abs
Error: Unbound value absf
Hint: Did you mean abs?



hw2 ???

fix:
log 0.00001

bad:
min 3.1 3.1
Error: This expression has type float
       This is not a function; it cannot be applied.



hw2 eval

fix:
let rec eval (e,x,y) = match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)
| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))
| Thresh (i1, i2, i3, i4) -> 
if (eval (i1, x, y)) < (eval (i2, x, y)) 
then eval (i3, x, y)
else eval (i4, x, y)
| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0
| SinLog (a',b',c) ->
let a = abs_float (eval (a', x, y))
in let b = abs_float (eval (b', x, y))
in let my_log = fun l' -> let l = (max 0.1 l') in (log l) /. (log 10.0)
in
if eval (c, x, y) < 0.0
then (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0
else -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)

bad:
let rec eval (e,x,y) = match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)
| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))
| Thresh (i1, i2, i3, i4) -> 
if (eval (i1, x, y)) < (eval (i2, x, y)) 
then eval (i3, x, y)
else eval (i4, x, y)
| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0
| SinLog (a',b',c) ->
let a = abs_float (eval (a', x, y))
in let b = abs_float (eval (b', x, y))
in let my_log = fun l' -> let l = (min 0.1 l') in (log l) / (log 10.0)
in
if eval (c, x, y) < 0.0
then (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0
else -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)
Error: This expression has type int ref
       This is not a function; it cannot be applied.


let rec eval (e,x,y) = match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)
| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))
| Thresh (i1, i2, i3, i4) -> 
if (eval (i1, x, y)) < (eval (i2, x, y)) 
then eval (i3, x, y)
else eval (i4, x, y)
| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0
| SinLog (a',b',c) ->
let a = abs_float (eval (a', x, y))
in let b = abs_float (eval (b', x, y))
in let my_log = fun l' -> let l = (min 0.1 l') in (log l) /. (log 10.0)
in
if eval (c, x, y) < 0.0
then (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0
else -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)
Error: This expression has type float but an expression was expected of type
         int



hw2 eval

fix:
let rec eval (e,x,y) = match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)
| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))
| Thresh (i1, i2, i3, i4) -> 
if (eval (i1, x, y)) < (eval (i2, x, y)) 
then eval (i3, x, y)
else eval (i4, x, y)
| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a
in max' -1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))
| SinLog (a',b',c) -> 1.0

bad:
let rec eval (e,x,y) = match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)
| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))
| Thresh (i1, i2, i3, i4) -> 
if (eval (i1, x, y)) < (eval (i2, x, y)) 
then eval (i3, x, y)
else eval (i4, x, y)
| ECosSin (a,b) -> max 1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))
| SinLog (a',b',c) -> 1.0
Error: This expression has type int ref
       but an expression was expected of type int


let rec eval (e,x,y) = match e with
VarX -> x
| VarY -> y
| Sine i -> sin (pi *. eval (i, x, y))
| Cosine i -> cos (pi *. eval (i, x, y))
| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)
| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))
| Thresh (i1, i2, i3, i4) -> 
if (eval (i1, x, y)) < (eval (i2, x, y)) 
then eval (i3, x, y)
else eval (i4, x, y)
| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a
in max' 1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))
| SinLog (a',b',c) -> 1.0
Error: This expression has type int ref
       This is not a function; it cannot be applied.



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun y -> y in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 pipe

fix:
let _ = pipe [(fun x -> x)] 4

bad:
let _ = pipe [(fun x -> x + 2)] 4
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let _ = pipe [(fun x -> 2)] 4
Error: This expression has type int but an expression was expected of type
         'a -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun y -> y in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun y -> y + 3 in
List.fold_left f base fs

let _ = pipe [] 3

bad:
let pipe fs = 
let f a x = x a in
let base = fun y -> y _+ 3 in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = a in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = 3 + a in
let base = fun y -> y in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let pipe fs = 
let f a x = 3 + a in
let base = fun y -> y in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun y -> y in
List.fold_left f base fs

(fun a -> a + 1) (fun b -> b + 3) 4

bad:
let _ = pipe [(fun x -> x); (fun x -> x)] 4
Error: This expression has type int but an expression was expected of type
         'a -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x = fun g -> (x a) g in
let base = fun g -> g in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun g -> g (x a) in
let base = fun g -> g in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = fun g -> (x a) g in
let base = fun g -> g in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let pipe fs = 
let f a x = fun g -> (a x) g in
let base = fun g -> g in
List.fold_left f base fs
Error: This expression has type ('a -> 'a -> 'b) -> 'a -> 'a -> 'b
       but an expression was expected of type
         ('a -> 'a -> 'b) -> 'a -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = fun g -> g (a x)  in
let base = fun g -> g in
List.fold_left f base fs
Error: This expression has type ('a -> 'a) -> 'a -> 'a
       but an expression was expected of type ('a -> 'a) -> 'a
       The type variable 'a occurs inside 'a -> 'a


let pipe fs = 
let f a x = fun g -> g (x a)  in
let base = fun g -> g in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = fun g -> (g x) a  in
let base = fun g -> g in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> ('b -> 'a -> 'c) -> 'c
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside ('b -> 'a -> 'c) -> 'c


let pipe fs = 
let f a x = fun g -> (g a) x  in
let base = fun g -> g in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> ('a -> 'b -> 'c) -> 'c
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside ('a -> 'b -> 'c) -> 'c


let pipe fs = 
let f a x = fun g -> (a x) g in
let base = fun g -> g in
List.fold_left f base fs
Error: This expression has type ('a -> 'a -> 'b) -> 'a -> 'a -> 'b
       but an expression was expected of type
         ('a -> 'a -> 'b) -> 'a -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = fun g -> x (a g) in
let base = fun g -> g in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ "a" in
let base = failwith "" in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = ^ "a" in
let base = failwith "" in
let l = sl in
List.fold_left f base l
Error: Syntax error



hw3 stringOfList

fix:
 h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = sepConcat "; " (List.map f l)

bad:
let stringOfList f l = sepConcat "; " (map f l)
Error: Unbound value map
Hint: Did you mean max?



hw3 clone

fix:
let rec clone x n = match n with
| 0 -> []
| _ -> x :: clone x (n - 1)

bad:
let rec clone x n = match n with
| 0 -> []
| x :: clone x (n - 1)
Error: Syntax error: pattern expected.



hw3 padZero

fix:
let padZero l1 l2 = 
let ll1 = List.length l1
in let ll2 = List.length l2
in ((clone 0 (ll2 - ll1)) @ l1, (clone 0 (ll1 - ll2)) @ l2)

bad:
let padZero l1 l2 = 
let l1 = List.length l1
in let l2 = List.length l2
in ((clone 0 (l2 - l1)) @ l1, (clone 0 (l1 - l2)) @ l2)
Error: This expression has type int but an expression was expected of type
         int list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) mod 10) in
let base = (0, 1) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in
let base = (0, 1) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int * int
       but an expression was expected of type int * int list
       Type int is not compatible with type int list 



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) :: ds) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) :: ds) in
let base = (0, []) in
let args = List.reverse (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value List.reverse



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f (c, ds) (x1, x2) = (2, ds @ [(c + x1 + x2)]) in
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f (c, ds) (x1, x2) = ((2, ds @ [(c + x1 + x2)]) in
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Characters 65-66:
  let f (c, ds) (x1, x2) = ((2, ds @ [(c + x1 + x2)]) in
                           ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f (c, ds) (x1, x2) = if List.length ds = List.length l1 
then (0, (c + x1 + x2) / 10 :: (c + x1 + x2) mod 10 :: ds)
else ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f (c, ds) (x1, x2) = if List.length ds = List.length x1 
then (0, (c + x1 + x2) / 10 :: (c + x1 + x2) mod 10 :: ds)
else ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f (indent, acc) x = (0 :: indent, (List.fold_left bigAdd [] (clone l2 x)) @ indent) in
let base = ([], []) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f (indent, acc) x = (0 :: indent, (List.fold_left bigAdd 0 (clone l2 x)) @ indent) in
let base = ([], []) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int but an expression was expected of type
         int list
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int but an expression was expected of type
         int list



hw1 sumList

fix:
let rec sumList xs = failwith "TBD:sumList"

bad:
val sumList : int list -> int
Error: Syntax error


sumList : int list -> int
Error: Syntax error


sumList : int list -> int
Error: Syntax error


val sumList : int list -> int
Error: Syntax error


val sumList : int list -> int
Error: Syntax error


let sumList : int list -> int
Error: Syntax error


let sumList : int list -> int
Error: Syntax error


let sumList : int list -> int
Error: Syntax error


sumList : int list -> int
Error: Syntax error


sumList : int list -> int
Error: Syntax error



hw1 sumList

fix:
let rec sumList xs =
match xs with
| [] -> []
| let sum  = sum + hd :: sumLists tl

failwith "TBD:sumList"

let _ = sumList [1; 2; 3; 4]

bad:
let rec sumList xs =
match xs with
| [] -> []
| let sum in hd::tl -> sum = sum + hd :: sumLists tl
Error: Syntax error



hw1 sumList

fix:
let rec sumList xs =
match xs with
| [] -> []
| hd::tl -> hd + (sumList tl)

failwith "TBD:sumList"

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

bad:
let rec sumList xs =
match xs with
| [] -> []
| hd::tl -> sum  = sum + hd :: sumLists tl
Error: Unbound value sum



hw1 digitsOfInt

fix:
let digitsOfInt n = 
let rec loop n acc =
if n = 0 then acc
else loop (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> loop n []

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

bad:
let _ = digitsOfInt 352663
Error: Unbound value sumList



hw1 digitsOfInt

fix:
let digitsOfInt n = 
let rec loop n acc =
if n = 0 then acc
else loop (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> loop n acc

bad:
let _ = digitsOfInt 345
Error: This expression has type int -> int list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

bad:
let digitsOfInt n = 
let rec loop n acc =
if n = 0 then acc
else loop (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> loop n [7]
Error: Unbound value acc



hw1 digitsOfInt

fix:
let digitsOfInt n = 
let rec loop n tlist =
if n = 0 then tlist
else loop (n/10) (n mod 10::tlist) in
match n with
| 0 -> [0]
| _ -> loop n [7]

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

bad:
let digitsOfInt n = 
let rec loop n tlist =
if n = 0 then tlist
else loop (n/10) (n mod 10::tlist)
Error: Syntax error



hw2 assoc

fix:
let rec assoc (d,k,l) =
let rec ahelper d k l = 
match l with
| [] -> d
| hd::tl ->
(match hd with
| (h,t) ->
if (h = k)
then t
else ahelper d k tl)
in
ahelper d k l

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

bad:
let rec assoc (d,k,l) =
let rec ahelper d k l = 
match l with
| [] -> d
| hd::tl ->
match hd with
| (h,t) ->
if (h = k)
then t
else ahelper d k tl
Error: Syntax error


let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])
Error: Unbound value assoc


let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])
Error: Unbound value assoc


let rec assoc (d,k,l) =
let rec ahelper d k l = 
match l with
| [] -> d
| hd::tl ->
(match hd with
| (h,t) ->
if (h = k)
then t
else ahelper d k tl)
Error: Syntax error


let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])
Error: Unbound value assoc


let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])
Error: Unbound value assoc


let rec assoc (d,k,l) =
let rec ahelper d k l = 
match l with
| [] -> d
| hd::tl ->
(match hd with
| () -> d
| (h,t) ->
if (h = k)
then t
else ahelper d k tl)
Error: Syntax error


let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])
Error: Unbound value assoc



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| hd::tl -> 
let seen' = hd::seen in
let rest' = tl in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen::h in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]
Error: Unbound value removeDuplicates


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = (seen::h) in
let rest' = (t) in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| hd::tl -> 
let seen' = 
if (List.mem tl 2 = true) then seen
else hd::seen in
let rest' = tl in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| hd::tl -> 
let seen' = 
if (List.mem tl hd = true) then seen
else hd::seen in
let rest' = tl in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This expression has type 'a but an expression was expected of type
         'a list list
       The type variable 'a occurs inside 'a list list


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| hd::tl -> 
let seen' = 
if (List.mem tl 2 = true) then seen
else hd::seen in
let rest' = tl in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This expression has type int but an expression was expected of type
         'a list list



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| hd::tl -> 
let seen' = 
if (List.mem h tl = true) then seen
else hd::seen in
let rest' = tl in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| hd::tl -> 
let seen' = 
if (List.mem tl hd = true) then seen
else hd::seen in
let rest' = tl in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This expression has type 'a but an expression was expected of type
         'a list list
       The type variable 'a occurs inside 'a list list



hw2 wwhile

fix:
let rec wwhile (f,b) =
let rec wwhelper f b =
let (b', c') = f b in
if (c' = false) then b'
else wwhelper f b'
in wwhelper f b

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let rec wwhile (f,b) =
let rec wwhelper f b =
let (b', c') = f b;
if (c' = false) then b'
else wwhelper f b'
in wwhelper fb
Error: Syntax error


let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)
Error: Unbound value wwhile


let rec wwhile (f,b) =
let rec wwhelper f b =
let (b', c') = f b;
if (c' = false) then b'
else wwhelper f b'
in wwhelper f b
Error: Syntax error


let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)
Error: Unbound value wwhile



hw2 exprToString

fix:
let rec exprToString e =
let rec eTShelper e expr =
let e::= x 
| y 
| sin (pi*e) 
| cos (pi*e) 
| ((e + e)/2) 
| e * e 
| (e<e ? e : e) in
match e with
| VarX -> expr ^ e
| VarY -> expr ^ e
| Sine -> expr ^ e
| Cosine -> expr ^ e
| Average  -> expr ^ e
| Times    -> expr ^ e
| Thresh   -> expr ^ e
in
eTShelper e ""

let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e =
let rec eTShelper e expr =
let e::= x 
| y 
| sin (pi*e) 
| cos (pi*e) 
| ((e + e)/2) 
| e * e 
| (e<e ? e : e) in
match e with
| VarX -> expr ^ e
| VarY -> expr ^ e
| Sine -> expr ^ e
| Cosine -> expr ^ e
| Average  -> expr ^ e
| Times    -> expr ^ e
| Thresh   -> expr ^ e
in
eTShelper e ""
Error: Syntax error: pattern expected.



hw2 eval

fix:
let rec eval (e,x,y) =
let rec evalhelper e x y =
match e with
| VarX -> float x
| VarY -> float y
| Sine(p1) -> sin(pi *. evalhelper p1 x y)
| Cosine(p1) -> cos(pi *. evalhelper p1 x y)
in
evalhelper e x y

let _ = eval(Sine(Varx), 0.5, -0.5)

bad:
let rec eval (e,x,y) =
let rec evalhelper e x y =
match e with
| VarX -> x
| VarY -> y
| Sine(p1) -> sin(pi * evalhelper p1)
| Cosine(p1) -> evalhelper p1
in
evalhelper e x y
Error: This expression has type float but an expression was expected of type
         int


let _ = eval(Sine(Varx), 0.5, -0.5)
Error: This variant expression is expected to have type expr
       The constructor Varx does not belong to type expr
Hint: Did you mean VarX or VarY?


let rec eval (e,x,y) =
let rec evalhelper e x y =
match e with
| VarX -> x
| VarY -> y
| Sine(p1) -> sin(pi *. evalhelper p1)
| Cosine(p1) -> evalhelper p1
in
evalhelper e x y
Error: This expression has type 'a -> 'a -> 'a
       but an expression was expected of type float


let _ = eval(Sine(Varx), 0.5, -0.5)
Error: This variant expression is expected to have type expr
       The constructor Varx does not belong to type expr
Hint: Did you mean VarX or VarY?


let rec eval (e,x,y) =
let rec evalhelper e x y =
match e with
| VarX -> x
| VarY -> y
| Sine(p1) -> sin(pi *. float evalhelper p1)
| Cosine(p1) -> evalhelper p1
in
evalhelper e x y
Error: This function has type int -> float
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = eval(Sine(Varx), 0.5, -0.5)
Error: This variant expression is expected to have type expr
       The constructor Varx does not belong to type expr
Hint: Did you mean VarX or VarY?


let rec eval (e,x,y) =
let rec evalhelper e x y =
match e with
| VarX -> x
| VarY -> y
| Sine(p1) -> sin(pi *. evalhelper p1)
| Cosine(p1) -> cos(pi *. evalhelper p1)
in
evalhelper e x y
Error: This expression has type 'a -> 'a -> 'a
       but an expression was expected of type float


let _ = eval(Sine(Varx), 0.5, -0.5)
Error: This variant expression is expected to have type expr
       The constructor Varx does not belong to type expr
Hint: Did you mean VarX or VarY?


let rec eval (e,x,y) =
let rec evalhelper e x y =
match e with
| VarX -> float x
| VarY -> float y
| Sine(p1) -> sin(pi *. evalhelper p1)
| Cosine(p1) -> cos(pi *. evalhelper p1)
in
evalhelper e x y
Error: This expression has type int -> int -> float
       but an expression was expected of type float


let _ = eval(Sine(Varx), 0.5, -0.5)
Error: This variant expression is expected to have type expr
       The constructor Varx does not belong to type expr
Hint: Did you mean VarX or VarY?


let rec eval (e,x,y) =
let rec evalhelper e x y =
match e with
| VarX -> float x
| VarY -> float y
| Sine(p1) -> sin(pi *. evalhelper p1 x y)
| Cosine(p1) -> cos(pi *. evalhelper p1)
in
evalhelper e x y
Error: This expression has type int -> int -> float
       but an expression was expected of type float


let _ = eval(Sine(Varx), 0.5, -0.5)
Error: This variant expression is expected to have type expr
       The constructor Varx does not belong to type expr
Hint: Did you mean VarX or VarY?



hw2 eval

fix:
let rec eval (e,x,y) =
let rec evalhelper e x y =
match e with
| VarX -> x
| VarY -> y
| Sine(p1) -> sin(pi *. evalhelper p1 x y)
| Cosine(p1) -> cos(pi *. evalhelper p1 x y)
in
evalhelper e x y

let _ = eval(Sine(VarX), 0.5, -0.5)

bad:
let _ = eval(Sine(VarX), 0.5, -0.5)
Error: This expression has type float but an expression was expected of type
         int



hw2 ???

fix:
let _ = sin(pi*.0.3)

bad:
let _ = sin(pi*0.3)
Error: This expression has type float but an expression was expected of type
         int



hw2 build

fix:
let rec build (rand, depth) = 
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand 0 1 = 0) then expr ^ "VarX"
else expr ^ "Var"
| 1 ->
if (rand 0 1 = 0) then 
expr ^ "Sine(" ^ (buildhelper 0 (depth-1) expr) ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 (depth-1) expr ^ ")"
in
buildhelper (rand 0 4) depth ""

bad:
let rec build (rand, depth) = 
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand 0 1 = 0) then expr ^ "VarX"
else expr ^ "Var"
| 1 ->
if (rand 0 1 = 0) then 
expr ^ "Sine(" ^ buildhelper 0 depth-1 expr ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 depth-1 expr ^ ")"
in
buildhelper (rand 0 4) depth ""
Error: This expression has type string -> string
       but an expression was expected of type int


let rec build (rand, depth) = 
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand 0 1 = 0) then expr ^ "VarX"
else expr ^ "Var"
| 1 ->
if (rand 0 1 = 0) then 
expr ^ "Sine(" ^ buildhelper 0 (depth-1) expr ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 depth-1 expr ^ ")"
in
buildhelper (rand 0 4) depth ""
Error: This expression has type string -> string
       but an expression was expected of type int



hw2 build

fix:
let rec build (rand, depth) = 
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand 0 1 = 0) then expr ^ "VarX"
else expr ^ "VarY"
| 1 ->
if (rand 0 1 = 0) then 
expr ^ "Sine(" ^ buildhelper 0 (depth-1) expr ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 (depth-1) expr ^ ")"
| 2 ->
if (rand 0 1 = 0) then 
expr ^ "((" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ "+" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ ")/2)"
else 
expr ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ "*" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr)
| 4 -> 
expr ^ "(" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ "<" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ "?" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ ":" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ ")"
in
buildhelper (rand 0 4) depth ""

let _ = build (rand, 3)

bad:
let rec build (rand, depth) = 
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand 0 1 = 0) then expr ^ "VarX"
else expr ^ "VarY"
| 1 ->
if (rand 0 1 = 0) then 
expr ^ "Sine(" ^ buildhelper 0 (depth-1) expr ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 (depth-1) expr ^ ")"
| 2 ->
if (rand 0 1 = 0) then 
expr ^ "((" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ "+" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ ")/2)"
else 
expr ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ "*" ^ (eTShelper p2 expr)
| 4 -> 
expr ^ "(" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ "<" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ "?" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ ":" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ ")"
in
buildhelper (rand 0 4) depth ""
Error: Unbound value eTShelper


let _ = build (rand, 3)
Error: Unbound value rand
Hint: Did you mean land?



hw2 build

fix:
let g1 () = failwith "to be implemented"

let g2 () = failwith "to be implemented"

let g3 () = failwith "to be implemented"

let c1 () = failwith "to be implemented"

let c2 () = failwith "to be implemented"

let c3 () = failwith "to be implemented"

let rand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let _ = build (rand, 3)

bad:
let _ = build (rand, 3)
Error: Unbound value rand
Hint: Did you mean land?



hw2 build

fix:
let rec build (rand, depth) = 
(*
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand(0,1) = 0) then expr ^ "VarX"
else expr ^ "VarY"
| 1 ->
if (rand(0,1) = 0) then 
expr ^ "Sine(" ^ buildhelper 0 (depth-1) expr ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 (depth-1) expr ^ ")"
| 2 ->
if (rand(0,1) = 0) then 
expr ^ "((" ^ (buildhelper (num-1) (depth-1) expr) ^ "+" ^ (buildhelper (num-1) (depth-1) expr) ^ ")/2)"
else 
expr ^ (buildhelper (num-1) (depth-1) expr) ^ "*" ^ (buildhelper (num-1) (depth-1) expr)
| 3 -> expr ^ (buildhelper (num-1) (depth) expr)
| 4 ->
expr ^ "(" ^ (buildhelper (num-2) (depth-1) expr) ^ "<" ^ (buildhelper (num-2) (depth-1) expr) ^ "?" ^ (buildhelper (num-2) (depth-1) expr) ^ ":" ^ (buildhelper (num-2) (depth-1) expr) ^ ")"
*)
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand(0,1) = 0) then buildX()
else buildY()
| 1 ->
if (rand(0,1) = 0) then 
buildSine(buildhelper 0 0 expr)
else buildCosine(buildhelper 0 0 expr)
| 2 ->
if (rand(0,1) = 0) then 
buildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
else 
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| 3 ->
if (rand(0,1) = 0) then 
buildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
else 
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| 4 ->
buildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| _ ->
buildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
in
buildhelper (rand(1,4)) depth ""

bad:
let rec build (rand, depth) = 
let rec buildhelper num depth expr = 
match num with
(*
| 0 ->
if (rand(0,1) = 0) then expr ^ "VarX"
else expr ^ "VarY"
| 1 ->
if (rand(0,1) = 0) then 
expr ^ "Sine(" ^ buildhelper 0 (depth-1) expr ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 (depth-1) expr ^ ")"
| 2 ->
if (rand(0,1) = 0) then 
expr ^ "((" ^ (buildhelper (num-1) (depth-1) expr) ^ "+" ^ (buildhelper (num-1) (depth-1) expr) ^ ")/2)"
else 
expr ^ (buildhelper (num-1) (depth-1) expr) ^ "*" ^ (buildhelper (num-1) (depth-1) expr)
| 3 -> expr ^ (buildhelper (num-1) (depth) expr)
| 4 ->
expr ^ "(" ^ (buildhelper (num-2) (depth-1) expr) ^ "<" ^ (buildhelper (num-2) (depth-1) expr) ^ "?" ^ (buildhelper (num-2) (depth-1) expr) ^ ":" ^ (buildhelper (num-2) (depth-1) expr) ^ ")"
*)
| 0 ->
if (rand(0,1) = 0) then buildX()
else buildY()
| 1 ->
if (rand(0,1) = 0) then 
buildCosine(buildhelper 0 (depth-1) expr)
else expr ^ "Cosine(" ^ buildhelper 0 (depth-1) expr ^ ")"
| 2 ->
if (rand(0,1) = 0) then 
expr ^ "((" ^ (buildhelper (num-1) (depth-1) expr) ^ "+" ^ (buildhelper (num-1) (depth-1) expr) ^ ")/2)"
else 
expr ^ (buildhelper (num-1) (depth-1) expr) ^ "*" ^ (buildhelper (num-1) (depth-1) expr)
| 3 -> expr ^ (buildhelper (num-1) (depth) expr)
| 4 ->
expr ^ "(" ^ (buildhelper (num-2) (depth-1) expr) ^ "<" ^ (buildhelper (num-2) (depth-1) expr) ^ "?" ^ (buildhelper (num-2) (depth-1) expr) ^ ":" ^ (buildhelper (num-2) (depth-1) expr) ^ ")"
in
let num = rand(1,4) in 
buildhelper num depth ""
Error: This expression has type expr but an expression was expected of type
         string


let rec build (rand, depth) = 
(*
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand(0,1) = 0) then expr ^ "VarX"
else expr ^ "VarY"
| 1 ->
if (rand(0,1) = 0) then 
expr ^ "Sine(" ^ buildhelper 0 (depth-1) expr ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 (depth-1) expr ^ ")"
| 2 ->
if (rand(0,1) = 0) then 
expr ^ "((" ^ (buildhelper (num-1) (depth-1) expr) ^ "+" ^ (buildhelper (num-1) (depth-1) expr) ^ ")/2)"
else 
expr ^ (buildhelper (num-1) (depth-1) expr) ^ "*" ^ (buildhelper (num-1) (depth-1) expr)
| 3 -> expr ^ (buildhelper (num-1) (depth) expr)
| 4 ->
expr ^ "(" ^ (buildhelper (num-2) (depth-1) expr) ^ "<" ^ (buildhelper (num-2) (depth-1) expr) ^ "?" ^ (buildhelper (num-2) (depth-1) expr) ^ ":" ^ (buildhelper (num-2) (depth-1) expr) ^ ")"
*)
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand(0,1) = 0) then buildX()
else buildY()
| 1 ->
if (rand(0,1) = 0) then 
buildSine(buildhelper (depth-1) (depth-1) expr)
else buildCosine(buildhelper 0 (depth-1) (depth-1) expr)
| (2 || 3) ->
if (rand(0,1) = 0) then 
buildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
else 
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| (4 || _) ->
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
in
buildhelper (rand(1,4)) depth ""
Error: Syntax error: operator expected.


let rec build (rand, depth) = 
(*
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand(0,1) = 0) then expr ^ "VarX"
else expr ^ "VarY"
| 1 ->
if (rand(0,1) = 0) then 
expr ^ "Sine(" ^ buildhelper 0 (depth-1) expr ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 (depth-1) expr ^ ")"
| 2 ->
if (rand(0,1) = 0) then 
expr ^ "((" ^ (buildhelper (num-1) (depth-1) expr) ^ "+" ^ (buildhelper (num-1) (depth-1) expr) ^ ")/2)"
else 
expr ^ (buildhelper (num-1) (depth-1) expr) ^ "*" ^ (buildhelper (num-1) (depth-1) expr)
| 3 -> expr ^ (buildhelper (num-1) (depth) expr)
| 4 ->
expr ^ "(" ^ (buildhelper (num-2) (depth-1) expr) ^ "<" ^ (buildhelper (num-2) (depth-1) expr) ^ "?" ^ (buildhelper (num-2) (depth-1) expr) ^ ":" ^ (buildhelper (num-2) (depth-1) expr) ^ ")"
*)
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand(0,1) = 0) then buildX()
else buildY()
| 1 ->
if (rand(0,1) = 0) then 
buildSine(buildhelper (depth-1) (depth-1) expr)
else buildCosine(buildhelper 0 (depth-1) (depth-1) expr)
| 2 ->
if (rand(0,1) = 0) then 
buildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
else 
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| 3 ->
if (rand(0,1) = 0) then 
buildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
else 
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| 4 ->
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| _ ->
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
in
buildhelper (rand(1,4)) depth ""
Error: This function has type int -> int -> 'a -> expr
       It is applied to too many arguments; maybe you forgot a `;'.


let rec build (rand, depth) = 
(*
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand(0,1) = 0) then expr ^ "VarX"
else expr ^ "VarY"
| 1 ->
if (rand(0,1) = 0) then 
expr ^ "Sine(" ^ buildhelper 0 (depth-1) expr ^ ")"
else expr ^ "Cosine(" ^ buildhelper 0 (depth-1) expr ^ ")"
| 2 ->
if (rand(0,1) = 0) then 
expr ^ "((" ^ (buildhelper (num-1) (depth-1) expr) ^ "+" ^ (buildhelper (num-1) (depth-1) expr) ^ ")/2)"
else 
expr ^ (buildhelper (num-1) (depth-1) expr) ^ "*" ^ (buildhelper (num-1) (depth-1) expr)
| 3 -> expr ^ (buildhelper (num-1) (depth) expr)
| 4 ->
expr ^ "(" ^ (buildhelper (num-2) (depth-1) expr) ^ "<" ^ (buildhelper (num-2) (depth-1) expr) ^ "?" ^ (buildhelper (num-2) (depth-1) expr) ^ ":" ^ (buildhelper (num-2) (depth-1) expr) ^ ")"
*)
let rec buildhelper num depth expr = 
match num with
| 0 ->
if (rand(0,1) = 0) then buildX()
else buildY()
| 1 ->
if (rand(0,1) = 0) then 
buildSine(buildhelper 0 0 expr)
else buildCosine(buildhelper 0 0 expr)
| 2 ->
if (rand(0,1) = 0) then 
buildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
else 
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| 3 ->
if (rand(0,1) = 0) then 
buildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
else 
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| 4 ->
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
| _ ->
buildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)
in
buildhelper (rand(1,4)) depth ""
Error: This expression has type 'a * 'b * 'c * 'd
       but an expression was expected of type expr * expr



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile((let k x = f x = x in k b), b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let fixpoint (f,b) = wwhile((let k x = f x != x in k b), b)
Error: Unbound value fixpoint


let fixpoint (f,b) = wwhile((let k x = f x != b in k b), b)
Error: This expression has type bool but an expression was expected of type
         'a -> 'a * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile((let k x = f x = x in f), b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

bad:
let fixpoint (f,b) = wwhile((fun k x -> f x = x), b)
Error: Unbound value fixpoint


let fixpoint (f,b) = wwhile((let k x = f x = x
Error: This function expects too many arguments, it should have type
'a -> 'a * bool


), b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile((let k x = f x = x;), b)
Error: Syntax error


let fixpoint (f,b) = wwhile((let k x = f x = x in k b), b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile((let k x = f x != x in k b), b)
Error: This expression has type bool but an expression was expected of type
         'a -> 'a * bool


let fixpoint (f,b) = wwhile((let k x = f x in (x, x=b)), b)
Error: This expression has type bool but an expression was expected of type
         'a -> 'a * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile((let k x = f x in (b, (k b)!=b)), b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

bad:
let fixpoint (f,b) = wwhile({let k x = f x in (b, k b!=b)), b
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile({let k x = f x in (b, (k b)!=b)), b
Error: Syntax error: operator expected.


)
Error: Syntax error: operator expected.



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

bad:
let fixpoint (f,b) = wwhile((let k x = f x in (b, b!=b)), b)
Error: Unbound value fixpoint


let fixpoint (f,b) = wwhile(let k x = f x in (b, b!=b), b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile(let k x = f x = y in (x, y!=x), b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value y


let fixpoint (f,b) = wwhile(let k x = f x = x in (x, x!=x), b)
Error: Unbound value fixpoint


let fixpoint (f,b) = wwhile(let k x = let y = f x in (x, y!=x), b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile(let k x = let y = f x in f x in (x, y!=x), b)
Error: Syntax error: operator expected.


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile(let f x = let xx = x*x*x in (xx, xx < 100), b)
Error: Unbound value fixpoint


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Syntax error: operator expected.



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)

bad:
let fixpoint (f,b) = wwhile(let g x = f x in (x, x<100), b)
Error: Unbound value fixpoint


let fixpoint (f,b) = wwhile(let g x = f x in (g x, x<100), b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile(let g x = f x in g x in (x, x<100), b
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


)
Characters 27-28:
  let fixpoint (f,b) = wwhile(let g x = f x in g x in (x, x<100), b;;
                             ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Syntax error


let fixpoint (f,b) = wwhile(let g x = f x in g b in (x, x<100), b
Error: Unbound value fixpoint


)
Characters 27-28:
  let fixpoint (f,b) = wwhile(let g x = f x in g b in (x, x<100), b;;
                             ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Syntax error


let fixpoint (f,b) = wwhile((let g x = f x in g b in (x, x<100)
Error: Unbound value fixpoint


), b
Characters 28-29:
  let fixpoint (f,b) = wwhile((let g x = f x in g b in (x, x<100);;
                              ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let fixpoint (f,b) = wwhile(let g x = (f x) in g b in (x, x<100), b
Error: Syntax error


)
Characters 27-28:
  let fixpoint (f,b) = wwhile(let g x = (f x) in g b in (x, x<100), b;;
                             ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Syntax error


let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1
Error: Unbound value fixpoint



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile(let g x = (f x) in g b, b)
Error: This expression has type bool but an expression was expected of type
         'a -> 'a * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile(let g x = f x in g b, b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile(let g x = f x in g b != x, b)
Error: This expression has type int -> int
       but an expression was expected of type int -> int -> int * bool
       Type int is not compatible with type int -> int * bool 


let fixpoint (f,b) = wwhile(let g x = f x in g b != b, b)
Error: This expression has type bool but an expression was expected of type
         'a -> 'a * bool



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile(let g x = f x in (g b, (g b)!= b), b)
Error: This expression has type int -> int
       but an expression was expected of type int -> int -> int * bool
       Type int is not compatible with type int -> int * bool 


let fixpoint (f,b) = wwhile(let xx = x*x*x in (xx, xx < 100), b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile(let xx = b*b*b in (xx, xx < 100), b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile(let f x = let xx = x*x*x in (xx, xx < 100), b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile((let g x = f x in f), b)
Error: Syntax error: operator expected.



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile((let g f x = let y = f x in (y,y != x)), b)
Error: This expression has type int -> int
       but an expression was expected of type int -> int * bool
       Type int is not compatible with type int * bool 


let fixpoint (f,b) = wwhile((let y = let g f x = f x in (y,y != x)), b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile((let g x = f x != x in (y,y != x)), b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile((let g x = f x in (x, x!=x)), b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile((let g x = f x !=x), b)
Error: This expression has type int -> int
       but an expression was expected of type int -> int * bool
       Type int is not compatible with type int * bool 


let fixpoint (f,b) = wwhile((let g x = f x !=x in g b), b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile((let g x = f x in g b), b)
Error: This expression has type bool but an expression was expected of type
         'a -> 'a * bool



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g b), b)
Error: This expression has type int -> int
       but an expression was expected of type int -> int -> int * bool
       Type int is not compatible with type int -> int * bool 


let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g), b)
Error: This expression has type 'a * bool
       but an expression was expected of type 'b -> 'b * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile((let g b = let xx = f x in (xx, xx!=b) in g), b)

bad:
let fixpoint (f,b) = wwhile((let g x = let xx = f x in (b, xx!=b) in g), b)
Error: Unbound value wwhile


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile((let g x = let xx = f xx in (xx, xx!=b) in g), b)

bad:
let fixpoint (f,b) = wwhile((let g x = let xx = f b in (xx, xx!=b) in g), b)
Error: Unbound value wwhile


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g b), b)

bad:
let fixpoint (f,b) = wwhile((let g xx = let xx = f x in (xx, xx!=b) in g), b)
Error: Unbound value wwhile


let fixpoint (f,b) = wwhile((let g x = xx = f x in (xx, xx!=b) in g
Error: Unbound value wwhile


let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g), b)
Characters 28-29:
  let fixpoint (f,b) = wwhile((let g x = xx = f x in (xx, xx!=b) in g;;
                              ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=b) in inwwhile), b)

bad:
let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g), b)
Error: Unbound value wwhile


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile((let inwwhile x = f x in (inwwhile b, (inwwhile b)!=b)), b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

bad:
let fixpoint (f,b) = wwhile((let inwwhile x = f x in (x, (inwwhile b)!=b)), b)
Error: Unbound value wwhile


let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=b)), b)
Error: Unbound value wwhile


let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=b) in inwwhile), b)
Error: Syntax error: operator expected.


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=(f b)) in inwwhile), b)

bad:
let _ = fixpoint (collatz, 3)
Error: Unbound value fixpoint


let _ = fixpoint (collatz, 48)
Error: Unbound value fixpoint


let _ = fixpoint (collatz, 107)
Error: Unbound value fixpoint


let _ = fixpoint (collatz, 9001)
Error: Unbound value fixpoint



hw2 fixpoint

fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value fixpoint



hw2 fixpoint

fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

bad:
let fixpoint (f,b) = 
wwhile((let helper x = let res = f x in (res, res!=(f b)) in helper), b)
Error: Unbound value fixpoint


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile


let fixpoint (f,b) = 
wwhile((let helper x = let res = f x in (f b, res!=(f b)) in helper), b)
Error: Unbound value fixpoint


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile


let fixpoint (f,b) = 
wwhile((let helper x = let res = f x in (b, res!=(f b)) in helper), b)
Error: Unbound value fixpoint


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let fixpoint (f,b) = 
wwhile((let helper x = let res = f x in (res, res!=b) in helper), b)

bad:
let _ = fixpoint (collatz, 3)
Error: Unbound value fixpoint


let _ = fixpoint (collatz, 48)
Error: Unbound value fixpoint


let _ = fixpoint (collatz, 107)
Error: Unbound value fixpoint


let _ = fixpoint (collatz, 9001)
Error: Unbound value fixpoint


let fixpoint (f,b) = 
wwhile((let helper x = let res = f x in (f b, res!=b) in helper), b)
Error: Unbound value fixpoint


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let fixpoint (f,b) = 
wwhile((let helper x = let res = f x in (res, res!=(f b)) in helper), b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile


let fixpoint (f,b) = 
wwhile((let helper x = let res = f x in (res, res!=(f b)) in 
printf("%d\n", helper)), b)
Error: Unbound value fixpoint


let fixpoint (f,b) = 
wwhile(let helper x = (f x != (f b)) in helper), b
Error: Unbound value wwhile


)
Error: Unbound value wwhile


let fixpoint (f,b) = 
wwhile(let helper x = (f x != (f b)) in helper b), b
Error: Syntax error


let fixpoint (f,b) = 
wwhile(let helper x = (f x != (f b)) in helper), b
Error: Unbound value wwhile


let fixpoint (f,b) = 
wwhile(let helper x = (f x, f x != (f b)) in helper), b
Error: Unbound value wwhile


let fixpoint (f,b) = 
wwhile(let helper x = (f x, f x = (f b)) in helper), b
Error: Unbound value wwhile


let fixpoint (f,b) = 
wwhile(let helper x = (f x, f x = (f b)) in helper b), b
Error: Unbound value wwhile


)
Error: Unbound value wwhile


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Syntax error


let fixpoint (f,b) = 
wwhile(let helper x = (f x, f x = (f b)) in helper b, b)
Error: Unbound value fixpoint


let fixpoint (f,b) = 
wwhile(let helper x = (f x, f x = (f b)) in helper b, b)
Error: Unbound value wwhile


let fixpoint (f,b) = 
wwhile((let helper x = (f x, f x = (f b)) in helper b), b)
Error: Unbound value wwhile


let fixpoint (f,b) = 
wwhile((let helper x = (f x, (f x)=(f b)) in helper b), b)
Error: Unbound value wwhile


let fixpoint (f,b) = 
wwhile((let helper x = (f x, (f x)=(f b)) in helper), b)
Error: Unbound value wwhile


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile


let fixpoint (f,b) = 
wwhile((let helper x = (f b, b=(f b)) in helper), b)
Error: Unbound value fixpoint


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile


let fixpoint (f,b) = 
wwhile((let helper x = (f b, b=(f b)) in helper b), b)
Error: Unbound value fixpoint


let fixpoint (f,b) = 
wwhile((let helper x = (f b, b=f b) in helper), b)
Error: Unbound value wwhile


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, b!=f x) in helper), b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, b=f x) in helper), b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let fixpoint (f,b) = 
wwhile((let helper x = f x, b=f x in helper b), b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

bad:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, b=f x) in helper b), b)
Error: Unbound value wwhile


let fixpoint (f,b) = 
wwhile((let helper x = f x, b=f x in helper b), b)
Error: Unbound value wwhile


let fixpoint (f,b) = 
wwhile((let helper x = f x, b=f x in helper), b)
Error: Unbound value wwhile


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, f x = b) in helper), b)

bad:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, b=f x) in helper b), b)
Error: Unbound value fixpoint


let fixpoint (f,b) = 
wwhile((let helper x = (f x, b=f x) in (helper b)), b)
Error: Unbound value wwhile


let fixpoint (f,b) = 
wwhile((let helper x = (f x, b=f x) in helper b), b)
Error: Unbound value wwhile


let fixpoint (f,b) = 
wwhile((let helper b = (f b, b=f x) in helper), b)
Error: Unbound value wwhile


let fixpoint (f,b) = 
wwhile((let helper b = (f b, b=f b) in helper), b)
Error: Unbound value wwhile


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile


let fixpoint (f,b) = 
wwhile((let helper x = (f x, b < 10) in helper), b)
Error: Unbound value fixpoint


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile


let fixpoint (f,b) = 
wwhile((let helper x = (f x, f x=x) in helper), b)
Error: Unbound value fixpoint


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let fixpoint (f,b) = 
wwhile((let helper x = (f b, x!=(f x)) in helper), b)

bad:
let fixpoint (f,b) = 
wwhile((let helper x = (f x, (f x)=x) in helper b), b)
Error: Unbound value wwhile


let fixpoint (f,b) = 
wwhile((let helper x = (f x, (f x)=x) in helper), b)
Error: Unbound value wwhile


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile


let fixpoint (f,b) = 
wwhile((let helper x = (f x, x!=(f x)) in helper b), b)
Error: Unbound value fixpoint


let fixpoint (f,b) = 
wwhile((let helper x = (f x, x!=(f x)) in helper), b)
Error: Unbound value wwhile


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile


let fixpoint (f,b) = 
wwhile((let helper x = (f x, x!=(f x)) in (helper b)), b)
Error: Unbound value fixpoint


let fixpoint (f,b) = 
wwhile((let helper x = (f x, x!=(f x)) in helper b), b)
Error: Unbound value wwhile


let fixpoint (f,b) = 
wwhile((let helper x = (f x, x!=(f x)) in helper), b)
Error: Unbound value wwhile


let fixpoint (f,b) = 
wwhile((let helper x = (f x, b!=(f x)) in helper), b)
Error: Unbound value wwhile


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let fixpoint (f,b) = 
wwhile((let helper x = let xx = f x in (f x, x!=(f x)) in helper), b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

bad:
let fixpoint (f,b) = 
wwhile((let helper x = let xx = f x in (xx, x!=(xx)) in helper), b)
Error: Unbound value wwhile


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let _ = fixpoint (collatz, 3)
Error: Unbound value fixpoint


let _ = fixpoint (collatz, 48)
Error: Unbound value fixpoint


let _ = fixpoint (collatz, 107)
Error: Unbound value fixpoint


let _ = fixpoint (collatz, 9001)
Error: Unbound value fixpoint


let fixpoint (f,b) = 
wwhile((let helper x = (f x, x!=(f x)) in helper), b)
Error: Unbound value fixpoint



hw3 sqsum

fix:
let sqsum xs = 
let f a x = (+)
in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = failwith "to be implemented" in
let base = base + xs**2 in
List.fold_left f base xs
Error: Unbound value base


let _ = sqsum []
Error: Unbound value sqsum


let sqsum xs = 
let f a x = base**2 in
let base = base+a in
List.fold_left f base xs
Error: Unbound value base


let sqsum xs = 
let f a x = base**2 in
let base = a in
List.fold_left f base xs
Error: Unbound value base


let sqsum xs = 
let f a x = a**2 in
let base = a in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         float


let sqsum xs = 
let f a x = int a**2 in
let base = a in
List.fold_left f base xs
Error: Unbound value int


let sqsum xs = 
let f a x = a+base in
let base = a in
List.fold_left f base xs
Error: Unbound value base


let sqsum xs = 
let f a x = a in
let base = a in
List.fold_left f base xs
Error: Unbound value a


let sqsum xs = 
let f a x = (+) in
let base = a in
List.fold_left f base xs
Error: Unbound value a


let sqsum xs = 
let f a x = (+) in
let base = base + f a x in
List.fold_left f base xs
Error: Unbound value base


let sqsum xs = 
let f a x = (+) in
let base = f a x in
List.fold_left f base xs
Error: Unbound value a


let sqsum xs = 
let f a x = (+) in
let base = base in
List.fold_left f base xs
Error: Unbound value base


let sqsum xs = 
let f a x = (+) in
let base = a ** 2 in
List.fold_left f base xs
Error: Unbound value a


let sqsum xs = 
let f a x = (+) in
let base = 3**2 in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         float


let sqsum xs = 
let f a x = (+) in
let base = 2 in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         int -> int -> int


let sqsum xs = 
let f a x = (+) in
let base = base + 1 in
List.fold_left f base xs
Error: Unbound value base


let sqsum xs = 
let f a x = (+) in
let base = 0 in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         int -> int -> int


let sqsum xs = 
let f a x = (+)
in
let base = base + a**2
in
List.fold_left f base xs
Error: Unbound value base


let sqsum xs = 
let f a x = (+)
in
let base = a**2
in
List.fold_left f base xs
Error: Unbound value a


let sqsum xs = 
let f a x = (+)
in
let base = f a**2 x
in
List.fold_left f base xs
Error: Unbound value a


let sqsum xs = 
let f a x = (+)
in
let base = f 2 x
in
List.fold_left f base xs
Error: Unbound value x



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a**2 in
let base = f 2 xs
in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         float


let sqsum xs = 
let f a x = a + base in
let base = f 2 xs
in
List.fold_left f base xs
Error: Unbound value base



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a*a in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a in
let base = []
in
List.fold_left f base xs
Error: This expression has type 'a list
       but an expression was expected of type int


let sqsum xs = 
let f a x = a*a in
let base = _
in
List.fold_left f base xs
Error: Syntax error


let sqsum xs = 
let f a x = a*a in
let base = 
match xs with
| [] -> []
| x::xs' -> f x xs'
in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         'a list



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a*a in
let base = 0
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = x*x in
let base = f 2 xs
in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         int list



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a*a in
let base = f 4 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = 
match x with
| hd::tl -> hd * hd + f a tl
in
let base = f 4 xs
in
List.fold_left f base xs
Error: Unbound value f


let sqsum xs = 
let f a x = 
match x with
| hd::tl -> hd * hd + (f a tl)
in
let base = f 4 xs
in
List.fold_left f base xs
Error: Unbound value f


let sqsum xs = 
let f a x = 
match x with
| hd::tl -> hd * hd
in
let base = f 4 xs
in
List.fold_left f base xs
Error: This expression has type int list
       but an expression was expected of type int list list
       Type int is not compatible with type int list 



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a + x*x in
let base = f 4 xs
in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

bad:
let sqsum xs = 
let f a x = a + x*x in
let base = f 4 xs
in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         int list



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a*a in
let base = f (f 0 xs) xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a in
let base = f a xs
in
List.fold_left f base xs
Error: Unbound value a


let sqsum xs = 
let f a x = a*a in
let base = f base xs
in
List.fold_left f base xs
Error: Unbound value base


let sqsum xs = 
let f a x = a*a in
let base = f (f a xs) xs
in
List.fold_left f base xs
Error: Unbound value a



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a*a in
let base = f 4 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a in
let base = f _ xs
in
List.fold_left f base xs
Error: Syntax error


let sqsum xs = 
let f a x = a*a in
let base = f 4 thing
in
List.fold_left f base xs
Error: Unbound value thing



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a*a in
let base = f 8 xs
in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

bad:
let sqsum xs = 
let f a x = a*a + x in
let base = f 4 xs
in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         int list


let sqsum xs = 
let f a x = a*a in
let base = base + f 4 xs
in
List.fold_left f base xs
Error: Unbound value base


let sqsum xs = 
let f a x = a*a in
let base = f base xs
in
List.fold_left f base xs
Error: Unbound value base


let sqsum xs = 
let f a x = a*a in
let base = f xs xs
in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         'a list



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a*a in
let base = 
match xs with
| [] -> 0
| hd::tl -> f (f 0 hd) tl
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a in
let base = 
match xs with
| [] -> base
| hd::tl -> f (f base hd) tl
in
List.fold_left f base xs
Error: Unbound value base


let sqsum xs = 
let f a x = a*a in
let base = 
match xs with
| [] -> 0
| hd::tl -> f (f base hd) tl
in
List.fold_left f base xs
Error: Unbound value base



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a*a in
let base = 
match xs with
| [] -> 4
| hd::tl -> f (f 2 hd) tl
in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

bad:
let sqsum xs = 
let f a x =  
match xs with
| [] -> a
| hd::tl -> f (f a hd) tl in
let base = 0
in
List.fold_left f base xs
Error: Unbound value f


let sqsum xs = 
let rec f a x =  
match xs with
| [] -> a
| hd::tl -> f (f a hd) tl in
let base = 0
in
List.fold_left f base xs
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a*a in
let base = f 2 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a in
let base = base
in
List.fold_left f base xs
Error: Unbound value base



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a*a in
let base = 
match xs with
| [] -> f 0 xs
| hd::tl -> f (f hd hd) tl
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a in
let base = 
match xs with
| [] -> f 0 xs
| hd::tl -> f (f base hd) tl
in
List.fold_left f base xs
Error: Unbound value base


let sqsum xs = 
let f a x = a*a in
let base = 
match xs with
| [] -> f 0 xs
| hd::tl -> f (f a hd) tl
in
List.fold_left f base xs
Error: Unbound value a



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a*a in
let base = 
match xs with
| hd::tl -> f (f hd hd) tl
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a in
let base = 
match xs with
| [] -> xs
| hd::tl -> f (f hd hd) tl
in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         int list



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a*a in
let base = 
match xs with
| hd::tl -> f hd hd + f (f hd hd) tl
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a in
let base = 
match xs with
| hd::tl -> f hd hd + f tl tl
in
List.fold_left f base xs
Error: This expression has type int list
       but an expression was expected of type int



hw3 sqsum

fix:
let sqsum xs = 
let f a x = match xs with
| [] -> a
| hd::tl -> hd*hd in
let base = f 0 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = match xs with
| [] -> a
| hd::tl -> f hd tl in
let base = f 0 xs
in
List.fold_left f base xs
Error: Unbound value f



hw3 sqsum

fix:
let sqsum xs = 
let f a x = 
match xs with
| [] -> a
| hd::tl -> a + hd*hd in
let base = f 4 xs
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = 
match xs with
| [] -> a
| hd::tl -> a + hd*hd in
let base = []
in
List.fold_left f base xs
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a + x*x in
let base = match xs with
| [] -> 0
| hd::tl -> f 0 hd
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = 
match xs with
| [] -> a
| hd::tl -> a + x*x in
let base = f 0 xs
in
List.fold_left f base xs
Error: This expression has type 'a list
       but an expression was expected of type int


let sqsum xs = 
let f a x = a + x*x in
let base = match xs with
| [] -> []
| hd::tl -> f 0 hd
in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         'a list



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 
match xs with
| [] -> f 0 0
| hd::tl -> f 0 hd
in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a + x*x in
let base = 
match xs with
| [] -> f 0 []
| hd::tl -> f 0 hd
in
List.fold_left f base xs
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 
match xs with
| [] -> 0
| hd::tl -> f 0 hd
in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

bad:
let sqsum xs = 
let f a x = a + x*x in
let base = 
match xs with
| [] -> 0
| hd::tl -> f -1 hd
in
List.fold_left f base xs
Error: This expression has type int -> int -> int
       but an expression was expected of type int



hw3 sqsum

fix:
let _ = sqsum [1;2;3]

List.fold_left (fun sum a -> sum + a * a) 0 [2;5;3;1]

bad:
let _ = sqsum [1;2;3]

List.fold_left (fun sum a -> sum + a * a) 0 [2;5;3;1]
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe fs = 
let f a x = x in
let base = 0
in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe fs = 
let f a x = fun x -> a x in
let base = fun x -> x
in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = 0
in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let _ = pipe [] 3
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let pipe fs = 
let f a x =  in
let base = x
in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = fun x -> a x in
let base = x
in
List.fold_left f base fs
Error: Unbound value x



hw3 pipe

fix:
let pipe fs = 
let f a x = fun x -> a x in
let base = fun x -> 0
in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

bad:
let pipe fs = 
let f a x = fun x -> a x in
let base = fun x
in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = fun x -> a x in
let base = fun x -> x
in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> x a in
let base = fun x -> x
in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside ('a -> 'c) -> 'c



hw3 pipe

fix:
let pipe fs = 
let f a x = fun x -> a x in
let base = fun x -> 0
in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

bad:
let pipe fs = 
let f a x = fun x -> a x in
let base = x
in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = fun x -> a x in
let base = fun x -> a
in
List.fold_left f base fs
Error: Unbound value a



hw3 pipe

fix:
let pipe fs = 
let f a x = fun y ->  a x in
let base = fun x -> x
in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun y ->  y a x in
let base = fun x -> x
in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> ('a -> 'b -> 'c) -> 'c
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside ('a -> 'b -> 'c) -> 'c



hw3 pipe

fix:
let pipe fs = 
let f a x = fun k -> x k(a) in
let base = fun x -> x
in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

bad:
let pipe fs = 
let f a x = fun y ->  a (y x) in
let base = fun x -> x
in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'c -> ('c -> 'a) -> 'b
       but an expression was expected of type ('a -> 'b) -> 'c -> 'a -> 'b
       The type variable 'a occurs inside 'c -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x = fun k -> x a in
let base = fun x -> x
in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         (int -> int) -> int


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This expression has type int but an expression was expected of type
         (int -> int) -> int



hw3 pipe

fix:
let pipe fs = 
let f a x = fun k -> x k(k) in
let base = fun x -> x
in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun k -> x k(f a k) in
let base = fun x -> x
in
List.fold_left f base fs
Error: Unbound value f



hw3 pipe

fix:
let pipe fs = 
let f a x = fun k -> x k(a) in
let base = fun x -> x
in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         int -> int


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This expression has type int but an expression was expected of type
         int -> int



hw3 pipe

fix:
let pipe fs = 
let f a x = fun k -> a x in
let base = fun y -> y
in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

bad:
let pipe fs = 
let f a x = fun k -> fun a x in
let base = fun y -> y
in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = fun k -> a k(x) in
let base = fun y -> y
in
List.fold_left f base fs
Error: This expression has type ('a -> 'b -> 'c) -> 'b -> 'a -> 'c
       but an expression was expected of type
         ('a -> 'b -> 'c) -> 'b -> 'a -> 'b -> 'c
       The type variable 'c occurs inside 'b -> 'c



hw3 pipe

fix:
let pipe fs = 
let f a x = fun k -> x k a in
let base = fun x -> x
in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs = 
let f a x = fun k -> x a k in
let base = fun x -> x
in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

bad:
et _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: Syntax error


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This expression has type int but an expression was expected of type
         (int -> int) -> int



hw3 clone

fix:
let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x (n-1))

bad:
let rec clone x n =
match n > 0 with
| true -> x::(clone x n-1)
| false -> x
Error: This expression has type 'a list
       but an expression was expected of type int


let _ = clone 3 5
Error: Unbound value clone


let _ = clone "foo" 2
Error: Unbound value clone


let _ = clone clone (-3)
Error: Unbound value clone


let rec clone x n =
match n > 0 with
| true -> x::(clone x n-1)
| false -> x::[]
Error: This expression has type 'a list
       but an expression was expected of type int


let _ = clone 3 5
Error: Unbound value clone


let _ = clone "foo" 2
Error: Unbound value clone


let _ = clone clone (-3)
Error: Unbound value clone


let rec clone x n =
match n > 0 with
| true -> x @ clone x n-1
| false -> x @ []
Error: This expression has type int but an expression was expected of type
         'a list


let _ = clone 3 5
Error: Unbound value clone


let _ = clone "foo" 2
Error: Unbound value clone


let rec clone x n =
match n > 0 with
| true -> x @ clone x n-1
| false -> []
Error: This expression has type int but an expression was expected of type
         'a list


let rec clone x n =
match n = 0 with
| true -> x
| false -> x @ clone x n-1
Error: This expression has type 'a list
       but an expression was expected of type int


let _ = clone 3 5
Error: Unbound value clone


let _ = clone "foo" 2
Error: Unbound value clone


let rec clone x n =
match n = 0 with
| true -> (x)
| false -> (x) @ (clone x n-1)
Error: This expression has type 'a list
       but an expression was expected of type int


let _ = clone 3 5
Error: Unbound value clone


let _ = clone "foo" 2
Error: Unbound value clone


let _ = clone clone (-3)
Error: Unbound value clone


let rec clone x n =
match n = 0 with
| true -> []
| false -> (x) @ (clone x n-1)
Error: This expression has type 'a list
       but an expression was expected of type int


let _ = clone 3 5
Error: Unbound value clone


let _ = clone "foo" 2
Error: Unbound value clone


let _ = clone clone (-3)
Error: Unbound value clone


let rec clone x n =
match n = 0 with
| true -> []
| false -> (x) :: (clone x n-1)
Error: This expression has type 'a list
       but an expression was expected of type int


let rec clone x n =
match n = 0 with
| true -> []
| false -> (x) @ (clone x n-1)
Error: This expression has type 'a list
       but an expression was expected of type int


let rec clone x n =
match n = 0 with
| true -> []
| false -> (x) :: (clone x n-1)
Error: This expression has type 'a list
       but an expression was expected of type int


let _ = clone 3 5
Error: Unbound value clone


let _ = clone "foo" 2
Error: Unbound value clone


let _ = clone clone (-3)
Error: Unbound value clone


let rec clone x n =
match (n = 0) with
| true -> []
| false -> (x) :: (clone x n-1)
Error: This expression has type 'a list
       but an expression was expected of type int


let _ = clone 3 5
Error: Unbound value clone


let _ = clone "foo" 2
Error: Unbound value clone


let _ = clone clone (-3)
Error: Unbound value clone



hw3 padZero

fix:
let padZero l1 l2 =
if(List.length l1 > List.length l2) then
clone 0 (List.length l1 - List.length l2) @ l2
else if (List.length l1 < List.length l2) then
clone 0 (List.length l2 - List.length l1) @ l1

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

bad:
let padZero l1 l2 =
if(List.length l1 > List.length l2) then
(clone 0 (List.length l1 - List.length l2)) @ l2
else if (List.length l1 < List.length l2) then
clone 0 (List.length l2 - List.length l1) @ l1
Error: This expression has type int list
       but an expression was expected of type unit


let padZero l1 l2 =
if(List.length l1 > List.length l2) then
(clone 0 (List.length l1 - List.length l2)) @ l2
else if (List.length l1 < List.length l2) then
(clone 0 (List.length l2 - List.length l1)) @ l1
Error: This expression has type int list
       but an expression was expected of type unit


let padZero l1 l2 =
if(List.length l1 > List.length l2) then
clone 0 (List.length l1 - List.length l2) @ l2
else if (List.length l1 < List.length l2) then
clone 0 (List.length l2 - List.length l1) @ l1
Error: This expression has type int list
       but an expression was expected of type unit



hw3 padZero

fix:
let padZero l1 l2 =
if(List.length l1 > List.length l2) then
l1::(clone 0 (List.length l1 - List.length l2) @ l2)
else if (List.length l1 < List.length l2) then
l2::(clone 0 (List.length l2 - List.length l1) @ l1)

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

bad:
let padZero l1 l2 =
if(List.length l1 > List.length l2) then
l1::(clone 0 (List.length l1 - List.length l2) @ l2)
else if (List.length l1 < List.length l2) then
clone 0 (List.length l2 - List.length l1) @ l1
Error: This expression has type int list
       but an expression was expected of type 'a list list
       Type int is not compatible with type 'a list 



hw3 padZero

fix:
let padZero l1 l2 =
if(List.length l1 > List.length l2) then
l1::((clone 0 (List.length l1 - List.length l2)) @ l2)
else if (List.length l1 < List.length l2) then
l2::((clone 0 (List.length l2 - List.length l1)) @ l1)

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

bad:
let padZero l1 l2 =
if(List.length l1 > List.length l2) then
l1::((clone 0 (List.length l1 - List.length l2)) @ l2)
else if (List.length l1 < List.length l2) then
l2::((clone 0 (List.length l2 - List.length l1)) @ l1)
Error: This expression has type int list
       but an expression was expected of type 'a list list
       Type int is not compatible with type 'a list 



hw3 padZero

fix:
let padZero l1 l2 =
match List.length l1 > List.length l2 with
| true -> l1::((clone 0 (List.length l1 - List.length l2)) @ l2)
| false -> ((clone 0 (List.length l2 - List.length l1)) @ [l1])::l2

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

bad:
let padZero l1 l2 =
if(List.length l1 > List.length l2) then
l1@[(clone 0 (List.length l1 - List.length l2)) @ [l2]]
else if (List.length l1 < List.length l2) then
((clone 0 (List.length l2 - List.length l1)) @ [l1])::l2
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 ???

fix:
let _ = ([0;0]@[1;1])

bad:
let _ = [9;9;9;9]::([0;0]@[1;1])
Error: This expression has type int list
       but an expression was expected of type int list list
       Type int is not compatible with type int list 


let _ = [9;9;9;9]::([0;0]::[1;1])
Error: This expression has type int but an expression was expected of type
         int list


let _ = [9;9;9;9]::([0;0]@[1;1])
Error: This expression has type int list
       but an expression was expected of type int list list
       Type int is not compatible with type int list 



hw3 ???

fix:
let _ = List.append ([0;0]@[1;1]) [1]

bad:
let _ = ([0;0]@[1;1])::[1]
Error: This expression has type int but an expression was expected of type
         int list


let _ = List.append [0;0]@[1;1] [1]
Error: This expression has type int list -> int list
       but an expression was expected of type 'a list



hw3 padZero

fix:
let _ = (([0;0]@[1;1]), [1])

let padZero l1 l2 =
match List.length l1 > List.length l2 with
| true -> (l1,((clone 0 (List.length l1 - List.length l2)) @ l2))
| false -> (((clone 0 (List.length l2 - List.length l1)) @ [l1]),l2)

bad:
let _ = [9;9;9;9]::([0;0]@[1;1])
Error: This expression has type int list
       but an expression was expected of type int list list
       Type int is not compatible with type int list 


let padZero l1 l2 =
match List.length l1 > List.length l2 with
| true -> (l1,((clone 0 (List.length l1 - List.length l2)) @ l2))
| false -> (((clone 0 (List.length l2 - List.length l1)) @ [l1]),l2)
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = [0] in
let args = l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = 0 in
let args = l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a * 'b



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = 0 in
let args = f l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = 0 in
let args = (l1,l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type int list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = () in
let base = ([],[]) in
let args = f l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = ([],[]) in
let args = f l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b list
       but an expression was expected of type int


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = in
let base = ([],[]) in
let args = f l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = ([],[]) in
let base = ([],[]) in
let args = f l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b list
       but an expression was expected of type 'c list



hw3 mulByDigit

fix:
let rec mulByDigit i l = 
let comb a (hd::tl) =
a + hd
in
let rec mBDhelper i x =
match x with
| [] -> []
| hd::tl ->
if (hd*i-9 != 0) then
(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))
else
(hd*i)::(mBDhelper i tl)
in
mBDhelper i l

let _ = mulByDigit 9 [9;9;9;9]

bad:
let rec mulByDigit i l = 
let rec mBDhelper i x =
match x with
| [] -> []
| hd::tl ->
if (hd*i/10 != 0) then
hd*i mod 10::(hd*i/10 + mBDhelper i tl)
else
(hd*i)::(mBDhelper i tl)
in
mBDhelper i l
Error: This expression has type int list
       but an expression was expected of type int


let rec mulByDigit i l = 
let rec mBDhelper i x =
match x with
| [] -> 0
| hd::tl ->
if (hd*i/10 != 0) then
(hd*i mod 10)::(hd*i/10 + mBDhelper i tl)
else
(hd*i)::(mBDhelper i tl)
in
mBDhelper i l
Error: This expression has type 'a list
       but an expression was expected of type int


let rec mulByDigit i l = 
let rec mBDhelper i x =
match x with
| [] -> []
| hd::tl ->
if (hd*i-9 != 0) then
(hd*i/10)::(hd*i mod 10 + mBDhelper i tl)
else
(hd*i)::(mBDhelper i tl)
in
mBDhelper i l
Error: This expression has type int list
       but an expression was expected of type int



hw3 mulByDigit

fix:
let rec mulByDigit i l = 
let comb a b =
match b with
| [] -> (a)
| hd::tl -> (a + hd)
in
let rec mBDhelper i x =
match x with
| [] -> []
| hd::tl ->
if (hd*i-9 != 0) then
(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))
else
(hd*i)::(mBDhelper i tl)
in
mBDhelper i l

let _ = mulByDigit 9 [9;9;9;9]

bad:
let rec mulByDigit i l = 
let comb a b =
match b with
| [] -> a
| hd::tl -> a + hd
in
let rec mBDhelper i x =
match x with
| [] -> []
| hd::tl ->
if (hd*i-9 != 0) then
(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))
else
(hd*i)::(mBDhelper i tl)
in
mBDhelper i l
Error: This expression has type int but an expression was expected of type
         int list



hw3 mulByDigit

fix:
let rec mulByDigit i l = 
let comb a b =
match b with
| [] -> [a]
| hd::tl -> [a + hd]::[tl]
in
let rec mBDhelper i x =
match x with
| [] -> []
| hd::tl ->
if (hd*i > 9) then
(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))
else
(hd*i)::(mBDhelper i tl)
in
mBDhelper i l

let _ = mulByDigit 9 [9;9;9;9]

bad:
let rec mulByDigit i l = 
let comb a b =
match b with
| [] -> [a]
| hd::tl -> [a + hd]::tl
in
let rec mBDhelper i x =
match x with
| [] -> []
| hd::tl ->
if (hd*i > 9) then
(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))
else
(hd*i)::(mBDhelper i tl)
in
mBDhelper i l
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 bigAdd

fix:
let bigAdd l1 l2 =
let add (l1, l2) =
let f a x =
let carry =
match a with
| (x,y) -> x in
match x with
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = () in
let base = ([],[]) in
let args = (l1, l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b list
       but an expression was expected of type unit



hw3 bigAdd

fix:
let bigAdd l1 l2 =
let add (l1, l2) =
let f a x =
match x with
| (addend_a,addend_b) ->
let prevcarry = 
match a with
| (x, y) -> x in
let new_carry = (prevcarry + addend_a + addend_b) / 10 in
let digit = (prevcarry + addend_a + addend_b) mod 10
in
match a with
| (x,[]) -> (new_carry, new_carry::[digit]) 
| (x, c::d::y) -> (new_carry, new_carry::digit::d::y) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

bad:
let bigAdd l1 l2 =
let add (l1, l2) =
let f a x =
match x with
| (addend_a,addend_b) ->
let prevcarry = 
match a with
| (x, y) -> x in
let new_carry = (prevcarry + addend_a + addend_b) / 10 in
let digit = (prevcarry + addend_a + addend_b) mod 10
in
match a with
| (x,[]) -> (new_carry, new_carry::digit) 
| (x, c::d::y) -> (new_carry, new_carry::digit::d::y) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         int list



hw3 bigMul

fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0
in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = fun k -> x (a k) in
let base = fun y -> y
in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = 
match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ x in
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l =
List.map f l

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n =
let rec clonehelper tx tn =
match (tn = 0) with
| true -> []
| false -> tx :: clonehelper tx (tn - 1)
in
clonehelper x (abs n)

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let padZero l1 l2 =
match List.length l1 > List.length l2 with
| true -> (l1,(List.append (clone 0 (List.length l1 - List.length l2)) l2))
| false -> ((List.append(clone 0 (List.length l2 - List.length l1)) l1),l2)

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

let rec removeZero l =
let rec removeZH templ =
match templ with
| [] -> []
| hd::tl -> 
if (hd = 0) then removeZH tl
else hd::tl
in
removeZH l

let _ = removeZero [0;0;0;1;0;0;2]

let _ = removeZero [9;9]

let _ = removeZero [0;0;0;0]

let bigAdd l1 l2 =
let add (l1, l2) =
let f a x =
match x with
| (addend_a,addend_b) ->
let prevcarry = 
match a with
| (x, y) -> x in
let new_carry = (prevcarry + addend_a + addend_b) / 10 in
let digit = (prevcarry + addend_a + addend_b) mod 10
in
match a with
| (x, c::d::y) -> (new_carry, new_carry::digit::d::y)
| _ -> (new_carry, new_carry::[digit]) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

let rec mulByDigit i l = 
let comb a b =
match b with
| [] -> [a]
| hd::tl -> List.append [a + hd] tl
in
let rec mBDhelper i x =
match x with
| [] -> []
| hd::tl ->
if (hd*i > 9) then
(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))
else
(hd*i)::(mBDhelper i tl)
in
mBDhelper i l

let _ = mulByDigit 9 [9;9;9;9]

let bigMul l1 l2 = 
let f a x = l1 in
let base = ([], 1) in
let args =
let rec argmaker x y =
match y with
| [] -> (,)
| hd::tl -> List.append (x,hd) (argmaker x tl)
in
argmaker l1 l2
in
let (_, res) = List.fold_left f base args in
res

let _ = bigMul [9;9;9;9] [9;9;9;9]

let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
let args =
let rec argmaker x y =
match y with
| [] -> (,)
| hd::tl -> List.append (x,hd) (argmaker x tl)
in
argmaker l1 l2
in
let (_, res) = List.fold_left f base args in
res
Error: Syntax error: operator expected.



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = l1 in
let base = (0, []) in
let args =
let rec argmaker x y =
match y with
| [] -> (x,[])
| hd::tl -> List.append (x,hd) (argmaker x tl)
in
argmaker l1 l2
in
let (_, res) = List.fold_left f base args in
res

let _ = bigMul [9;9;9;9] [9;9;9;9]

let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = l1 in
let base = ([], 1) in
let args =
let rec argmaker x y =
match y with
| [] -> (x,[])
| hd::tl -> List.append (x,[hd]) (argmaker x tl)
in
argmaker l1 l2
in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let bigMul l1 l2 = 
let f a x = l1 in
let base = ([], 1) in
let args =
let rec argmaker x y =
match y with
| [] -> (x,0)
| hd::tl -> List.append (x,hd) (argmaker x tl)
in
argmaker l1 l2
in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = l1 in
let base = (0, []) in
let args =
let rec argmaker x y =
match y with
| hd::tl -> 
if (tl=[]) then (x,hd) 
else (x,hd)::(argmaker x tl)
in
argmaker l1 l2
in
let (_, res) = List.fold_left f base args in
res

let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = l1 in
let base = (0, []) in
let args =
let rec argmaker x y =
match y with
| [] -> (x,[])
| hd::tl -> List.append ((x,hd)) (argmaker x tl)
in
argmaker l1 l2
in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list



hw3 bigMul

fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0
in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = fun k -> x (a k) in
let base = fun y -> y
in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = 
match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ x in
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l =
List.map f l

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n =
let rec clonehelper tx tn =
match (tn = 0) with
| true -> []
| false -> tx :: clonehelper tx (tn - 1)
in
clonehelper x (abs n)

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let padZero l1 l2 =
match List.length l1 > List.length l2 with
| true -> (l1,(List.append (clone 0 (List.length l1 - List.length l2)) l2))
| false -> ((List.append(clone 0 (List.length l2 - List.length l1)) l1),l2)

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

let rec removeZero l =
let rec removeZH templ =
match templ with
| [] -> []
| hd::tl -> 
if (hd = 0) then removeZH tl
else hd::tl
in
removeZH l

let _ = removeZero [0;0;0;1;0;0;2]

let _ = removeZero [9;9]

let _ = removeZero [0;0;0;0]

let bigAdd l1 l2 =
let add (l1, l2) =
let f a x =
match x with
| (addend_a,addend_b) ->
let prevcarry = 
match a with
| (x, y) -> x in
let new_carry = (prevcarry + addend_a + addend_b) / 10 in
let digit = (prevcarry + addend_a + addend_b) mod 10
in
match a with
| (x, c::d::y) -> (new_carry, new_carry::digit::d::y)
| _ -> (new_carry, new_carry::[digit]) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

let rec mulByDigit i l = 
let comb a b =
match b with
| [] -> [a]
| hd::tl -> List.append [a + hd] tl
in
let rec mBDhelper i x =
match x with
| [] -> []
| hd::tl ->
if (hd*i > 9) then
(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))
else
(hd*i)::(mBDhelper i tl)
in
mBDhelper i l

let _ = mulByDigit 9 [9;9;9;9]

let bigMul l1 l2 = 
let f a x = a::x in
let base = (0, []) in
let args =
let rec argmaker x y =
match y with
| hd::tl -> 
if (tl=[]) then [(x,hd)]
else (x,hd)::(argmaker x tl)
in
argmaker l1 l2
in
let (_, res) = List.fold_left f base args in
res

let _ = bigMul [9;9;9;9] [9;9;9;9]

let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = List.combine a x in
let base = (0, []) in
let args =
let rec argmaker x y =
match y with
| hd::tl -> 
if (tl=[]) then [(x,hd)]
else (x,hd)::(argmaker x tl)
in
argmaker l1 l2
in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a list -> 'b list -> ('a * 'b) list
       but an expression was expected of type 'a list -> 'b list -> 'a list
       The type variable 'a occurs inside 'a * 'b


let _ = bigMul [9;9;9;9] [9;9;9;9]
Error: This expression has type 'a list
       but an expression was expected of type int * 'b list


let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]
Error: This expression has type 'a list
       but an expression was expected of type int * 'b list


let bigMul l1 l2 = 
let f a x = a::x in
let base = (0, []) in
let args =
let rec argmaker x y =
match y with
| hd::tl -> 
if (tl=[]) then [(x,hd)]
else (x,hd)::(argmaker x tl)
in
argmaker l1 l2
in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a -> 'a list -> 'a list
       but an expression was expected of type 'a -> 'a list -> 'a
       The type variable 'a occurs inside 'a list



hw3 ???

fix:
let change x =
let rec changehelper acc x =
match x with
| [] -> []
| hd::tl -> changehelper (acc*10 + hd) tl
in changehelper 0 x

let _ = change [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9]

bad:
let change x =
let rec changehelper acc x =
match x with
| [] -> []
| hd::tl -> changehelper (acc ^ int_to_string hd) tl
in changehelper "" x
Error: Unbound value int_to_string
Hint: Did you mean int_of_string?


let change x =
let rec changehelper acc x =
match x with
| [] -> []
| hd::tl -> changehelper (acc ^ int_of_string hd) tl
in changehelper "" x
Error: This expression has type int but an expression was expected of type
         string


let _ = change [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9]
Error: This expression has type int but an expression was expected of type
         string



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n >0 then n/10::[n mod 10]
else []

bad:
let rec digitsOfInt n = match n with 
0 -> []
| n -> [n % 10]::digitsOfInt (n/10)
Error: Unbound value %


let _ = digitsOfInt 3124
Error: This expression has type int but an expression was expected of type
         'a list


let _ = digitsOfInt 352663
Error: This expression has type int but an expression was expected of type
         'a list


let rec digitsOfInt n = 
if n > 0 then digitsOfInt(n/10)::n mod 10
else []
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let _ = digitsOfInt 3124
Error: This expression has type int but an expression was expected of type
         'a list


let _ = digitsOfInt 352663
Error: This expression has type int but an expression was expected of type
         'a list


let rec digitsOfInt n = 
if n > 0 then digitsOfInt n/10::n mod 10
else []
Error: This expression has type 'a list
       but an expression was expected of type int


let _ = digitsOfInt 3124
Error: This expression has type int but an expression was expected of type
         'a list


let _ = digitsOfInt 352663
Error: This expression has type int but an expression was expected of type
         'a list


let rec digitsOfInt n = 
if n >0 then n/10::n mod 10
else []
Error: This expression has type int but an expression was expected of type
         int list



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n > 0 then (n mod 10) :: (digitsOfInt (n/10))
else []

bad:
if n > 0 then (n mod 10) :: (digitsOfInt (n/10))
else []
Error: Unbound value n


et rec digitsOfInt n = 
if n > 0 then (n mod 10) :: (digitsOfInt (n/10))
else []
Error: Syntax error



hw1 additivePersistence

fix:
let additivePersistence n = 
let count = 0 in
if n < 10 then count
else sumList(digitsOfInt n)

bad:
let rec additivePersistence n = match n with
| [] -> []
| h :: t -> t + digitsOfInt (additivePersistence h)
Error: This expression has type 'a list
       but an expression was expected of type int


let rec additivePersistence n = 
if n < 10 then n + sum
else let sum _ = sumList (digitsOfInt(n))
Error: Syntax error


let rec additivePersistence n = 
if n < 10 then n + sum
else let sum _ = sumList (digitsOfInt n)
Error: Syntax error


let rec additivePersistence n = 
if n < 10 then n + sum
else let sum _ = additivePersistence sumList (digitsOfInt n)
Error: Syntax error


let rec additivePersistence n = 
if n < 10 then n + sum
else let sum = additivePersistence sumList (digitsOfInt n)
Error: Syntax error


let additivePersistence n = 
if n < 10 then count
else (sumList (digitsOfInt n), count + 1)
Error: Unbound value count


let additivePersistence n = 
let count = 0 in
if n < 10 then count
else (sumList (digitsOfInt n), count + 1)
Error: This expression has type 'a * 'b
       but an expression was expected of type int


let additivePersistence n = 
let count = 0 in
if n < 10 then count
else sumList (digitsOfInt n) count + 1
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 additivePersistence

fix:
let additivePersistence n = 
let count = 0 in
if n < 10 then 1
else 1 + sumList(digitsOfInt n)

bad:
let additivePersistence n = 
let count = 0 in
if n < 10 then count
else count + 1 sumList(digitsOfInt n)
Error: This expression has type int
       This is not a function; it cannot be applied.


let additivePersistence n = 
let count = 0 in
if n < 10 then count
else count + 1 in sumList(digitsOfInt n)
Error: Unbound value n



hw1 additivePersistence

fix:
let rec additivePersistence n = 
if n < 10 then 1
else 1 + additivePersistence (sumList(digitsOfInt n))

bad:
let rec additivePersistence n = 
if n < 10 then 1
else 1 + additivePersistence sumList(digitsOfInt n)
Error: This function has type int -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 digitalRoot

fix:
let rec digitalRoot n = 
let sum = 0 in
if n < 10 then n + sum
else sum = digitalRoot(sumList(digitsOfInt n))

let _ = digitalRoot 9876

bad:
let rec digitalRoot n = 
if n < 10 then n + sum
else let sum = digitalRoot(sumList(digitsOfInt n))
Error: Syntax error



hw2 assoc

fix:
let rec assoc (d,k,l) =   
match l with
| [] -> d
| x :: xs -> match x with
| (s,i) -> if s = k then i
else assoc(d,k,xs)

bad:
let rec assoc (d,k,l) =   
match l with
| [] -> d
| x :: xs -> match x
| (s,i) -> if s = k then i
else assoc(d,k,xs)
Error: Syntax error



hw2 removeDuplicates

fix:
et removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) = false then seen @ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

bad:
et removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h = seen) = false then seen' @ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: Unbound value et


et removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h = seen) = false then seen@ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: Unbound value et


et removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h = seen) = false then seen @ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: Unbound value et


et removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) = false then seen @ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: Unbound value et


 _ = removeDuplicates [1;6;2;4;12;2;13;6;9]
Error: Syntax error



hw2 eval

fix:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)

)

let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr,0.5,0.2)

bad:
let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) + eval(w,x,y))/2.0)
| Times(v,w) -> eval(v,x,y) * eval(v,x,y)
| Thresh(a,b,c,d) -> (eval(a,x,y) < eval(b,x,y) ? eval(c,x,y) : eval(d,x,y))
Error: Syntax error


let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)
Error: Unbound value eval


let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)
Error: Unbound value eval


let _ = eval (sampleExpr,0.5,0.2)
Error: Unbound value eval


let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) + eval(w,x,y))/2.0)
| Times(v,w) -> eval(v,x,y) * eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)
Characters 217-218:
  | Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y);;
                          ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


)
Error: Syntax error


let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)
Error: Unbound value eval


let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)
Error: Unbound value eval


let _ = eval (sampleExpr,0.5,0.2)
Error: Unbound value eval


let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) + eval(w,x,y))/2.0)
| Times(v,w) -> eval(v,x,y) * eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
Error: This expression has type float but an expression was expected of type
         int


)
Error: Syntax error


let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)
Error: Unbound value eval


let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)
Error: Unbound value eval


let _ = eval (sampleExpr,0.5,0.2)
Error: Unbound value eval


let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) + .eval(w,x,y))/2.0)
| Times(v,w) -> eval(v,x,y) * eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
Error: Syntax error: operator expected.


)
Error: Syntax error


let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)
Error: Unbound value eval


let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)
Error: Unbound value eval


let _ = eval (sampleExpr,0.5,0.2)
Error: Unbound value eval


let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/2.0)
| Times(v,w) -> eval(v,x,y) * eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
Error: This expression has type float but an expression was expected of type
         int


)
Error: Syntax error


let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)
Error: Unbound value eval


let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)
Error: Unbound value eval


let _ = eval (sampleExpr,0.5,0.2)
Error: Unbound value eval


let rec eval (e,x,y) = match e with 
| Sine(v) -> sin(eval(v,x,y))
| Cosine(v) -> cos(eval(v,x,y))
| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)
| Times(v,w) -> eval(v,x,y) * eval(v,x,y)
| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
Error: This expression has type float but an expression was expected of type
         int


)
Error: Syntax error


let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)
Error: Unbound value eval


let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)
Error: Unbound value eval


let _ = eval (sampleExpr,0.5,0.2)
Error: Unbound value eval



hw2 build

fix:
let rec build (rand, depth) = 
if depth > 0 
then let depth = (depth -1) in
match rand(0,4) with
| 0 -> buildSine(build(rand,depth))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth),build(rand,depth))
| 3 -> buildTimes(build(rand,depth), build(rand,depth))
| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))
else 
match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = 
if depth > 0 
then d = d -1 in
match rand(0,4) with
| 0 -> buildSine(build(rand,d))
| 1 -> buildCosine(build(rand,d))
| 2 -> buildAverage(build(rand,d))
| 3 -> buildTimes(build(rand,d))
| 4 -> buildThresh(build(rand,d))
Error: Unbound value d


let rec build (rand, depth) = 
if depth > 0 
then depth = depth -1 in
match rand(0,4) with
| 0 -> buildSine(build(rand,depth))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth))
| 3 -> buildTimes(build(rand,depth))
| 4 -> buildThresh(build(rand,depth))
Error: This expression has type bool but an expression was expected of type
         unit


let rec build (rand, depth) = 
if depth > 0 
then let depth = depth -1 in
match rand(0,4) with
| 0 -> buildSine(build(rand,depth))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth))
| 3 -> buildTimes(build(rand,depth))
| 4 -> buildThresh(build(rand,depth))
Error: This expression has type expr but an expression was expected of type
         unit


let rec build (rand, depth) = 
if depth > 0 
then let depth = depth -1 in
match rand(0,4) with
| 0 -> buildSine((build(rand,depth)))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth))
| 3 -> buildTimes(build(rand,depth))
| 4 -> buildThresh(build(rand,depth))
Error: This expression has type expr but an expression was expected of type
         unit


let rec build (rand, depth) = 
if depth > 0 
then let d = depth -1 in
match rand(0,4) with
| 0 -> buildSine((build(rand,d)))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth))
| 3 -> buildTimes(build(rand,depth))
| 4 -> buildThresh(build(rand,depth))
Error: This expression has type expr but an expression was expected of type
         unit


let rec build (rand, depth) = 
if depth > 0 
then let depth = (depth -1) in
match rand(0,4) with
| 0 -> buildSine((build(rand,depth)))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth))
| 3 -> buildTimes(build(rand,depth))
| 4 -> buildThresh(build(rand,depth))
Error: This expression has type expr but an expression was expected of type
         unit


let rec build (rand, depth) = 
if depth > 0 
then let depth = (depth -1) in
match rand(0,4) with
| 0 -> buildSine((build(rand,depth)))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth))
| 3 -> buildTimes(build(rand,depth))
| 4 -> buildThresh(build(rand,depth))
else 
match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()
Error: This expression has type expr but an expression was expected of type
         expr * expr


let rec build (rand, depth) = 
if depth > 0 
then let depth = (depth -1) in
match rand(0,4) with
| 0 -> buildSine(build(rand,depth))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth),build(rand,depth))
| 3 -> buildTimes(build(rand,depth), build(rand,depth))
| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth))
else 
match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()
Error: This expression has type 'a * 'b * 'c
       but an expression was expected of type expr * expr * expr * expr



hw2 build

fix:
let rec build (rand, depth) = 
if depth > 0 
then let depth = (depth -1) in
match rand(0,4) with
| 0 -> buildSine(build(rand,depth))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth),build(rand,depth))
| 3 -> buildTimes(build(rand,depth), build(rand,depth))
| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))
else 
match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildY()

bad:
 rec build (rand, depth) = 
if depth > 0 
then let depth = (depth -1) in
match rand(0,4) with
| 0 -> buildSine(build(rand,depth))
| 1 -> buildCosine(build(rand,depth))
| 2 -> buildAverage(build(rand,depth),build(rand,depth))
| 3 -> buildTimes(build(rand,depth), build(rand,depth))
| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))
else 
match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = fun nest -> (x(a nest))  in
let base = fun x -> x in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

bad:
let pipe fs = 
let f a x = f nest -> x(a nest)  in
let base = f x -> x in
List.fold_left f base fs
Error: Syntax error


let _ = pipe [] 3
Error: Unbound value pipe


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: Unbound value pipe


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: Unbound value pipe


let pipe fs = 
let f a x = f nest -> (x(a nest))  in
let base = f x -> x in
List.fold_left f base fs
Error: Syntax error


let _ = pipe [] 3
Error: Unbound value pipe


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: Unbound value pipe


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: Unbound value pipe



hw3 stringOfList

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = "["^(sepConcat ";" List.map(f l))^"]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

bad:
let stringOfList f l = "["^sepConcat ";" [List.map(f l)]^"]"
Error: This expression has type 'a list -> 'b list
       but an expression was expected of type string


let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: Unbound value stringOfList


let _ = stringOfList (fun x -> x) ["foo"]
Error: Unbound value stringOfList


let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]
Error: Unbound value stringOfList


let stringOfList f l = "["^sepConcat ";"^[List.map(f l)]^"]"
Error: This expression has type string list -> string
       but an expression was expected of type string


let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: Unbound value stringOfList


let _ = stringOfList (fun x -> x) ["foo"]
Error: Unbound value stringOfList


let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]
Error: Unbound value stringOfList


let stringOfList f l = "["^sepConcat ";" [List.map(f l)]^"]"
Error: This expression has type 'a list -> 'b list
       but an expression was expected of type string


let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: Unbound value stringOfList


let _ = stringOfList (fun x -> x) ["foo"]
Error: Unbound value stringOfList


let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]
Error: Unbound value stringOfList


let stringOfList f l = "["^sepConcat ";" [List.map(f l)]^"]"
Error: This expression has type 'a list -> 'b list
       but an expression was expected of type string


let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: Unbound value stringOfList


let _ = stringOfList (fun x -> x) ["foo"]
Error: Unbound value stringOfList


let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]
Error: Unbound value stringOfList


let stringOfList f l = "["^sepConcat ";" List.map(f l)^"]"
Error: This function has type string -> string list -> string
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: Unbound value stringOfList


let _ = stringOfList (fun x -> x) ["foo"]
Error: Unbound value stringOfList


let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]
Error: Unbound value stringOfList



hw3 stringOfList

fix:
let stringOfList f l = "["^(sepConcat ";" (List.map f l))^"]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

bad:
let stringOfList f l = "["^sepConcat ";" List.map(f l)^"]"
Error: This function has type string -> string list -> string
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: Unbound value stringOfList


let _ = stringOfList (fun x -> x) ["foo"]
Error: Unbound value stringOfList


let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]
Error: Unbound value stringOfList


let stringOfList f l = "["^sepConcat(";" List.map(f l))^"]"
Error: This expression has type string
       This is not a function; it cannot be applied.


let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: Unbound value stringOfList


let _ = stringOfList (fun x -> x) ["foo"]
Error: Unbound value stringOfList


let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]
Error: Unbound value stringOfList



hw3 padZero

fix:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y = clone (List.hd l1) (List.length l1 - List.length l2) in
(y, l2)
else let z = clone (List.hd l2) (List.length l2 - List.length l1) in
(z, l1)

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2
then l1, l2
else if List.length l1 > List.length l2
Error: Syntax error


let y =clone List.hd l1 (List.length l1 - List.length l2)
y, l2
Error: This function has type 'a -> int -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.


let padZero l1 l2 = 
if List.length l1 = List.length l2
then l1, l2
else if (List.length l1 > List.length l2)
Error: Syntax error


let y =clone List.hd l1 (List.length l1 - List.length l2)
y, l2
Error: This function has type 'a -> int -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.


let padZero l1 l2 = 
if List.length l1 = List.length l2
then l1, l2
else if (List.length l1) > (List.length l2)
Error: Syntax error


let y =clone List.hd l1 (List.length l1 - List.length l2)
y, l2
Error: This function has type 'a -> int -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.


let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y =clone List.hd l1 (List.length l1 - List.length l2)
(y, l2)
Error: Syntax error


let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y =clone List.hd l1 (List.length l1 - List.length l2) then(y, l2)
Error: Syntax error


let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y =clone List.hd l1 (List.length l1 - List.length l2) -> (y, l2)
Error: Syntax error


let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y =clone List.hd l1 (List.length l1 - List.length l2) (y, l2)
Error: Syntax error


let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y =clone l1 (List.length l1 - List.length l2) in
(y, l2)
else let z = clone l2 (List.length l2 - List.length l1) in
(z, l1)
Error: This expression has type 'a list list
       but an expression was expected of type 'a list
       The type variable 'a occurs inside 'a list


let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y =clone List.hd l1 (List.length l1 - List.length l2) in
(y, l2)
else let z = clone List.hd l2 (List.length l2 - List.length l1) in
(z, l1)
Error: This function has type 'a -> int -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.


let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y = clone List.hd l1 (List.length l1 - List.length l2) in
(y, l2)
else let z = clone List.hd l2 (List.length l2 - List.length l1) in
(z, l1)
Error: This function has type 'a -> int -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 removeZero

fix:
let rec removeZero l = 
match l with 
| x::xs -> if x = 0 then removeZero(xs) else l

bad:
let rec removeZero l = 
match l with 
x::xs -> if x = 0 then removeZero(xs)
| [] -> xs
Error: Unbound value xs



hw3 bigAdd

fix:
let sqsum xs = 
let f a x = x*x + a in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = fun nest -> (x(a nest))  in
let base = fun x -> x in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = "["^(sepConcat ";" (List.map f l))^"]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n = 
if n <= 0 then []
else x::clone x(n-1)

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let padZero l1 l2 = 
if List.length l1 = List.length l2
then (l1, l2)
else if (List.length l1) > (List.length l2)
then let y = clone 0 (List.length l1 - List.length l2) @ l2 in
(l1, y)
else let z = clone 0 (List.length l2 - List.length l1) @ l1 in
(z,l2)

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

let rec removeZero l = failwith "to be implemented"

let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> match a with
| (carry,[result]) -> if carry = 1 then 

match 
let base = (0,[]) in

if d1 + d2 > 9 then let carry = 1
else let carry = 0

let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
if d1 + d2 > 9 then let carry = 1
else let carry = 0
match a with 
| (c,result) -> (carry, d1+d2+c)

let base = (0,[]) in
let args = List.combine(List.rev l1 List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  in
let base = [] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  failwith "tba" in
let base = [] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type 'b * 'c



hw3 bigAdd

fix:
let rec removeZero l = failwith "to be implemented"

let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
if d1 + d2 > 9 then let carry = 1
else let carry = 0
match a with 
| (c,result) -> (carry, d1+d2+c)

let base = (0,[]) in
let args = List.combine(List.rev l1 List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
if d1 + d2 > 9 then let carry = 1
else then let carry = 0
match a with 
| (c,result) -> (carry, d1+d2+c)
Error: Syntax error


let base = (0,[]) in
let args = List.combine(List.rev l1 List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> match a with
| (carry,[result]) -> if carry = 1 then 

match 
let base = (0,[]) in

if d1 + d2 > 9 then let carry = 1
else let carry = 0
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
if d1 + d2 > 9 then let carry = 1
else let carry = 0
match a with 
| (c,result) -> (carry, d1+d2+c)
Error: Syntax error


let base = (0,[]) in
let args = List.combine(List.rev l1 List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)
else (0,(d1+d2)::result) in
let base = (0,[]) in
let args = List.combine(List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
if (d1 + d2 > 9) then let carry = 1
else let carry = 0
match a with 
| (c,result) -> (carry, d1+d2+c)
Error: Syntax error


let base = (0,[]) in
let args = List.combine(List.rev l1 List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
if (d1 + d2 > 9) then let carry = 1
else carry = 0
match a with 
| (c,result) -> (carry, d1+d2+c)
Error: Syntax error


let base = (0,[]) in
let args = List.combine(List.rev l1 List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
if (d1 + d2 > 9) then let carry = 1
else let carry = 0
match a with 
| (c,result) -> (carry, d1+d2+c)
Error: Syntax error


let base = (0,[]) in
let args = List.combine(List.rev l1 List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)
else (0,(d1+d2)::result)
Error: Syntax error


let base = (0,[]) in
let args = List.combine(List.rev l1 List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)
else (0,(d1+d2)::result) in
let base = (0,[]) in
let args = List.combine(List.rev l1 List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)
else (0,(d1+d2)::result) in
let base = (0,[]) in
let args = List.combine(List.rev l1, List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)
else (0,(d1+d2+carry)::result) in
let base = (0,[]) in
let args = [(0,0)]@List.combine(List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)
else (0,(d1+d2+carry)::result) in
let base = (0,[]) in
let args = [0]@[List.combine(List.rev l1)(List.rev l2)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type ('a * 'b) list
       but an expression was expected of type int


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)
else (0,(d1+d2+carry)::result) in
let base = (0,[]) in
let args = [0]@List.combine(List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type ('a * 'b) list
       but an expression was expected of type int list
       Type 'a * 'b is not compatible with type int 



hw3 bigMul

fix:
let bigMul l1 l2 = 
match l2 with
| x::xs -> xs

let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 =  
let f a x =  match x with 
| (_,n) -> 
match a with
| (numzero,result) ->
(i + 1, bigAdd(mulByDigit n l1 @ clone 0 i) result)
Error: Syntax error


let base = (0,[]) in
let args = List.combine (List.rev l1)(List.rev l2)
Error: Syntax error


)
Error: Syntax error


let (_, res) = List.fold_left f base args in
res
Error: Unbound value f


let bigMul l1 l2 =  
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd(mulByDigit x l1 @ clone 0 numzero) result)
Error: Syntax error


let base = (0,[]) in
let args = List.rev l2
Error: Syntax error


let (_, res) = List.fold_left f base args in
res
Error: Unbound value f


let bigMul l1 l2 =  
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd(mulByDigit * l1 @ clone 0 numzero) result)
Error: Syntax error


let base = (0,[]) in
let args = List.rev l2
Error: Syntax error


let (_, res) = List.fold_left f base args in
res
Error: Unbound value f


let bigMul l1 l2 =  
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd(mulByDigit * l1 :: clone 0 numzero) result)
Error: Syntax error


let base = (0,[]) in
let args = List.rev l2
Error: Syntax error


let (_, res) = List.fold_left f base args in
res
Error: Unbound value f


let bigMul l1 l2 =  
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd(mulByDigit * l1 :: clone 0 numzero) result) in
let base = (0,[]) in
let args = List.rev l2
Error: Syntax error


let (_, res) = List.fold_left f base args in
res
Error: Unbound value f


let bigMul l1 l2 =  
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd(mulByDigit * l1 :: clone 0 numzero) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int -> int list -> int list
       but an expression was expected of type int
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int -> int list -> int list
       but an expression was expected of type int


let bigMul l1 l2 =  
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd(mulByDigit l1 x :: clone 0 numzero) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list
       but an expression was expected of type int
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int list
       but an expression was expected of type int


let bigMul l1 l2 =  
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd(mulByDigit x l1 :: clone 0 numzero) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list
       but an expression was expected of type int
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int list
       but an expression was expected of type int


let bigMul l1 l2 =  
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list
       but an expression was expected of type int
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int list
       but an expression was expected of type int



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, (bigAdd((mulByDigit x l1) @ clone 0 numzero)) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
match l2 with
| x::xs -> xs in
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value l1
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value l1


let bigMul l1 l2 = 
match l2 with
| x::xs -> t in
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value t
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value t


let bigMul l1 l2 = 
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list
       but an expression was expected of type int
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int list
       but an expression was expected of type int


let bigMul l1 l2 = 
let f a x =  
match a with
| (numzero,result) ->
(numzero + 1, (bigAdd((mulByDigit x l1) :: clone 0 numzero)) result) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list
       but an expression was expected of type int
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n <= 0
then []
else n - (n/10) * 10 :: digitsOfInt (n/10)

bad:
let rec digitsOfInt n = 
if n <= 0
then []
else n - (n/10) * 10 :: digitsOfInt n/10
Error: This expression has type int list
       but an expression was expected of type int



hw1 additivePersistence

fix:
let _ = additivePersistence (-1)

bad:
let _ = additivePersistence -1
Error: This expression has type int -> int
       but an expression was expected of type int



hw1 listReverse

fix:
let rec listReverse l = match l with
| [] -> []
| hd::tl -> append (listReverse tl) [hd]

let _ = listReverse [1; 2; 3; 4]

bad:
let _ = listReverse [1; 2; 3; 4]
Error: This expression has type int but an expression was expected of type
         'a list


let _ = listReverse ["a"; "b"; "c"; "d"]
Error: This expression has type string but an expression was expected of type
         'a list


let _ = listReverse [1; 2; 3; 4]
Error: This expression has type int but an expression was expected of type
         'a list


let _ = listReverse ["a"; "b"; "c"; "d"]
Error: This expression has type string but an expression was expected of type
         'a list



hw1 palindrome

fix:
let palindrome w = match (explode w) with
| [] -> true
| head::[] -> true
| head::tail -> 
if head = List.hd (listReverse tail)
then palindrome (List.tl (listReverse tail))
else false

let _ = palindrome "malayalam"

bad:
let palindrome w = match (explode w) with
| [] -> true
| head::[] -> true
| head::tail -> 
if head = hd (listReverse w)
then palindrome (tl (listReverse tail))
else false
Error: Unbound value hd


let palindrome w = match (explode w) with
| [] -> true
| head::[] -> true
| head::tail -> 
if head = List.hd (listReverse w)
then palindrome (List.tl (listReverse tail))
else false
Error: This expression has type string but an expression was expected of type
         'a list


let palindrome w = match (explode w) with
| [] -> true
| head::[] -> true
| head::tail -> 
if head = List.hd (listReverse [w])
then palindrome (List.tl (listReverse [tail]))
else false
Error: This expression has type string but an expression was expected of type
         char



hw2 assoc

fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (di,ki) ->
if ki = k
then di
else assoc (d,k,t)

bad:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (di * ki) ->
if ki = k
then di
else assoc (d,k,t)
Characters 72-73:
  | (di * ki) ->
    ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])
Error: Unbound value assoc


let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| di * ki ->
if ki = k
then di
else assoc (d,k,t)
Error: Syntax error


let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (di * ki) ->
if ki = k
then di
else assoc (d,k,t)
Characters 72-73:
  | (di * ki) ->
    ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (di*ki) ->
if ki = k
then di
else assoc (d,k,t)
Characters 72-73:
  | (di*ki) ->
    ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw2 assoc

fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (ki,di) ->
if ki = k
then di
else assoc (d,k,t)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])
Error: This expression has type string but an expression was expected of type
         int



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = 
if List.mem h seen
then seen
else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = 
if List.mem (h, seen)
then seen
else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This expression has type ('a * 'b) list -> bool
       but an expression was expected of type bool


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = 
if List.mem h
then seen
else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This expression has type 'a list -> bool
       but an expression was expected of type bool



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile (
let g a = 
f a, f a != a
in 
g, b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
 g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Syntax error



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((fun a -> f a, f a != a), b)

bad:
let fixpoint (f,b) = wwhile (
fun a ->
f a, f a != a
in 
g, b
Characters 28-29:
  let fixpoint (f,b) = wwhile (
                              ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let fixpoint (f,b) = wwhile (
fun a ->
f a, f a != a, b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a


let fixpoint (f,b) = wwhile (
fun a ->
f a, f a != a
, b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a


let fixpoint (f,b) = wwhile (
fun a ->
f a, f a != a
, b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a


let fixpoint (f,b) = wwhile (fun a -> f a, f a != a, b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a



hw2 exprToString

fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> String.concat "pi* " ^ exprToString s

let sampleExpr2 = Sine(VarX)

let _ = exprToString sampleExpr2

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> String.concat sep ["pi* "; exprToString s]
Error: Unbound value sep



hw2 eval

fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> sin(pi *. eval e)

let _ = VarX, 0.5, 0.6

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> sin(pi * eval e)
Error: This expression has type float but an expression was expected of type
         int



hw2 build

fix:
let rec build (rand, depth) =
if 
(depth = 0)
then
match rand(0,2) with
| 0 -> buildX()
| 1 -> buildY()
else 
match rand (0,100) with
| i when (i<5) -> 
buildSine (build (rand, depth-1))
| i when (i<10) -> 
buildCosine (build (rand, depth-1))
| i when (i<20) -> 
buildAverage (build (rand, depth-1), build (rand, depth-1))
| i when (i<80) -> 
buildTimes (build (rand, depth-1), build (rand, depth-1))
| i when (i<100) ->
buildThresh (build (rand, depth-1), build (rand, depth-1), 
build (rand, depth-1), build (rand, depth-1))

bad:
let rec build (rand, depth) =
if 
(depth = 0)
then
match rand(0,2) with
| 0 -> buildX()
| 1 -> buildY()
else 
match rand (0,100) with
| i if (i<5) -> 
buildSine (build (rand, depth-1))
| i if (i<10) -> 
buildCosine (build (rand, depth-1))
| i if (i<20) -> 
buildAverage (build (rand, depth-1), build (rand, depth-1))
| i if (i<80) -> 
buildTimes (build (rand, depth-1), build (rand, depth-1))
| i if (i<100) ->
buildThresh (build (rand, depth-1), build (rand, depth-1), 
build (rand, depth-1), build (rand, depth-1))
Error: Syntax error



hw2 eval

fix:
let rec eval (e,x,y) = match e with
| VarX -> 
x
| VarY -> 
y
| Sine e1 -> 
sin(pi *. eval (e1,x,y))
| Cosine e1 -> 
cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> 
(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0
| Times (e1,e2) -> 
eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if (eval(e1,x,y)<eval(e2,x,y))
then eval(e3,x,y)
else eval(e4,x,y)
| Log e1 ->
let b = eval (e1,x,y)
in
if (b > 1.0)
then log(b)
else 0.0

bad:
let rec eval (e,x,y) = match e with
| VarX -> 
x
| VarY -> 
y
| Sine e1 -> 
sin(pi *. eval (e1,x,y))
| Cosine e1 -> 
cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> 
(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0
| Times (e1,e2) -> 
eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if (eval(e1,x,y)<eval(e2,x,y))
then eval(e3,x,y)
else eval(e4,x,y)
| Log e1 ->
let b = eval (e1,x,y)
in
if (b > 1.0)
then log(b)
else 0
Error: This expression has type int but an expression was expected of type
         float



hw2 eval

fix:
let rec eval (e,x,y) = match e with
| VarX -> 
x
| VarY -> 
y
| Sine e1 -> 
sin(pi *. eval (e1,x,y))
| Cosine e1 -> 
cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> 
(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0
| Times (e1,e2) -> 
eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if (eval(e1,x,y)<eval(e2,x,y))
then eval(e3,x,y)
else eval(e4,x,y)
| Log e1 ->
let b = eval (e1,x,y)
in
if (b > 1.0)
then log(b)
else 0.0
| SumOfSquares (e1,e2,e3) ->
(eval(e1,x,y) ** 2.0) +. (eval(e2,x,y) ** 2.0) +. (eval(e3,x,y) ** 2.0)

bad:
let rec eval (e,x,y) = match e with
| VarX -> 
x
| VarY -> 
y
| Sine e1 -> 
sin(pi *. eval (e1,x,y))
| Cosine e1 -> 
cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> 
(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0
| Times (e1,e2) -> 
eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if (eval(e1,x,y)<eval(e2,x,y))
then eval(e3,x,y)
else eval(e4,x,y)
| Log e1 ->
let b = eval (e1,x,y)
in
if (b > 1.0)
then log(b)
else 0.0
| SumOfSquares (e1,e2,e3) ->
(eval(e1,x,y) ** 2.0) + (eval(e2,x,y) ** 2.0) + (eval(e3,x,y) ** 2.0)
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| VarX -> 
x
| VarY -> 
y
| Sine e1 -> 
sin(pi *. eval (e1,x,y))
| Cosine e1 -> 
cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> 
(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0
| Times (e1,e2) -> 
eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if (eval(e1,x,y)<eval(e2,x,y))
then eval(e3,x,y)
else eval(e4,x,y)
| Log e1 ->
let b = eval (e1,x,y)
in
if (b > 1.0)
then log(b)
else 0.0
| SumOfSquares (e1,e2,e3) ->
(eval(e1,x,y) **. 2.0) + (eval(e2,x,y) **. 2.0) + (eval(e3,x,y) **. 2.0)
Error: Unbound value **.
Hint: Did you mean *. or **?



hw3 sqsum

fix:
let sqsum xs = 
let f a x = x**2.0 in
let base = 0.0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = x**2 in
let base = 0 in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         float


let sqsum xs = 
let f a x = x**2.0 in
let base = 0 in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         float


let sqsum xs = 
let f a x = x**.2.0 in
let base = 0 in
List.fold_left f base xs
Error: Unbound value **.
Hint: Did you mean *. or **?



hw3 sqsum

fix:
let sqsum xs = 
let f a x = x*x in
let base = 0 in
List.fold_left f base xs

bad:
let _ = sqsum [1;2;3;4]
Error: This expression has type int but an expression was expected of type
         float


let sqsum xs = 
let f a x = x*xin
Error: Syntax error


let base = 0 in
List.fold_left f base xs
Error: Unbound value f



hw3 sqsum

fix:
let sqsum xs = 
let f a x = x*x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = base + x in
let base = x*x in
List.fold_left f base xs
Error: Unbound value base



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = f in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = a in
List.fold_left f base fs
Error: Unbound value a


let pipe fs = 
let f a x = x a in
let base = z in
List.fold_left f base fs
Error: Unbound value z


let pipe fs = 
let f a x = x a in
let base = x in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = x a in
let base = fs in
List.fold_left f base fs
Error: This expression has type 'a but an expression was expected of type
         ('a -> 'a) list
       The type variable 'a occurs inside ('a -> 'a) list



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun a->a in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let pipe fs = 
let f a x = x a in
let base = x in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = x a in
let base = 'a->'a in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x  in
let base = fun b->b in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let pipe fs = 
let f a x = x (a->a) in
let base = fun a->a in
List.fold_left f base fs
Characters 29-30:
  let f a x = x (a->a) in
                ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let pipe fs = 
let f a x = x a->a in
let base = fun a->a in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = fun c->x c in
let base = fun b->b in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x-> x a in
let base = fun b->b in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside ('a -> 'c) -> 'c



hw3 stringOfList

fix:
let stringOfList f l = sepConcat "; " (List.map f l)

bad:
let stringOfList f l = List.map sepConcat ";" l
Error: This function has type ('a -> 'b) -> 'a list -> 'b list
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 padZero

fix:
let padZero l1 l2 = 
let length1 = List.length l1 in
let length2 = List.length l2 in
if (length1 > length2)
then List.append (clone 0 (length1 - length2)), length2
else List.append (clone 0 (length2 - length1)), length1

bad:
let padZero l1 l2 = 
let length1 = List.length l1 in
let length2 = List.length l2 in
if (lenth1 > length2)
then List.append (clone 0 (length1 - length2)), length2
else List.append (clone 0 (length2 - length1)), length1
Error: Unbound value lenth1
Hint: Did you mean length1?



hw1 sumList

fix:
let rec sumList xs = match xs with
| [] -> 0
| h::t -> h + sumList t

bad:
let rec sumList xs = match xs with
| [] -> []
| h::t -> h+sumList t
Error: This expression has type 'a list
       but an expression was expected of type int



hw1 ???

fix:
let h::t = [1;0]

bad:
h::t = [1;0]
Error: Unbound value h



hw1 ???

fix:
let _ = 4::[]

bad:
let h::t = 1232
Error: This expression has type int but an expression was expected of type
         'a list


let h+t = 1232
Error: Syntax error


let [] = 1232
Error: This expression has type int but an expression was expected of type
         'a list


let [] = 1232
Error: This expression has type int but an expression was expected of type
         'a list



hw1 ???

fix:
5 mod 5

bad:
5%5
Error: Unbound value %



hw1 ???

fix:
5::[1]

bad:
[5]::1
Error: This expression has type int but an expression was expected of type
         int list list


[5]::[1]
Error: This expression has type int but an expression was expected of type
         int list



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n < 0
then true
else false

bad:
let rec digitsOfInt n = 
if n < 0
then []
Error: This variant expression is expected to have type unit
       The constructor [] does not belong to type unit


let rec digitsOfInt n = 
if n < 0
then -> []
Error: Syntax error


let rec digitsOfInt n = 
if n < 0
then true
Error: This variant expression is expected to have type unit
       The constructor true does not belong to type unit



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n < 0
then []
else []

bad:
let rec digitsOfInt n = 
if n < 0
then []
else
Error: Syntax error



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n < 0
then []
else 
let (x,y) = (n mod 10, n / 10) in
n::(digitsOfInt n)

bad:
let rec digitsOfInt n = 
| n < 0 -> true
Error: Syntax error


let rec digitsOfInt n =
Error: Syntax error


with
| n < 0 -> true
Error: Syntax error



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n > 0
then []
else if (n mod 10) < 10
then []
else (n mod 10)::(digitsOfInt (n / 10))

bad:
let rec digitsOfInt n = 
if n > 0
then []
else 
if (n mod 10) < 10
then [x]
else x::(digitsOfInt (n / 10))
Error: Unbound value x


let rec digitsOfInt n = 
if n > 0
then []
else if (n mod 10) < 10
then []
else x::(digitsOfInt (n / 10))
Error: Unbound value x



hw1 ???

fix:
let append x y= 
x::y

append 1 [2]

bad:
append 1 2
Error: This expression has type int but an expression was expected of type
         int list



hw1 ???

fix:
let append x y = match y with
| [] -> [x]
| h::t -> h::(append x t)

bad:
let append x y = match y with
| [] -> x
| h::t -> h::(append x t)
Error: This expression has type 'a list
       but an expression was expected of type 'a list list
       The type variable 'a occurs inside 'a list



hw1 ???

fix:
let append x y = x+y

bad:
let append x y = match y with
| [] -> []
| h::t -> h::(append x t)
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.


let append (x, y) = match y with
| [] -> []
| h::t -> h::(append x t)
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 additivePersistence

fix:
let rec additivePersistence n = 
let x = sumList n in
if x < 10
then countlist n
else additivePersistence [x]

bad:
let rec additivePersistence n = 
let x = sumList n in
if x < 10
then countlist n
else additivePersistence x
Error: This expression has type int but an expression was expected of type
         int list



hw1 ???

fix:
let rec sumdigits x = 
let y = digits x in
match y with
| [] -> 0
| h::t -> 1 + sumdigits x

bad:
let rec sumdigits x = 
let y = digits x in
match y with
| [] -> 0
| h::t -> 1 + sumdigits
Error: This expression has type int -> int
       but an expression was expected of type int



hw1 additivePersistence

fix:
let rec additivePersistence n = 
if sumList (digits n) < 10
then numdigits (digits n)
else additivePersistence (sumList (digits n))

bad:
let rec additivePersistence n = 
if sumList (digits n) < 10
then numdigits n
else additivePersistence sumList n
Error: This expression has type int but an expression was expected of type
         'a list


let rec additivePersistence n = 
if sumList (digits n) < 10
then numdigits (digits n)
else additivePersistence sumList n
Error: This function has type int -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let rec additivePersistence n = 
if sumList (digits n) < 10
then numdigits (digits n)
else additivePersistence (sumList n)
Error: This expression has type int but an expression was expected of type
         int list



hw1 digitsOfInt

fix:
let _ = digitsOfInt (-3124)

bad:
let _ = digitsOfInt -3124
Error: This expression has type int -> int list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let _ = digitsOfInt (-3124)

bad:
let _ = digitsOfInt -3124
Error: This expression has type int -> int list
       but an expression was expected of type int



hw2 wwhile

fix:
let rec wwhile (f,b) =
let (b',c') = f b in
if c'
then wwhile (f, b')
else
b'

bad:
let rec wwhile (f,b) =
let (b',c') = f b in
if c'
then f b'
else
b'
Error: This expression has type 'a but an expression was expected of type
         'a * bool
       The type variable 'a occurs inside 'a * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((fun x -> if (x=b) then (b,false) else (f x,true)),b)

bad:
let fixpoint (f,b) = wwhile (fun x -> if(f x)=x then (b,false) else (f x,true),b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a


let fixpoint (f,b) = wwhile (fun x -> if (x=b) then (b,false) else (f x,true),b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a



hw2 exprToString

fix:
let rec exprToString e = match e with 
VarX -> 1
| VarY-> 1
| Sine x -> 1
| Cosine  x -> 1
| Average (x,y) -> 1
| Times  (x,y)  -> 1
| Thresh  (x,y,z,w) -> 1

bad:
let rec exprToString e = match e with 
VarX -> printf "A"
| VarY-> printf "A"
| Sine x -> printf "A"
| Cosine  x -> printf "A"
| Average x y -> printf "A"
| Times  x y  -> printf "A"
| Thresh  x y z w -> printf "A"
Error: Syntax error


let rec exprToString e = match e with 
VarX -> printf "A"
| VarY-> printf "A"
| Sine x -> printf "A"
| Cosine  x -> printf "A"
| Average (x,y) -> printf "A"
| Times  (x,y)  -> printf "A"
| Thresh  (x,y,z,w) -> printf "A"
Error: Unbound value printf


let rec exprToString e = match e with 
VarX -> Printf.printf "A"
| VarY-> printf "A"
| Sine x -> printf "A"
| Cosine  x -> printf "A"
| Average (x,y) -> printf "A"
| Times  (x,y)  -> printf "A"
| Thresh  (x,y,z,w) -> printf "A"
Error: Unbound value printf



hw2 exprToString

fix:
let rec exprToString e = match e with 
VarX -> Printf.sprintf "x"
| VarY-> Printf.sprintf "y"
| Sine x ->Printf.sprintf ""
| Cosine  x -> Printf.sprintf ""
| Average (x,y) -> Printf.sprintf ""
| Times  (x,y)  -> Printf.sprintf ""
| Thresh  (x,y,z,w) -> Printf.sprintf "%s<%s?%s:" (exprToString x) (exprToString y) (exprToString z)

bad:
let rec exprToString e = match e with 
let sprintf=Printf.sprintf in
VarX -> sprintf("x")
| VarY-> sprintf("x")
| Sine x ->3
| Cosine  x -> 4
| Average (x,y) -> 5
| Times  (x,y)  -> 6
| Thresh  (x,y,z,w) -> sprintf("%s<%s?%s:") x,y,z
Error: Syntax error


let rec exprToString e = match e with 
VarX -> Printf.sprintf("x")
| VarY-> sprintf("x")
| Sine x ->3
| Cosine  x -> 4
| Average (x,y) -> 5
| Times  (x,y)  -> 6
| Thresh  (x,y,z,w) -> sprintf("%s<%s?%s:") x,y,z
Error: Unbound value sprintf


let rec exprToString e = match e with 
VarX -> Printf.sprintf("x")
| VarY-> Printf.sprintf("x")
| Sine x ->Printf.sprintf ("")
| Cosine  x -> Printf.sprintf ("")
| Average (x,y) -> Printf.sprintf ("")
| Times  (x,y)  -> Printf.sprintf ("")
| Thresh  (x,y,z,w) -> Printf.sprintf("%s<%s?%s:") x,y,z
Error: This expression has type 'a * 'b * 'c
       but an expression was expected of type string


let rec exprToString e = match e with 
VarX -> Printf.sprintf "x"
| VarY-> Printf.sprintf "x"
| Sine x ->Printf.sprintf ""
| Cosine  x -> Printf.sprintf ""
| Average (x,y) -> Printf.sprintf ""
| Times  (x,y)  -> Printf.sprintf ""
| Thresh  (x,y,z,w) -> Printf.sprintf "%s<%s?%s:" x,y,z
Error: This expression has type 'a * 'b * 'c
       but an expression was expected of type string


let rec exprToString e = match e with 
VarX -> Printf.sprintf "x"
| VarY-> Printf.sprintf "x"
| Sine x ->Printf.sprintf ""
| Cosine  x -> Printf.sprintf ""
| Average (x,y) -> Printf.sprintf ""
| Times  (x,y)  -> Printf.sprintf ""
| Thresh  (x,y,z,w) -> Printf.sprintf "%s<%s?%s:" x y z
Error: This expression has type expr but an expression was expected of type
         string


let rec exprToString e = match e with 
VarX -> Printf.sprintf "x"
| VarY-> Printf.sprintf "y"
| Sine x ->Printf.sprintf ""
| Cosine  x -> Printf.sprintf ""
| Average (x,y) -> Printf.sprintf ""
| Times  (x,y)  -> Printf.sprintf ""
| Thresh  (x,y,z,w) -> Printf.sprintf "%s<%s?%s:" exprToString x exprToString y exprToStringz
Error: This expression has type
         ('a -> 'b -> 'c, unit, string, string, string, 'a -> 'b -> 'c)
         CamlinternalFormatBasics.fmt
       but an expression was expected of type
         ('a -> 'b -> 'c, unit, string, string, string, string)
         CamlinternalFormatBasics.fmt
       Type 'a -> 'b -> 'c is not compatible with type string 



hw2 ???

fix:
sin(2.)

bad:
sin(2)
Error: This expression has type int but an expression was expected of type
         float



hw2 eval

fix:
eval(Sine(VarX),0.,0.)

bad:
eval(Sine(0))
Error: This expression has type expr but an expression was expected of type
         expr * float * float


eval(Sine(VarX),0,0)
Error: This expression has type int but an expression was expected of type
         float



hw2 eval

fix:
let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y))
| Cosine a -> x
| Average (a,b) -> x
| Times (a,b) -> x
| Thresh (a,b,c,d) -> x

eval(Sine(VarX),1.,0.)

bad:
let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(pi*eval(a,x,y))
| Cosine a -> x
| Average (a,b) -> x
| Times (a,b) -> x
| Thresh (a,b,c,d) -> x
Error: This expression has type float but an expression was expected of type
         int



hw2 eval

fix:
let pi = 4.0 *. atan 1.0

let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin((eval(a,x,y)*2.))
| Cosine a -> x
| Average (a,b) -> x
| Times (a,b) -> x
| Thresh (a,b,c,d) -> x

eval(Sine(VarX),1.,0.)

bad:
eval(a,x,y)*2.
Error: This expression has type int * int
       but an expression was expected of type expr



hw2 eval

fix:
let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y)*.pi)
| Cosine a -> cos(eval(a,x,y)*.pi)
| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y) /. 2.)
| Times (a,b) -> x
| Thresh (a,b,c,d) -> x

bad:
let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y)*.pi)
| Cosine a -> cos(eval(a,x,y)*.pi)
| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y) /. 2)
| Times (a,b) -> x
| Thresh (a,b,c,d) -> x
Error: This expression has type int but an expression was expected of type
         float



hw2 eval

fix:
let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> x

let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr1,0.5,0.2)

bad:
let _ = eval (sampleExpr,0.5,0.2)
Error: This expression has type expr/1210
       but an expression was expected of type expr/1410
Error: This expression has type expr/2898
       but an expression was expected of type expr/2918
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type expr/1210
       but an expression was expected of type expr/1410



hw2 ???

fix:
sampleExpr2

bad:
sampleExp
Error: Unbound value sampleExp
Hint: Did you mean sampleExpr?
Error: Unbound value sampleExp
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value sampleExp
Hint: Did you mean sampleExpr?



hw2 ???

fix:
sampleExpr1

bad:
sampleExpr3
Error: Unbound value sampleExpr3
Hint: Did you mean sampleExpr1, sampleExpr2 or sampleExpr?
Error: Unbound value sampleExpr3
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value sampleExpr3
Hint: Did you mean sampleExpr1, sampleExpr2 or sampleExpr?



hw2 eval

fix:
let _ = eval (sampleExpr1,0.5,0.2)

bad:
let _ = eval (sampleExpr,0.5,0.2)
Error: This expression has type expr/1210
       but an expression was expected of type expr/1410
Error: This expression has type expr/3092
       but an expression was expected of type expr/3112
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type expr/1210
       but an expression was expected of type expr/1410



hw2 build

fix:
let g1 () = failwith "to be implemented"

let g2 () = failwith "to be implemented"

let g3 () = failwith "to be implemented"

let c1 () = failwith "to be implemented"

let c2 () = failwith "to be implemented"

let c3 () = failwith "to be implemented"

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

let emitColor (f1,f2,f3,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_c_"^name) in
let chan = open_out (fname^".ppm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P6 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z1 = f1 (x,y) in
let z2 = f2 (x,y) in
let z3 = f3 (x,y) in

(* Convert the result to a grayscale value *)
let iz1 = toIntensity(z1) in
let iz2 = toIntensity(z2) in
let iz3 = toIntensity(z3) in

(* Emit one byte per color for this pixel *)
output_char chan (char_of_int iz1);
output_char chan (char_of_int iz2);
output_char chan (char_of_int iz3);
)) in  
close_out chan;
ignore(Sys.command ("convert "^fname^".ppm  "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".ppm"))

let doRandomColor (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand (seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e1 = build (g, depth) in
let e2 = build (g, depth) in
let e3 = build (g, depth) in

let _ = Format.printf "red   = %s \n" (exprToString e1) in
let _ = Format.printf "green = %s \n" (exprToString e2) in
let _ = Format.printf "blue  = %s \n" (exprToString e3) in

let f1 = eval_fn e1 in
let f2 = eval_fn e2 in
let f3 = eval_fn e3 in

(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitColor (f1,f2,f3,n,name)

type test = unit -> string

let key = ""

let prefix130 = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)); ErrorCode "exception")

let explode s = 
let rec _exp i = 
if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in
_exp 0

let implode cs = 
String.concat "" (List.map (String.make 1) cs)

let drop_paren s = 
implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))

let eq_real p (r1,r2) = 
(r1 -. r2) < p || (r2 -. r1) < p

let scoreMsg () = 
Format.sprintf "Results: Score/Max = %d / %d \n" !score !max

bad:
build(rand,1)
Error: Unbound value rand
Hint: Did you mean land?



hw2 build

fix:
let rec build (rand, depth) =

let g1 () = failwith "to be implemented"

let g2 () = failwith "to be implemented"

let g3 () = failwith "to be implemented"

let c1 () = failwith "to be implemented"

let c2 () = failwith "to be implemented"

let c3 () = failwith "to be implemented"

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

let emitColor (f1,f2,f3,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_c_"^name) in
let chan = open_out (fname^".ppm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P6 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z1 = f1 (x,y) in
let z2 = f2 (x,y) in
let z3 = f3 (x,y) in

(* Convert the result to a grayscale value *)
let iz1 = toIntensity(z1) in
let iz2 = toIntensity(z2) in
let iz3 = toIntensity(z3) in

(* Emit one byte per color for this pixel *)
output_char chan (char_of_int iz1);
output_char chan (char_of_int iz2);
output_char chan (char_of_int iz3);
)) in  
close_out chan;
ignore(Sys.command ("convert "^fname^".ppm  "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".ppm"))

let doRandomColor (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand (seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e1 = build (g, depth) in
let e2 = build (g, depth) in
let e3 = build (g, depth) in

let _ = Format.printf "red   = %s \n" (exprToString e1) in
let _ = Format.printf "green = %s \n" (exprToString e2) in
let _ = Format.printf "blue  = %s \n" (exprToString e3) in

let f1 = eval_fn e1 in
let f2 = eval_fn e2 in
let f3 = eval_fn e3 in

(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitColor (f1,f2,f3,n,name)

type test = unit -> string

let key = ""

let prefix130 = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)); ErrorCode "exception")

let explode s = 
let rec _exp i = 
if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in
_exp 0

let implode cs = 
String.concat "" (List.map (String.make 1) cs)

let drop_paren s = 
implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))

let eq_real p (r1,r2) = 
(r1 -. r2) < p || (r2 -. r1) < p

let scoreMsg () = 
Format.sprintf "Results: Score/Max = %d / %d \n" !score !max

bad:
let rec build (rand, depth) =
Error: Syntax error



hw2 build

fix:
let rec build (rand, depth) = 
if depth<2
then let x=rand(0,2) in
match x with
|0 -> buildX()
|1 -> buildY()
else
let x=rand(0,5) in
match x with
|0 -> buildSine(build(rand,depth))
|1 -> buildCosine(build(rand,depth))

bad:
let rec build (rand, depth) = 
if depth<2
then let x=rand(0,2) in
match x with
|0 -> buildX()
|1 -> buildY()
else
let x=rand(0,5) in
match x with
|0 -> buildSin(build(rand,depth))
|1 -> buildCosin(build(rand,depth))
Error: Unbound value buildSin
Hint: Did you mean buildSine?
Error: Unbound value buildSin
Hint: Did you mean build, buildY or buildX?
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value buildSin
Hint: Did you mean buildSine?



hw2 build

fix:
let g1 () = doRandomGray(2,1,1)

let g2 () = failwith "to be implemented"

let g3 () = failwith "to be implemented"

let c1 () = failwith "to be implemented"

let c2 () = failwith "to be implemented"

let c3 () = failwith "to be implemented"

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

let emitColor (f1,f2,f3,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_c_"^name) in
let chan = open_out (fname^".ppm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P6 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z1 = f1 (x,y) in
let z2 = f2 (x,y) in
let z3 = f3 (x,y) in

(* Convert the result to a grayscale value *)
let iz1 = toIntensity(z1) in
let iz2 = toIntensity(z2) in
let iz3 = toIntensity(z3) in

(* Emit one byte per color for this pixel *)
output_char chan (char_of_int iz1);
output_char chan (char_of_int iz2);
output_char chan (char_of_int iz3);
)) in  
close_out chan;
ignore(Sys.command ("convert "^fname^".ppm  "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".ppm"))

bad:
build(rand,1)
Error: Unbound value rand
Hint: Did you mean land?



hw2 ???

fix:
makeRand(0,1)

bad:
makeRandom(0,1)
doRandomGray(1,1,1)
Error: Unbound value makeRandom
Hint: Did you mean makeRand?
Error: Unbound constructor VarX
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value makeRandom
Hint: Did you mean makeRand?


makeRand(0,1)
doRandomGray(1,1,1)
Error: This function has type int * int -> int * int -> int
       It is applied to too many arguments; maybe you forgot a `;'.
Error: Unbound constructor VarX
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This function has type int * int -> int * int -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw2 eval

fix:
let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))
| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)

bad:
let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (.9*eval(a,x,y)) else (.1*eval(a,x,y))
| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)
Error: Syntax error: operator expected.


let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (.9*.eval(a,x,y)) else (.1*.eval(a,x,y)
| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)
Error: Syntax error: operator expected.


let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y)
| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)
Characters 392-393:
  | Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y)
                                                                             ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))
| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)
Error: Syntax error


let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))
| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y)  eval(a,x,y)
Error: Syntax error



hw3 sqsum

fix:
let sqsum xs = 
let f a x = x*x
in
let base = 0 in
List.fold_left f base xs

bad:
let _ = sqsum [1;2;3;4]
Error: This expression has type int but an expression was expected of type
         int list


let _ = sqsum [(-1); (-2); (-3); (-4)]
Error: This expression has type int but an expression was expected of type
         int list



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe fs = 
let f a x = x(a) in
let base = 0 in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe fs = 
let f a x = x(a) in
let base = f 0 in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = f 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x(a) in
let base = a in
List.fold_left f base fs
Error: Unbound value a



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun a -> 0 in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         int -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun a->a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun a' in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x a in
let base = fun a'->_ in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x a in
let base = fun 'a->'a in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = 'a in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = a in
let base = fun a -> a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun a -> a in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = fun z -> a (x z) in
let base = fun a-> f a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun a-> f a in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x ^ a in
let base =  sepConcat sep t in
let l =  h in
List.fold_left f base l

bad:
let _ = sepConcat ", " ["foo";"bar";"baz"]
Error: This expression has type string but an expression was expected of type
         string list


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x ^ a in
let base =  sepConcat sep t in
let l =  f in
List.fold_left f base l
Error: This expression has type string -> string -> string
       but an expression was expected of type string list



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = "" in
let base =  sepConcat sep t in
let l =  h in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x ^ a in
let base =  sepConcat sep t in
let l =  "" in
List.fold_left f base l
Error: This expression has type string but an expression was expected of type
         string list



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x^a in
let base =  sepConcat sep t in
let l =  t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = "" in
let base =  sepConcat sep t in
let l =  "" in
List.fold_left f base l
Error: This expression has type string but an expression was expected of type
         'a list


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = "" in
let base =  sepConcat sep {} in
let l =  "" in
List.fold_left f base l
Error: Syntax error


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = "" in
let base =  sepConcat sep [] in
let l =  "" in
List.fold_left f base l
Error: This expression has type string but an expression was expected of type
         'a list


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = "" in
let base =  "" in
let l =  "" in
List.fold_left f base l
Error: This expression has type string but an expression was expected of type
         'a list



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base =  if t=[] then "A" else h in
let l =  sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base =  if t=[] then "A" else t in
let l =  sl in
List.fold_left f base l
Error: This expression has type 'a list
       but an expression was expected of type string



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^x in
let base =  if t=[] then sep else h in
let l =  sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^x in
let base =  if t="" then sep else h in
let l =  sl in
List.fold_left f base l
Error: This expression has type string but an expression was expected of type
         'a list



hw3 ???

fix:
fun x -> x

bad:
fun x -> 'b
Error: Syntax error


fun x -> y
Error: Unbound value y



hw3 stringOfList

fix:
let _ = sepConcat "X" ["hello"]

let stringOfList f l = failwith List.map (fun x-> x) l

bad:
let _ = sepConcat "X" ["hello"]

fun x -> x
Error: Syntax error


let stringOfList f l = failwith List.map (fun x-> "") l
Error: This expression has type ('a -> 'b) -> 'a list -> 'b list
       but an expression was expected of type string


let _ = sepConcat "X" ["hello"]

fun x -> x
Error: Syntax error


let stringOfList f l = failwith List.map (fun x-> "") l
Error: This expression has type ('a -> 'b) -> 'a list -> 'b list
       but an expression was expected of type string



hw3 stringOfList

fix:
let asd_ x = x

let stringOfList f l = failwith List.map asd l

bad:
let stringOfList f l = failwith List.map (fun x-> x) (l)
Error: This expression has type ('a -> 'b) -> 'a list -> 'b list
       but an expression was expected of type string



hw3 stringOfList

fix:
let stringOfList f l = List.map (sepConcat "") l

bad:
let stringOfList f l = List.map asd l
Error: Unbound value asd
Hint: Did you mean asd_ or asr?
Error: Unbound value asd
Hint: Did you mean asr?
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value asd
Hint: Did you mean asd_ or asr?



hw3 stringOfList

fix:
let stringOfList f l = List.map (sepConcat " ") l

let _ = stringOfList string_of_int [1;2;3;4;5;6]

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: This expression has type int but an expression was expected of type
         string list



hw3 stringOfList

fix:
let stringOfList f l = List.map (sepConcat "") l

bad:
let stringOfList f l = List.map (sepConcat " ") l.string
Error: Unbound record field string



hw3 stringOfList

fix:
let stringOfList f l = List.map (fun x->x) l

let _ = stringOfList string_of_int [1;2;3;4;5;6]

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: This expression has type int but an expression was expected of type
         string



hw3 stringOfList

fix:
let stringOfList f l = List.map (fun x-> Printf.sprintf "%d" x) l

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: This expression has type int but an expression was expected of type
         string



hw3 stringOfList

fix:
let stringOfList f l = List.map (sepConcat f) l

bad:
let _ = stringOfList (fun x -> x) ["foo"]
Error: This expression has type string but an expression was expected of type
         int



hw3 stringOfList

fix:
let stringOfList f l = List.map (f) l

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: This expression has type int -> string
       but an expression was expected of type string



hw3 clone

fix:
let sqsum xs = 
let f a x = x*x+a in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = fun z -> x (a z) in
let base = fun a -> a in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base =  h in
let l =  t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = List.map (f) l

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n =
let accum=[] in
if n<1
then []
else clone x::accum n-1

bad:
let rec clone x n =
let acc = [] in
if x=0
then acc
else acc::clone x n-1
Error: This expression has type 'a list list
       but an expression was expected of type int


let rec clone x n =
let acc = [] in
if n=0
then acc
else clone x::acc n-1
Error: This expression has type int -> 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside int -> 'a list


let rec clone x n =
let acc = [] in
if n=0
then acc
else clone x::acc n-1
Error: This expression has type int -> 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside int -> 'a list



hw3 clone

fix:
let rec clone x n =
let accum=[] in
if n<1
then []
else clone x n

bad:
let rec clone x n =
let accum=[] in
if n<1
then []
else clone x n-1
Error: This expression has type 'a list
       but an expression was expected of type int


let rec clone x n =
let accum=[] in
if n<1
then []
else clone x ne
Error: Unbound value ne



hw3 clone

fix:
let rec clone x n =
let accum=[] in
if n<1
then []
else clone x (n-1)

bad:
let rec clone x n =
let accum=[] in
if n<1
then []
else clone x n-1
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 ???

fix:
let h::t = [1;1]

bad:
h::t = [1]
Error: Unbound value h



hw3 clone

fix:
let _ = clone 3 5

bad:
let _ = clone 3 -1
Error: This expression has type int -> int list
       but an expression was expected of type int



hw3 padZero

fix:
let padZero l1 l2 = ((clone (clone 0 1)::l1 2),l2)

bad:
let _ = padZero [9;9] [1;0;0;2]
Error: This expression has type int but an expression was expected of type
         int list



hw3 padZero

fix:
let padZero l1 l2 = ((clone 0::l1 2),l2)

bad:
let _ = padZero [9;9] [1;0;0;2]
Error: This expression has type 'a list
       but an expression was expected of type
         int -> (int -> int list list) list



hw3 padZero

fix:
let sqsum xs = 
let f a x = x*x+a in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = fun z -> x (a z) in
let base = fun a -> a in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base =  h in
let l =  t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = List.map (f) l

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n =
let accum=[] in
let rec helper accum n=
if n<1
then accum
else helper (x::accum)(n-1) in
helper accum n

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
List.concat (clone 0 (b-a)) l1

bad:
let _ = padZero [9;9] [1;0;0;2]
Error: This expression has type 'a list
       but an expression was expected of type int -> (int -> int list) list



hw3 padZero

fix:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
then List.append (clone 0 (b-a)) l1
else []

bad:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
List.append (clone 0 (b-a)) l1
Error: Syntax error


let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
List.append (clone 0 (b-a)) l1
Error: Syntax error


let _ = padZero [9;9] [1;0;0;2]
Error: This expression has type 'a list
       but an expression was expected of type int -> (int -> int list) list


let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
List.append l2 l1
Error: Syntax error


let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
List.append (clone 0 (b-a)) l1
else []
Error: Syntax error



hw3 padZero

fix:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
a

bad:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
then (List.append (clone 0 (b-a)) l1)
else if(b<a)
then (List.append (clone 0 (a-b)) l2)
Error: This expression has type int list
       but an expression was expected of type unit


let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
then (List.append (clone 0 (b-a)) l1)
else if(b<a)
then (List.append (clone 0 (a-b)) l2)
Error: This expression has type int list
       but an expression was expected of type unit


let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
then (List.append (clone 0 (b-a)) l1)
else if(b<a)
then List.append (clone 0 (a-b)) l2
Error: This expression has type int list
       but an expression was expected of type unit


let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
then (List.append (clone 0 (b-a)) l1)
Error: This expression has type int list
       but an expression was expected of type unit


let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
then List.append (clone 0 (b-a)) l1
Error: This expression has type int list
       but an expression was expected of type unit


let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
then List.append (clone 0 b-a) l1
Error: This expression has type int list
       but an expression was expected of type int


let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
then List.append (clone 0 1) l1
Error: This expression has type int list
       but an expression was expected of type unit


let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(1)
then List.append (clone 0 1) l1
Error: This expression has type int but an expression was expected of type
         bool


let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(true)
then List.append (clone 0 1) l1
Error: This expression has type int list
       but an expression was expected of type unit


let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(true)
then List.append l1 l1
Error: This expression has type 'a list
       but an expression was expected of type unit



hw3 padZero

fix:
let padZero l1 l2 = List.length l1

bad:
let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
then a
Error: This expression has type int but an expression was expected of type
         unit


let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
then 1
Error: This expression has type int but an expression was expected of type
         unit


let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
then 1
Error: This expression has type int but an expression was expected of type
         unit


let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
then ""
Error: This expression has type string but an expression was expected of type
         unit



hw3 padZero

fix:
let padZero l1 l2 = let a = List.length l1 in
a

bad:
let padZero l1 l2 = let a = List.length l1
Error: Syntax error



hw3 padZero

fix:
let padZero l1 l2 = let a = List.length l1 in
let b= List.length l2 in
if (1<2)
then 1
else 2

bad:
let padZero l1 l2 = let a = List.length l1 in
let b= List.length l2 in
if (a<b)
then a
Error: This expression has type int but an expression was expected of type
         unit


let padZero l1 l2 = let a = List.length l1 in
let b= List.length l2 in
if (1<2)
then 1
Error: This expression has type int but an expression was expected of type
         unit


let padZero l1 l2 = let a = List.length l1 in
let b= List.length l2 in
if (1<2)
then clone 0 1
Error: This expression has type int list
       but an expression was expected of type unit



hw3 stringOfList

fix:
let stringOfList f l = sepConcat "," (List.map (f) l)

bad:
let stringOfList f l = sepConcat(" " (List.map (f) l))
Error: This expression has type string
       This is not a function; it cannot be applied.



hw3 stringOfList

fix:
let stringOfList f l = (sepConcat ";" (List.map (f) l))

let _ = stringOfList string_of_int [1;2;3;4;5;6]

bad:
let stringOfList f l = "["::(sepConcat ";" (List.map (f) l))
Error: This expression has type string but an expression was expected of type
         string list



hw3 stringOfList

fix:
let sqsum xs = 
let f a x = x*x+a in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = fun z -> x (a z) in
let base = fun a -> a in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base =  h in
let l =  t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = Printf.sprintf"[%s]" (sepConcat ";" (List.map (f) l))

bad:
let stringOfList f l = (sepConcat ";" (List.map (f) l))."]"
Error: Syntax error



hw3 bigAdd

fix:
let sqsum xs = 
let f a x = x*x+a in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = fun z -> x (a z) in
let base = fun a -> a in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base =  h in
let l =  t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = Printf.sprintf"[%s]" (sepConcat "; " (List.map (f) l))

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n =
let accum=[] in
let rec helper accum n=
if n<1
then accum
else helper (x::accum)(n-1) in
helper accum n

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in
if(a<b)
then ((List.append (clone 0 (b-a)) l1),l2)
else if(b<a)
then (l1,(List.append (clone 0 (a-b)) l2))
else 
(l1,l2)

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

let rec removeZero l = match l with
| [] -> []
| h::t -> if h=0 then removeZero t else l

let _ = removeZero [0;0;0;1;0;0;2]

let _ = removeZero [9;9]

let _ = removeZero [0;0;0;0]

let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  base  in
let base = [] in
let args = (l1,l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  x+1::a in
let base = [] in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list
       but an expression was expected of type 'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  x+1::a in
let base = [] in
let args = (l1,l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type int list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a  in
let base = ([],[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a  in
let base = [] in
let args = (l1,l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
([],[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
a=(t,(h+x))::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type 'b list * 'c


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
a=(_,(h+x))
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error: operator expected.


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
a=(l1,(h+x))
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list * int -> int -> bool
       but an expression was expected of type
         int list * int -> int -> int list * int
       Type bool is not compatible with type int list * int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
x+h
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list * 'a -> int -> int
       but an expression was expected of type
         int list * 'a -> int -> int list * 'a
       Type int is not compatible with type int list * 'a 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
(x+h,_)
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error: operator expected.


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
(x+h,[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list * 'a -> int -> int * 'b list
       but an expression was expected of type
         int list * 'a -> int -> int list * 'a
       Type int is not compatible with type int list 



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
([],[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
(0,0)::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b
       but an expression was expected of type (int * int) list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
0::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b
       but an expression was expected of type int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
[0;0]::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b
       but an expression was expected of type int list list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
[[0];[0]]::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b
       but an expression was expected of type int list list list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
([],[])::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b
       but an expression was expected of type ('c list * 'd list) list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
([],0)::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b
       but an expression was expected of type ('c list * int) list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
[([],0)]::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b
       but an expression was expected of type ('c list * int) list list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
[],0::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b
       but an expression was expected of type int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
[]::a
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b
       but an expression was expected of type 'c list list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
a=(t,x+h::b)
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list * int list -> int -> bool
       but an expression was expected of type
         int list * int list -> int -> int list * int list
       Type bool is not compatible with type int list * int list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
a=(t,b)
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b -> 'c -> bool
       but an expression was expected of type
         'a list * 'b -> 'c -> 'a list * 'b
       Type bool is not compatible with type 'a list * 'b 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
a=([],[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b list -> 'c -> bool
       but an expression was expected of type
         'a list * 'b list -> 'c -> 'a list * 'b list
       Type bool is not compatible with type 'a list * 'b list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,_) =a  in
a=([],[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b list -> 'c -> bool
       but an expression was expected of type
         'a list * 'b list -> 'c -> 'a list * 'b list
       Type bool is not compatible with type 'a list * 'b list 



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
(t,x+h::b)
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
a=(l1,[])
in
let base = (List.rev l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b list -> 'c -> bool
       but an expression was expected of type
         'a list * 'b list -> 'c -> 'a list * 'b list
       Type bool is not compatible with type 'a list * 'b list 



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h in
let asd2=x+h-(asd*10) in
let asd3=asd::t in
let (_,asd4)=padZero asd3 (asd2::b) in
(asd3,asd4)
else
(t,(x+h)::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h::t in
(asd,padZero(asd,x+h::b))
else
(t,x+h::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h::t in
(asd,padZero(asd,(x+h::b)))
else
(t,x+h::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h in
let asd2=x+h-(asd*10) in
let asd3=asd::t in
(asd3,padZero(asd3,asd2))
else
(t,x+h::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h in
let asd2=x+h-(asd*10) in
let asd3=asd::t in
(asd3,padZero(asd3 asd2))
else
(t,x+h::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list
       This is not a function; it cannot be applied.


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h in
let asd2=x+h-(asd*10) in
let asd3=asd::t in
(asd3,padZero asd3 asd2)
else
(t,x+h::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h in
let asd2=x+h-(asd*10) in
let asd3=asd::t in
(asd3,padZero asd3 asd2::b)
else
(t,x+h::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h in
let asd2=x+h-(asd*10) in
let asd3=asd::t in
(asd3,padZero asd3 (asd2::b))
else
(t,x+h::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type int list * int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x/h) > 0)
then
let asd= x/h in
let asd2=x+h-(asd*10) in
let asd3=asd::t in
(asd3,padZero asd3 (asd2::b))
else
(t,(x+h)::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type int list * int list



hw3 ???

fix:
let _= (1,3)>(1,2)

bad:
let _ (_,3)>(1,2)
Error: Syntax error


let _= (_,3)>(1,2)
Error: Syntax error: operator expected.



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x+h) > 9)
then
let asd2=x+h-10 in
let h2::t2=t in
let asd3=h2+1::t2 in
(asd3,asd2::b)
else if(t=[] & (x+h)>9)
then
let asd2=x+h-10 in
let asd3=asd2::b in
([],1::asd3)
else
(t,(x+h)::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x+h) > 9)
then
let asd2=x+h-10 in
let h2::t2=t in
let asd3=h2+1::t2 in
(asd3,asd2::b)
else if(t=[])
then
let asd2=x+h-10 in
let asd3=t in
let asd3=h2+1::t2 in
(_,asd2::b)
else
(t,(x+h)::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error: operator expected.


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x+h) > 9)
then
let asd2=x+h-10 in
let h2::t2=t in
let asd3=h2+1::t2 in
(asd3,asd2::b)
else if(t=[])
then
let asd2=x+h-10 in
let asd3=t in
let asd3=h2+1::t2 in
([],asd2::b)
else
(t,(x+h)::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value h2



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x+h) > 9)
then
if(t=[])
then
([],1::(x+h-10)::b)
else
let h2::t2=t in
((h2+1::t2),(x+h-10)::b)

else
(t,(x+h)::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  
let (h::t,b) =a  in
if((x+h) > 9)
then
if((t=[])
then
([],1::(x+h-10)::b)
else
let h2::t2=t in
((h2+1::t2),(x+h-10)::b)

else
(t,(x+h)::b)
in
let base = (List.rev l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Characters 95-96:
  if((t=[])
    ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw3 mulByDigit

fix:
let rec mulByDigit i l = 
let accum = [] in
let rec helper x l accum= 
if(x != 0)
then
helper (x-1) l (bigAdd l accum)
else accum
in
mulByDigit i (helper i l accum)

bad:
let rec mulByDigit i l = 
let accum = [] in
let rec helper i l accum = 
if(i ~=0)
then
match l with
| h::t -> list.concat (helper i-1 t (bigAdd h h)) accum
else accum
in
helper
Error: Unbound value ~=


let rec mulByDigit i l = 
let accum = [] in
let rec helper i l accum = 
if(i != 0)
then
match l with
| h::t -> list.concat (helper i-1 t (bigAdd h h)) accum
else accum
in
helper
Error: Unbound value list


let rec mulByDigit i l = 
let accum = [] in
let rec helper x l accum= 
if(x != 0)
then
helper x-1 l (bigAdd l accum)
else accum
in
mulByDigit (helper i l accum)
Error: This expression has type 'a -> 'b -> 'c
       but an expression was expected of type int


let rec mulByDigit i l = 
let accum = [] in
let rec helper x l accum= 
if(x != 0)
then
helper (x-1) l (bigAdd l accum)
else accum
in
mulByDigit (helper i l accum)
Error: This expression has type int list
       but an expression was expected of type int



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = let (q,w) = a in
(mulByDigit x q,[]) in 
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = let (q,w) = a in
mulByDigit x q in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list * 'a -> int -> int list
       but an expression was expected of type
         int list * 'a -> int -> int list * 'a
       Type int list is not compatible with type int list * 'a 


let bigMul l1 l2 = 
let f a x = let (q,w) = a in
(mulByDigit x q)
Error: Syntax error


let bigMul l1 l2 = 
let f a x = let (q,w) = a in
(mulByDigit x q) in 
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list * 'a -> int -> int list
       but an expression was expected of type
         int list * 'a -> int -> int list * 'a
       Type int list is not compatible with type int list * 'a 



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = let (q,w) = a in
(q+1,mulByDigit x l1) in 
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = let (q,w) = a in
((+)1,mulByDigit x q) in 
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type
         int list * 'a -> int -> (int -> int) * int list
       but an expression was expected of type
         int list * 'a -> int -> int list * 'a
       Type int -> int is not compatible with type int list 


let bigMul l1 l2 = 
let f a x = let (q,w) = a in
(q+1,mulByDigit x q) in 
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int but an expression was expected of type
         int list



hw2 wwhile

fix:
let rec wwhile (f,b) =   
let (b', c') = f b in 
if c' then 
wwhile (f,b') 
else 
b'

bad:
let rec wwhile (f,b) =   
let (b', c') = f b in 
if c' then 
wwhile (f,b') 
else 
b'
Error: Unbound value return



hw2 fixpoint

fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let fixpoint (f,b) = wwhile (let f b =  let fb  = f b in
(fb,fb=b) ,b)
Error: Unbound value fixpoint


let fixpoint (f,b) = wwhile (let f b in  let fb  = f b in
(fb,fb=b) ,b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ((  let fb  = f b in
(fb,fb=b)) ,b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ((  let w b = let fb  = f b in
(fb,fb=b)) ,b)
Error: Unbound value wwhile


let fixpoint (f,b) = wwhile ((  let w b = let fb  = f b in 
(fb,fb=b) in f b) ,b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ((  let w b' = let fb  = f b' in 
(fb,fb=b') in f b) ,b)
Error: Unbound value wwhile


let fixpoint (f,b) = wwhile ((  let w b' = let fb  = f b' in 
(fb,fb=b') in f b') ,b)
Error: Unbound value wwhile


let fixpoint (f,b) = wwhile ((  let w b' = let fb  = f b' in 
(fb,fb=b') in f b) ,b)
Error: Unbound value wwhile


let fixpoint (f,b) = let w b' = let fb  = f b' in 
(fb,fb=b') in  wwhile ( w ,b)
Error: Unbound value wwhile


let fixpoint (f,b) =  wwhile (let w b' = let fb  = f b' in 
(fb,fb=b') in  w ,b)
Error: Unbound value wwhile


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 build

fix:
let _ = exprToString build (makeRand,5)

bad:
let rec build (rand, depth) = 
if depth = 0 then
let x= rand 1 2 in 
if x=1 then
buildX()
else
buildY()
else
let b = build(rand,depth-1) in 
match rand 1 5 with
| 1 -> buildSine(b)
| 2 -> buildCosine(b)
| 3 -> buildAverage(b,build(rand,depth-1))
| 4 -> buildTimes(b,build(rand,depth-1))
| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
Error: This function has type expr -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw2 build

fix:
let rec build (rand, depth) = 
if depth = 0 then
let x= rand (1,2) in 
if x=1 then
buildX()
else
buildY()
else
let b = build(rand,depth-1) in 
match rand(1,5) with
| 1 -> buildSine(b)
| 2 -> buildCosine(b)
| 3 -> buildAverage(b,build(rand,depth-1))
| 4 -> buildTimes(b,build(rand,depth-1))
| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))

let _ = exprToString (build (makeRand,5))

bad:
let _ = exprToString (build (makeRand,5))
Error: This function has type expr -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw2 build

fix:
let _ = let rand=makeRand(10,10) in exprToString (build (rand,5))

bad:
let _ = let rand=makeRand(10,39) in exprToString (build (rand,5))
Error: This expression has type int * int -> int * int -> int
       but an expression was expected of type int * int -> int
       Type int * int -> int is not compatible with type int 



hw2 ???

fix:
let _ = tanh (( -0.5+.0.9)/.0.4)

bad:
let _ = tanh (pi*. -0.5+.0.9)
Error: This expression has type float -> float
       but an expression was expected of type int



hw3 sqsum

fix:
let sqsum xs = 
let f a x = (a*a)+ x  in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

bad:
let sqsum xs = 
let f a x = a^2::x  in
let base = 0 in
List.fold_left f base xs
Error: This expression has type 'a list
       but an expression was expected of type string


let _ = sqsum []
Error: Unbound value sqsum


let _ = sqsum [1;2;3;4]
Error: Unbound value sqsum


let _ = sqsum [(-1); (-2); (-3); (-4)]
Error: Unbound value sqsum


let sqsum xs = 
let f a x = (a^2)::x  in
let base = 0 in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         string


let _ = sqsum []
Error: Unbound value sqsum


let _ = sqsum [1;2;3;4]
Error: Unbound value sqsum


let _ = sqsum [(-1); (-2); (-3); (-4)]
Error: Unbound value sqsum


let sqsum xs = 
let f a x = (a^2.)::x  in
let base = 0 in
List.fold_left f base xs
Error: This expression has type float but an expression was expected of type
         string


let sqsum xs = 
let f a x = (a*a)::x  in
let base = 0 in
List.fold_left f base xs
Error: This expression has type int -> int list -> int list
       but an expression was expected of type int -> int list -> int
       Type int list is not compatible with type int 


let _ = sqsum []
Error: Unbound value sqsum


let _ = sqsum [1;2;3;4]
Error: Unbound value sqsum


let _ = sqsum [(-1); (-2); (-3); (-4)]
Error: Unbound value sqsum



hw3 pipe

fix:
let pipe fs n= 
let f a x = x a  in
let base = n in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe fs = 
let f a x = x a  in
let base = f   in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a  in
let base = f a in
List.fold_left f base fs
Error: Unbound value a


let pipe fs = 
let f a x = x a  in
let base = f _ in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x a  in
let base = f fs in
List.fold_left f base fs
Error: This expression has type 'a but an expression was expected of type
         ((('a -> 'b) -> 'b) -> ('a -> 'b) -> 'b) list
       The type variable 'a occurs inside
       ((('a -> 'b) -> 'b) -> ('a -> 'b) -> 'b) list


let pipe fs = 
let f a x = x a  in
let base = _  in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x   in
let base = f   in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a  in
let base = f fs  in
List.fold_left f base fs
Error: This expression has type 'a but an expression was expected of type
         ((('a -> 'b) -> 'b) -> ('a -> 'b) -> 'b) list
       The type variable 'a occurs inside
       ((('a -> 'b) -> 'b) -> ('a -> 'b) -> 'b) list



hw3 pipe

fix:
let pipe fs  = 
let f a x = x   in
let base = 0   in
List.fold_left f base fs

bad:
let pipe fs  = 
let f a x = x   in
let base =   in
List.fold_left f base fs
Error: Syntax error


let pipe fs  = 
let f a x = x   in
let base =   in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs  = 
let f a x = x a  in
let base = function y ->y  in
List.fold_left f base fs

bad:
let pipe fs  = 
let f a x = x a  in
let base = function y   in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = function y -> y  in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let pipe fs = 
let f a x = x a in
let base = fun y  in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = function y -> y  in
List.fold_left f base

let _ = pipe [] 3

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = function y -> y  in
List.fold_left f base fs

let _ = pipe [] 3

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         (('a -> 'a) -> 'a -> 'a) list


let pipe fs = 
let f a x = x a in
let base = function y -> y  in
List.fold_left f base xs
Error: Unbound value xs


let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         (('a -> 'a) -> 'a -> 'a) list



hw3 stringOfList

fix:
let stringOfList f l = "[" ^ (sepConcat "; " (List.map f l)) ^ "]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

bad:
let stringOfList f l = "[" ^ (sepConcat "; " (map f l)) ^ "]"
Error: Unbound value map
Hint: Did you mean max?


let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: Unbound value stringOfList


let _ = stringOfList (fun x -> x) ["foo"]
Error: Unbound value stringOfList


let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]
Error: Unbound value stringOfList



hw3 clone

fix:
let rec clone x n = 
let rec helper x n acc =
if n<= 0 then
acc
else
helper x (n-1) (x::acc) 
in
helper x n []

bad:
let rec clone x n = 
let rec helper x n acc 
if n<= 0 then
acc
else
helper x (n-1) (x::acc) 
in
helper x n []
Error: Syntax error



hw3 padZero

fix:
let padZero l1 l2 = 
let len1=List.length l1 in 
let len2=List.length l2 in
if len1>len2 then
l1
else
l2

bad:
let padZero l1 l2 = 
let len1=List.length l1 in 
let len2=List.length l2 in
if len1>len2 then
((clone 0 (len1-len2)) @ len2),len1
Error: This expression has type 'a * 'b
       but an expression was expected of type unit


)
else
((clone 0 (len2-len1)) @ len1),len2
Error: Syntax error


)
Error: Syntax error


let _ = padZero [9;9] [1;0;0;2]
Error: Unbound value padZero


let _ = padZero [1;0;0;2] [9;9]
Error: Unbound value padZero



hw3 padZero

fix:
let padZero l1 l2 = 
let len1=List.length l1 in 
let len2=List.length l2 in
if len1>len2 then
(clone 0 (len1-len2)) 
else
(clone 0 (len2-len1))

bad:
let padZero l1 l2 = 
let len1=List.length l1 in 
let len2=List.length l2 in
if len1>len2 then
(clone 0 (len1-len2)) 
else
((clone 0 (len2-len1)) @ l1),l2
Error: This expression has type 'a * 'b
       but an expression was expected of type int list


)
Error: Syntax error



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = 
let (v,l)=x in
let (ac,la)=a in
let mul= mulByDigit v l in
let shift= mulByDigit ac mul in 
(ac*10,bigAdd shift la)
in
let base = (1,[]) in
let args = List.map (fun x -> (x,(List.rev l2))) l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (v,l)=x in
let (ac,la)=a in
let mul= mulByDigit v l in
let shift= mulByDigit ac a in 
(ac*10,bigAdd mul shift)
in
let base = (1,[]) in
let args = List.map (fun x -> (x,l2)) l1 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int * 'a
       but an expression was expected of type int list


let bigMul l1 l2 = 
let f a x = 
let (v,l)=x in
let (ac,la)=a in
let mul= mulByDigit v l in
let shift= mulByDigit mul ac in 
(ac*10,bigAdd shift la)
in
let base = (1,[]) in
let args = List.map (fun x -> (x,(List.rev l2))) l1 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs = 
let f a x = x(a) in
let base = function y ->y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x(a) in
let base = function  in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x(a) in
let base = function x in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x =  x(a) in
let base = function y ->y in
List.fold_left f base fs

let _ = pipe [] 3

bad:
let pipe fs = 
let f a x = function x(a) in
let base = 0 in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = function _ ->x(a) in
let base = 0 in
List.fold_left f base fs
Error: This expression has type int but an expression was expected of type
         'a -> 'b


let pipe fs = 
let f a x =  x(a) in
let base = function in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = function v ->  x (a v) in
let base = function y ->y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = function f' -> f' x(a) in
let base = function y ->y in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> ('b -> 'a -> 'c) -> 'c
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside ('b -> 'a -> 'c) -> 'c


let pipe fs = 
let f a x = function f'->  x(f' a) in
let base = function y ->y in
List.fold_left f base fs
Error: This expression has type 'a -> ('b -> 'c) -> ('a -> 'b) -> 'c
       but an expression was expected of type 'a -> ('b -> 'c) -> 'a
       The type variable 'a occurs inside ('a -> 'b) -> 'c



hw3 removeZero

fix:
let rec multByDigit i l =
let rec helper i l2 acc s =
match l2 with
| []   -> 
s::acc
| h::t -> 
let n = i*h + s in
if n>9 then
helper i t ((n mod 10)::acc) (n/10) 
else
helper i t (n::acc) 0
in 
removeZero (helper i (List.rev l) [] 0)

bad:
let rec multByDigit i l =
rec helper i l2 acc s =
match l2 with
| []   -> 
s::acc
| h::t -> 
let n = i*h + s in
if n>9 then
helper i t ((n mod 10)::acc) (n/10) 
else
helper i t (n::acc) 0
in 
removeZero (helper i (List.rev l) [] 0)
Error: Syntax error



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| n ->  (n mod 10) :: (helper (n / 10)) in
helper n

bad:
let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| n ->  (n mod 10) @ (helper (n / 10)) in
helper n
Error: This expression has type int but an expression was expected of type
         'a list



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| n ->  helper (n / 10) @ [(n mod 10)] in
helper n

bad:
let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| n ->  (n mod 10) :: (helper (n / 10)) in
(helper n).reverse
Error: Unbound record field reverse


let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| n ->  (n mod 10) :: (helper (n / 10)) in
let rec reverse xs =
match xs with
| [] -> xs
| hd :: tl -> (reverse tl) :: hd in
reverse (helper n)
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| n ->  (n mod 10) :: (helper (n / 10)) in
let rec reverse xs =
match xs with
| [] -> []
| hd :: tl -> (reverse tl) :: hd in
reverse (helper n)
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec digitsOfInt n = 
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> (append tl (hd :: xs2)) in
let rec helper x =
match x with 
| 0 -> [] 
| n ->  append (helper (n / 10)) (n mod 10) in
helper n
Error: This expression has type int but an expression was expected of type
         'a list


let rec digitsOfInt n = 
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> (append tl (hd :: xs2)) in
let rec helper x =
match x with 
| 0 -> [] 
| n ->  append [helper (n / 10)] [(n mod 10)] in
helper n
Error: This expression has type int but an expression was expected of type
         'a list


let rec digitsOfInt n = 
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> (append tl (hd :: xs2)) in
let rec helper x =
match x with 
| 0 -> [] 
| n ->  append [helper (n / 10)] [n mod 10] in
helper n
Error: This expression has type int but an expression was expected of type
         'a list


let rec digitsOfInt n = 
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> (append tl (hd :: xs2)) in
let rec helper x =
match x with 
| 0 -> [] 
| n ->  append [helper (n / 10)] [(n mod 10)] in
helper n
Error: This expression has type int but an expression was expected of type
         'a list


let rec digitsOfInt n = 
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> (append tl (hd :: xs2)) in
let rec helper x =
match x with 
| 0 -> [] 
| n ->  (append [helper (n / 10)] [(n mod 10)]) in
helper n
Error: This expression has type int but an expression was expected of type
         'a list


let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| n ->  helper (n / 10) @ [(n mod 10)]
Error: Syntax error


) in
helper n
Error: Syntax error


let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| n ->  helper (n / 10) @ [(n mod 10)]
Error: Syntax error



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> (append tl (hd :: xs2)) in
let rec helper x =
match x with 
| 0 -> [] 
| n ->  (append (helper (n / 10)) [(n mod 10)]) in
helper n

bad:
let rec digitsOfInt n = 
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> (append tl (hd :: xs2)) in
let rec helper x =
match x with 
| 0 -> [] 
| n ->  (append helper (n / 10) [(n mod 10)]) in
helper n
Error: This function has type 'a list -> 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> (append tl (hd :: xs2)) in
let rec helper x =
match x with 
| 0 -> [] 
| m ->  (append (helper (m / 10)) [(m mod 10)]) in
helper n

bad:
let rec digitsOfInt n = 
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> (append tl (hd :: xs2)) in
let rec helper x =
match x with 
| 0 -> [] 
| m ->  helper (append [(m / 10)] [(m mod 10)]) in
helper n
Error: This expression has type int list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> hd :: append tl xs2 in
let rec helper x =
match x with 
| 0 -> [] 
| m ->  (append (helper (m / 10)) [(m mod 10)]) in
helper n

bad:
let rec digitsOfInt n = 
let rec append xs1 xs2 = 
match xs2 with 
| [] -> xs1
| hd :: tl -> (append (xs1 :: hd) tl) in
let rec helper x =
match x with 
| 0 -> [] 
| m ->  (append (helper (m / 10)) [(m mod 10)]) in
helper n
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 digitsOfInt

fix:
let _ = digitsOfInt 352663

bad:
let _ = digitsOfInt 3124
Error: This expression has type int -> int list
       but an expression was expected of type int



hw1 additivePersistence

fix:
let rec additivePersistence n = 
let rec helper count x =
if (x < 10) then count else  (helper (count + 1) (sumList (digits n)))
in (helper 0 n)

bad:
let _ = additivePersistence 9876
Error: Unbound value sumList



hw1 additivePersistence

fix:
let rec additivePersistence n = 
let rec helper count x =
if (count = 1) then count else  (helper (count + 1) (sumList (digits n)))
in (helper 0 n)

bad:
let _ = additivePersistence 9876
Error: Unbound value sumList



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| m ->  (append (helper (m / 10)) [(m mod 10)]) in
helper n

bad:
let rec digitsOfInt n = 
let rec helper x =
match x with 
| 0 -> [] 
| m ->  (append (helper (m / 10)) [(m mod 10)]) in
helper n
Error: Unbound value digitalRoot


let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> hd :: (append tl xs2)
Error: Unbound value append



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l = 
let rec helper xs result =
match xs with
| [] -> result
| hd :: tl ->  helper tl  (hd :: result) in
helper xs []
Error: This expression has type 'a list
       This is not a function; it cannot be applied.


let rec listReverse l = 
let rec helper xs result =
match xs with
| [] -> result
| hd :: tl ->  helper tl  (hd :: result) in
helper xs []
Error: Unbound value xs


let rec listReverse l = 
let rec helper xs result =
match xs with
| [] -> result
| hd :: tl ->  helper tl  (hd :: result) in
helper l []
Error: Unbound value xs



hw1 ???

fix:
let rec append xs1 xs2 = 
let rec helper xs1 xs2 result = 
match xs1 with 
| [] -> result
| hd :: tl -> (helper tl xs2  (hd :: result)) in
(helper xs1 xs2 [])

append [1] [2]

bad:
let rec append xs1 xs2 = 
let rec helper xs1 xs2 result = 
match xs1 with 
| [] -> result
| hd :: tl -> (helper tl xs2  hd :: result) in
(helper xs1 xs2 [])
Error: Syntax error


let rec append xs1 xs2 = 
let rec helper xs1 xs2 result = 
match xs1 with 
| [] -> result
| hd :: tl -> (helper tl xs2  (hd :: result)) in
(helper xs1 xs2 [])
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 ???

fix:
let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> hd :: (append tl xs2)

bad:
let rec append xs1 xs2 = 
let rec helper xs1 xs2 result = 
match xs1 with 
| [] -> result
| hd :: tl -> (helper tl xs2  (hd :: result)) in
(helper xs1 xs2 [])


append [1] [2]
Error: This expression has type 'a list
       This is not a function; it cannot be applied.


let rec append l1 l2 = 
let rec helper xs1 xs2 result = 
match xs1 with 
| [] -> result
| hd :: tl -> (helper tl xs2  (hd :: result)) in
(helper xs1 xs2 [])


append [1] [2]
Error: This expression has type 'a list
       This is not a function; it cannot be applied.


let rec append l1 l2 = 
let rec helper xs1 xs2 result = 
match xs1 with 
| [] -> result
| hd :: tl -> (helper tl xs2  (hd :: result)) in
(helper l1 l2 [])


append [1] [2]
Error: Unbound value xs1


let rec append l1 l2 = 
let rec helper xs1 xs2 result = 
match xs1 with 
| [] -> result
| hd :: tl -> (helper tl xs2  (hd :: result)) in
helper l1 l2 []


append [1] [2]
Error: This expression has type 'a list
       This is not a function; it cannot be applied.


let rec append l1 l2 = 
let rec helper xs1 xs2 result = 
match xs1 with 
| [] -> result
| hd :: tl -> (helper tl [] (hd :: result)) in
helper l1 l2 []


append [1] [2]
Error: This function has type 'a list -> 'b -> 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.


let rec append l1 l2 = 
let rec helper xs1 xs2 result = 
match xs1 with 
| [] -> result
| hd :: tl -> (helper tl [] (hd :: result)) in
helper l1 l2 []


append [1] [2]
Error: This function has type 'a list -> 'b list -> 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.


let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> hd :: (append tl xs2)

append [1] [2]
Error: This function has type 'a list -> 'b list -> 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.


let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> hd :: (append tl xs2) 

append [1] [2]
Error: This expression has type 'a list
       This is not a function; it cannot be applied.


let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> hd :: (append tl xs2) 

append [1] [2]
Error: This expression has type 'a list
       This is not a function; it cannot be applied.


let rec append xs1 xs2 = 
match xs1 with 
| [] -> xs2
| hd :: tl -> hd :: (append tl xs2)
Error: This expression has type 'a list
       This is not a function; it cannot be applied.



hw2 ???

fix:
let _ = List.mem 3 [1;2;3]

bad:
let _ = List.mem [1;2;3] 3
Error: This expression has type int but an expression was expected of type
         int list list



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = 
if List.mem h seen then h :: seen else seen  in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

l

bad:
et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]
Error: Syntax error



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = 
if List.mem h seen then h :: seen else seen  in
let rest' = t in helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]
Error: Syntax error



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)

bad:
let fixpoint (f,b) = wwhile (let xx = f xx in (xx, (f xx) = xx),b)
Error: Unbound value x


let fixpoint (f,b) = wwhile (let xx = in (xx, (f xx) = xx),b)
Error: Unbound value xx


let fixpoint (f,b) = wwhile (fun xx ((xx, (f xx) = xx)),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile (fun xx ((xx, f xx = xx)),b)
Characters 42-43:
  let fixpoint (f,b) = wwhile (fun xx ((xx, (f xx) = xx)),b);;
                                            ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let fixpoint (f,b) = wwhile (fun xx -> ((xx, f xx = xx)),b)
Error: Syntax error: pattern expected.


let fixpoint (f,b) = wwhile (fun xx -> (xx, f xx = xx),b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a


let fixpoint (f,b) = wwhile ((fun xx -> (xx, f xx = xx)),b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a



hw2 wwhile

fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let rec wwhile (f,b) =
let rec acc result =
let res = (f result) in
match res with
(b', c') -> if c' then acc b' else b'
in
acc b
Error: This expression has type 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((fun xx -> (f xx, (f xx) != xx)),b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 100)
Error: Unbound value wwhile


let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) != xx)),b)
Error: Unbound value fixpoint


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 739085 )
Error: Unbound value wwhile


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 739080 )
Error: Unbound value fixpoint



hw2 ???

fix:
let _ = pi / sqrt(2.0)

bad:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1
Error: Unbound value fixpoint



hw2 exprToString

fix:
exprToString VarX

bad:
let rec exprToString e = 
let acc curr result = 
match curr with 
| VarX x -> sprintf "%s" x
| VarY y -> sprintf "%s" y in
acc e

exprToString VarX
Error: The constructor VarX expects 0 argument(s),
       but is applied here to 1 argument(s)


let rec exprToString e = 
let acc curr result = 
match curr with 
| VarX x -> sprintf "%s" x
| VarY y -> sprintf "%s" y in
acc e ""

exprToString VarX
Error: The constructor VarX expects 0 argument(s),
       but is applied here to 1 argument(s)


let rec exprToString e = 
let acc curr result = 
match curr with 
| VarX-> sprintf "x" 
| VarY y -> sprintf "y" in
acc e ""

exprToString VarX
Error: The constructor VarX expects 0 argument(s),
       but is applied here to 1 argument(s)


let rec exprToString e = 
let acc curr result = 
match curr with 
| VarX-> sprintf "x" 
| VarY y -> sprintf "y" in
acc e ""

exprToString VarX
Error: The constructor VarY expects 0 argument(s),
       but is applied here to 1 argument(s)


let rec exprToString e = 
let acc curr result = 
match curr with 
| VarX-> sprintf "x" 
| VarY -> sprintf "y" in
acc e ""

exprToString VarX
Error: The constructor VarY expects 0 argument(s),
       but is applied here to 1 argument(s)


let rec exprToString e = 
let acc curr result = 
match curr with 
| VarX-> sprintf "x" 
| VarY -> sprintf "y" in
acc e ""

exprToString VarX
Error: Unbound value sprintf


let rec exprToString e = 
let acc curr result = 
match curr with 
| VarX-> printf "x" 
| VarY -> printf "y" in
acc e ""

exprToString VarX
Error: Unbound value sprintf


let rec exprToString e = 
let acc curr result = 
match curr with 
| VarX-> Printf.sprintf "x" 
| VarY -> sprintf "y" in
acc e ""

exprToString VarX
Error: Unbound value printf


let rec exprToString e = 
let acc curr result = 
match curr with 
| VarX-> Printf.sprintf "x" 
| VarY -> Printf.sprintf "y" in
acc e ""

exprToString VarX
Error: Unbound value sprintf


let rec exprToString e = 
let rec acc curr result = 
match curr with 
| VarX-> Printf.sprintf "x" 
| VarY -> Printf.sprintf "y" in
acc e ""

exprToString VarX
Error: This function has type expr -> 'a -> string
       It is applied to too many arguments; maybe you forgot a `;'.


let rec exprToString e = 
let rec acc curr result = 
match curr with 
| VarX-> Printf.sprintf "x" 
| VarY -> Printf.sprintf "y" in
acc e ""

exprToString VarX
Error: This function has type expr -> 'a -> string
       It is applied to too many arguments; maybe you forgot a `;'.


let rec exprToString e = 
let rec accu curr result = 
match curr with 
| VarX-> Printf.sprintf "x" 
| VarY -> Printf.sprintf "y" in
accu e ""

exprToString VarX
Error: This function has type expr -> 'a -> string
       It is applied to too many arguments; maybe you forgot a `;'.


let rec exprToString e = 
let rec accu curr result = 
match curr with 
| VarX-> Printf.sprintf "x" 
| VarY -> Printf.sprintf "y" in
accu e ""
Error: This function has type expr -> 'a -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw2 exprToString

fix:
exprToString VarX

bad:
let rec exprToString e = 
match e with 
| VarX-> Printf.sprintf "x" 
| VarY -> Printf.sprintf "y"  
| Sine x   -> Printf.sprintf "Sine(%s)" exprToString x
Error: Unbound value Printf.srprintf
Hint: Did you mean sprintf?


let rec exprToString e = 
match e with 
| VarX -> Printf.sprintf "x" 
| VarY -> Printf.sprintf "y"  
| Sine x -> Printf.sprintf "Sine\(%s\)" exprToString x
Error: This expression has type
         ('a -> 'b, unit, string, string, string, 'a -> 'b)
         CamlinternalFormatBasics.fmt
       but an expression was expected of type
         ('a -> 'b, unit, string, string, string, string)
         CamlinternalFormatBasics.fmt
       Type 'a -> 'b is not compatible with type string 


let rec exprToString e = 
match e with 
| VarX -> Printf.sprintf "x" 
| VarY -> Printf.sprintf "y"  
| Sine x -> Printf.sprintf "Sine(%s)" exprToString x
Error: This expression has type
         ('a -> 'b, unit, string, string, string, 'a -> 'b)
         CamlinternalFormatBasics.fmt
       but an expression was expected of type
         ('a -> 'b, unit, string, string, string, string)
         CamlinternalFormatBasics.fmt
       Type 'a -> 'b is not compatible with type string 


let rec exprToString e = 
match e with 
| VarX -> Printf.sprintf "x" 
| VarY -> Printf.sprintf "y"  
| Sine x -> Printf.sprintf "Sine(%s)" (exprToString x)
Error: This expression has type
         ('a -> 'b, unit, string, string, string, 'a -> 'b)
         CamlinternalFormatBasics.fmt
       but an expression was expected of type
         ('a -> 'b, unit, string, string, string, string)
         CamlinternalFormatBasics.fmt
       Type 'a -> 'b is not compatible with type string 



hw2 exprToString

fix:
let rec assoc (d,k,l) = 
let rec acc xs = 
match xs with 
| (k', v') :: tl -> 
if k' = k then 
v' else 
acc tl
| [] -> d
| _ -> failwith "This ain't your mom's hashmap"
in
acc l

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = 
if List.mem h seen then seen else h :: seen  in
let rest' = t in helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) =
let rec acc result =
let res = (f result) in
match res with
(b', c') -> if c' then acc b' else b'
in
acc b

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) = wwhile ((fun xx -> (f xx, (f xx) != xx)),b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0 )

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

type expr = 
VarX
| VarY
| Sine     of expr
| Cosine   of expr
| Average  of expr * expr
| Times    of expr * expr
| Thresh   of expr * expr * expr * expr

let rec exprToString e = 
match e with 
| VarX -> "x"
| VarY -> "y"
| Sine(x) -> Printf.sprintf "Sine(%s)" exprToString x

bad:
exprToString Sine(VarX)
Error: This function has type expr -> string
       It is applied to too many arguments; maybe you forgot a `;'.


exprToString Sine(VarX)
Error: This function has type expr -> string
       It is applied to too many arguments; maybe you forgot a `;'.


| failwith "Why don't you just make me write a lisp compiler"


exprToString Sine(VarX)
Error: This function has type expr -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw2 exprToString

fix:
let rec exprToString e = 
match e with 
| VarX -> "x"
| VarY -> "y"
| Sine(x) -> Printf.sprintf "Sine(%s)" (exprToString x)

exprToString Sine(VarX)

bad:
let rec exprToString e = 
match e with 
| VarX -> "x"
| VarY -> "y"
| Sine(x) -> Printf.sprintf "Sine(%s)" (exprToString x)
Error: This expression has type
         ('a -> 'b, unit, string, string, string, 'a -> 'b)
         CamlinternalFormatBasics.fmt
       but an expression was expected of type
         ('a -> 'b, unit, string, string, string, string)
         CamlinternalFormatBasics.fmt
       Type 'a -> 'b is not compatible with type string 



hw2 exprToString

fix:
exprToString Sine(VarX)

bad:
let rec exprToString e = 
match e with 
| VarX -> "x"
| VarY -> "y"
| Sine(x) -> Printf.sprintf "Sine(%s)" (exprToString x)
Error: This expression has type
         ('a -> 'b -> 'c -> 'd, unit, string, string, string,
          'a -> 'b -> 'c -> 'd)
         CamlinternalFormatBasics.fmt
       but an expression was expected of type
         ('a -> 'b -> 'c -> 'd, unit, string, string, string, string)
         CamlinternalFormatBasics.fmt
       Type 'a -> 'b -> 'c -> 'd is not compatible with type string 



hw2 exprToString

fix:
exprToString Sine(VarX)

bad:
exprToString Sine(VarX)
Error: This function has type expr -> string
       It is applied to too many arguments; maybe you forgot a `;'.


let rec exprToString e = 
match e with 
| VarX -> "x"
| VarY -> "y"
| Sine(x) -> Printf.sprintf "Sine(%s)" (exprToString x)
| _ -> failwith "are we writing a lisp compiler now"
Error: This function has type expr -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw2 exprToString

fix:
let rec exprToString e = 
match e with 
| VarX -> "x"
| VarY -> "y"
| Sine(x) -> Printf.sprintf "Sine(pi*%s)" (exprToString x)
| 
| _ -> failwith "are we writing a lisp compiler now"

bad:
let _ = exprToString (Sine(VarX))
Error: This function has type expr -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw2 exprToString

fix:
let _ = exprToString (Sine(VarX))

bad:
let rec exprToString e = 
match e with 
| VarX -> "x"
| VarY -> "y"
| Sine(x) -> Printf.sprintf "Sine(pi*%s)" (exprToString x)
| _ -> failwith "are we writing a lisp compiler now"
Error: Syntax error



hw2 exprToString

fix:
let _ = exprToString (Sine(Average(VarX, VarY)))

bad:
let rec exprToString e = 
match e with 
| VarX -> "x"
| VarY -> "y"
| Sine(e') -> Printf.sprintf "sin(pi*%s)" (exprToString e')
| Cosine(e') -> Printf.sprintf "cos(pi*%s)" (exprToString e')
| Average(e1, e2) -> Printf.sprintf "((%s+%s)/2)" 
(exprToString e1) 
(exprToString e2)
| Times (e1, e2) -> Printf.sprintf "%s*%s"
exprToString e1
exprToString e2
| _ -> failwith "are we writing a lisp compiler now"
Error: The constructor Times expects 2 argument(s),
       but is applied here to 1 argument(s)


let rec exprToString e = 
match e with 
| VarX -> "x"
| VarY -> "y"
| Sine(e') -> Printf.sprintf "sin(pi*%s)" (exprToString e')
| Cosine(e') -> Printf.sprintf "cos(pi*%s)" (exprToString e')
| Average(e1, e2) -> Printf.sprintf "((%s+%s)/2)" 
(exprToString e1) 
(exprToString e2)
| Times (e1, e2) -> Printf.sprintf "%s*%s"
(exprToString e1)
(exprToString e2)
| _ -> failwith "are we writing a lisp compiler now"
Error: This expression has type
         ('a -> 'b -> 'c, unit, string, string, string, 'a -> 'b -> 'c)
         CamlinternalFormatBasics.fmt
       but an expression was expected of type
         ('a -> 'b -> 'c, unit, string, string, string, string)
         CamlinternalFormatBasics.fmt
       Type 'a -> 'b -> 'c is not compatible with type string 



hw2 eval

fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr,0.5,0.2)

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine(e') -> sin(eval(e', x, y))
| Cosine(e') -> cos(eval(e', x, y))
| Average(e1, e2) -> (eval(e1, x, y) + eval(e2, x, y))/2
| Times (e1, e2) -> (eval(e1, x, y) * eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if eval(e1, x, y) < eval (e2, x, y)
then eval(e3, x, y)
else eval(e4, x, y)
| _ -> failwith "we are seriously writing a lisp compiler god save us all"
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine(e') -> sin(eval(e', x, y))
| Cosine(e') -> cos(eval(e', x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/2
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if eval(e1, x, y) < eval (e2, x, y)
then eval(e3, x, y)
else eval(e4, x, y)
| _ -> failwith "we are seriously writing a lisp compiler god save us all"
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine(e') -> sin(eval(e', x, y))
| Cosine(e') -> cos(eval(e', x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if eval(e1, x, y) < eval (e2, x, y)
then eval(e3, x, y)
else eval(e4, x, y)
| _ -> failwith "we are seriously writing a lisp compiler god save us all"
Error: This expression has type float but an expression was expected of type
         int



hw2 eval

fix:
let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

bad:
let _ = eval (sampleExpr1,0.5,0.2)
Error: This expression has type expr/1070
       but an expression was expected of type expr/1675
Error: This expression has type expr/2036
       but an expression was expected of type expr/2056
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type expr/1070
       but an expression was expected of type expr/1675



hw2 eval

fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine(e') -> sin(pi*.eval(e', x, y))
| Cosine(e') -> cos(pi*.eval(e', x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if eval(e1, x, y) < eval (e2, x, y)
then eval(e3, x, y)
else eval(e4, x, y)
| _ -> failwith "we are seriously writing a lisp compiler god save us all"
Error: This expression has type float but an expression was expected of type
         int



hw2 assoc

fix:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

bad:
let rec assoc (d,k,l) = 
match l with 
| (k', v') :: tl -> 
if k' = k then 
v' else 
assoc (d, k, tl)
| [] -> d
| _ -> failwith "This ain't your mom's hashmap"
Error: This expression has type 'a but an expression was expected of type
         'a * 'b * ('b * ('c -> 'd -> 'e)) list
       The type variable 'a occurs inside
       'a * 'b * ('b * ('c -> 'd -> 'e)) list



hw2 wwhile

fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let rec wwhile (f,b) =
let res = (f b) in
match res with
(b', c') -> if c' then wwhile (f, b') else b'
Error: Unbound value result



hw2 eval

fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr,0.5,0.2)

let _ = eval (Average(Sqrt (VarX), Sqrt(VarY)), 0.3, -0.3)

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine(e') -> sin(pi*.eval(e', x, y))
| Cosine(e') -> cos(pi*.eval(e', x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if eval(e1, x, y) < eval (e2, x, y)
then eval(e3, x, y)
else eval(e4, x, y)
| Sqrt (e) -> sqrt (abs (eval e))
| _ -> failwith "we are seriously writing a lisp compiler god save us all"
Error: Unbound value ^.


let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine(e') -> sin(pi*.eval(e', x, y))
| Cosine(e') -> cos(pi*.eval(e', x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if eval(e1, x, y) < eval (e2, x, y)
then eval(e3, x, y)
else eval(e4, x, y)
| Sqrt (e) -> sqrt (abs (eval (e, x, y)))
| _ -> failwith "we are seriously writing a lisp compiler god save us all"
Error: This expression has type expr but an expression was expected of type
         expr * float * float


let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine(e') -> sin(pi*.eval(e', x, y))
| Cosine(e') -> cos(pi*.eval(e', x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if eval(e1, x, y) < eval (e2, x, y)
then eval(e3, x, y)
else eval(e4, x, y)
| Sqrt (e) -> sqrt (absF (eval (e, x, y)))
| _ -> failwith "we are seriously writing a lisp compiler god save us all"
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine(e') -> sin(pi*.eval(e', x, y))
| Cosine(e') -> cos(pi*.eval(e', x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if eval(e1, x, y) < eval (e2, x, y)
then eval(e3, x, y)
else eval(e4, x, y)
| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))
| _ -> failwith "we are seriously writing a lisp compiler god save us all"
Error: Unbound value absF
Hint: Did you mean abs?



hw2 ???

fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(Sqrt(VarX)),Cosine(Average(VarX,VarY)))))

bad:
let _ = sqrt (abs_foat (-0.3))
Error: Unbound value abs_foat
Hint: Did you mean abs_float?


let _ = sqrt (abs_float (-0.3))
Error: Unbound value abs_foat
Hint: Did you mean abs_float?



hw2 eval

fix:
let _  = eval (Quad (VarX, VarY, VarX), 0.5, 0.5)

bad:
let _  = eval (Quad (VarX, VarY, VarX), 0.5, -0.5)
Error: This expression has type int but an expression was expected of type
         float



hw2 build

fix:
let rec build (rand, depth) = match depth with
| 0 -> VarX
| _ -> let next = build (rand, depth - 1) in
match rand (1, 7) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (next, next)
| 4 -> buildTimes (next, next)
| 5 -> buildThresh (next, next, next, next)
| 6 -> buildSqrt next
| 7 -> buildGauss (next, next, next)

let g1 () = failwith "to be implemented"

let g2 () = failwith "to be implemented"

let g3 () = failwith "to be implemented"

let c1 () = failwith "to be implemented"

let c2 () = failwith "to be implemented"

let c3 () = failwith "to be implemented"

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

let emitColor (f1,f2,f3,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_c_"^name) in
let chan = open_out (fname^".ppm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P6 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z1 = f1 (x,y) in
let z2 = f2 (x,y) in
let z3 = f3 (x,y) in

(* Convert the result to a grayscale value *)
let iz1 = toIntensity(z1) in
let iz2 = toIntensity(z2) in
let iz3 = toIntensity(z3) in

(* Emit one byte per color for this pixel *)
output_char chan (char_of_int iz1);
output_char chan (char_of_int iz2);
output_char chan (char_of_int iz3);
)) in  
close_out chan;
ignore(Sys.command ("convert "^fname^".ppm  "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".ppm"))

let doRandomColor (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand (seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e1 = build (g, depth) in
let e2 = build (g, depth) in
let e3 = build (g, depth) in

let _ = Format.printf "red   = %s \n" (exprToString e1) in
let _ = Format.printf "green = %s \n" (exprToString e2) in
let _ = Format.printf "blue  = %s \n" (exprToString e3) in

let f1 = eval_fn e1 in
let f2 = eval_fn e2 in
let f3 = eval_fn e3 in

(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitColor (f1,f2,f3,n,name)

type test = unit -> string

let key = ""

let prefix130 = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)); ErrorCode "exception")

let explode s = 
let rec _exp i = 
if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in
_exp 0

let implode cs = 
String.concat "" (List.map (String.make 1) cs)

let drop_paren s = 
implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))

let eq_real p (r1,r2) = 
(r1 -. r2) < p || (r2 -. r1) < p

let scoreMsg () = 
Format.sprintf "Results: Score/Max = %d / %d \n" !score !max

bad:
let rec build (rand, depth) = match depth with
| 0 -> VarX
| _ -> let next = build (rand, depth - 1) in
match rand (1, 7) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (next next)
| 4 -> buildTimes next next
| 5 -> buildThresh next next next next
| 6 -> buildSqrt next
| 7 -> buildGauss next next next
Error: This function has type expr * expr -> expr
       It is applied to too many arguments; maybe you forgot a `;'.


let rec build (rand, depth) = match depth with
| 0 -> VarX
| _ -> let next = build (rand, depth - 1) in
match rand (1, 7) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (next, next)
| 4 -> buildTimes next next
| 5 -> buildThresh next next next next
| 6 -> buildSqrt next
| 7 -> buildGauss next next next
Error: This expression has type expr
       This is not a function; it cannot be applied.


let rec build (rand, depth) = match depth with
| 0 -> VarX
| _ -> let next = build (rand, depth - 1) in
match rand (1, 7) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (next, next)
| 4 -> buildTimes (next, next)
| 5 -> buildThresh (next, next, next, next)
| 6 -> buildSqrt next
| 7 -> buildGauss (next, next, next)
Error: This function has type expr * expr -> expr
       It is applied to too many arguments; maybe you forgot a `;'.



hw2 build

fix:
)
| _ -> let next = build (rand, depth - 1) in
match rand (1, 7) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (next, next)
| 4 -> buildTimes (next, next)
| 5 -> buildThresh (next, next, next, next)
| 6 -> buildSqrt next
| 7 -> buildGauss (next, next, next)

bad:
let rec build (rand, depth) = match depth with
(| 0 -> match rand (1, 2) with
1 -> buildX
| 2 -> buildY)
| _ -> let next = build (rand, depth - 1) in
match rand (1, 7) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (next, next)
| 4 -> buildTimes (next, next)
| 5 -> buildThresh (next, next, next, next)
| 6 -> buildSqrt next
| 7 -> buildGauss (next, next, next)
Error: Syntax error


let rec build (rand, depth) = match depth with
( 0 -> match rand (1, 2) with
1 -> buildX
| 2 -> buildY)
| _ -> let next = build (rand, depth - 1) in
match rand (1, 7) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (next, next)
| 4 -> buildTimes (next, next)
| 5 -> buildThresh (next, next, next, next)
| 6 -> buildSqrt next
| 7 -> buildGauss (next, next, next)
Error: Syntax error: operator expected.


let rec build (rand, depth) = match depth with
0 -> match rand (1, 2) with
1 -> buildX
| 2 -> buildY
Characters 47-48:
  ( 0 -> match rand (1, 2) with
  ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw2 ???

fix:
let _ = abs_float (x)

bad:
let _ = abs_float -.40
Error: This expression has type int -> int
       but an expression was expected of type float


let _ = abs_float (-.40)
Error: This expression has type float -> float
       but an expression was expected of type float


let _ = abs_float (-0.40)
Error: This expression has type int but an expression was expected of type
         float



hw2 build

fix:
let buildAbs(e)			   = Abs(e)

bad:
let buildSqrt(e)                   = Sqrt(e)
Error: Unbound value x



hw2 ???

fix:
let _ = makeRand (1, 2)

bad:
let _ = makeRand (1, 2)
Error: Unbound value rand
Hint: Did you mean land?



hw2 ???

fix:
let _ = makeRand (1, 2) (1, 2)

bad:
let _ = makeRand (1, 2) (1, 2)
Error: This expression has type int but an expression was expected of type
         int * int



hw2 ???

fix:
let _ = makeRand (2, 2) (1,2)

bad:
let _ = makeRand (2, (1, 2))
Error: Syntax error: ')' expected
Error: This '(' might be unmatched


let _ = makeRand (2, 2) (1,2)
Error: This expression has type 'a * 'b
       but an expression was expected of type int



hw2 build

fix:
let rec build (rand, depth) = match depth with
| 0 -> (match rand (1, 3) with
1-> VarX
| 2 -> VarY )
| _ -> let next = build (rand, depth - 1) in
match rand (1, 8) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))
| 4 -> buildTimes (next, build (rand, depth - 1))
| 5 -> buildThresh (next, 
build (rand, depth - 1),
build (rand, depth - 1), 
build (rand, depth - 1))
| 6 -> buildSqrt next
| 7 -> buildGauss (next, 
build (rand, depth - 1), 
build (rand, depth - 1))

bad:
let rec build (rand, depth) = match depth with
| 0 -> (match rand (1, 3) with
1-> VarX
| 2 -> VarY )
| _ -> let next = build (rand, depth - 1) in
match rand (1, 7) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))
| 4 -> buildTimes (next, build (rand, depth - 1))
| 5 -> buildThresh (next, 
build (rand, depth - 1),
build (rand, depth - 1), 
build (rand, depth - 1))
| 6 -> buildSqrt next
| 7 -> buildGauss (next, 
build (rand, depth - 1), 
build (rand, depth - 1))
Error: Syntax error: operator expected.



hw2 build

fix:
let g1 () = failwith "to be implemented"

let g2 () = failwith "to be implemented"

let g3 () = failwith "to be implemented"

let c1 () = failwith "to be implemented"

let c2 () = failwith "to be implemented"

let c3 () = failwith "to be implemented"

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

bad:
let rec build (rand, depth) = match depth with
| 0 -> 
(match rand (0, 2) with
| 0-> VarX
| 1 -> VarY 
| _ -> VarY)
| _ -> let next = build (rand, depth - 1) in
(match rand (1, 8) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))
| 4 -> buildTimes (next, build (rand, depth - 1))
| 5 -> buildThresh (next, 
build (rand, depth - 1),
build (rand, depth - 1), 
build (rand, depth - 1))
| 6 -> buildSqrt next
| 7 -> buildGauss (next, 
build (rand, depth - 1), 
build (rand, depth - 1))
| _ -> buildAbs next)
Error: This expression has type expr but an expression was expected of type
         int



hw2 eval

fix:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine(e') -> sin(pi*.eval(e', x, y))
| Cosine(e') -> cos(pi*.eval(e', x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if eval(e1, x, y) < eval (e2, x, y)
then eval(e3, x, y)
else eval(e4, x, y)
| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))
| Logistic (e1, e2, e3) -> 
(2.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y) *. eval(e3, x, y )))
-. 1.0))
| _ -> failwith "error"

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine(e') -> sin(pi*.eval(e', x, y))
| Cosine(e') -> cos(pi*.eval(e', x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if eval(e1, x, y) < eval (e2, x, y)
then eval(e3, x, y)
else eval(e4, x, y)
| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))
| Logistic (e1, e2, e3) -> 
(2.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y)))
-. 1.0) ** eval (e3, x, y))
| _ -> failwith "error"
Error: This expression has type int but an expression was expected of type
         float



hw2 build

fix:
let g1 () = failwith "to be implemented"

let g2 () = failwith "to be implemented"

let g3 () = failwith "to be implemented"

let c1 () = failwith "to be implemented"

let c2 () = failwith "to be implemented"

let c3 () = failwith "to be implemented"

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

let emitColor (f1,f2,f3,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_c_"^name) in
let chan = open_out (fname^".ppm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P6 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z1 = f1 (x,y) in
let z2 = f2 (x,y) in
let z3 = f3 (x,y) in

(* Convert the result to a grayscale value *)
let iz1 = toIntensity(z1) in
let iz2 = toIntensity(z2) in
let iz3 = toIntensity(z3) in

(* Emit one byte per color for this pixel *)
output_char chan (char_of_int iz1);
output_char chan (char_of_int iz2);
output_char chan (char_of_int iz3);
)) in  
close_out chan;
ignore(Sys.command ("convert "^fname^".ppm  "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".ppm"))

let doRandomColor (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand (seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e1 = build (g, depth) in
let e2 = build (g, depth) in
let e3 = build (g, depth) in

let _ = Format.printf "red   = %s \n" (exprToString e1) in
let _ = Format.printf "green = %s \n" (exprToString e2) in
let _ = Format.printf "blue  = %s \n" (exprToString e3) in

let f1 = eval_fn e1 in
let f2 = eval_fn e2 in
let f3 = eval_fn e3 in

(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitColor (f1,f2,f3,n,name)

let _ = doRandomGray (5, 7, 180)

bad:
let rec build (rand, depth) = match depth with
| 0 -> 
(match rand (0, 1) with
| 0-> VarX
| 1 -> VarY 
| _ -> VarY)
| _ -> let next = build (rand, depth - 1) in
(match rand (1, 6) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))
| 4 -> buildTimes (next, build (rand, depth - 1))
| 5 -> buildThresh (next, 
build (rand, depth - 1),
build (rand, depth - 1), 
build (rand, depth - 1))
| 6 -> buildSqrt next)
Error: Syntax error: ')' expected
Error: This '(' might be unmatched



hw2 build

fix:
let rec build (rand, depth) = match depth with
| 0 -> 
(match rand (0, 2) with
| 0-> VarX
| 1 -> VarY 
| _ -> VarY)
| _ -> let next = build (rand, depth - 1) in
(match rand (1, 6) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))
| 4 -> buildTimes (next, build (rand, depth - 1))
| 5 -> buildThresh (next, 
build (rand, depth - 1),
build (rand, depth - 1), 
build (rand, depth - 1))
| 6 -> buildSqrt next
| 7 -> buildLogistic (next,
build (rand, depth - 1), 
build (rand, depth - 1)))

let g1 () = (8, 7, 180)

let g2 () = (8, 52, 13)

let g3 () = (8, 13, 10)

let c1 () = (8, 2, 17)

let c2 () = (8, 5, 43)

let c3 () = (8, 83, 4)

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

let emitColor (f1,f2,f3,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_c_"^name) in
let chan = open_out (fname^".ppm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P6 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z1 = f1 (x,y) in
let z2 = f2 (x,y) in
let z3 = f3 (x,y) in

(* Convert the result to a grayscale value *)
let iz1 = toIntensity(z1) in
let iz2 = toIntensity(z2) in
let iz3 = toIntensity(z3) in

(* Emit one byte per color for this pixel *)
output_char chan (char_of_int iz1);
output_char chan (char_of_int iz2);
output_char chan (char_of_int iz3);
)) in  
close_out chan;
ignore(Sys.command ("convert "^fname^".ppm  "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".ppm"))

let doRandomColor (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand (seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e1 = build (g, depth) in
let e2 = build (g, depth) in
let e3 = build (g, depth) in

let _ = Format.printf "red   = %s \n" (exprToString e1) in
let _ = Format.printf "green = %s \n" (exprToString e2) in
let _ = Format.printf "blue  = %s \n" (exprToString e3) in

let f1 = eval_fn e1 in
let f2 = eval_fn e2 in
let f3 = eval_fn e3 in

(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitColor (f1,f2,f3,n,name)

type test = unit -> string

let key = ""

let prefix130 = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)); ErrorCode "exception")

let explode s = 
let rec _exp i = 
if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in
_exp 0

let implode cs = 
String.concat "" (List.map (String.make 1) cs)

let drop_paren s = 
implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))

let eq_real p (r1,r2) = 
(r1 -. r2) < p || (r2 -. r1) < p

let scoreMsg () = 
Format.sprintf "Results: Score/Max = %d / %d \n" !score !max

bad:
let rec build (rand, depth) = match depth with
| 0 -> 
(match rand (0, 2) with
| 0-> VarX
| 1 -> VarY 
| _ -> VarY)
| _ -> let next = build (rand, depth - 1) in
(match rand (1, 6) with
| 1-> buildSine next
| 2 -> buildCosine next
| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))
| 4 -> buildTimes (next, build (rand, depth - 1))
| 5 -> buildThresh (next, 
build (rand, depth - 1),
build (rand, depth - 1), 
build (rand, depth - 1))
| 6 -> buildSqrt next
| 7 -> buildLogistic (next,
build (rand, depth - 1), 
build (rand, depth - 1)))
Error: Syntax error: ')' expected
Error: This '(' might be unmatched



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a + x^2 in
let base = 0 in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         string


let sqsum xs = 
let f a x = a +. x ** 2in
let base = 0 in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         float


let sqsum xs = 
let f a x = a +. x ** 2.0 in
let base = 0 in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         float


let sqsum xs = 
let f a x = a + x*xin
Error: Syntax error



hw3 ???

fix:
let _ = List.fold_right (+) [1;2;3] 0

bad:
[1,2,3].fold_right (+) 0
Error: Unbound record field fold_right


let _ = [1,2,3].fold_right (+) 0
Error: Unbound record field fold_right


let _ = List.fold_right (+) 0 [1,2,3]
Error: This expression has type int but an expression was expected of type
         int list


let _ = List.fold_right (+) [1,2,3] 0
Error: This expression has type 'a * 'b * 'c
       but an expression was expected of type int



hw3 ???

fix:
let _ = List.fold_left(+) 0 [1;2;3]

bad:
let _ = List.fold_left(+) [1;2;3] 0
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs =
let rec iter acc curr = 
match curr with 
|[] -> acc
| h::tl -> iter (h acc) tl in
iter (fun y-> y) fs

bad:
let pipe fs = 
let f a x = a x in
let base = x in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = fs (a x) in
let base = x in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = fs (a x) in
let base = fun y -> y in
List.fold_left f base fs
Error: This expression has type 'a -> 'a -> 'a
       but an expression was expected of type 'a list


let pipe fs =
let rec iter acc curr = 
match curr with 
|[] -> acc
| h::tl -> iter (h curr) tl in
iter (fun y-> y) fs
Error: This expression has type ('a -> 'b) list
       but an expression was expected of type 'a
       The type variable 'a occurs inside ('a -> 'b) list



hw3 pipe

fix:
let _ = pipe [] 3

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs =
let rec iter acc curr = 
match curr with 
|[] -> acc
| h::tl -> iter (h (acc)) tl in
iter (fun y-> y) fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)]
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 ???

fix:
let _ = compose (fun x -> x + 1) (fun x -> x* 2) 1

bad:
let _ = compose ((+) 1) (
Error: Syntax error: operator expected.


let _ = compose (((+) 1)) (
Error: Syntax error: operator expected.


let _ = compose (+) 1
Error: This expression has type int but an expression was expected of type
         'a -> int


) ( * 2) 1
Error: Syntax error


let _ = compose (+ 1) ( * 2) 1
Characters 22-23:
  let _ = compose (+ 1) ( * 2) 1;;
                        ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw3 pipe

fix:
let pipe fs =
let rec iter acc curr = 
match curr with 
|[] -> acc
| h::tl -> iter (fun x -> (h (acc x))) tl in
iter id fs

bad:
let pipe fs =
let rec iter acc curr = 
match curr with 
|[] -> acc
| h::tl -> iter (fun x -> (h (acc x)) tl in
iter id fs
Characters 83-84:
  | h::tl -> iter (fun x -> (h (acc x)) tl in
                  ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw3 pipe

fix:
let pipe fs = 
let f a x =  fun y -> (a (x y))   in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  fun y -> ((a (x y))   in
let base = fun y -> y in
List.fold_left f base fs *
Characters 37-38:
  let f a x =  fun y -> ((a (x y))   in
                        ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let pipe fs = 
let f a x =  fun y -> ((a (x y))   in
let base = fun y -> y in
List.fold_left f base fs *
Characters 37-38:
  let f a x =  fun y -> ((a (x y))   in
                        ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


)
Error: Syntax error


let pipe fs = 
let f a x =  fun y -> (a (x y))   in
let base = fun y -> y in
List.fold_left f base fs *
Error: Syntax error



hw3 stringOfList

fix:
let stringOfList f l = 
"[" ^ List.fold_left (^) 
""
(List.map f l) ^ "]"

bad:
let stringOfList f l = 
"[" ^ List.map f l ^ "]"
Error: This expression has type 'a list
       but an expression was expected of type string



hw3 stringOfList

fix:
let stringOfList f l = 
"[" ^
List.fold_left (fun x acc -> x ^ "; " ^ acc) 
""
(List.map f l) ^ "]"

bad:
let stringOfList f l = 
"[" (fun x acc -> x ^ "; " ^ acc) 
List.fold_left (^) 
""
(List.map f l) ^ "]"
Error: This expression has type string
       This is not a function; it cannot be applied.



hw3 stringOfList

fix:
let stringOfList f l = 
"[" ^
(List.fold_right (fun x acc -> x ^ "; " ^ acc) 
(List.map f l) 
"")
^ "]"

bad:
let stringOfList f l = 
"[" ^
List.fold_right (fun x acc -> x ^ "; " ^ acc) 
""
(List.map f l) ^ "]"
Error: This expression has type string but an expression was expected of type
         string list



hw3 padZero

fix:
let padZero l1 l2 = 
let len1 = List.length l1 in
let len2 = List.length l2 in
( clone 0 (len2 - len1) @ l1,
clone 0 (len1 - len2)@  l2)

bad:
let padZero l1 l2 = 
let len1 = List.len l1 in
let len2 = List.len l2 in
( clone 0 (len2 - len1) @ l1,
clone 0 (len1 - len2)@  l2)
Error: Unbound value List.len



hw3 padZero

fix:
let padZero l1 l2 = 
let diff = (List.length l2) - (List.length l1) in
( clone 0 diff @ l1,
clone 0 (-diff) @  l2)

bad:
let padZero l1 l2 = 
let diff = (List.length l2) - (List.length l1) in
( clone 0 diff @ l1,
clone 0 -diff @  l2)
Error: This expression has type int -> int list
       but an expression was expected of type int



hw3 removeZero

fix:
let rec removeZero l = match l with
| [] -> l
| h :: t -> if (h = 0) then removeZero t 
else l

bad:
let rec removeZero l = match l with
| [] -> l
| h :: t -> if (h = 0) then removeZer t 
else l
Error: Unbound value removeZer
Hint: Did you mean removeZero?



hw3 ???

fix:
let _ = List.combine [1;2;3] [4;5;6]

bad:
let _ = list.Combine = [1;2;3] [4;5;6]
Error: Syntax error


let _ = list.Combine  [1;2;3] [4;5;6]
Error: Syntax error


let _ = list.Combine [1;2;3] [4;5;6]
Error: Syntax error


let _ = list.combine [1;2;3] [4;5;6]
Error: Unbound value list



hw3 ???

fix:
let _ = List.hd [1;2;3] + List.hd [4;5]

bad:
let _ = [1;2;3].hd + [4;5].hd
Error: Unbound record field hd


let _ = [1;2;3].headd + [4;5].hd
Error: Unbound record field headd


let _ = [1;2;3].head + [4;5].hd
Error: Unbound record field head


let _ = List.hd [1;2;3] + [4;5].hd
Error: Unbound record field hd



hw3 bigAdd

fix:
let _ = bigAdd [1] [2]

bad:
let _ = bigAdd [1] [2];


let _ = bigAdd [9;9] [1;0;0;2]
Error: Syntax error



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
((if (addit > 10) then (addit / 10) else 0), 
( addit mod 10 :: num)	)  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
((if (addit > 10) then (addit / 10) else 0), 
( addit mod 10 :: num)	  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))
Characters 132-133:
  ((if (addit > 10) then (addit / 10) else 0), 
  ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f x a = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
((if (addit > 10) then 1 else 0), 
( addit mod 10 :: num))  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_right f args base in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
((if (addit > 10) then 1 else 0), 
( addit mod 10 :: num))  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_right f args base in res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int * int list -> int * int -> int * int list
       but an expression was expected of type
         int * int list -> int * int -> int * int
       Type int list is not compatible with type int 



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, ((addit mod 10) :: num)) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry 
print_int l1' in
(addit / 10, ( addit mod 10 :: num)) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type
         ((int -> unit) -> int -> int) * int list ->
         int * int -> int * int list
       but an expression was expected of type
         ((int -> unit) -> int -> int) * int list ->
         int * int -> ((int -> unit) -> int -> int) * int list
       Type int is not compatible with type (int -> unit) -> int -> int 



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, ((addit mod 10) :: num)) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [1; 9] [0; 1]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
if (x = [] && carry > 0) then carry :: num else num
Error: Syntax error



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, ((addit mod 10) :: num)) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = x in
let (l1', l2') = a in 
let addit = l1' + l2' + carry in
(addit / 10, ((addit mod 10) :: num)) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int * int -> int * int list -> int * int list
       but an expression was expected of type
         int * int -> int * int list -> int * int
       Type int list is not compatible with type int 



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =  
let (carry, num) = a in 
let (l1, l2) = x in
(0, l1 :: num)  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
(0, x :: a)
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =  (0, x :: a) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list -> 'a -> int * 'a list
       but an expression was expected of type 'a list -> 'a -> 'a list
       Type int * 'a list is not compatible with type 'a list 


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =  (0, x :: a) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list -> 'a -> int * 'a list
       but an expression was expected of type 'a list -> 'a -> 'a list
       Type int * 'a list is not compatible with type 'a list 


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =  let (l1, l2) = x in
(0, l2 :: a)
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =  let (l1, l2) = x in
(0, l2 :: a)  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list -> 'b * 'a -> int * 'a list
       but an expression was expected of type 'a list -> 'b * 'a -> 'a list
       Type int * 'a list is not compatible with type 'a list 


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =  let (l1, l2) = x in
(0, l2 :: a)  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list -> 'b * 'a -> int * 'a list
       but an expression was expected of type 'a list -> 'b * 'a -> 'a list
       Type int * 'a list is not compatible with type 'a list 


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =  let (l1, l2) = x in
(0, l1 :: a)  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list -> 'a * 'b -> int * 'a list
       but an expression was expected of type 'a list -> 'a * 'b -> 'a list
       Type int * 'a list is not compatible with type 'a list 


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =  
let (carry, nume ) = a in 
let (l1, l2) = x in
(0, l1 :: num)  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value num
Hint: Did you mean nume?


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =  
let (carry, nume ) = a in 
let (l1, l2) = x in
(0, l1 :: num)  in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value num
Hint: Did you mean nume?



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, num @ [(addit mod 10)]) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, num @ ((addit mod 10) )) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a list


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, num @ (addit mod 10) )
Error: Syntax error


) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, num @ (addit mod 10) ) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a list


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, num @ (addit mod 10) ) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, num @ [(addit mod 10)]) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (car, res) = List.fold_left f base args in car
in 
(add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, num @ [(addit mod 10)]) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in _
in 
removeZero (add (padZero l1 l2))
Error: Syntax error



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, num @ [(addit mod 10)]) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (car, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = l1' + l2' + carry in
(addit / 10, num @ [(addit mod 10)]) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (car, res) = List.fold_left f base args in res
in 
removeZeros (add (padZero l1 l2))
Error: Unbound value removeZeros
Hint: Did you mean removeZero?
Error: Unbound value removeZeros
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value removeZeros
Hint: Did you mean removeZero?



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (car, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(if addit >= 10 then 1 else 0, num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (car, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type int


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(if addit >= 10 then 1 else 0, num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine l1 l2 in
let (car, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type int



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine [0; l1] [0; l2] in
let (car, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list * int list
       but an expression was expected of type int * int
       Type int list is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2)
Error: Syntax error



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
failwith (Printf.sprintf "hi %d" addit)
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
failwith printf.sprintf "hi %d" addit
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value printf


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
failwith Printf.sprintf "hi %d" addit
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type ('a, unit, string) format -> 'a
       but an expression was expected of type string



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
Printf.printf "hi %d" car 
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type
         ('a -> 'b, out_channel, unit, unit, unit, 'a -> 'b)
         CamlinternalFormatBasics.fmt
       but an expression was expected of type
         ('a -> 'b, out_channel, unit, unit, unit, unit)
         CamlinternalFormatBasics.fmt
       Type 'a -> 'b is not compatible with type unit 


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" car )
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value car


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" car );
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value car


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" car; )
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value car


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry; )
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type unit
       This is not a function; it cannot be applied.


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf ("hi %d") carry; )
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type unit
       This is not a function; it cannot be applied.


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf ("hi %d") carry
Characters 134-135:
  (Printf.printf ("hi %d") carry;;
  ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
Printf.printf ("hi %d") carry
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf ("hi %d") carry)
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type unit
       This is not a function; it cannot be applied.


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf ("hi %d") carry)
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.kprintf ("hi %d") carry)
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.kprintf ("hi %d") carry)
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type string but an expression was expected of type
         string -> 'a


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf ("hi %d") carry)
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type unit
       This is not a function; it cannot be applied.


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry)
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type unit
       This is not a function; it cannot be applied.


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf ("hi %d" carry)
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Characters 134-135:
  (Printf.printf ("hi %d" carry)
  ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf ("hi %d" carry))
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type string
       This is not a function; it cannot be applied.


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry)
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type unit
       This is not a function; it cannot be applied.


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %d" carry;
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Characters 134-135:
  (Printf.printf "hi %d" carry;
  ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d\n" addit; in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "hi %s" carry;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         string


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d\n" addit
((if addit >= 10 then 1 else 0), num @ [addit mod 10])
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d\n" addit;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d\n" addit; in
(if addit >= 10 then 1 else 0), num @ [addit mod 10]
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d\n" addit; in
(if addit >= 10 then 1 else 0), num @ [addit mod 10]
Error: Syntax error


) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d\n" addit in
(if addit >= 10 then 1 else 0), num @ [addit mod 10]
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d\n" addit; in
(if addit >= 10 then 1 else 0), num @ [addit mod 10]
Error: Syntax error



hw3 bigAdd

fix:
let _ = bigAdd [1; 9] [2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let () = Printf.printf "%d"; in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int -> unit
       but an expression was expected of type unit



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
Printf.printf "%d\n" addit;
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
Printf.printf ("%d\n" addit);
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type string
       This is not a function; it cannot be applied.


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
Printf.printf ("%d\n", addit);
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type
         ('c, out_channel, unit) format =
           ('c, out_channel, unit, unit, unit, unit)
           CamlinternalFormatBasics.format6



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%8d%8d%8d\n" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%8d%8d%8d\n" l1' l2' carry; (if addit >= 10 then 1 else 0), num @ [addit mod 10])
Error: Syntax error



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%8d%8d%8d\n"; l1'; l2'; carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%8d%8d%8d\n"; l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int
       This is not a function; it cannot be applied.



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf; Printf.sprintf "%8d%8d%8d\n"; l1'; l2'; carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf Printf.sprintf "%8d%8d%8d\n"; l1'; l2'; carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type ('a, unit, string) format -> 'a
       but an expression was expected of type
         ('b -> 'c, out_channel, unit) format =
           ('b -> 'c, out_channel, unit, unit, unit, unit)
           CamlinternalFormatBasics.format6



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.sprintf "%8d%8d%8d\n" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf Printf.sprintf "%8d%8d%8d\n" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type ('a, unit, string) format -> 'a
       but an expression was expected of type
         ('b -> 'c -> 'd -> 'e -> 'f, out_channel, unit) format =
           ('b -> 'c -> 'd -> 'e -> 'f, out_channel, unit, unit, unit, unit)
           CamlinternalFormatBasics.format6


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf (Printf.sprintf "%8d%8d%8d\n" l1' l2' carry); ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type string but an expression was expected of type
         ('a, out_channel, unit) format =
           ('a, out_channel, unit, unit, unit, unit)
           CamlinternalFormatBasics.format6



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s"; Printf.sprintf "%8d%8d%8d\n" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s "Printf.sprintf "%8d%8d%8d\n" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type
         ('a -> 'b -> 'c -> 'd -> 'e, out_channel, unit, unit, unit,
          'a -> 'b -> 'c -> 'd -> 'e)
         CamlinternalFormatBasics.fmt
       but an expression was expected of type
         ('a -> 'b -> 'c -> 'd -> 'e, out_channel, unit, unit, unit, unit)
         CamlinternalFormatBasics.fmt
       Type 'a -> 'b -> 'c -> 'd -> 'e is not compatible with type unit 


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s" Printf.sprintf "%8d%8d%8d\n" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type
         ('a -> 'b -> 'c -> 'd -> 'e, out_channel, unit, unit, unit,
          'a -> 'b -> 'c -> 'd -> 'e)
         CamlinternalFormatBasics.fmt
       but an expression was expected of type
         ('a -> 'b -> 'c -> 'd -> 'e, out_channel, unit, unit, unit, unit)
         CamlinternalFormatBasics.fmt
       Type 'a -> 'b -> 'c -> 'd -> 'e is not compatible with type unit 



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let _ = Printf.printf "%d\n" addit in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s\n" addit
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type
         ('a -> 'b, out_channel, unit, unit, unit, 'a -> 'b)
         CamlinternalFormatBasics.fmt
       but an expression was expected of type
         ('a -> 'b, out_channel, unit, unit, unit, unit)
         CamlinternalFormatBasics.fmt
       Type 'a -> 'b is not compatible with type unit 


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s\n" addit;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         string


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s\n" addit;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         string


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s\n" addit;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         string


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s\n" addit;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         string


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s\n" addit;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         string


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(Printf.printf "%s\n" addit;
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         string


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
((Printf.printf "%s\n" addit);
((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         string


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(let _ = Printf.printf "%s\n" addit);
((if addit >= 10 then 1 else 0), num @ [addit mod 10])
Error: Syntax error: operator expected.


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let _ = Printf.printf "%s\n" addit in
((if addit >= 10 then 1 else 0), num @ [addit mod 10])
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let _ = Printf.printf "%d\n" addit in
((if addit >= 10 then 1 else 0), num @ [addit mod 10])
Error: Syntax error



hw3 ???

fix:
let _ = Printf.printf "%s" "moo"

bad:
let _ = Printf.printf string_of_int 1
Error: This expression has type int -> string
       but an expression was expected of type
         ('a -> 'b, out_channel, unit) format =
           ('a -> 'b, out_channel, unit, unit, unit, unit)
           CamlinternalFormatBasics.format6


let _ = Printf.printf (string_of_int 1)
Error: This expression has type string but an expression was expected of type
         ('a, out_channel, unit) format =
           ('a, out_channel, unit, unit, unit, unit)
           CamlinternalFormatBasics.format6


let _ = Printf.printf "%*s"( string_of_int 1)
Error: This expression has type string but an expression was expected of type
         int



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
let _ = Printf.printf (string_of_int addit) in
((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type string but an expression was expected of type
         ('a, out_channel, unit) format =
           ('a, out_channel, unit, unit, unit, unit)
           CamlinternalFormatBasics.format6



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(addit / 10, num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine ([0] @ l1) ([0]@ l2) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(addit / 10), num @ [addit mod 10]
Error: Syntax error



hw3 ???

fix:
let _ = List.fold_left (fun a x -> x /. a) 1.0 [1.0;4.0]

bad:
let _ = List.fold_left fun a x -> x / a 1 [1.0;4.0]
Error: Syntax error


let _ = List.fold_left (fun a x -> x / a) 1 [1.0;4.0]
Error: This expression has type float but an expression was expected of type
         int


let _ = List.fold_left (fun a x -> x / a) 1.0 [1.0;4.0]
Error: This expression has type float but an expression was expected of type
         int



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(addit / 10, num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0]@ l2)) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(addit / 10, num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine (List.reverse ([0] @ l1)) (List.Reverse ([0]@ l2)) in
let (car, res) = List.fold_left f base args in 
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value List.reverse



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(addit / 10, num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0]@ l2)) in
let (car, res) = List.fold_left f base args in 
List.rev res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (carry, num) = a in
let (l1', l2') = x in 
let addit = (l1' + l2' + carry) in
(addit / 10, num @ [addit mod 10]) in
let base = (0 , []) in
let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0]@ l2)) in
let (car, res) = List.fold_left f base args in 
List.reve res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value List.reve
Hint: Did you mean rev?



hw3 mulByDigit

fix:
let rec mulByDigit i l = if i = 0 then 0
else if i = 1 then l 
else (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)
else bigAdd l (mulByDibit (i - 1) l)

bad:
let _ = mulByDigit 9 [9;9;9;9]
Error: Unbound value bigAdd


let rec mulByDigit i l = if i = 1 then l 
else mulByDigit (i - 1) (bigAdd l l)
Error: Unbound value mulByDigit


let _ = mulByDigit 9 [9;9;9;9]
Error: Unbound value bigAdd


let rec mulByDigit i l = if i = 0 then 0
else if i = 1 then l 
else l
Error: Unbound value mulByDigit



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = 
let (place, num) = a in
let placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   
in
(place + 1 ,bigAdd num (mulByDigit (x * placement) l1)) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (place, num) = a in
let placement =  10 ** place  in
(addit / 10, (addit mod 10) :: num) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a list
       but an expression was expected of type int


let bigMul l1 l2 = 
let f a x = 
let (place, num) = a in
let placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   
in
(addit / 10, (addit mod 10) :: num) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int but an expression was expected of type
         float


let bigMul l1 l2 = 
let f a x = 
let (place, num) = a in
let placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   
in
(bigAdd a mulByDigit (x * place) l1) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value addit


let bigMul l1 l2 = 
let f a x = 
let (place, num) = a in
let placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   
in
(bigAdd a mulByDigit ((x * place) l1)) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value bigAdd


let bigMul l1 l2 = 
let f a x = 
let (place, num) = a in
let placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   
in
(bigAdd a (mulByDigit (x * place) l1)) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value bigAdd


let bigMul l1 l2 = 
let f a x = 
let (place, num) = a in
let placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   
in
(place + 1 , bigAdd num (mulByDigit (x * place) l1)) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value bigAdd


let bigMul l1 l2 = 
let f a x = 
let (place, num) = a in
let placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   
in
(place + 1 ,bigAdd num (mulByDigit (x * place) l1)) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value bigAdd


let _ = bigMul [9;9;9;9] [9;9;9;9]
Error: Unbound value bigAdd



hw1 digitsOfInt

fix:
let _ = digitsOfInt 1

bad:
let _ = digitsOfInt -1
Error: This expression has type int -> int list
       but an expression was expected of type int


let _ = digitsOfInt -1.5
Error: This expression has type int -> int list
       but an expression was expected of type int


let _ = digitsOfInt -1
Error: This expression has type int -> int list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let rec sumList xs = match xs with
| []     -> 0 
| hd::tl -> hd + sumList tl

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

let rec digithelper n l=
let x = n/10 in
let y = n mod 10 in
if x <= 0
then y :: l
else digithelper x (y :: l)

let digitsOfInt n =
if n =< 0 
then []
else 
digithelper n []

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

let _ = digitsOfInt 0

let _ = digitsOfInt 1

let _ = digitsOfInt -12

bad:
let _ = digitsOfInt -12
Error: This expression has type int -> int list
       but an expression was expected of type int



hw1 additivePersistence

fix:
let rec addPHelper n pos =
let sum = sumList pos in 
if sum < 10
then sum
else addPHelper sum pos

let additivePersistence n = 
let pos = digits n in
addPHelper n pos

let _ = additivePersistence 9876

bad:
let rec addPHelper n pos =
let sum = sumList pos in 
if sum < 10
then sum
else addPHelper sum
Error: This expression has type int list
       but an expression was expected of type int


let additivePersistence n = 
let pos = digits n in
addPHelper n pos
Error: This expression has type int list -> int
       but an expression was expected of type int


let _ = additivePersistence 9876
Error: This function has type int -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 additivePersistence

fix:
let _ = additivePersistence 1

bad:
let _ = additivePersistence 1
Error: This expression has type int -> int
       but an expression was expected of type int



hw2 build

fix:
let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))

let rec build (rand, depth) = failwith "TBD"

let g1 () = doRandomGray (3, 1, 5)

let g2 () = failwith "to be implemented"

let g3 () = failwith "to be implemented"

let c1 () = doRandomColor (3, 1, 5)

let c2 () = failwith "to be implemented"

let c3 () = failwith "to be implemented"

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

let emitColor (f1,f2,f3,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_c_"^name) in
let chan = open_out (fname^".ppm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P6 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z1 = f1 (x,y) in
let z2 = f2 (x,y) in
let z3 = f3 (x,y) in

(* Convert the result to a grayscale value *)
let iz1 = toIntensity(z1) in
let iz2 = toIntensity(z2) in
let iz3 = toIntensity(z3) in

(* Emit one byte per color for this pixel *)
output_char chan (char_of_int iz1);
output_char chan (char_of_int iz2);
output_char chan (char_of_int iz3);
)) in  
close_out chan;
ignore(Sys.command ("convert "^fname^".ppm  "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".ppm"))

let doRandomColor (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand (seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e1 = build (g, depth) in
let e2 = build (g, depth) in
let e3 = build (g, depth) in

let _ = Format.printf "red   = %s \n" (exprToString e1) in
let _ = Format.printf "green = %s \n" (exprToString e2) in
let _ = Format.printf "blue  = %s \n" (exprToString e3) in

let f1 = eval_fn e1 in
let f2 = eval_fn e2 in
let f3 = eval_fn e3 in

(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitColor (f1,f2,f3,n,name)

type test = unit -> string

let key = ""

let prefix130 = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)); ErrorCode "exception")

let explode s = 
let rec _exp i = 
if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in
_exp 0

let implode cs = 
String.concat "" (List.map (String.make 1) cs)

let drop_paren s = 
implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))

let eq_real p (r1,r2) = 
(r1 -. r2) < p || (r2 -. r1) < p

let scoreMsg () = 
Format.sprintf "Results: Score/Max = %d / %d \n" !score !max

bad:
let rec build (rand, depth) = match depth with
| 0 -> buildX 
| 1 -> (build (rand, depth-(depth -1)))
| 2 -> buildTimes(build (rand, depth-(depth -2)), build(rand, depth-(depth -2)))
Error: Unbound value buildX
Hint: Did you mean build?


let rec build (rand, depth) = match depth with
| 0 -> buildX 
| 1 -> (build (rand, depth-(depth -1)))
| 2 -> buildTimes(build (rand, depth-(depth -2)), build(rand, depth-(depth -2)))
Error: Unbound value buildX
Hint: Did you mean build?



hw2 eval

fix:
let rec eval (e,x,y) = match e with 
| VarX              -> x
| VarY              -> y
| Sine(e)          -> sin(pi *. eval(e,x,y))
| Cosine(e)        -> cos(pi *. eval(e,x,y))
| Average(e1,e2)   -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.
| Times(e1,e2)     -> eval(e1,x,y) *. eval(e2,x,y)
(* | PowerUp(e1,e2)   -> (abs(eval(e1,x,y))) ** (abs(eval(e2,x,y))) *)
| Square2(e1,e2,e3)-> sqrt((eval(e1,x,y))**2. +. (eval(e2,x,y))**2. +. (eval(e3,x,y))**2.)/. 2.     (* New Operator *)
| Thresh(a,b,a_less,b_less) -> 
if eval(a,x,y) < eval(b,x,y)
then eval(a_less, x, y)
else eval(b_less, x, y)

eval (Times(VarX,VarY), 0.5, -0.5)

eval (Cosine(Times(VarX,VarY)), 0.5,-0.5)

eval (Sine(Average(VarX,VarY)), 0.5, -0.5)

eval (Sine(Average(VarX,VarY)), 0.3 ,0.3)

eval (sampleExpr1,0.5,0.2)

bad:
let rec eval (e,x,y) = match e with 
| BuildX()              -> x
| VarY              -> y
| Sine(e)          -> sin(pi *. eval(e,x,y))
| Cosine(e)        -> cos(pi *. eval(e,x,y))
| Average(e1,e2)   -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.
| Times(e1,e2)     -> eval(e1,x,y) *. eval(e2,x,y)
(* | PowerUp(e1,e2)   -> (abs(eval(e1,x,y))) ** (abs(eval(e2,x,y))) *)
| Square2(e1,e2,e3)-> sqrt((eval(e1,x,y))**2. +. (eval(e2,x,y))**2. +. (eval(e3,x,y))**2.)/. 2.     (* New Operator *)
| Thresh(a,b,a_less,b_less) -> 
if eval(a,x,y) < eval(b,x,y)
then eval(a_less, x, y)
else eval(b_less, x, y)
Error: Syntax error


eval (Times(VarX,VarY), 0.5, -0.5)
Error: Unbound constructor BuildX


eval (Cosine(Times(VarX,VarY)), 0.5,-0.5)
Error: Unbound value eval


eval (Sine(Average(VarX,VarY)), 0.5, -0.5)
Error: Unbound value eval


eval (Sine(Average(VarX,VarY)), 0.3 ,0.3)
Error: Unbound value eval


eval (sampleExpr1,0.5,0.2)
Error: Unbound value eval



hw3 pipe

fix:
let pipe fs = 
let f a x = x (a+1) in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = [fs a] in
let base = 0 in
List.fold_left f base fs
Error: This expression has type int but an expression was expected of type
         'a list



hw2 wwhile

fix:
let rec wwhile (f,b) = 
let ( a , b ) = (f b) in
5

bad:
let rec wwhile (f,b) = 
let ( a , b ) = f b in
if b then wwhile f a else a
Error: This expression has type 'a -> 'b * bool
       but an expression was expected of type ('a -> 'b * bool) * 'a


let rec wwhile (f,b) = 
let ( a , b ) = (f b) in
if b then wwhile f a else a
Error: This expression has type 'a -> 'b * bool
       but an expression was expected of type ('a -> 'b * bool) * 'a


let rec wwhile (f,b) = 
let ( a , b ) = (f b) in
if b then wwhile (f a) else a
Error: This expression has type 'a * bool
       but an expression was expected of type ('a -> 'a * bool) * 'a



hw2 wwhile

fix:
let rec wwhile (f,b) = 
let ( b' , c' ) = f b in
if c' then wwhile ( f, b' ) else b'

bad:
let rec wwhile (f,b) = 
let ( b' , c' ) = (f b) in
if c' then f b' else b'
Error: This expression has type 'a but an expression was expected of type
         'a * bool
       The type variable 'a occurs inside 'a * bool


let rec wwhile (f,b) = 
let ( b' , c' ) = (f b) in
if c' then wwhile (f b') else b'
Error: This expression has type 'a * bool
       but an expression was expected of type ('a -> 'a * bool) * 'a


let rec wwhile (f,b) = 
let ( b' , c' ) = f b in
if c' then wwhile f b' else b'
Error: This expression has type 'a -> 'b * bool
       but an expression was expected of type ('a -> 'b * bool) * 'a



hw2 fixpoint

fix:
let fixpoint (f,b) = 
let rec helper (f, b) =
let b' = f b in
if b' = b then b' else helper (f, b')
in helper (f, b)

bad:
let fixpoint (f,b) = 
let rec helper (f, b) =
let b' = f b in
if b' = b then b' else helper (f, b')
Error: Syntax error



hw2 fixpoint

fix:
let _ = fixpoint (collatz, 9349802374897001)

bad:
let _ = fixpoint (collatz, 93rew001)
Error: This expression has type int
       This is not a function; it cannot be applied.



hw2 ???

fix:
let pi = 4.0 *. atan 1.0

sin ( pi )

bad:
let pi = 4.0 *. atan 1.0
sin ( pi )
Error: This expression has type expr but an expression was expected of type
         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)



hw2 eval

fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr,0.5,0.2)

bad:
let rec eval (e,x,y) = match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e' x y ) ) )
| Cosine e'
-> cos ( pi *. ( eval e' x y ) )
| Average ( e1, e2 )
-> (( eval e1 x y ) +. ( eval e2 x y )) /. 2
| Times ( e1, e2 )
-> ( eval e1 x y ) *. ( eval e2 x y )
| Thresh ( a, b, a_less, b_less )
-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )
Error: This expression has type expr but an expression was expected of type
         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)


let rec eval (e,x,y) = match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) )
| Cosine e'
-> cos ( pi *. ( eval e' x y ) )
| Average ( e1, e2 )
-> (( eval e1 x y ) +. ( eval e2 x y )) /. 2
| Times ( e1, e2 )
-> ( eval e1 x y ) *. ( eval e2 x y )
| Thresh ( a, b, a_less, b_less )
-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )
Error: This expression has type expr
       This is not a function; it cannot be applied.


let rec eval (e,x,y) = match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval e' x y ) )
| Average ( e1, e2 )
-> (( eval e1 x y ) +. ( eval e2 x y )) /. 2
| Times ( e1, e2 )
-> ( eval e1 x y ) *. ( eval e2 x y )
| Thresh ( a, b, a_less, b_less )
-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )
Characters 79-80:
  -> sin ( pi *. ( eval (e', x, y ) )
         ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let rec eval (e,x,y) = match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval (e', x, y ) ) )
| Average ( e1, e2 )
-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2
| Times ( e1, e2 )
-> ( eval e1 x y ) *. ( eval e2 x y )
| Thresh ( a, b, a_less, b_less )
-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )
Error: This function has type expr * float * float -> float
       It is applied to too many arguments; maybe you forgot a `;'.


let rec eval (e,x,y) = match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval (e', x, y ) ) )
| Average ( e1, e2 )
-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0
| Times ( e1, e2 )
-> ( eval e1 x y ) *. ( eval e2 x y )
| Thresh ( a, b, a_less, b_less )
-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )
Error: This expression has type int but an expression was expected of type
         float


let rec eval (e,x,y) = match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval (e', x, y ) ) )
| Average ( e1, e2 )
-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0
| Times ( e1, e2 )
-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))
| Thresh ( a, b, a_less, b_less )
-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )
Error: This function has type expr * float * float -> float
       It is applied to too many arguments; maybe you forgot a `;'.


let rec eval (e,x,y) = match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval (e', x, y ) ) )
| Average ( e1, e2 )
-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0
| Times ( e1, e2 )
-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))
| Thresh ( a, b, a_less, b_less )
-> if eval ( a, x ,y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )
Error: This expression has type expr
       This is not a function; it cannot be applied.


let rec eval (e,x,y) = match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval (e', x, y ) ) )
| Average ( e1, e2 )
-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0
| Times ( e1, e2 )
-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))
| Thresh ( a, b, a_less, b_less )
-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )
Error: This expression has type expr
       This is not a function; it cannot be applied.



hw2 eval

fix:
let _ = eval (Average(VarX,VarY)), 5.0, 10.0

)

bad:
let _ = eval (sampleExpr1,0.5,0.2)
Error: Unbound value sampleExpr
Hint: Did you mean sampleExpr1?
Error: Unbound value sampleExpr
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value sampleExpr
Hint: Did you mean sampleExpr1?



hw2 eval

fix:
let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv

bad:
let _ = eval ((Average(VarX,VarY)), 5.0, 10.0 )
Error: Syntax error



hw2 eval

fix:
let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

bad:
let _ = eval sampleExpr 0.5 0.2
Error: This expression has type expr but an expression was expected of type
         expr * float * float
Error: Unbound constructor Average
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type expr but an expression was expected of type
         expr * float * float


let _ = eval( sampleExpr, 0.5, 0.2 )
Error: This function has type expr * float * float -> float
       It is applied to too many arguments; maybe you forgot a `;'.
Error: Unbound constructor Average
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This function has type expr * float * float -> float
       It is applied to too many arguments; maybe you forgot a `;'.



hw2 ???

fix:
let q = g1

let _ = doRandomGray( q )

bad:
let _ = doRandomGray( (g1) )
Error: This expression has type unit -> int * int * int
       but an expression was expected of type int * int * int
Error: Unbound constructor VarX
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type unit -> int * int * int
       but an expression was expected of type int * int * int



hw2 ???

fix:
let _ = doRandomGray( 12, 9239, 32432 )

bad:
let _ = doRandomGray( 76, 9239, 32432 )
Error: This expression has type unit -> int * int * int
       but an expression was expected of type int * int * int
Error: Unbound constructor VarX
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type unit -> int * int * int
       but an expression was expected of type int * int * int



hw2 ???

fix:
let _ = doRandomColor( 200000000, 3032, 1056 )

bad:
let _ = doRandomColor( 2000000000, 3032, 1056 )
Error: Integer literal exceeds the range of representable integers of type int



hw2 eval

fix:
let rec eval (e,x,y) = match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval (e', x, y ) ) )
| Average ( e1, e2 )
-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0
| Times ( e1, e2 )
-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))
| Thresh ( a, b, a_less, b_less )
-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )
| Factorial e'
-> factorial( eval( e', x, y ), 1 )
| Sum3( e1, e2, e3 )
-> eval( e1, x, y ) +. eval( e2, x, y ) +. eval( e3, x, y )

bad:
let rec eval (e,x,y) = match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval (e', x, y ) ) )
| Average ( e1, e2 )
-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0
| Times ( e1, e2 )
-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))
| Thresh ( a, b, a_less, b_less )
-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )
| Factorial e'
-> factorial( eval( e' ), 1 )
| Sum3( e1, e2, e3 )
-> eval( e1 ) +. eval( e2 ) +. eval( e3 )
Error: This expression has type expr but an expression was expected of type
         expr * float * float


let rec eval (e,x,y) = match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval (e', x, y ) ) )
| Average ( e1, e2 )
-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0
| Times ( e1, e2 )
-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))
| Thresh ( a, b, a_less, b_less )
-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )
Error: This expression has type 'a * 'b
       but an expression was expected of type float



hw2 eval

fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval ((Average(VarX,VarY)), 5.0, 10.0 )

let _ = eval (Factorial(VarX), 5, 0 )

bad:
let rec eval (e,x,y) = match e with
VarX				
-> x
| VarY
-> y
| Sine e'
-> sin ( pi *. ( eval (e', x, y ) ) )
| Cosine e'
-> cos ( pi *. ( eval (e', x, y ) ) )
| Average ( e1, e2 )
-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0
| Times ( e1, e2 )
-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))
| Thresh ( a, b, a_less, b_less )
-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )
| Factorial e'
-> factorial (eval( e', x, y )) 1.0 
| Sum3( e1, e2, e3 )
-> eval( e1, x, y ) +. eval( e2, x, y ) +. eval( e3, x, y )
Error: This function has type float -> float -> float
       It is applied to too many arguments; maybe you forgot a `;'.



hw2 eval

fix:
let _ = eval (Factorial(VarX), 5.0, 4.0 )

bad:
let _ = eval (Factorial(VarX), 5.0, 0.0 )
Error: This expression has type int but an expression was expected of type
         float



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x))

let _ = fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let fixpoint (f,b) = wwhile ( (f, ( b, ( f b ) = b ))), b
Error: Syntax error


let fixpoint (f,b) = wwhile ( f b, b )
Error: This expression has type 'a but an expression was expected of type
         'a * 'b
       The type variable 'a occurs inside 'a * 'b



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ( (f b) = b , b )

bad:
let fixpoint (f,b) = wwhile ( (f b), b )
Error: This expression has type int -> int
       but an expression was expected of type int -> int -> int * bool
       Type int is not compatible with type int -> int * bool 



hw2 fixpoint

fix:
let rec assoc (d,k,l) = match l with
[] -> d
| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if ( List.mem h seen ) then seen else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev(helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) = 
let ( b' , c' ) = f b in
if c' then wwhile ( f, b' ) else b'

let f x = let xx = x*x*x in (xx, xx < 512) in wwhile (f,2)

let fixpoint (f,b) = wwhile ( 
let f' b' = f b in ( f, b' = b )
, b )

bad:
let fixpoint (f,b) = wwhile ( f, (f b) = b , b )
Error: This expression has type bool but an expression was expected of type
         'a -> 'a * bool


let fixpoint (f,b) = wwhile ( 
let f' b' = let xx = f b in ( b' = b ) 
, b )
Error: This expression has type 'a * 'b * 'c
       but an expression was expected of type ('d -> 'd * bool) * 'd


let fixpoint (f,b) = wwhile ( 
let f' b' = f b in ( b' = b ) 
, b )
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ( 
let b' = f b in ( b' = b ) 
, b )
Error: Unbound value b'


let fixpoint (f,b) = wwhile ( 
let f x = let xx = x*x*x in (xx, xx < 512) in wwhile (f,2)
, b )
Error: This expression has type bool but an expression was expected of type
         'a -> 'a * bool


let fixpoint (f,b) = wwhile ( 
let f x = let xx = x*x*x in (xx, xx < 512)
, b )
Error: This expression has type int but an expression was expected of type
         'a -> 'a * bool


let fixpoint (f,b) = wwhile ( 
let f x = let xx = x*x*x in (xx, xx < 512)
, b )
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ( 
let f x = x*x*x in (xx, xx < 512)
, b )
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ( 
let f x = let xx = x*x*x in (xx, xx < 512)
, b )
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile ( 
let f' x = let xx = x*x*x in (xx, xx < 512)
, b )
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ( 
let b' = f b in ( f, b' = b)
, b )
Error: Syntax error: operator expected.


let fixpoint (f,b) =  
let b' = f b in wwhile( ( f, b' = b)
, b )
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) =  
let b' = f b in wwhile( ( f , b' = b)
, b )
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) =  
let b' = f b in wwhile( f , b' = b
, b )
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ( 
let f' b' = ( f, b = b' ) in f b
, b )

bad:
let fixpoint (f,b) = wwhile ( 
let f' b' = f b in ( f', b' = b )
, b )
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile ( 
let b' = f b in ( f, b' = b )
, b )
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile ( 
let b' = f b in ( f, (b' = b) )
, b )
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile ( 
let f' b' = ( f b, b = b' )
, b )
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile ( 
let f' b' = ( f b, b = b' ) in f b
, b )
Error: Syntax error: operator expected.



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ( 
let f' = ( f, b = f b ) in f b
, b )

bad:
let fixpoint (f,b) = wwhile ( 
let f' b' = ( f, b = b' ) in f b
, b )
Error: Unbound value b'



hw2 wwhile

fix:
let f x = let xx = x*x*x in (xx, xx < 512)

wwhile (f,2)

bad:
let f x = let xx = x*x*x in (xx, xx < 512) in wwhile (f,2)
Error: This expression has type 'a -> 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'a * bool



hw3 pipe

fix:
let sqsum xs = 
let f a x = a + x * x in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = a x in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fs a in
let base = fs x in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = fs a in
let base = fs in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'a


let pipe fs = 
let f a x = fs a x in
let base = fs a in
List.fold_left f base fs
Error: Unbound value a


let pipe fs = 
let f a x = fs a x in
let base = 0 in
List.fold_left f base fs
Error: This expression has type int -> 'a -> int
       but an expression was expected of type 'a list


let pipe fs = 
let f a x = fs a in
let base = 0 in
List.fold_left f base fs
Error: This expression has type int -> int
       but an expression was expected of type 'a list


let pipe fs = 
let f a x = fs x in
let base = 0 in
List.fold_left f base fs
Error: This expression has type 'a -> int
       but an expression was expected of type 'a list


let pipe fs = 
let f a x = a x in
let base = 0 in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = [] in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = 'a in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let _ = pipe [] 3

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs y = 
let f a x = x a in
let base = y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = a in
List.fold_left f base fs
Error: Unbound value a



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x  in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x  in
let base = fun x -> x  in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = a + x a in
let base = fun x -> x  in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let pipe fs = 
let f a x = a x + x a in
let base = fun x -> x  in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> int
       but an expression was expected of type 'a
       The type variable 'a occurs inside ('a -> 'b) -> int



hw3 pipe

fix:
let pipe fs y = 
let f a x = x a in
let base = y  in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let pipe fs = 
let f a x = a -> x in
let base = fun x -> x  in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = fun x', y -> x a + a
Error: Syntax error


let base = fun x -> x  in
List.fold_left f base fs
Error: Unbound value f


let pipe fs = 
let f a x = fun x' y -> x a + a
Error: Syntax error


let base = fun x -> x  in
List.fold_left f base fs
Error: Unbound value f


let pipe fs = 
let f a x = fun x' y -> x a + a
Error: Syntax error


let base = fun x -> x  in
List.fold_left f base fs
Error: Unbound value f



hw3 pipe

fix:
let pipe fs = 
let f a x = fun a -> x a  in
let base = fun x -> x  in
List.fold_left f base fs

bad:
let _ = pipe [(fun x y -> y+x); (fun x -> x + 3)] 3
Error: This expression has type int -> 'a
       but an expression was expected of type int


let _ = pipe [(fun x y -> y+x); (fun x y -> x + y)] 3
Error: This expression has type int -> 'a
       but an expression was expected of type int


let pipe fs = 
let f a x = fun x' y -> x a + a in
let base = fun x -> x  in
List.fold_left f base fs
Error: This expression has type int -> (int -> int) -> 'a -> 'b -> int
       but an expression was expected of type int -> (int -> int) -> int
       Type 'a -> 'b -> int is not compatible with type int 



hw3 pipe

fix:
let _ = pipe [(fun x -> x ^ ", " ^ x); (fun x -> x ^ ", " ^ x ^ "!")] "corn"

bad:
let _ = pipe [(fun x -> x ^ ", " ^ x); (fun x -> x ^ ", " ^ x ^ "!")] corn
Error: Unbound value corn



hw3 pipe

fix:
let cat = pipe []

bad:
let _ = pipe [(fun x -> x ^ ", " ^ x); (fun x -> x ^ ", " ^ x ^ "!")] "corn"
Error: This expression has type 'a -> 'a
       but an expression was expected of type string


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h ^ sep ^ a in
let base = sepConcat sep t in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h ^ sep ^ a in
let base = "" in
let l = sepConcat sep t in
List.fold_left f base l
Error: This expression has type string but an expression was expected of type
         'a list



hw3 stringOfList

fix:
let stringOfList f l = match l with
[] -> ""
| h::t -> 
let f' a x = x ^ a in
let base = f h in
let l = t in
List.fold_left f' base l

bad:
let stringOfList f l = match l with
[] -> ""
| h::t -> f h ^ stringOfList f t
Error: Unbound value stringOfList



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  in
let base = fun x -> x in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fs a in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type ('a -> 'a) -> 'a -> 'a
       but an expression was expected of type 'b list



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = a in
List.fold_left f base fs
Error: Unbound value a


let pipe fs = 
let f a x = x a in
let base = fs in
List.fold_left f base fs
Error: This expression has type 'a but an expression was expected of type
         ('a -> 'a) list
       The type variable 'a occurs inside ('a -> 'a) list


let pipe fs = 
let f a x = x a in
let base = fun x in
List.fold_left f base fs
Error: Syntax error



hw3 ???

fix:
let crack a x = x a

let base = fun x -> x

List.fild_left crack base []

bad:
List.fold_left ( fun a x -> x a , fun x -> x, []  ) 3
Error: This expression has type int but an expression was expected of type
         'a * ('b -> 'b * 'c list)



hw3 ???

fix:
let crack a x = x a

let base = fun x -> x

List.fold_left crack base [fun x -> x * x] 3

bad:
List.fold_left crack base [fun x -> x * x] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


List.fold_left crack base [fun x -> (x * x)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs = 
let f a x = fun y -> y in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x -> a in
let base = fun x -> x in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = a -> x in
let base = fun x -> x in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = a + x in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let pipe fs = 
let f a x = a x + x in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type (int -> int) -> int -> int
       but an expression was expected of type
         (int -> int) -> int -> int -> int
       Type int is not compatible with type int -> int 


let pipe fs = 
let f a x = fun x -> a -> x in
let base = fun x -> x in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = fun x -> a in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'c -> 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'c -> 'a


let pipe fs = 
let f a x = fun y -> a in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'c -> 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'c -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x = fun y-> y in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun -> a in
let base = fun x -> x in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = fun y -> x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (a,x) in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'a * 'b
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'a * 'b


let pipe fs = 
let f a x = fun y -> fun x -> a in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'c -> 'd -> 'a



hw3 pipe

fix:
let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let _ = pipe [(fun x -> x ^ ", " ^ x); (fun x -> x ^ ", " ^ x ^ "!")] "corn"

bad:
let cat = pipe [(fun x -> x + x )] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 ???

fix:
List.append [1;2;3] [4;5;6]

bad:
List.append( [1;2;3], [4;5;6] )
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


List.append( [1;2;3], [4;5;6] )
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list



hw3 ???

fix:
let a = [1;2;3]

let b = [4;5;6]

bad:
a = [1;2;3]
Error: Unbound value a


b = [4;5;6]
Error: Unbound value b


List.append a b
Error: Unbound value a



hw3 clone

fix:
clone 0 5

bad:
List.append clone 0 5 a
Error: This function has type 'a list -> 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.


List.append clone( 0 5 ) a
Error: This function has type 'a list -> 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 padZero

fix:
let rec padZero l1 l2 = 
let diffsize = List.length l1 - List.length l2 in
if diffsize > 0 then
( l1, List.append (clone 0 diffsize) l2 )
else
( (List.append (clone 0 ((List.length l1) - (List.length l2))) l1),  l2 )

bad:
let rec padZero l1 l2 = 
if List.length l1 > List.length l2 then
( l1, List.append (clone 0 ((List.length l1) - (List.length l2))), l2 )
else if List.length l1 < List.length l2 then
( (List.append (clone 0 ((List.length l1) - (List.length l2))) l1),  l2 )
else
( l1, l2 )
Error: This expression has type 'a * 'b
       but an expression was expected of type
         'c list * (int list -> int list) * 'd list



hw3 padZero

fix:
let rec padZero l1 l2 = 
let diffsize = List.length l1 - List.length l2 in
if diffsize > 0 then
( l1, List.append (clone 0 diffsize) l2 )
else
( List.append (clone 0 ( -1 * diffsize )) l1,  l2 )

bad:
let rec padZero l1 l2 = 
let diffsize = List.length l1 - List.length l2 in
if diffsize > 0 then
( l1, List.append (clone 0 diffsize) l2 )
else
( List.append clone 0 ( -1 * diffsize ) l1,  l2 )
Error: This function has type 'a list -> 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a
| _ -> a 
in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1::t1, h2::t2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a
| _ -> a 
in
let base = [0] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list
       but an expression was expected of type 'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1::t1, h2::t2) -> ( [], ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a )
| _ -> ( [], a )
in
let base = [0] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type
         int list -> int list * int list -> 'a list * int list
       but an expression was expected of type
         int list -> int list * int list -> int list
       Type 'a list * int list is not compatible with type int list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1::t1, h2::t2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a
| _ -> a 
in
let base = [0] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list
       but an expression was expected of type 'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1::t1, h2::t2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a
| _ -> a 
in
let base = [0] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list * int list
       but an expression was expected of type int list list * int list list
       Type int is not compatible with type int list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a
| _ -> a 
in
let base = ([],[]) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b list
       but an expression was expected of type int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a
| _ -> a 
in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list
       but an expression was expected of type 'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a
| _ -> a 
in
let base = ([],[]) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b list
       but an expression was expected of type int list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a
| _ -> a 
in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1, h2) -> (removeZero (((h1 + h2) / 10 )::(( h1 + h2) mod 10 ))) :: a
| _ -> a 
in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1, h2) -> (removeZero (((h1 + h2) / 10 )::[(( h1 + h2) mod 10 )])) :: a
| _ -> a 
in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list list
       but an expression was expected of type int list
       Type int list is not compatible with type int 



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (x1, x2) -> match a with
(h1, h2::t2) -> let sum = x1 + x2 + h2 in
( ( sum / 10 ) , sum::( sum mod 10 )::t2)
in
let base = (0,[0]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (x1, x2) -> match a with
(_, h2::t2) ->
( ((x1 + x2 + h2) / 10 ) , (x1 + x2 + h2) / 10 )::(( x1 + x2 + h2 ) mod 10 )::t2
Error: Syntax error


)
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = match x with
| (x1, x2) -> match a with
( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in
( ( h1 + 1 ) , (mul / 10)::( mul mod 10 )::t2)
| (_,_) -> (0,[0]) in
let base = (1,[0]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = match x with
| (x1, x2) -> match a with
( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in
( ( h1 + 1 , (mul / 10)::( mul mod 10 )::t2)
| (_,_) -> (0,[0]) in
let base = (1,[0]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
Characters 120-121:
  ( ( h1 + 1 , (mul / 10)::( mul mod 10 )::t2)
  ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let bigMul l1 l2 = 
let f a x = match x with
| (x1, x2) -> match a with
( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in
( ( h1 + 1 , (mul / 10))::( mul mod 10 )::t2)
| (_,_) -> (0,[0]) in
let base = (1,[0]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int but an expression was expected of type
         int * int


let bigMul l1 l2 = 
let f a x = match x with
| (x1, x2) -> match a with
( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in
( ( h1 + 1 , (mul / 10))::(( mul mod 10 )::t2))
| (_,_) -> (0,[0]) in
let base = (1,[0]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int but an expression was expected of type
         int * int



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = 
let ( pos, total ) = a in
( pos + 1, mulByDigit (int_of_float (10.0 ** float_of_int pos)) l2 ) in 
let base = (0,[0]) in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let ( pos, total ) = a in
( pos + 1, mulByDigit ( 10 ** pos) l2 ) in 
let base = (0,[0]) in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int but an expression was expected of type
         float


let bigMul l1 l2 = 
let f a x = 
let ( pos, total ) = a in
( pos + 1, mulByDigit ( 10.0 ** pos) l2 ) in 
let base = (0,[0]) in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int but an expression was expected of type
         float


let bigMul l1 l2 = 
let f a x = 
let ( pos, total ) = a in
( pos + 1, mulByDigit ( 10.0 ** float_of_int pos) l2 ) in 
let base = (0,[0]) in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type float but an expression was expected of type
         int



hw1 sumList

fix:
let rec sumList xs = 
if xs = [] then 0
else let h::t = xs in
h + (sumList t)

bad:
let rec sumList xs = 
if (hd xs) = [] then 0
else let h::t = xs in
h + (sumList t)
Error: Unbound value hd


let rec sumList xs = 
if (xs hd xs) = [] then 0
else let h::t = xs in
h + (sumList t)
Error: Unbound value hd


let rec sumList xs = 
if (List.hd xs) = [] then 0
else let h::t = xs in
h + (sumList t)
Error: This expression has type 'a list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if (n mod 2 = 0) & (n > 0) then
let rec loop input =
if input = 0 then []
else (loop (input / 10))@[(input mod 10)]
in (loop n)
else []

bad:
let rec digitsOfInt n = 
if (n mod 2 = 0) and (n > 0) then
let rec loop input =
if input = 0 then []
else (loop (input / 10))@[(input mod 10)]
in (loop n)
else []
Error: Syntax error



hw1 additivePersistence

fix:
let rec additivePersistence n = 
if (n / 10) = 0 then n
else additivePersistence (sumList (digits n))

bad:
let rec additivePersistence n = 
if (n / 10) = 0 then n
else additivePersistence (sumList digits n)
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 palindrome

fix:
let palindrome w = 
let wEx = explode w in
let rec palHelper lst =
if (List.length lst) < 2 then []
else if ((List.tl lst) = lst) then
let b::rest = lst in
let b2::rest2 = listReverse rest in
palHelper rest2
else [1]
in
if (List.length (palHelper wEx)) = 0 then true
else false

bad:
let palindrome w = 
if (List.hd w) = (List.tl w) then
let b::rest = w in
let c @ (x::[]) = rest in
palindrome x
Error: Syntax error


let palindrome w = 
let wEx = explode w in
let rec palHelper lst =
if (List.size lst) < 2 then []
else if (List.hd lst) = (List.tl lst) then
let b::rest = lst in
let b2::rest2 = listReverse rest in
palHelper rest2
else [1]
in
if (List.size (palHelper wEx)) = 0 then true
else false
Error: Unbound value List.size


let palindrome w = 
let wEx = explode w in
let rec palHelper lst =
if (List.length lst) < 2 then []
else if (List.hd lst) = (List.tl lst) then
let b::rest = lst in
let b2::rest2 = listReverse rest in
palHelper rest2
else [1]
in
if (List.length (palHelper wEx)) = 0 then true
else false
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let palindrome w = 
let wEx = explode w in
let rec palHelper lst =
if (List.length lst) < 2 then []
else if (List.hd lst) = (List.tl lst) then
let b::rest = lst in
let b2::rest2 = listReverse rest in
palHelper rest2
else [1]
in
if (List.length (palHelper wEx)) = 0 then true
else false
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let palindrome w = 
let wEx = explode w in
let rec palHelper lst =
if (List.length lst) < 2 then []
else if (List.tl lst) = (List.hd lst) then
let b::rest = lst in
let b2::rest2 = listReverse rest in
palHelper rest2
else [1]
in
if (List.length (palHelper wEx)) = 0 then true
else false
Error: This expression has type 'a but an expression was expected of type
         'a list
       The type variable 'a occurs inside 'a list


let palindrome w = 
let wEx = explode w in
let rec palHelper lst =
if (List.length lst) < 2 then []
else if (List.tl lst) == (List.hd lst) then
let b::rest = lst in
let b2::rest2 = listReverse rest in
palHelper rest2
else [1]
in
if (List.length (palHelper wEx)) = 0 then true
else false
Error: This expression has type 'a but an expression was expected of type
         'a list
       The type variable 'a occurs inside 'a list


let palindrome w = 
let wEx = explode w in
let rec palHelper lst =
if (List.length lst) < 2 then []
else if ((List.tl lst) = (List.hd lst)) then
let b::rest = lst in
let b2::rest2 = listReverse rest in
palHelper rest2
else [1]
in
if (List.length (palHelper wEx)) = 0 then true
else false
Error: This expression has type 'a but an expression was expected of type
         'a list
       The type variable 'a occurs inside 'a list



hw1 ???

fix:
let rec sizeLst lst =
if lst = [] then 0
else let h::t = lst in
(sizeLst t) + 1

bad:
let rec sizeLst lst =
if lst = [] then 0
else let h::t = lst in
(sizeList t) + 1
Error: Unbound value sizeList
Hint: Did you mean sizeLst?



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if (n mod 2 = 0) && (n > 0) then
let rec loop input =
if input < 10 then [input]
else let [y] = (loop (input / 10)) in
y::[(input mod 10)]
in loop n
else []

bad:
let rec digitsOfInt n = 
if (n mod 2 = 0) && (n > 0) then
let rec loop input =
if input < 10 then input
else (loop (input / 10))::[(input mod 10)]
in (loop n)
else []
Error: This expression has type 'a list
       but an expression was expected of type int



hw2 fixpoint

fix:
let fixpoint (f,b) = 
let y = (f b) in match y with
| (aPrime, _) -> 
if b = aPrime then b
else fixpoint (f, aPrime)

bad:
let fixpoint (f,b) = 
if b = (f b) then b
else fixpoint (f, f b)
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> 'a * bool
       The type variable 'a occurs inside 'a * bool


let fixpoint (f,b) = 
let y = f b in
if b = y then b
else fixpoint (f, y)
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> 'a * bool
       The type variable 'a occurs inside 'a * bool


let fixpoint (f,b) = 
let y = f b in
if b = y then b
else fixpoint (f, y)
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> 'a * bool
       The type variable 'a occurs inside 'a * bool


let fixpoint (f,b) = 
let y = (f b) in
if b = y then b
else fixpoint (f, y)
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> 'a * bool
       The type variable 'a occurs inside 'a * bool


let fixpoint (f,b) = 
let y = (f b) in match y with
| aPrime -> 
if b = aPrime then b
else fixpoint (f, aPrime)
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> 'a * bool
       The type variable 'a occurs inside 'a * bool



hw2 eval

fix:
let rec eval (e,x,y) = match e with
| Thresh (e1,e2,e3,e4) ->
if (eval (e1,x,y)) < (eval (e2,x,y))
then (eval (e3,x,y))
else (eval (e4,x,y))
| Times (e1,e2) -> (eval (e1,x,y)) *. (eval (e2,x,y))
| Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) /. 2.0
| Cosine (e1) -> cos ( 3.142 *. (eval (e1,x,y)) )
| Sine (e1) -> sin ( 3.142 *. (eval (e1,x,y)) )
| VarY -> y
| VarX -> x

bad:
let rec eval (e,x,y) = match e with
| Thresh (e1,e2,e3,e4) ->
if (eval (e1,x,y)) < (eval (e2,x,y))
then (eval (e3,x,y))
else (eval (e4,x,y))
| Times (e1,e2) -> (eval (e1,x,y)) *. (eval (e2,x,y))
| Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) / 2.0
| Cosine (e1) -> cos ( 3.142 *. (eval (e1,x,y)) )
| Sine (e1) -> sin ( 3.142 *. (eval (e1,x,y)) )
| VarY -> y
| VarX -> x
Error: This expression has type float but an expression was expected of type
         int



hw2 build

fix:
let rec assoc (d,k,l) = match l with
| []           -> d
| (ki,vi)::t   -> 
if (ki = k) then vi
else assoc (d,k,t)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = 
if (List.mem h seen) then seen
else (h::seen) 
in
let rest' = t 
in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) = 
let y = f b in match y with
| (b', c')   -> 
if c' then wwhile (f,b')
else b'

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) = 
let f' b = (f b, b != f b) in
wwhile(f',b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

type expr = 
VarX
| VarY
| Sine     of expr
| Cosine   of expr
| Average  of expr * expr
| Times    of expr * expr
| Thresh   of expr * expr * expr * expr

let rec exprToString e = match e with
| Thresh (e1,e2,e3,e4)  ->
"(" ^ exprToString e1 ^
"<" ^ exprToString e2 ^
"?" ^ exprToString e3 ^
":" ^ exprToString e4 ^ ")"
| Times (e1,e2) ->
exprToString e1 ^
"*" ^ exprToString e2
| Average (e1,e2) ->
"((" ^ exprToString e1 ^
"+" ^ exprToString e2 ^ ")/2)"
| Cosine (e1) ->
"cos(pi*" ^ exprToString e1 ^ ")"
| Sine (e1) ->
"sin(pi*" ^ exprToString e1 ^ ")"
| VarY -> "y"
| VarX -> "x"

let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

let _ = exprToString sampleExpr1

let buildX()                       = VarX

let buildY()                       = VarY

let buildSine(e)                   = Sine(e)

let buildCosine(e)                 = Cosine(e)

let buildAverage(e1,e2)            = Average(e1,e2)

let buildTimes(e1,e2)              = Times(e1,e2)

let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)

let pi = 4.0 *. atan 1.0

let rec eval (e,x,y) = match e with
| Thresh (e1,e2,e3,e4) ->
if (eval (e1,x,y)) < (eval (e2,x,y))
then (eval (e3,x,y))
else (eval (e4,x,y))
| Times (e1,e2) -> (eval (e1,x,y)) *. (eval (e2,x,y))
| Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) /. 2.0
| Cosine (e1) -> cos ( pi *. (eval (e1,x,y)) )
| Sine (e1) -> sin ( pi *. (eval (e1,x,y)) )
| VarY -> y
| VarX -> x

let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr1 ,0.5,0.2)

let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv

let sampleExpr =
buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(
buildX()),buildTimes(buildCosine (buildCosine (buildAverage
(buildTimes (buildY(),buildY()),buildCosine (buildX())))),
buildCosine (buildTimes (buildSine (buildCosine
(buildY())),buildAverage (buildSine (buildX()), buildTimes
(buildX(),buildX()))))))),buildY())))

let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))

let _ = eval_fn sampleExpr (0.5,0.2)

let _ = eval_fn sampleExpr2 (0.5,0.2)

let rec build (rand, depth) = match depth with
| 0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then buildSine( build(rand, depth-1) )
else if y = 3 then buildCosine( build(rand, depth-1) )
else if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )
else if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )
else if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),
build(rand, depth-1), build(rand, depth-1) )

let g1 () = failwith "to be implemented"

let g2 () = failwith "to be implemented"

let g3 () = failwith "to be implemented"

let c1 () = failwith "to be implemented"

let c2 () = failwith "to be implemented"

let c3 () = failwith "to be implemented"

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

let emitColor (f1,f2,f3,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_c_"^name) in
let chan = open_out (fname^".ppm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P6 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z1 = f1 (x,y) in
let z2 = f2 (x,y) in
let z3 = f3 (x,y) in

(* Convert the result to a grayscale value *)
let iz1 = toIntensity(z1) in
let iz2 = toIntensity(z2) in
let iz3 = toIntensity(z3) in

(* Emit one byte per color for this pixel *)
output_char chan (char_of_int iz1);
output_char chan (char_of_int iz2);
output_char chan (char_of_int iz3);
)) in  
close_out chan;
ignore(Sys.command ("convert "^fname^".ppm  "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".ppm"))

let doRandomColor (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand (seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e1 = build (g, depth) in
let e2 = build (g, depth) in
let e3 = build (g, depth) in

let _ = Format.printf "red   = %s \n" (exprToString e1) in
let _ = Format.printf "green = %s \n" (exprToString e2) in
let _ = Format.printf "blue  = %s \n" (exprToString e3) in

let f1 = eval_fn e1 in
let f2 = eval_fn e2 in
let f3 = eval_fn e3 in

(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitColor (f1,f2,f3,n,name)

type test = unit -> string

let key = ""

let prefix130 = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)); ErrorCode "exception")

let explode s = 
let rec _exp i = 
if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in
_exp 0

let implode cs = 
String.concat "" (List.map (String.make 1) cs)

let drop_paren s = 
implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))

let eq_real p (r1,r2) = 
(r1 -. r2) < p || (r2 -. r1) < p

let scoreMsg () = 
Format.sprintf "Results: Score/Max = %d / %d \n" !score !max

bad:
let rec build (rand, depth) = match depth with
| 0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then buildSine( build(rand, depth-1) )
else if y = 3 then buildCosine( build(rand, depth-1) )
else if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )
else if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )
else if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),
build(rand, depth-1), build(rand, depth-1) )
Error: This expression has type expr but an expression was expected of type
         unit


let rec build (rand, depth) = match depth with
| 0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then buildSine( build(rand, depth-1) )
else if y = 3 then buildCosine( build(rand, depth-1) )
else if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )
else if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )
Error: This expression has type expr but an expression was expected of type
         unit


let rec build (rand, depth) = match depth with
| 0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then buildSine( build(rand, depth-1) )
else if y = 3 then buildCosine( build(rand, depth-1) )
else if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )
else if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )
else if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),build(rand, depth-1), build(rand, depth-1) )
Error: This expression has type expr but an expression was expected of type
         unit


let rec build (rand, depth) = match depth with
| 0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then buildSine( build(rand, depth-1) )
Error: This expression has type expr but an expression was expected of type
         unit



hw2 ???

fix:
let rand (a, b) = if a < b then a else b

bad:
rand(0,4)
Error: Unbound value rand
Hint: Did you mean land?


rand
Error: Unbound value rand
Hint: Did you mean land?



hw2 build

fix:
let rec assoc (d,k,l) = match l with
| []           -> d
| (ki,vi)::t   -> 
if (ki = k) then vi
else assoc (d,k,t)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = 
if (List.mem h seen) then seen
else (h::seen) 
in
let rest' = t 
in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) = 
let y = f b in match y with
| (b', c')   -> 
if c' then wwhile (f,b')
else b'

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) = 
let f' b = (f b, b != f b) in
wwhile(f',b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

type expr = 
VarX
| VarY
| Sine     of expr
| Cosine   of expr
| Average  of expr * expr
| Times    of expr * expr
| Thresh   of expr * expr * expr * expr

let rec exprToString e = match e with
| Thresh (e1,e2,e3,e4)  ->
"(" ^ exprToString e1 ^
"<" ^ exprToString e2 ^
"?" ^ exprToString e3 ^
":" ^ exprToString e4 ^ ")"
| Times (e1,e2) ->
exprToString e1 ^
"*" ^ exprToString e2
| Average (e1,e2) ->
"((" ^ exprToString e1 ^
"+" ^ exprToString e2 ^ ")/2)"
| Cosine (e1) ->
"cos(pi*" ^ exprToString e1 ^ ")"
| Sine (e1) ->
"sin(pi*" ^ exprToString e1 ^ ")"
| VarY -> "y"
| VarX -> "x"

let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

let _ = exprToString sampleExpr1

let buildX()                       = VarX

let buildY()                       = VarY

let buildSine(e)                   = Sine(e)

let buildCosine(e)                 = Cosine(e)

let buildAverage(e1,e2)            = Average(e1,e2)

let buildTimes(e1,e2)              = Times(e1,e2)

let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)

let pi = 4.0 *. atan 1.0

let rec eval (e,x,y) = match e with
| Thresh (e1,e2,e3,e4) ->
if (eval (e1,x,y)) < (eval (e2,x,y))
then (eval (e3,x,y))
else (eval (e4,x,y))
| Times (e1,e2) -> (eval (e1,x,y)) *. (eval (e2,x,y))
| Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) /. 2.0
| Cosine (e1) -> cos ( pi *. (eval (e1,x,y)) )
| Sine (e1) -> sin ( pi *. (eval (e1,x,y)) )
| VarY -> y
| VarX -> x

let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr1 ,0.5,0.2)

let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv

let sampleExpr =
buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(
buildX()),buildTimes(buildCosine (buildCosine (buildAverage
(buildTimes (buildY(),buildY()),buildCosine (buildX())))),
buildCosine (buildTimes (buildSine (buildCosine
(buildY())),buildAverage (buildSine (buildX()), buildTimes
(buildX(),buildX()))))))),buildY())))

let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))

let _ = eval_fn sampleExpr (0.5,0.2)

let _ = eval_fn sampleExpr2 (0.5,0.2)

let rand (a, b) = if a < b then a else b

let rec build (rand, depth) = match depth with
| 0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then buildSine( build(rand, depth-1) )
else if y = 3 then buildCosine( build(rand, depth-1) )
else if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )
else if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )
else if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),
build(rand, depth-1), build(rand, depth-1) )

let g1 () = failwith "to be implemented"

let g2 () = failwith "to be implemented"

let g3 () = failwith "to be implemented"

let c1 () = failwith "to be implemented"

let c2 () = failwith "to be implemented"

let c3 () = failwith "to be implemented"

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

let emitColor (f1,f2,f3,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_c_"^name) in
let chan = open_out (fname^".ppm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P6 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z1 = f1 (x,y) in
let z2 = f2 (x,y) in
let z3 = f3 (x,y) in

(* Convert the result to a grayscale value *)
let iz1 = toIntensity(z1) in
let iz2 = toIntensity(z2) in
let iz3 = toIntensity(z3) in

(* Emit one byte per color for this pixel *)
output_char chan (char_of_int iz1);
output_char chan (char_of_int iz2);
output_char chan (char_of_int iz3);
)) in  
close_out chan;
ignore(Sys.command ("convert "^fname^".ppm  "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".ppm"))

let doRandomColor (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand (seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e1 = build (g, depth) in
let e2 = build (g, depth) in
let e3 = build (g, depth) in

let _ = Format.printf "red   = %s \n" (exprToString e1) in
let _ = Format.printf "green = %s \n" (exprToString e2) in
let _ = Format.printf "blue  = %s \n" (exprToString e3) in

let f1 = eval_fn e1 in
let f2 = eval_fn e2 in
let f3 = eval_fn e3 in

(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitColor (f1,f2,f3,n,name)

type test = unit -> string

let key = ""

let prefix130 = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)); ErrorCode "exception")

let explode s = 
let rec _exp i = 
if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in
_exp 0

let implode cs = 
String.concat "" (List.map (String.make 1) cs)

let drop_paren s = 
implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))

let eq_real p (r1,r2) = 
(r1 -. r2) < p || (r2 -. r1) < p

let scoreMsg () = 
Format.sprintf "Results: Score/Max = %d / %d \n" !score !max

bad:
let rec build (rand, depth) = match depth with
| 0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then buildSine( build(rand, depth-1) )
else if y = 3 then buildCosine( build(rand, depth-1) )
else if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )
else if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )
else if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),
build(rand, depth-1), build(rand, depth-1) )
Error: This expression has type expr but an expression was expected of type
         unit



hw2 build

fix:
let rec build (rand, depth) = match depth with
| 0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in build(rand , y-1)

bad:
let rec build (rand, depth) = match depth with
| 0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then buildSine( build(rand, depth-1) )
Error: This expression has type expr but an expression was expected of type
         unit


let rec build (rand, depth) = match depth with
| 0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if (y = 2) then buildSine( build(rand, depth-1) )
Error: This expression has type expr but an expression was expected of type
         unit



hw2 build

fix:
let rec assoc (d,k,l) = match l with
| []           -> d
| (ki,vi)::t   -> 
if (ki = k) then vi
else assoc (d,k,t)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = 
if (List.mem h seen) then seen
else (h::seen) 
in
let rest' = t 
in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) = 
let y = f b in match y with
| (b', c')   -> 
if c' then wwhile (f,b')
else b'

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) = 
let f' b = (f b, b != f b) in
wwhile(f',b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

type expr = 
VarX
| VarY
| Sine     of expr
| Cosine   of expr
| Average  of expr * expr
| Times    of expr * expr
| Thresh   of expr * expr * expr * expr

let rec exprToString e = match e with
| Thresh (e1,e2,e3,e4)  ->
"(" ^ exprToString e1 ^
"<" ^ exprToString e2 ^
"?" ^ exprToString e3 ^
":" ^ exprToString e4 ^ ")"
| Times (e1,e2) ->
exprToString e1 ^
"*" ^ exprToString e2
| Average (e1,e2) ->
"((" ^ exprToString e1 ^
"+" ^ exprToString e2 ^ ")/2)"
| Cosine (e1) ->
"cos(pi*" ^ exprToString e1 ^ ")"
| Sine (e1) ->
"sin(pi*" ^ exprToString e1 ^ ")"
| VarY -> "y"
| VarX -> "x"

let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

let _ = exprToString sampleExpr1

let buildX()                       = VarX

let buildY()                       = VarY

let buildSine(e)                   = Sine(e)

let buildCosine(e)                 = Cosine(e)

let buildAverage(e1,e2)            = Average(e1,e2)

let buildTimes(e1,e2)              = Times(e1,e2)

let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)

let pi = 4.0 *. atan 1.0

let rec eval (e,x,y) = match e with
| Thresh (e1,e2,e3,e4) ->
if (eval (e1,x,y)) < (eval (e2,x,y))
then (eval (e3,x,y))
else (eval (e4,x,y))
| Times (e1,e2) -> (eval (e1,x,y)) *. (eval (e2,x,y))
| Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) /. 2.0
| Cosine (e1) -> cos ( pi *. (eval (e1,x,y)) )
| Sine (e1) -> sin ( pi *. (eval (e1,x,y)) )
| VarY -> y
| VarX -> x

let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr1 ,0.5,0.2)

let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv

let sampleExpr =
buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(
buildX()),buildTimes(buildCosine (buildCosine (buildAverage
(buildTimes (buildY(),buildY()),buildCosine (buildX())))),
buildCosine (buildTimes (buildSine (buildCosine
(buildY())),buildAverage (buildSine (buildX()), buildTimes
(buildX(),buildX()))))))),buildY())))

let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))

let _ = eval_fn sampleExpr (0.5,0.2)

let _ = eval_fn sampleExpr2 (0.5,0.2)

let rand (a, b) = if a < b then a else b

let rec build (rand, depth) = match depth with
0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then buildX()

let g1 () = failwith "to be implemented"

let g2 () = failwith "to be implemented"

let g3 () = failwith "to be implemented"

let c1 () = failwith "to be implemented"

let c2 () = failwith "to be implemented"

let c3 () = failwith "to be implemented"

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

let emitColor (f1,f2,f3,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_c_"^name) in
let chan = open_out (fname^".ppm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P6 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z1 = f1 (x,y) in
let z2 = f2 (x,y) in
let z3 = f3 (x,y) in

(* Convert the result to a grayscale value *)
let iz1 = toIntensity(z1) in
let iz2 = toIntensity(z2) in
let iz3 = toIntensity(z3) in

(* Emit one byte per color for this pixel *)
output_char chan (char_of_int iz1);
output_char chan (char_of_int iz2);
output_char chan (char_of_int iz3);
)) in  
close_out chan;
ignore(Sys.command ("convert "^fname^".ppm  "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".ppm"))

let doRandomColor (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand (seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e1 = build (g, depth) in
let e2 = build (g, depth) in
let e3 = build (g, depth) in

let _ = Format.printf "red   = %s \n" (exprToString e1) in
let _ = Format.printf "green = %s \n" (exprToString e2) in
let _ = Format.printf "blue  = %s \n" (exprToString e3) in

let f1 = eval_fn e1 in
let f2 = eval_fn e2 in
let f3 = eval_fn e3 in

(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitColor (f1,f2,f3,n,name)

type test = unit -> string

let key = ""

let prefix130 = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)); ErrorCode "exception")

let explode s = 
let rec _exp i = 
if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in
_exp 0

let implode cs = 
String.concat "" (List.map (String.make 1) cs)

let drop_paren s = 
implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))

let eq_real p (r1,r2) = 
(r1 -. r2) < p || (r2 -. r1) < p

let scoreMsg () = 
Format.sprintf "Results: Score/Max = %d / %d \n" !score !max

bad:
let rec build (rand, depth) = match depth with
0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in build(rand , y-1) 
if (y = 2) then buildSine( build(rand, depth-1) ) 
else 
if y = 3 then buildCosine( build(rand, depth-1) )
else if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )
else if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )
else if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),
build(rand, depth-1), build(rand, depth-1) )
Error: Syntax error


let rec build (rand, depth) = match depth with
0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if (y = 2) then buildSine( build(rand, depth-1) ) 
else 
if y = 3 then buildCosine( build(rand, depth-1) )
else if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )
else if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )
else if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),
build(rand, depth-1), build(rand, depth-1) )
Error: This expression has type expr but an expression was expected of type
         unit


let rec build (rand, depth) = match depth with
0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then buildX()
Error: This expression has type expr but an expression was expected of type
         unit



hw2 build

fix:
let rec build (rand, depth) = 
if depth = 0 then
if rand(0,1) = 0 then buildX() else buildY()
else
let y = rand(2,6) in
buildX()

bad:
let rec build (rand, depth) = match depth with
0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then buildX()
Error: This expression has type expr but an expression was expected of type
         unit


let rec build (rand, depth) = match depth with
0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y == 2 then buildX()
Error: This expression has type expr but an expression was expected of type
         unit


let rec build (rand, depth) = match depth with
0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if y = 2 then 5
Error: This expression has type int but an expression was expected of type
         unit


let rec build (rand, depth) = match depth with
0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
y
Error: This expression has type int but an expression was expected of type
         expr


let rec build (rand, depth) = match depth with
0 -> if rand(0,1) = 0 then buildX() else buildY()
| _ -> let y = rand(2,6) in
if (y = 2) then y
Error: This expression has type int but an expression was expected of type
         unit


let rec build (rand, depth) = 
if depth = 0 then
if rand(0,1) = 0 then buildX() else buildY()
else
let y = rand(2,6) in
if (y = 2) then y
Error: This expression has type int but an expression was expected of type
         unit



hw2 build

fix:
let rec assoc (d,k,l) = match l with
| []           -> d
| (ki,vi)::t   -> 
if (ki = k) then vi
else assoc (d,k,t)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = 
if (List.mem h seen) then seen
else (h::seen) 
in
let rest' = t 
in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) = 
let y = f b in match y with
| (b', c')   -> 
if c' then wwhile (f,b')
else b'

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) = 
let f' b = (f b, b != f b) in
wwhile(f',b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

type expr = 
VarX
| VarY
| Sine     of expr
| Cosine   of expr
| Average  of expr * expr
| Times    of expr * expr
| Thresh   of expr * expr * expr * expr

let rec exprToString e = match e with
| Thresh (e1,e2,e3,e4)  ->
"(" ^ exprToString e1 ^
"<" ^ exprToString e2 ^
"?" ^ exprToString e3 ^
":" ^ exprToString e4 ^ ")"
| Times (e1,e2) ->
exprToString e1 ^
"*" ^ exprToString e2
| Average (e1,e2) ->
"((" ^ exprToString e1 ^
"+" ^ exprToString e2 ^ ")/2)"
| Cosine (e1) ->
"cos(pi*" ^ exprToString e1 ^ ")"
| Sine (e1) ->
"sin(pi*" ^ exprToString e1 ^ ")"
| VarY -> "y"
| VarX -> "x"

let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

let _ = exprToString sampleExpr1

let buildX()                       = VarX

let buildY()                       = VarY

let buildSine(e)                   = Sine(e)

let buildCosine(e)                 = Cosine(e)

let buildAverage(e1,e2)            = Average(e1,e2)

let buildTimes(e1,e2)              = Times(e1,e2)

let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)

let pi = 4.0 *. atan 1.0

let rec eval (e,x,y) = match e with
| Thresh (e1,e2,e3,e4) ->
if (eval (e1,x,y)) < (eval (e2,x,y))
then (eval (e3,x,y))
else (eval (e4,x,y))
| Times (e1,e2) -> (eval (e1,x,y)) *. (eval (e2,x,y))
| Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) /. 2.0
| Cosine (e1) -> cos ( pi *. (eval (e1,x,y)) )
| Sine (e1) -> sin ( pi *. (eval (e1,x,y)) )
| VarY -> y
| VarX -> x

let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr1 ,0.5,0.2)

let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv

let sampleExpr =
buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(
buildX()),buildTimes(buildCosine (buildCosine (buildAverage
(buildTimes (buildY(),buildY()),buildCosine (buildX())))),
buildCosine (buildTimes (buildSine (buildCosine
(buildY())),buildAverage (buildSine (buildX()), buildTimes
(buildX(),buildX()))))))),buildY())))

let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))

let _ = eval_fn sampleExpr (0.5,0.2)

let _ = eval_fn sampleExpr2 (0.5,0.2)

let rand (a, b) = if a < b then a else b

let rec build (rand, depth) = 
if depth = 0 then
if rand(0,1) = 0 then buildX() else buildY()
else
let y = rand(2,6) in
if y = 2 then buildX()

bad:
let rec build (rand, depth) = 
if depth = 0 then
if rand(0,1) = 0 then buildX() else buildY()
else
let y = rand(2,6) in
if y = 2 then buildX()
Error: This expression has type expr but an expression was expected of type
         unit



hw2 ???

fix:
let y = rand(2,6)

bad:
et y = rand(2,6)
Error: Unbound value et



hw2 build

fix:
let rec assoc (d,k,l) = match l with
| []           -> d
| (ki,vi)::t   -> 
if (ki = k) then vi
else assoc (d,k,t)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = 
if (List.mem h seen) then seen
else (h::seen) 
in
let rest' = t 
in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) = 
let y = f b in match y with
| (b', c')   -> 
if c' then wwhile (f,b')
else b'

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) = 
let f' b = (f b, b != f b) in
wwhile(f',b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

type expr = 
VarX
| VarY
| Sine     of expr
| Cosine   of expr
| Average  of expr * expr
| Times    of expr * expr
| Thresh   of expr * expr * expr * expr

let rec exprToString e = match e with
| Thresh (e1,e2,e3,e4)  ->
"(" ^ exprToString e1 ^
"<" ^ exprToString e2 ^
"?" ^ exprToString e3 ^
":" ^ exprToString e4 ^ ")"
| Times (e1,e2) ->
exprToString e1 ^
"*" ^ exprToString e2
| Average (e1,e2) ->
"((" ^ exprToString e1 ^
"+" ^ exprToString e2 ^ ")/2)"
| Cosine (e1) ->
"cos(pi*" ^ exprToString e1 ^ ")"
| Sine (e1) ->
"sin(pi*" ^ exprToString e1 ^ ")"
| VarY -> "y"
| VarX -> "x"

let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

let _ = exprToString sampleExpr1

let buildX()                       = VarX

let buildY()                       = VarY

let buildSine(e)                   = Sine(e)

let buildCosine(e)                 = Cosine(e)

let buildAverage(e1,e2)            = Average(e1,e2)

let buildTimes(e1,e2)              = Times(e1,e2)

let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)

let pi = 4.0 *. atan 1.0

let rec eval (e,x,y) = match e with
| Thresh (e1,e2,e3,e4) ->
if (eval (e1,x,y)) < (eval (e2,x,y))
then (eval (e3,x,y))
else (eval (e4,x,y))
| Times (e1,e2) -> (eval (e1,x,y)) *. (eval (e2,x,y))
| Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) /. 2.0
| Cosine (e1) -> cos ( pi *. (eval (e1,x,y)) )
| Sine (e1) -> sin ( pi *. (eval (e1,x,y)) )
| VarY -> y
| VarX -> x

let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr1 ,0.5,0.2)

let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv

let sampleExpr =
buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(
buildX()),buildTimes(buildCosine (buildCosine (buildAverage
(buildTimes (buildY(),buildY()),buildCosine (buildX())))),
buildCosine (buildTimes (buildSine (buildCosine
(buildY())),buildAverage (buildSine (buildX()), buildTimes
(buildX(),buildX()))))))),buildY())))

let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))

let _ = eval_fn sampleExpr (0.5,0.2)

let _ = eval_fn sampleExpr2 (0.5,0.2)

bad:
let rec build (rand, depth) = 
if depth = 0 then
if rand(0,1) = 0 then buildX() else buildY()
else
let y = rand(2,6) in
if y = 2 then y
Error: This expression has type int but an expression was expected of type
         unit



hw2 build

fix:
buildX()

bad:
let rec build (rand, depth) = 
if depth = 0 then
if rand(0,1) = 0 then VarX else VarY
else
let y = rand(2,6) in
if y = 2 then y
Error: This expression has type int but an expression was expected of type
         unit


let rec build (rand, depth) = 
if depth = 0 then
if rand (0,1) = 0 then VarX else VarY
else
let y = rand (2,6) in
if y = 2 then y
Error: This expression has type int but an expression was expected of type
         unit


let rec build (rand, depth) = 
if depth = 0 then
if rand (0,1) = 0 then buildX() else buildY()
else
let y = rand (2,6) in
if y = 2 then y
Error: This expression has type int but an expression was expected of type
         unit



hw2 build

fix:
let rec build (rand, depth) = 
if depth = 0 then
if (rand (0,1) = 0) then buildX() else buildY()
else
let y = rand (2,6) in
buildX()

bad:
if depth = 0 then
if rand (0,1) = 0 then buildX() else buildY()
Error: Unbound value depth


let rec build (rand, depth) = 
if depth = 0 then
if rand (0,1) = 0 then buildX() else buildY()
Error: This expression has type expr but an expression was expected of type
         unit


let rec build (rand, depth) = 
if depth = 0 then
if (rand (0,1) = 0) then buildX() else buildY()
else
let y = rand (2,6) in
if y = 2 then y
Error: This expression has type int but an expression was expected of type
         unit


let rec build (rand, depth) = 
if depth = 0 then
if (rand (0,1) = 0) then buildX() else buildY()
Error: This expression has type expr but an expression was expected of type
         unit



hw2 build

fix:
let rec build (rand, depth) = 
if depth = 0 then
if (rand (0,1) = 0) then buildX() else buildY()
else
let y = rand (2,6) in
buildX()

bad:
let rec build (rand, depth) = 
if depth = 0 then
if (rand (0,1) = 0) then buildX() else buildY()
Error: This expression has type expr but an expression was expected of type
         unit



hw2 build

fix:
let rec build (rand, depth) = 
if depth = 0 then
if (rand (0,1) = 0) then buildX() else buildY()
else
let y = rand (2,6) in match y with
| 2 -> buildSine( build(rand, depth-1) ) 
| 3 -> buildCosine( build(rand, depth-1) )
| 4 -> buildAverage( build(rand, depth-1), build(rand, depth-1) )
| 5 -> buildTimes( build(rand, depth-1), build(rand, depth-1) )
| 6 -> buildThresh( build(rand, depth-1), build(rand, depth-1),
build(rand, depth-1), build(rand, depth-1) )

bad:
let rec build (rand, depth) = 
if depth = 0 then
if (rand (0,1) = 0) then buildX() else buildY()
else
let y = rand (2,6) in match y with
| 2 -> buildSine( build(rand, depth-1) ) 
| 3 -> buildCosine( build(rand, depth-1) )
| 4 -> buildAverage( build(rand, depth-1), build(rand, depth-1) )
| 5 -> buildTimes( build(rand, depth-1), build(rand, depth-1) )
| 6 -> buildThresh( build(rand, depth-1), build(rand, depth-1),
build(rand, depth-1), build(rand, depth-1) )  *
Error: Syntax error



hw3 pipe

fix:
let sqsum xs = 
let f a x = a + (x*x) in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = a (x a) in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a (x a) in
let base = (fun y -> y) in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> (('a -> 'b) -> 'a) -> 'b
       but an expression was expected of type
         ('a -> 'b) -> (('a -> 'b) -> 'a) -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = (fun y -> y) in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = "" in
let l = h::t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x =  in
let base = "" in
let l = h in
List.fold_left f base l
Error: Syntax error



hw3 sepConcat

fix:
let _ = sepConcat "X" ["hello"]

bad:
let _ = sepConcat "X" ["hello"]

string_of_int 5
Error: This function has type string -> string list -> string
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = sepConcat "X" ["hello"]

string_of_int 5
Error: This function has type string -> string list -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 sepConcat

fix:
let _ = sepConcat "X" ["hello"]

let _ = string_of_int 5

bad:
let _ = sepConcat "X" ["hello"]

string_of_int [1]
Error: This function has type string -> string list -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 stringOfList

fix:
let stringOfList f l = sepConcat "; " (List.append ("["::List.map f l) ["]"])

bad:
let stringOfList f l = sepConcat "; " ["["; List.map f l;"]"]
Error: This expression has type 'a list
       but an expression was expected of type string


let stringOfList f l = sepConcat "; " [["["]; List.map f l;["]"]]
Error: This expression has type 'a list
       but an expression was expected of type string


let stringOfList f l = sepConcat "; " (List.append ("["::List.map f l) "]")
Error: This expression has type string but an expression was expected of type
         string list



hw3 stringOfList

fix:
let stringOfList f l = "[" ^ (sepConcat "; " (List.map f l)) ^ "]"

bad:
let stringOfList f l = "[" ^ (sepConcat "; " List.map f l) ^ "]"
Error: This function has type string -> string list -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([],r) , acc) -> failwith "should never reach here"
| ((h::[],r), acc) -> (([],0), r::acc)
| ((h::t,r) , acc) -> 
let sum = h+x+r in
((t,sum/10), (sum mod 10)::acc)
in
let (pad1, pad2) = padZero l1 l2 in
let base = ((List.rev pad1,0) , []) in
let args = (List.rev pad2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (_, acc) -> 
let (padded1, padded2) = padZero acc x in
let rec helper acc2 r lst1 lst2 = match lst1 with
| [] -> (match r with
| 0 -> acc2
| _ -> List.append acc2 [r])
| h1::t1 -> (match lst2 with
| [] -> failwith "Should never reach here!"
| h2::t2 -> let sum = (h1+h2+r) in
helper ((sum%10)::acc2) (sum/10) t1 t2)
in
(0, helper [] 0 padded1 padded2)
in
let base = [] in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value %


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (_, acc) -> 
let (padded1, padded2) = padZero acc x in
let rec helper acc2 r lst1 lst2 = match lst1 with
| [] -> (match r with
| 0 -> acc2
| _ -> List.append acc2 [r])
| h1::t1 -> (match lst2 with
| [] -> failwith "Should never reach here!"
| h2::t2 -> let sum = (h1+h2+r) in
helper ((sum % 10)::acc2) (sum/10) t1 t2)
in
(0, helper [] 0 padded1 padded2)
in
let base = [] in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value %


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (_, acc) -> 
let (padded1, padded2) = padZero acc x in
let rec helper acc2 r lst1 lst2 = match lst1 with
| [] -> (match r with
| 0 -> acc2
| _ -> List.append acc2 [r])
| h1::t1 -> (match lst2 with
| [] -> failwith "Should never reach here!"
| h2::t2 -> let sum = (h1 + h2 + r) in
helper ((sum % 10)::acc2) (sum/10) t1 t2)
in
(0, helper [] 0 padded1 padded2)
in
let base = [] in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value %


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (_, acc) -> 
let (padded1, padded2) = padZero acc x in
let rec helper acc2 r lst1 lst2 = match lst1 with
| [] -> (match r with
| 0 -> acc2
| _ -> List.append acc2 [r])
| h1::t1 -> (match lst2 with
| [] -> failwith "Should never reach here!"
| h2::t2 -> let sum = (h1 + h2 + r) in
helper ((sum mod 10)::acc2) (sum/10) t1 t2)
in
(0, helper [] 0 padded1 padded2)
in
let base = [] in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type int * int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (_, acc) -> 
let (padded1, padded2) = padZero acc x in
let rec helper acc2 r lst1 lst2 = match lst1 with
| [] -> (match r with
| 0 -> acc2
| _ -> List.append acc2 [r])
| h1::t1 -> (match lst2 with
| [] -> failwith "Should never reach here!"
| h2::t2 -> let sum = (h1 + h2 + r) in
helper ((sum mod 10)::acc2) (sum/10) t1 t2)
in
(0, helper [] 0 padded1 padded2)
in
let base = (0 , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list * int list
       but an expression was expected of type int * int
       Type int list is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (_, acc) -> 
let (padded1, padded2) = padZero acc x in
let rec helper acc2 r lst1 lst2 = match lst1 with
| [] -> (match r with
| 0 -> acc2
| _ -> List.append acc2 [r])
| h1::t1 -> (match lst2 with
| [] -> failwith "Should never reach here!"
| h2::t2 -> let sum = (h1 + h2 + r) in
helper ((sum mod 10)::acc2) (sum/10) t1 t2)
in
(0, helper [] 0 padded1 padded2)
in
let base = (0 , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list * int list
       but an expression was expected of type int * int
       Type int list is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (_, acc) -> 
let (padded1, padded2) = padZero acc x in
let rec helper acc2 r lst1 lst2 = match lst1 with
| [] -> (match r with
| 0 -> acc2
| _ -> List.append acc2 [r])
| h1::t1 -> (match lst2 with
| [] -> failwith "Should never reach here!"
| h2::t2 -> let sum = (h1 + h2 + r) in
helper ((sum mod 10)::acc2) (sum/10) t1 t2)
in
(0, helper [] 0 padded1 padded2)
in
let base = ([] , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b list
       but an expression was expected of type int * int list
       Type 'a list is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (_, acc) -> 
let (padded1, padded2) = padZero acc x in
let rec helper acc2 r lst1 lst2 = match lst1 with
| [] -> (match r with
| 0 -> acc2
| _ -> List.append acc2 [r])
| h1::t1 -> (match lst2 with
| [] -> failwith "Should never reach here!"
| h2::t2 -> let sum = (h1 + h2 + r) in
helper ((sum mod 10)::acc2) (sum/10) t1 t2)
in
([], helper [] 0 padded1 padded2)
in
let base = ([] , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list * int list
       but an expression was expected of type int * int
       Type int list is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (_, acc) -> 
let (padded1, padded2) = padZero acc x in
let rec helper acc2 r lst1 lst2 = match lst1 with
| [] -> (match r with
| 0 -> acc2
| _ -> List.append acc2 [r])
| h1::t1 -> (match lst2 with
| [] -> failwith "Should never reach here!"
| h2::t2 -> let sum = (h1 + h2 + r) in
helper ((sum mod 10)::acc2) (sum/10) t1 t2)
in
([], helper [] 0 (List.rev padded1) (List.rev padded2))
in
let base = ([] , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list * int list
       but an expression was expected of type int * int
       Type int list is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let g = 
(fun (c,d) -> (List.rev c; List.rev d) (padZero ((fun (a,b) -> b) a) x) in
let rec helper acc r (lst1, lst2) = 
if lst1 = [] then acc
else
let h1::t1 = lst1 in
let h2::t2 = lst2 in
let sum = h1+h2+r in
helper (sum mod 10)::acc (sum/10) (t1, t2)
in
helper [] 0 g
in
let base = ([] , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Characters 62-63:
  (fun (c,d) -> (List.rev c; List.rev d) (padZero ((fun (a,b) -> b) a) x) in
  ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let g = 
(fun (c,d) -> (List.rev c; List.rev d)) (padZero ((fun (a,b) -> b) a) x) in
let rec helper acc r (lst1, lst2) = 
if lst1 = [] then acc
else
let h1::t1 = lst1 in
let h2::t2 = lst2 in
let sum = h1+h2+r in
helper (sum mod 10)::acc (sum/10) (t1, t2)
in
helper [] 0 g
in
let base = ([] , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let g = 
(fun (c,d) -> (List.rev c; List.rev d)) (padZero ((fun (a,b) -> b) a) x) in
let rec helper acc r (lst1, lst2) = 
if lst1 = [] then acc
else
let h1::t1 = lst1 in
let h2::t2 = lst2 in
let sum = h1+h2+r in
helper ((sum mod 10)::acc) (sum/10) (t1, t2)
in
helper [] 0 g
in
let base = ([] , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list
       but an expression was expected of type int list * int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let g = 
(fun (c,d) -> (List.rev c, List.rev d)) (padZero ((fun (a,b) -> b) a) x) in
let rec helper acc r (lst1, lst2) = 
if lst1 = [] then acc
else
let h1::t1 = lst1 in
let h2::t2 = lst2 in
let sum = h1+h2+r in
helper ((sum mod 10)::acc) (sum/10) (t1, t2)
in
helper [] 0 g
in
let base = ([] , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * int list -> int list -> int list
       but an expression was expected of type
         'a * int list -> int list -> 'a * int list
       Type int list is not compatible with type 'a * int list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let g = 
(fun (c,d) -> (List.rev c, List.rev d)) (padZero ((fun (a,b) -> b) a) x) in
let rec helper acc r (lst1, lst2) = 
if lst1 = [] then acc
else
let h1::t1 = lst1 in
let h2::t2 = lst2 in
let sum = h1+h2+r in
helper ((sum mod 10)::acc) (sum/10) (t1, t2)
in
([], helper [] 0 g)
in
let base = ([] , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list * int list
       but an expression was expected of type int * int
       Type int list is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let g = 
(fun (c,d) -> (List.rev c, List.rev d)) (padZero ((fun (q,r) -> r) a) x) in
let rec helper acc r (lst1, lst2) = 
if lst1 = [] then acc
else
let h1::t1 = lst1 in
let h2::t2 = lst2 in
let sum = h1+h2+r in
helper ((sum mod 10)::acc) (sum/10) (t1, t2)
in
([], helper [] 0 g)
in
let base = ([] , []) in
let args = [[l1];[l2]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list * int list
       but an expression was expected of type int * int
       Type int list is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (([],r) , acc) -> failwith "should never reach here"
| ((h::[],r), acc) -> (([],0), r::acc)
| ((h::t,r) , acc) -> 
let sum = h+x+r in
((t,sum/10), (sum mod 10)::acc)
in
let (pad1, pad2) = padZero l1 l2 in
let base = (List.rev pad1 , []) in
let args = (List.rev pad2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list * 'a list
       but an expression was expected of type (int list * int) * int list
       Type int list is not compatible with type int list * int 



hw3 bigMul

fix:
let bigMul l1 l2 = 
if (l1 = [] || l2 = []) then []
else
let f a x = match a with
| ((lst,decPlace), acc) ->
((lst,decPlace+1), bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in
let base = ((l1,0), []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
if (l1 = [] || l2 = []) then []
else
let f a x = match a with
| ((lst,decPlace), acc) ->
((lst,decPlace+1) bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace)) in
let base = (l1, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
Characters 109-110:
  ((lst,decPlace+1) bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace)) in
  ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let bigMul l1 l2 = 
if (l1 = [] || l2 = []) then []
else
let f a x = match a with
| ((lst,decPlace), acc) ->
((lst,decPlace+1) bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in
let base = (l1, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a * int
       This is not a function; it cannot be applied.
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type 'a * int
       This is not a function; it cannot be applied.


let bigMul l1 l2 = 
if (l1 = [] || l2 = []) then []
else
let f a x = match a with
| ((lst,decPlace), acc) ->
((lst,decPlace+1) bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in
let base = ((l1,0), []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a * int
       This is not a function; it cannot be applied.
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type 'a * int
       This is not a function; it cannot be applied.



hw1 digitsOfInt

fix:
let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt (n/10)

bad:
let rec digitsOfInt n = if n <= 0 -> []
else n mod 10 :: digitofInt n/10
Error: Syntax error


let rec digitsOfInt n = if n <= 0 then -> []
else n mod 10 :: digitofInt n/10
Error: Syntax error


let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsofInt n/10s
Error: Unbound value digitsofInt
Hint: Did you mean digitsOfInt?


let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt n/10s
Error: This expression has type int list
       but an expression was expected of type int


let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt n/10
Error: This expression has type int list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let rec digitsOfInt n = if n <= 0 then [] else n mod 10 @ digitsOfInt (n/10)

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

bad:
let rec digitsOfInt n = if n <= 0 then [] else digitsOfInt (n/10):: n mod 10
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 digitsOfInt

fix:
let digitsOfInt n = 
let rec digitsHelper n l = if n = 0 then l else digitsHelper (n/10) (n mod 10::l)
in
if n<=0 then [] else digitsHelper n []

bad:
let rec digitsOfInt n = if n <= 0 then [] else digitsHelper n []
Error: Unbound value digitsHelper


let rec digitsHelper n l = if n = 0 then l else (n/10) n mod 10::l
Error: This expression has type int
       This is not a function; it cannot be applied.


let digitsOfInt n = 
let rec digitsHelper n l = if n = 0 then l else (n/10) n mod 10::l
in
if n<=0 then [] else digitsHelper n []
Error: This expression has type int
       This is not a function; it cannot be applied.


let digitsOfInt n = 
let rec digitsHelper n l = if n = 0 then l else (n/10) (n mod 10::l)
in
if n<=0 then [] else digitsHelper n []
Error: This expression has type int
       This is not a function; it cannot be applied.



hw1 digitalRoot

fix:
let rec digitalRoot n = 
let rec digHelper n = if n < 10 then n else digHelper (sumList (digitsOfInt n))
in
digHelper n

bad:
let rec digitalRoot n = 
let rec digHelper n = if n < 10 then n else digHelper (sumList n)
in
digHelper n
Error: This expression has type int but an expression was expected of type
         int list


let _ = digitalRoot 9876
Error: Unbound value digitalRoot



hw1 listReverse

fix:
let rec listReverse l = 
let rec listHelper l l2 = match l with
| [] -> l2 
| h::t -> listHelper t (h::l2)
in
listHelper l []

bad:
let rec listReverse l = 
let rec listHelper l l2 = match l with
| [] -> l2 
| h::t -> listHelper t h::l2
in
listHelper l []
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let _ = listReverse [1; 2; 3; 4]
Error: Unbound value listReverse


let _ = listReverse ["a"; "b"; "c"; "d"]
Error: Unbound value listReverse



hw2 assoc

fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> if fst h = k then snd h else assoc (d, k, t)

bad:
let rec assoc (d,k,l) = match l with
| [] -> d
| (s,i)::t -> if s = k then true else assoc d k t
Error: This function has type bool * 'a * ('a * 'b) list -> bool
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])
Error: Unbound value assoc


let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])
Error: Unbound value assoc


let rec assoc (d,k,l) = match l with
| [] -> d
| (s,i)::t -> if s = k then true else assoc (d k t)
Error: This expression has type bool
       This is not a function; it cannot be applied.


let rec assoc (d,k,l) = match l with
| [] -> d
| (s,i)::t -> if s = k then i else assoc (d k t)
Error: This expression has type ('a * ('a -> 'b -> 'c)) list
       but an expression was expected of type 'b
       The type variable 'b occurs inside ('a * ('a -> 'b -> 'c)) list


let rec assoc (d,k,l) = match l with
| [] -> d
| (s,i) as h::t -> if s = k then i else assoc (d k t)
Error: This expression has type ('a * ('a -> 'b -> 'c)) list
       but an expression was expected of type 'b
       The type variable 'b occurs inside ('a * ('a -> 'b -> 'c)) list


let rec assoc (d,k,l) = match l with
| [] -> d
| ((s,i) as h)::t -> if s = k then i else assoc (d k t)
Error: This expression has type ('a * ('a -> 'b -> 'c)) list
       but an expression was expected of type 'b
       The type variable 'b occurs inside ('a * ('a -> 'b -> 'c)) list


let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> if fst h = k then snd h else assoc (d k t)
Error: This expression has type ('a * ('a -> 'b -> 'c)) list
       but an expression was expected of type 'b
       The type variable 'b occurs inside ('a * ('a -> 'b -> 'c)) list



hw2 wwhile

fix:
let rec wwhile (f,b) = if snd (f b) then wwhile (f, fst (f b)) else fst (f b)

bad:
let rec wwhile (f,b) = let snd (f b) then wwhile f fst (f b) else fst (f b)
Characters 31-32:
  let rec wwhile (f,b) = let snd (f b) then wwhile f fst (f b) else fst (f b);;
                                 ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let rec wwhile (f,b) = let snd f b then wwhile f fst f b else fst f b
Error: Syntax error


let rec wwhile (f,b) = if snd f b then wwhile f fst f b else fst f b
Error: This expression has type 'a * ('b -> bool)
       but an expression was expected of type ('a * ('b -> bool)) * 'b



hw2 fixpoint

fix:
let fixpoint (f,b) = let fx b' = (f b', f b' = b') in
wwhile(fx,b)

bad:
let fixpoint (f,b) = wwhile ((if f b = b then (true,b) else (false,b)),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile (((f b) = b, (f b)),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile (f b, f b = b,b)
Error: This expression has type 'a * 'b * 'c
       but an expression was expected of type ('d -> 'd * bool) * 'd


let fixpoint (f,b) = 
wwhile(if f b = b then (f b, true) else (f b, false),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type bool -> bool * bool


let fixpoint (f,b) = 
wwhile((if f b = b then (f b, true) else (f b, false)),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = 
wwhile(let fx = if f b = b then (b,true) else (b,false),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = 
wwhile((let fx = if f b = b then (b,true) else (b,false)),b)
Error: Syntax error: operator expected.



hw2 fixpoint

fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

bad:
let fixpoint (f,b) = let fx b= (f b, f b = b) in
wwhile(fx,b)
Error: Unbound value wwhile


)
Error: Unbound value wwhile


let _ = fixpoint (collatz, 3)
Error: Syntax error



hw2 fixpoint

fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

bad:
let fixpoint (f,b) = 
let fx b = (f b, not (f b = b)) in
wwhile(fx,b)
Error: This function has type bool -> bool
       It is applied to too many arguments; maybe you forgot a `;'.



hw2 fixpoint

fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let fixpoint (f,b) = 
wwhile(fun x = f x , not (f x = x),b)
Error: Unbound value fixpoint


let fixpoint (f,b) = 
wwhile(fun x = f x , not (f x = x),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = 
wwhile(fun x -> f x , not (f x = x),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = 
wwhile(fun x -> (f x , not (f x = x)),b)
Error: Unbound value wwhile


let fixpoint (f,b) = 
wwhile((fun x -> f x , not (f x = x)),b)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let fixpoint (f,b) = 
wwhile(fun x -> f x  not (f x = x),b)
Error: Unbound value fixpoint


let fixpoint (f,b) = 
wwhile((fun x -> f x  not (f x = x)),b)
Error: Unbound value wwhile


let fixpoint (f,b) = 
wwhile((fun x -> f x , not (f x = x)),b)
Error: Unbound value wwhile



hw2 exprToString

fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

let _ = exprToString sampleExpr1

bad:
let rec exprToString e = match e with 
| VarX -> "VarX"
| VarY -> "VarY"
| Sine e1 -> "Sine("^ exprToString e1 ^ ")"
| Cosine e1 -> "Cosine(" ^ exprToString e1 ^ ")"
| Average e1 e11 -> "Average(" ^ exprToString e1 ^ "," ^ exprToString e2 ^ ")"
| Times e1 e2 -> "Times(" ^ exprToString e1 ^ "," ^ exprToString e2 ^ ")"
| Thresh e1 e2 e3 e4 -> "Thresh(" ^  exprToString e1 ^ "," ^ exprToString e2 ^"," ^ exprToString e3 ^ "," ^ exprToString e4 ^ ")"
Error: Syntax error


let rec exprToString e = match e with 
| VarX -> "VarX"
| VarY -> "VarY"
| Sine e1 -> "Sine("^ exprToString e1 ^ ")"
| Cosine e1 -> "Cosine(" ^ exprToString e1 ^ ")"
| Average (e1,e2) -> "Average(" ^ exprToString e1 ^ "," ^ exprToString e2 ^ ")"
| Times e1 e2 -> "Times(" ^ exprToString e1 ^ "," ^ exprToString e2 ^ ")"
| Thresh e1 e2 e3 e4 -> "Thresh(" ^  exprToString e1 ^ "," ^ exprToString e2 ^"," ^ exprToString e3 ^ "," ^ exprToString e4 ^ ")"
Error: Syntax error


let rec exprToString e = match e with 
| VarX -> "VarX"
| VarY -> "VarY"
| Sine e1 -> "Sine("^ exprToString e1 ^ ")"
| Cosine e1 -> "Cosine(" ^ exprToString e1 ^ ")"
| Average (e1,e2) -> "Average(" ^ exprToString e1 ^ "," ^ exprToString e2 ^ ")"
| Times e1 e2 -> "Times(" ^ exprToString e1 ^ "," ^ exprToString e2 ^ ")"
| Thresh e1 e2 e3 e4 -> "Thresh(" ^  exprToString e1 ^ "," ^ exprToString e2 ^"," ^ exprToString e3 ^ "," ^ exprToString e4 ^ ")"
Error: Syntax error


let rec exprToString e = match e with 
| VarX -> "VarX"
| VarY -> "VarY"
| Sine e1 -> "Sine("^ exprToString e1 ^ ")"
| Cosine e1 -> "Cosine(" ^ exprToString e1 ^ ")"
| Average (e1,e2) -> "Average(" ^ exprToString e1 ^ "," ^ exprToString e2 ^ ")"
| Times (e1,e2) -> "Times(" ^ exprToString e1 ^ "," ^ exprToString e2 ^ ")"
| Thresh (e1,e2,e3,e4) -> "Thresh(" ^  exprToString e1 ^ "," ^ exprToString e2 ^"," ^ exprToString e3 ^ "," ^ exprToString e4 ^ ")"
Error: Syntax error



hw2 eval

fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi .* exprToString e1)
| Cosine e1 -> cos(pi .* exprToString e1)
| Average (e1,e2) -> ((exprToString e1 .+ exprToString e2 )./2)
| Times (e1,e2) -> exprToString e1 .* exprToString e2 
| Thresh (e1,e2,e3,e4) -> (exprToString e1 < exprToString e2 ? exprToString e3 : exprToString e4)
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. exprToString e1)
| Cosine e1 -> cos(pi *. exprToString e1)
| Average (e1,e2) -> ((exprToString e1 +. exprToString e2 )/.2)
| Times (e1,e2) -> exprToString e1 *. exprToString e2 
| Thresh (e1,e2,e3,e4) -> (exprToString e1 < exprToString e2 ? exprToString e3 : exprToString e4)
Error: Syntax error: operator expected.


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y) : eval (e4,x,y))
Error: This expression has type string but an expression was expected of type
         float


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y) : eval (e4,x,y))
Error: Syntax error


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y) : eval (e4,x,y))
Error: Syntax error


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y):eval (e4,x,y))
Error: Syntax error


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y) : eval(e4,x,y))
Error: Syntax error


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? (eval (e3,x,y)) : eval(e4,x,y))
Error: Syntax error


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? (eval (e3,x,y)) : (eval(e4,x,y)))
Error: Syntax error: operator expected.


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> ((eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y)))
Error: Syntax error: operator expected.


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))
Error: Syntax error: operator expected.


eval
Error: Syntax error



hw2 eval

fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))

let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr,0.5,0.2)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))
Error: Syntax error


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))
Error: This expression has type int but an expression was expected of type
         float


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.float_of_int 2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))
Error: This expression has type float but an expression was expected of type
         int



hw2 build

fix:
let rec build (rand, depth) = 
let num = if (depth < 1) then rand(0,2) else rand(2,7) in
match num with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| _s
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))

bad:
let rec build (rand, depth) =
let expChooser (r,d) =  match r with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,d-1))
| 3
-> buildCosine(build (rand,d-1))
| 4
-> buildAverage(build (rand,d-1), build (rand,d-1))
| 5
-> buildTimes(build (rand,d-1), build (rand,d-1))
| 6
-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))
in  if (depth < 1) then expChooser rand (0,2) else expChooser rand (2,7)
Error: Syntax error


let rec build (rand, depth) =
let expChooser (r,d) =  match r with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,d-1))
| 3
-> buildCosine(build (rand,d-1))
| 4
-> buildAverage(build (rand,d-1), build (rand,d-1))
| 5
-> buildTimes(build (rand,d-1), build (rand,d-1))
| 6
-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))
in  if (depth < 1) then expChooser rand (0,2) depth else expChooser rand (2,7) depth
Error: This function has type int * int -> expr
       It is applied to too many arguments; maybe you forgot a `;'.


let rec build (rand, depth) =
let expChooser (r,d) =  match r with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,d-1))
| 3
-> buildCosine(build (rand,d-1))
| 4
-> buildAverage(build (rand,d-1), build (rand,d-1))
| 5
-> buildTimes(build (rand,d-1), build (rand,d-1))
| 6
-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))
in  if (depth < 1) then (expChooser (rand (0,2), depth) else (expChooser (rand (2,7)), depth)
Error: This function has type int * int -> expr
       It is applied to too many arguments; maybe you forgot a `;'.


let rec build (rand, depth) =
let expChooser (r,d) =  match r with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,d-1))
| 3
-> buildCosine(build (rand,d-1))
| 4
-> buildAverage(build (rand,d-1), build (rand,d-1))
| 5
-> buildTimes(build (rand,d-1), build (rand,d-1))
| 6
-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))
in  if (depth < 1) then (expChooser (rand (0,2)), depth) else (expChooser (rand (2,7)), depth)
Characters 397-398:
  in  if (depth < 1) then (expChooser (rand (0,2), depth) else (expChooser (rand (2,7)), depth);;
                          ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let rec build (rand, depth) =
let expChooser (r,d) =  match r with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,d-1))
| 3
-> buildCosine(build (rand,d-1))
| 4
-> buildAverage(build (rand,d-1), build (rand,d-1))
| 5
-> buildTimes(build (rand,d-1), build (rand,d-1))
| 6
-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))
in  if (depth < 1) then (expChooser (rand (0,2)), depth) else (expChooser (rand (2,7)), depth)
Error: This expression has type 'a * 'b
       but an expression was expected of type expr


let rec build (rand, depth) = let n = 
if (depth < 1) then rand (0,2) else rand(2,7)
Error: This expression has type 'a * 'b
       but an expression was expected of type expr


match n with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))
Error: Syntax error


let rec build (rand, depth) = let n = 
if (depth < 1) then rand (0,2) else rand(2,7)
match n with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))
Error: Unbound value n


let rec build (rand, depth) = let n = 
match n with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))
in if (depth < 1) then rand (0,2) else rand(2,7)
Error: Syntax error


let rec build (rand, depth) = 
let n = 
match n with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))
in n = if (depth < 1) then rand (0,2) else rand(2,7)
Error: Unbound value n


let rec build (rand, depth) = 
let n = if (depth < 1) then rand (0,2) else rand(2,7)
match n with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))
Error: Unbound value n


let rec build (rand, depth) = 
let n = if (depth < 1) then match rand(0,2) with else match rand(2,7) with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))
Error: Syntax error


let rec build (rand, depth) = 
let n = if (depth < 1) then (match rand(0,2) with) else (match rand(2,7) with)
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))
Error: Syntax error


let rec build (rand, depth) = 
if (depth < 1) then (match rand(0,2) with) else (match rand(2,7) with)
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))
Error: Syntax error: operator expected.


let rec build (rand, depth) = 
let num = if (depth < 1) rand(0,2) else rand(2,7) in
match num with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))
Error: Syntax error: operator expected.


let rec build (rand, depth) = 
let num = if (depth < 1) then rand(0,2) else rand(2,7) in
match num with
| 0
-> buildX()
| 1
-> buildY()
| 2
-> buildSine(build (rand,depth-1))
| 3
-> buildCosine(build (rand,depth-1))
| 4
-> buildAverage(build (rand,depth-1), build (rand,depth-1))
| 5
-> buildTimes(build (rand,depth-1), build (rand,depth-1))
| 6
-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))
Error: Syntax error



hw2 eval

fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))
| Power (e1,e2) -> eval (e1,x,y) ** abs_float (eval (e2,x,y))
| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))
| Power (e1,e2) -> eval (e1,x,y) ** abs_float eval (e2,x,y)
| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1,x,y))
| Cosine e1 -> cos(pi *. eval (e1,x,y))
| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)
| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) 
| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))
| Power (e1,e2) -> eval (e1,x,y) ** abs_float (eval (e2,x,y))
| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)
Error: This function has type float -> float
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base =  1 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a + f x in
let base = 0 in
List.fold_left f base fs
Error: Unbound value f


let pipe fs = 
let f a x = a + f x in
let base = x in
List.fold_left f base fs
Error: Unbound value f


let pipe fs = 
let f a x = a + x a in
let base = x in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = x a in
let base =  _ in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base =  (fun x -> x) in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a = x a in
let base = fun x -> x in 
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type bool


let pipe fs = 
let f a x = a = x a in
let base = 0 in 
List.fold_left f base fs
Error: This expression has type int but an expression was expected of type
         bool


let pipe fs = 
let f a x = a = f (a y) in
let base = fun x -> x in 
List.fold_left f base fs
Error: Unbound value f


let pipe fs = 
let f a x = a = x (a y) in
let base = fun x -> x in 
List.fold_left f base fs
Error: Unbound value y


let pipe fs = 
let f a x = a = x a in
let base = fun x -> x in 
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type bool



hw3 pipe

fix:
let pipe fs = 
let f a x =  x a in 
let base = fun x -> x in 
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let pipe fs = 
let f a x = a = fun x a -> x a in 
let base = fun x -> x in 
List.fold_left f base fs
Error: This expression has type (('a -> 'b) -> 'a -> 'b) -> 'c -> bool
       but an expression was expected of type
         (('a -> 'b) -> 'a -> 'b) -> 'c -> ('a -> 'b) -> 'a -> 'b
       Type bool is not compatible with type ('a -> 'b) -> 'a -> 'b 


let pipe fs = 
let f a x = a = fun x a t-> x (a t) in 
let base = fun x -> x in 
List.fold_left f base fs
Error: This expression has type
         (('a -> 'b) -> ('c -> 'a) -> 'c -> 'b) -> 'd -> bool
       but an expression was expected of type
         (('a -> 'b) -> ('c -> 'a) -> 'c -> 'b) ->
         'd -> ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b
       Type bool is not compatible with type
         ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b 


let pipe fs = 
let f a x = a = (fun x y -> x (a y)) in 
let base = fun x -> x in 
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'c
       but an expression was expected of type 'a
       The type variable 'a occurs inside ('a -> 'b) -> 'c


let pipe fs = 
let f a x = a = fun y ->  x (a y) in 
let base = fun x -> x in 
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> ('b -> 'b) -> bool
       but an expression was expected of type
         ('a -> 'b) -> ('b -> 'b) -> 'a -> 'b
       Type bool is not compatible with type 'a -> 'b 


let pipe fs = 
let f a x = let a = fun y ->  x (a y) in 
let base = fun x -> x in 
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x =  x a
Error: Syntax error


let base = fun x -> x in 
List.fold_left f base fs
Error: Unbound value f



hw3 pipe

fix:
let pipe fs = 
let f a x =  fun y -> x (a y) in 
let base = fun x -> x in 
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let pipe fs = 
let f a x =  let a = x a in 
let base = fun x -> x in 
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x =  a x in 
let base = fun x -> x in 
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 stringOfList

fix:
let stringOfList f l = "[" ^ (sepConcat ";" (List.map f l)) ^ "]"

bad:
let stringOfList f l = "[" ^ List.map sepConcat ";" l ^ "]"
Error: This function has type ('a -> 'b) -> 'a list -> 'b list
       It is applied to too many arguments; maybe you forgot a `;'.


let stringOfList f l = "[" ^ sepConcat ";" List.map f l ^ "]"
Error: This function has type string -> string list -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 clone

fix:
let rec clone x n = 
let rec cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper(x,n-1,x::acc) in
cloneHelper(x,n,[])

bad:
let rec clone x n = 
let rec cloneHelper x n acc = if n < 0 then acc else cloneHelper x n-1 x::acc in
cloneHelper x n []
Error: This expression has type 'a list -> 'a list
       but an expression was expected of type int


let rec clone x n = 
let rec cloneHelper x n acc = if n < 0 then acc else cloneHelper (x,n-1,x::acc) in
cloneHelper x n []
Error: This expression has type 'a * 'b * 'c
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a * 'b * 'c


let rec clone x n = 
let rec cloneHelper x n acc = if n < 0 then acc else cloneHelper (x,n-1,x::acc) in
cloneHelper x n []
Error: This expression has type 'a * 'b * 'c
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a * 'b * 'c


let rec clone x n = 
let rec cloneHelper x n acc = if n < 0 then acc else cloneHelper (x,n-1,x::acc) in
cloneHelper (x ,n,[])
Error: This expression has type 'a * 'b * 'c
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a * 'b * 'c


let rec clone x n = 
let rec cloneHelper x n acc = if n < 0 then acc else cloneHelper (x,n-1,x::acc) in
cloneHelper (x,n,[])
Error: This expression has type 'a * 'b * 'c
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a * 'b * 'c


let rec clone x n = if n < 0 then [] else clone x n-1
Error: This expression has type 'a list
       but an expression was expected of type int


let rec clone x n = if n < 0 then [] else clone (x,n-1)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a * 'b


let rec clone x n = 
let cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper(x,n-1,x::acc) in
cloneHelper(x,n,[])
Error: Unbound value cloneHelper



hw3 padZero

fix:
let padZero l1 l2 = 
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append (clone 0 (abs diff)) l1 else l2

bad:
let padZero l1 l2 = 
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append (clone 0 (abs diff)) l1
else if (diff > 0) then List.append (clone 0 diff) l2
Error: This expression has type int list
       but an expression was expected of type unit


let padZero l1 l2 = 
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append ((clone 0 (abs diff)) l1)
else if (diff > 0) then List.append ((clone 0 diff) l2)
Error: This expression has type int list
       This is not a function; it cannot be applied.


let padZero l1 l2 = 
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append ((clone 0 (abs diff)),l1)
else if (diff > 0) then List.append ((clone 0 diff),l2)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let padZero l1 l2 = 
let diff = List.length l1 - List.length l2 in
if (diff < 0) then (List.append ((clone 0 (abs diff)),l1),l2)
else if (diff > 0) then (l1,List.append ((clone 0 diff),l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let padZero l1 l2 = 
let diff = List.length l1 - List.length l2 in
if (diff < 0) then (List.combine ((clone 0 (abs diff)),l1),l2)
else if (diff > 0) then (l1,List.combine ((clone 0 diff),l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let padZero l1 l2 = 
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append (clone 0 (abs diff)) l1
else if (diff > 0) then List.append (clone 0 diff) l2
Error: This expression has type int list
       but an expression was expected of type unit


let padZero l1 l2 = 
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append (clone 0 (abs diff)) l1
else if (diff > 0) then List.append (clone 0 diff) l2
Error: This expression has type int list
       but an expression was expected of type unit


let padZero l1 l2 = 
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append (clone 0 (abs diff)) l1
Error: This expression has type int list
       but an expression was expected of type unit



hw3 padZero

fix:
let padZero l1 l2 = 
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append (clone 0 (abs diff)) l1 else if (diff > 0) then l1 else l1

bad:
let padZero l1 l2 = 
let diff = List.length l1 - List.length l2 in
if (diff < 0) then List.append (clone 0 (abs diff)) l1 else if l2 else l1
Error: Syntax error



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let sum = fst a + (fst x + snd x) mod 10 in
(sum/10, sum mod 10) in
let base = (0,0) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res::[] 
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + (fst x + snd x) mod 10 in
let base = 0 in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let sum = fst a + (fst x + snd x) mod 10 in
(sum/10, sum mod 10) in
let base = (0,0) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         int list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let sum = fst a + (fst x + snd x) in
(sum/10, (sum mod 10)::snd a) in
let base = (0,[]) in
let args = List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
List.rev res
in 
removeZero (add (padZero 0::l1 0::l2))

let _ = bigAdd [5;1] [5;4]

let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let sum = fst a + (fst x + snd x) in
(sum/10, (sum mod 10)::snd a) in
let base = (0,[]) in
let args = List.combine (List.reverse l1) (List.reverse l2) in
let (_, res) = List.fold_left f base args in
List.reverse res
in 
removeZero (add (padZero 0::l1 0::l2))
Error: Unbound value List.reverse


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let sum = fst a + (fst x + snd x) in
(sum/10, (sum mod 10)::snd a) in
let base = (0,[]) in
let args = List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
List.reverse res
in 
removeZero (add (padZero 0::l1 0::l2))
Error: Unbound value List.reverse



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let sum = fst a + (fst x + snd x) in
(sum/10, (sum mod 10)::snd a) in
let base = (0,[]) in
let args = List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
List.rev res
in 
removeZero (add (padZero (0::l1) (0::l2)))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let sum = fst a + (fst x + snd x) in
(sum/10, (sum mod 10)::snd a) in
let base = (0,[]) in
let args = List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
List.rev res
in 
removeZero (add (padZero (0::l1) (0::l2))

let _ = bigAdd [5;1] [5;4]
Characters 271-272:
  removeZero (add (padZero (0::l1) (0::l2))
             ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let sum = fst a + (fst x + snd x) in
(sum/10, (sum mod 10)::snd a) in
let base = (0,[]) in
let args = List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero (0::l1) (0::l2)))

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let sum = fst a + (fst x + snd x) in
(sum/10, (sum mod 10)::snd a) in
let base = (0,[]) in
let args = List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero (0:l1) (0:l2)))
Error: Unbound type constructor l1



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = (fst a + 1, bigAdd (snd a) (List.append l1 (clone 0 (fst a)))) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = (fst a + 1, bigAdd snd a (List.append l1 (clone 0 (fst a)))) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This function has type int list -> int list -> int list
       It is applied to too many arguments; maybe you forgot a `;'.
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This function has type int list -> int list -> int list
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 ???

fix:
51/10

bad:
51 mod 10
51/10
Error: This expression has type int
       This is not a function; it cannot be applied.



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n < 1 then []
else n mod 10 :: digitsOfInt(n/10)

bad:
let rec digitsOfInt n = match n with
| n < 1 -> []
| n mod 10 :: digitsofInt(n/10)
Error: Syntax error


let rec digitsOfInt n = match n with
if n < 1 then []
else n mod 10 :: digitsofInt(n/10)
Error: Syntax error


let rec digitsOfInt n = 
if n < 1 then []
else n mod 10 :: digitsofInt(n/10)
Error: Unbound value digitsofInt
Hint: Did you mean digitsOfInt?



hw1 additivePersistence

fix:
let rec additivePersistence n = 
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else
additivePersistence(addList(digitsOfInt(n)))

bad:
let rec additivePersistence n = 
let count = 0 in
if digitsOfInt(n).length = 1 then 
count
else
additivePersistence(addList(digitsofInt(n)))
Error: Unbound record field length


let rec additivePersistence n = 
let count = 0 in
if List.length digitsOfInt(n) = 1 then 
count
else
additivePersistence(addList(digitsofInt(n)))
Error: This function has type 'a list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let rec additivePersistence n = 
let count = 0 in
if (List.length digitsOfInt(n)) = 1 then 
count
else
additivePersistence(addList(digitsofInt(n)))
Error: This function has type 'a list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let rec additivePersistence n = 
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else
additivePersistence(addList(digitsofInt(n)))
Error: Unbound value digitsofInt
Hint: Did you mean digitsOfInt?


let rec additivePersistence n = 
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else
additivePersistence(addList(digitsofInt(n)))
Error: Unbound value digitsofInt
Hint: Did you mean digitsOfInt?



hw1 additivePersistence

fix:
addList[1;2;3;4]

let rec additivePersistence n = 
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count + 1
else 
let count = count + 1
additivePersistence(addList(digitsOfInt(n)))

bad:
let rec additivePersistence n = 
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else
inc count
additivePersistence(addList(digitsOfInt(n)))
Error: Unbound value inc
Hint: Did you mean incr?


let rec additivePersistence n = 
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else
incr count
additivePersistence(addList(digitsOfInt(n)))
Error: This function has type int ref -> unit
       It is applied to too many arguments; maybe you forgot a `;'.


let rec additivePersistence n = 
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else
incr(count)
additivePersistence(addList(digitsOfInt(n)))
Error: This function has type int ref -> unit
       It is applied to too many arguments; maybe you forgot a `;'.


let rec additivePersistence n = 
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else (
incr(count)
additivePersistence(addList(digitsOfInt(n)))
)
Error: This function has type int ref -> unit
       It is applied to too many arguments; maybe you forgot a `;'.


let rec additivePersistence n = 
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else (
incr(count)
Characters 104-105:
  else (
       ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


additivePersistence(addList(digitsOfInt(n)))
)
Error: Syntax error


let rec additivePersistence n = 
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else 
incr(count)
Error: This expression has type int but an expression was expected of type
         int ref


additivePersistence(addList(digitsOfInt(n)))
Error: Unbound value n
Error: Unbound value digitsOfInt
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value n


let rec additivePersistence n = 
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else 
count = count + 1
additivePersistence(addList(digitsOfInt(n)))
Error: This expression has type int
       This is not a function; it cannot be applied.


let rec additivePersistence n = 
let count = 0 in
if (List.length(digitsOfInt(n))) = 1 then 
count
else 
let count = count + 1
additivePersistence(addList(digitsOfInt(n)))
Error: Syntax error



hw1 digitsOfInt

fix:
let rec addList (f,xs) = match xs with
| [] -> 0
| h::t -> h+ addList(f,t)

addList (digitsOfInt,5)

bad:
addList digitsOfInt 5
Error: This function has type 'a * int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 ???

fix:
let rec addList xs = match xs with
| [] -> 0
| h::t -> h + addList t

bad:
let rec addHelp(count, n) = 
if n < 10 then
count + 1
else
addHelp(count+1, addNum(n))
Error: Unbound value addNum



hw1 digitsOfInt

fix:
let rec addNum n = 
if n < 10 then n
else 
addList(digitsOfInt(n))

bad:
let rec addNum = match n with
if n < 10 then n
else 
addList(digitsOfInt(n))
Error: Syntax error


let rec addNum = 
if n < 10 then n
else 
addList(digitsOfInt(n))
Error: Unbound value n



hw1 additivePersistence

fix:
let rec addList xs = match xs with
| [] -> 0
| h::t -> h + addList t

let rec addNum n = 
if n < 10 then n
else 
addList(digitsOfInt(n))

let rec additivePersistence n = 
addHelp(0, n)

let rec addHelp(count, n) = 
if n < 10 then
count + 1
else
addHelp(count+1, addNum(n))

bad:
let rec additivePersistence n = 
let count = 0 in 
if n < 10 then
count + 1
else 
let count = count + 1
Error: Syntax error



hw1 palindrome

fix:
let palindrome w = 
let l = explode w in
if listReverse(l) = l then
true
else
false

bad:
let palindrome w = 
let l = explode s in
if listReverse(l) = l then
true
else
false
Error: Unbound value s



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' =
if List.mem h seen
then
seen
else
h::seen
in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' =
if List.mem h seen
then
seem
else
h::seem
in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: Unbound value seem
Hint: Did you mean seen?



hw2 wwhile

fix:
let rec wwhile (f,b) = 
let a', b' = f b in  
if b' = true 
then wwhile (f, b')
else a'

bad:
 rec wwhile (f,b) = 
let f b = x, y in 
if y = true 
then wwhile (f, x)
else x
Error: Syntax error


 rec wwhile (f,b) = 
let f b = (x, y) in 
if y = true 
then wwhile (f, x)
else x
Error: Syntax error


let rec wwhile (f,b) = 
let f(b) = (x, y) in 
if y = true 
then wwhile (f, x)
else x
Error: This expression has type bool but an expression was expected of type
         int


let rec wwhile (f,b) = 
let f(b) = (x, y) in 
if x = true 
then wwhile (f, x)
else x
Error: This expression has type bool but an expression was expected of type
         string


let rec wwhile (f,b) = 
let f(b) = (b', c') in 
if c' = true 
then wwhile (f, b')
else x
Error: Unbound value b'


let rec wwhile (f,b) = 
let f(b) = b', c' in 
if c' = true 
then wwhile (f, b')
else x
Error: Unbound value b'


let rec wwhile (f,b) = 
let f b = b', c' in 
if c' = true 
then wwhile (f, b')
else x
Error: Unbound value b'


let rec wwhile (f,b) = 
let f b = q, x in 
if c' = true 
then wwhile (f, b')
else x
Error: Unbound value q


let rec wwhile (f,b) = 
let f b = q, x 
if c' = true 
then wwhile (f, b')
else x
Error: Syntax error


let rec wwhile (f,b) = 
let f b = q, x in  
if c' = true 
then wwhile (f, b')
else x
Error: Unbound value q


let rec wwhile (f,b) = 
let f b = w in  
if c' = true 
then wwhile (f, b')
else x
Error: Unbound value w



hw2 wwhile

fix:
let rec wwhile (f,b) = 
let b', c' = f b in  
if c' = true 
then wwhile (f, b')
else b'

bad:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)
Error: This expression has type int -> int * bool
       but an expression was expected of type bool -> 'a * bool
       Type int is not compatible with type bool 



hw2 fixpoint

fix:
let fixpoint (f,b) = 
let f' b' = 
if f(b') = b'
then (b', true)
else
(b', false)
in 
wwhile(f' , b)

bad:
let fixpoint (f,b) = 
let f' = fun b'
if(f(b') = b')
then (b', true)
else
(b', false)
in 
wwhile(f' , b)
Error: Syntax error


let fixpoint (f,b) = 
let f' = fun b' = 
if(f(b') = b')
then (b', true)
else
(b', false)
in 
wwhile(f' , b)
Error: Syntax error


let fixpoint (f,b) = 
let fun f' b' =  
if(f(b') = b')
then (b', true)
else
(b', false)
in 
wwhile(f' , b)
Error: Syntax error


let fixpoint (f,b) = 
let f' b' =  fun
if(f(b') = b')
then (b', true)
else
(b', false)
in 
wwhile(f' , b)
Error: Syntax error


let fixpoint (f,b) = 
let f' b' =  fun
if(f(b') = b')
then (b', true)
else
(b', false)
in 
wwhile(f' , b)
Error: Syntax error


let fixpoint (f,b) = 
let f' b' =  fun
if(f(b') = b')
then (b', true)
else
(b', false)
in 
wwhile(f' , b)
Error: Syntax error


let fixpoint (f,b) = 
let f' b' =  fun
if(f(b') = b')
then (b', true)
else
(b', false)
in 
wwhile(f' , b)
Error: Syntax error


let fixpoint (f,b) = 
let f' b' =  fun
if(f(b') = b')
then (b', true)
else
(b', false)
in 
wwhile(f' , b)
Error: Syntax error


let fixpoint (f,b) = 
let f' b' =  function
if(f(b') = b')
then (b', true)
else
(b', false)
in 
wwhile(f' , b)
Error: Syntax error



hw2 exprToString

fix:
let rec exprToString e = match e with
| VarX		  -> "x"
| VarY		  -> "y"
| Sine e1	  -> "(sin"^ exprToString e1 ^")"
| Cosine e1	  -> "(cos"^exprToString e1 ^ ")"
| Average (e1, e2)-> "("^ exprToString e1 ^"+" ^ exprToString e2 ^ ")/2"
| Times (e1, e2)  -> "("^ exprToString e1 ^"*"^exprToString e2 ^")"
| Thresh (e1, e2, e3, e4) -> "("^ exprToString e1 ^ "<" ^ exprToString e2 ^ ")?("^ exprToString e3 ^ "):("^exprToString e4 ^ ")"

bad:
exprToString (Sine(VarX))
Error: This function has type expr -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw2 eval

fix:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval (e1, x, y))
| Cosine e1 -> cos(eval (e1, x, y))
| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)

bad:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval(e))
Error: Unbound constructor BuildSine


let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval(e1))
Error: This expression has type expr but an expression was expected of type
         expr * 'a * 'a


let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval e1)
Error: This expression has type expr but an expression was expected of type
         expr * 'a * 'a


let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval e1)
Error: This expression has type expr but an expression was expected of type
         expr * 'a * 'a


let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval e1, x, y)
Error: This expression has type expr but an expression was expected of type
         expr * 'a * 'a


let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval (e1, x, y))
Error: This expression has type 'a * 'b * 'c
       but an expression was expected of type float



hw2 eval

fix:
let pi = 4.0 *. atan 1.0

let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval (e1, x, y))
| Cosine e1 -> cos(eval (e1, x, y))
| Average (e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)/. 2.0)
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if 
(eval(e1, x, y) < eval(e2, x, y) 
then
eval(e3, x, y)
else
eval(e4, x, y)

bad:
let pi = 4.0 *. atan 1.0

(* eval : expr -> float * float -> float 
Evaluator for expressions in x and y *)
1<2?3:4
Error: Syntax error



hw2 eval

fix:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval (e1, x, y))
| Cosine e1 -> cos(eval (e1, x, y))
| Average (e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)/. 2.0)
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if 
eval(e1, x, y) < eval(e2, x, y)
then
eval(e3, x, y)
else
eval(e4, x, y)

bad:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval (e1, x, y))
| Cosine e1 -> cos(eval (e1, x, y))
| Average (e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)/. 2.0)
| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if 
(eval(e1, x, y) < eval(e2, x, y) )
then
eval(e3, x, y)
else
eval(e4, x, y)
Characters 283-284:
  (eval(e1, x, y) < eval(e2, x, y) 
  ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw3 pipe

fix:
let pipe fs = 
let f a x = (x a) in
let base = 0 in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe fs = 
let f a x = (x a) in
let base = [] in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe fs = 
let f a x = (x a) in
let base = fun g x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (x a) in
let base = x in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = (x a) in
let base = a in
List.fold_left f base fs
Error: Unbound value a


let pipe fs = 
let f a x = (x a) in
let base = g x->x in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = (x a) in
let base = fun g x -> x in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'b -> 'b
       but an expression was expected of type int


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This expression has type 'a -> 'b -> 'b
       but an expression was expected of type int



hw3 ???

fix:
let y = fun x -> x + 1

let x = fun z -> z*z

bad:
y = fun x -> x + 1
Error: Unbound value y



hw3 ???

fix:
let q x = y (x)

bad:
let z = (y x)
Error: This expression has type int -> int
       but an expression was expected of type int


let q = (y x)
Error: This expression has type int -> int
       but an expression was expected of type int


let q = (y(x))
Error: This expression has type int -> int
       but an expression was expected of type int


let q = fun adf -> fun x -> fun y
Error: Syntax error


let q = (fun x -> fun z)
Error: Syntax error: operator expected.



hw3 pipe

fix:
let pipe fs = 
let f a x = fun q -> x(a(q)) in
let base = fun g q -> q in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         int -> int



hw3 clone

fix:
let rec clone x n = match n with
| 0 -> []
| _ -> x::(clone x (n-1))

bad:
let rec clone x n =  
| 0 -> []
| _ -> x::clone n-1
Error: Syntax error


let rec clone x n = match n with
| 0 -> []
| _ -> x::clone n-1
Error: This expression has type int -> int list
       but an expression was expected of type int


let rec clone x n = match n with
| 0 -> []
| _ -> x::clone (x n-1)
Error: This expression has type int but an expression was expected of type
         int -> int


let rec clone x n = match n with
| 0 -> []
| _ -> x::(clone x n-1)
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 padZero

fix:
let padZero l1 l2 =
let lenl1 = List.length l1 in
let lenl2 = List.length l2 in
if lenl1 > lenl2
then (l1, (clone 0 (lenl1-lenl2))@l2)
else ((clone 0 (lenl2-lenl1))@l1, l2)

bad:
let padZero l1 l2 =
let lenl1 = List.length l1 in
let lenl2 = List.length l2 in
if lenl1 > lenl2
then (l1, (clone 0 lenl1-lenl2)@l2)
else ((clone 0 lenl2-lenl1)@l1, l2)
Error: This expression has type int list
       but an expression was expected of type int



hw3 removeZero

fix:
let _ = removeZero [0;0;0;0]

bad:
let _ = removeZero [0;0;0;0]

*
Error: Syntax error



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let rem = match a with
| (x, y) -> x in
match x with 
| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in
let digit = (rem + add_a + add_b) mod 10 in
match a with
| (x, y) -> (new_carry, digit::y) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let rem = match a in
| (x, y) -> x in
match x with 
| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in
let digit = (rem + add_a + add_b) mod 10 in
match a with
| (x, y) -> new_carry, digit::y
Error: Syntax error


) in

let base = (0, []) in
let args = List.rev(List.combine(l1, l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let rem = match a with
| (x, y) -> x in
match x with 
| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in
let digit = (rem + add_a + add_b) mod 10 in
match a with
| (x, y) -> new_carry, digit::y
Error: Syntax error


) in

let base = (0, []) in
let args = List.rev(List.combine(l1, l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let rem = match a with
| (x, y) -> x in
match x with 
| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in
let digit = (rem + add_a + add_b) mod 10 in
match a with
| (x, y) -> (new_carry, digit::y) in
let base = (0, []) in
let args = List.rev(List.combine(l1, l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (rem, _) = a in
let (el1, el2) = x in
let new_sum = rem + el1 + el2 in
let new_rem = if new_sum > 9 then 1 else 0 in
let norm_sum = if new_sum > 9 then new_sum-10 else new_sum in 
(new_rem, (norm_sum::y)) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (rem, _) = a in
let (el1, el2) = x in
let new_sum = rem + el1 + el2 in
let new_rem = if new_sum > 9 then 1 else 0 in
let norm_sum = if new_sum > 9 then new_sum-10 else new_sum in 
(new_rem, norm_sum::y)
Error: Syntax error


let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (rem, _) = a in
let (el1, el2) = x in
let new_sum = rem + el1 + el2 in
let new_rem = if new_sum > 9 then 1 else 0 in
let norm_sum = if new_sum > 9 then new_sum-10 else new_sum in 
(new_rem, norm_sum::y) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int -> int
       but an expression was expected of type int list



hw3 removeZero

fix:
let rec removeZero l = match l with
| []      -> []
| h::t    -> 
if h = 0 
then removeZero(t)
else h::t

List.combine([1;2] [3;4])

bad:
let rec removeZero l = match l with
| []      -> []
| h::t    -> 
if h = 0 
then removeZero(t)
else h::t

List.combine([1;2] [3;4])
Error: This expression has type int list
       This is not a function; it cannot be applied.



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (rem, acc) = a in
if ((List.length acc) = (List.length l1)) || (List.length acc = List.length l2)
then if rem = 1
then (0, 1::acc) 
else (0, acc)
else
let (el1, el2) = x in
let new_sum = rem + el1 + el2 in
let new_rem = if new_sum > 9 then 1 else 0 in
let norm_sum = if new_sum > 9 then new_sum-10 else new_sum in 
(new_rem, norm_sum::acc) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (rem, acc) = a in
if (acc.length = l1.length) || (acc.length = l2.length)
then if rem = 1
then (0, 1::acc) 
else (0, acc)
else
let (el1, el2) = x in
let new_sum = rem + el1 + el2 in
let new_rem = if new_sum > 9 then 1 else 0 in
let norm_sum = if new_sum > 9 then new_sum-10 else new_sum in 
(new_rem, norm_sum::acc) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound record field length



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (rem, acc) = a in

let (el1, el2) = x in
let new_sum = rem + el1 + el2 in
let new_rem = if new_sum > 9 then 1 else 0 in
let norm_sum = if new_sum > 9 then new_sum-10 else new_sum in 
let larger = if List.length l1 > List.length l2 then l1 else l2 in
if ((List.length acc) = (List.length larger)-1)
then if rem = 1
then (0, [1;norm_sum]@acc) 
else (0, acc)
else
(new_rem, norm_sum::acc) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [0;9;9;9]

let _ = bigAdd [0;9;9;9] [9;9;9;9]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (rem, acc) = a in

let (el1, el2) = x in
let new_sum = rem + el1 + el2 in
let new_rem = if new_sum > 9 then 1 else 0 in
let norm_sum = if new_sum > 9 then new_sum-10 else new_sum in 
let larger = if List.length l1 > List.length l2 then l1 else l2 in
if ((List.length acc) = (List.length larger)-1)
then if rem = 1
then (0, [1;norm_sum]@acc) 
else (0, acc)
else
(new_rem, norm_sum::acc) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZ
Characters 580-581:
  removeZero (add (padZ;;
                  ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (rem, acc) = a in

let (el1, el2) = x in
let new_sum = rem + el1 + el2 in
let new_rem = if new_sum > 9 then 1 else 0 in
let norm_sum = if new_sum > 9 then new_sum-10 else new_sum in 
let larger = if List.length l1 > List.length l2 then l1 else l2 in
if ((List.length acc) = (List.length larger)-1)
then if rem = 1
then (0, [1;norm_sum]@acc) 
else (0, norm_sum::acc)
else
(new_rem, norm_sum::acc) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [0;9;9;9]

let _ = bigAdd [0;9;9;9] [9;9;9;9]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (rem, acc) = a in

let (el1, el2) = x in
let new_sum = rem + el1 + el2 in
let new_rem = if new_sum > 9 then 1 else 0 in
let norm_sum = if new_sum > 9 then new_sum-10 else new_sum in 
let larger = if List.length l1 > List.length l2 then l1 else l2 in
if ((List.length acc) = (List.length larger)-1)
then if rem = 1
then (0, [1;norm_sum]@acc) 
else (0, norm_sum@acc)
else
(new_rem, norm_sum::acc) in
let base = (0, []) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a list



hw3 mulByDigit

fix:
let rec mulByDigit i l = match i with
| 1 -> l
| _ -> bigAdd (mulByDigit (i-1) l) l

bad:
let rec mulByDigit i l = match i with
| 0 -> l
| _ -> bigAdd (mulByDigit i-1) l
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let rec mulByDigit i l = match i with
| 1 -> l
| _ -> bigAdd (mulByDigit i-1) l
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = 
let (place, acc) = a in
(place+1, bigAdd ((mulByDigit x l1)@(clone 0 place)) acc) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = (bigAdd (mulByDigit x l1) a in
let base = [] in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Characters 32-33:
  let f a x = (bigAdd (mulByDigit x l1) a in
              ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let bigMul l1 l2 = 
let f a x = (bigAdd (mulByDigit x l1) a) in
let base = [] in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list
       but an expression was expected of type 'a * 'b


let bigMul l1 l2 = 
let f a x = 
let (place, acc) = a in
(place+1, (bigAdd(mulByDigit x l1)@clone 0 place) acc) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list -> int list
       but an expression was expected of type 'a list
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int list -> int list
       but an expression was expected of type 'a list


let bigMul l1 l2 = 
let f a x = 
let (place, acc) = a in
(place+1, (bigAdd(mulByDigit x l1)@clone (0 place)) acc) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list -> int list
       but an expression was expected of type 'a list
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int list -> int list
       but an expression was expected of type 'a list


let bigMul l1 l2 = 
let f a x = 
let (place, acc) = a in
(place+1, bigAdd(mulByDigit x l1)@clone (0 place) acc) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list -> int list
       but an expression was expected of type 'a list
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int list -> int list
       but an expression was expected of type 'a list



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n < 0 then []
else
let rec digits n digitList = 
if n = 0 then digitList
else digits (n/10) ((n mod 10)::digitList)

) in
match n with
| 0 -> [0]
| _ -> digits n []

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

bad:
let rec digitsOfInt n = 
if n <= 0 then []
else if n mod 10 = 0 then 0::digitsOfInt (n/10)
else if ((n-1) mod 10) = 0 then (1::digitsOfInt ((n-1)/10))
Error: This variant expression is expected to have type unit
       The constructor :: does not belong to type unit


let rec digitsOfInt n = 
if n <= 0 then []
else if n mod 10 = 0 then 0::digitsOfInt (n/10)
else if ((n-1) mod 10) = 0 then (1::(digitsOfInt ((n-1)/10)))
Error: This variant expression is expected to have type unit
       The constructor :: does not belong to type unit



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n < 0 then []
else
let rec digits n digitList = 
if n = 0 then digitList
else digits (n/10) ((n mod 10)::digitList) in
match n with
| 0 -> [0]
| _ -> digits n []

bad:
let rec digitsOfInt n = 
if n < 0 then []
else
let rec digits n digitList = 
if n = 0 then digitList
else digits (n/10) ((n mod 10)::digitList)
Error: Syntax error


) in
match n with
| 0 -> [0]
| _ -> digits n []
Error: Syntax error


let rec digitsOfInt n = 
if n < 0 then []
else
let rec digits n digitList = 
if n = 0 then digitList
else digits (n/10) ((n mod 10)::digitList)
Error: Syntax error


let rec digitsOfInt n = 
if n < 0 then []
else
let rec digits n digitList = 
if n = 0 then digitList
else digits (n/10) ((n mod 10)::digitList)
Error: Syntax error


) in
match n with
| 0 -> [0]
| _ -> digits n []
Error: Syntax error



hw2 assoc

fix:
let rec assoc (d,k,l) = 
match l with
| []     -> d
| ((a,b)::t) -> if a = k then b else assoc (d,k,t)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

bad:
let rec assoc (d,k,l) = 
match l with
| []     -> d
| (h::t) -> if h = (k,'a) then 'a else assoc (d,k,t)
Error: Syntax error: operator expected.


let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])
Error: Unbound value assoc


let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])
Error: Unbound value assoc


let rec assoc (d,k,l) = 
match l with
| []     -> d
| (h::t) -> if h = (k * 'a) then 'a else assoc (d,k,t)
Error: Syntax error: operator expected.


let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])
Error: Unbound value assoc


let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])
Error: Unbound value assoc


let rec assoc (d,k,l) = 
match l with
| []     -> d
| (h::t) -> if h = [k,'a] then 'a else assoc (d,k,t)
Error: Syntax error


let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])
Error: Unbound value assoc


let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])
Error: Unbound value assoc


let rec assoc (d,k,l) = 
match l with
| []     -> d
| (('a,'b)::t) -> if 'a = k then 'b else assoc (d,k,t)
Error: Syntax error: operator expected.


let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])
Error: Unbound value assoc


let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])
Error: Unbound value assoc



hw2 fixpoint

fix:
let rec assoc (d,k,l) = 
match l with
| []     -> d
| ((a,b)::t) -> if a = k then b else assoc (d,k,t)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
if List.mem h seen 
then helper (seen, t) 
else helper (h::seen, t)
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) = 
match f b with
| (x, false) -> x
| (x, true)  -> wwhile (f, x)

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) = wwhile (let g x = let bb = f b in (bb, bb = b) in f, b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile (let a = (f b, b = f b),b)
Error: Syntax error: operator expected.


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: This expression has type int -> int
       but an expression was expected of type int -> int * bool
       Type int is not compatible with type int * bool 


let fixpoint (f,b) = wwhile ((f b, b = f b),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: This expression has type int -> int
       but an expression was expected of type int -> int * bool
       Type int is not compatible with type int * bool 



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile (let g x = let bb = f x in (bb, bb = x) in g, b)

bad:
let fixpoint (f,b) = wwhile (let g = let bb = f b in (bb, bb = b) in g, b)
Error: This expression has type 'a * bool
       but an expression was expected of type 'b -> 'b * bool



hw2 exprToString

fix:
let rec exprToString e = match e with
| VarX -> x

let sampleExpr1 = VarX

let _ = exprToString sampleExpr1

bad:
let rec exprToString e = match e with
| VarX x -> Printf.printf "%s" x
Error: The constructor VarX expects 0 argument(s),
       but is applied here to 1 argument(s)



hw2 build

fix:
let rec build (rand, depth) = 
if depth = 0 then 
match rand mod 2 with
| 0 -> buildX()
| 1 -> buildY()
else
match rand mod 5 with
| 2 -> buildSine(build (rand, depth-1))
| 3 -> buildCosine(build (rand, depth-1))
| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))
| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))
| 6 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))

bad:
let rec build (rand, depth) = 
if depth = 0 then 
match rand (i,j) mod 2 with
| 0 -> buildX()
| 1 -> buildY()
else
match rand (i,j) mod 5 with
| 2 -> buildSine(build (rand, depth-1))
| 3 -> buildCosine(build (rand, depth-1))
| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))
| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))
| 6 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))
Error: Unbound value i


let rec build (rand, depth) = 
if depth = 0 then 
match rand mod 2 with
| 0 -> buildX()
| 1 -> buildY()
else
match rand mod 5 with
| 2 -> buildSine(build (rand, depth-1))
| 3 -> buildCosine(build (rand, depth-1))
| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))
| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))
| 6 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))
Error: Unbound value i



hw3 sqsum

fix:
let sqsum xs = 
let rec f a x = match x with
| []     -> a
| (h::t) -> f (a+(h*h)) t in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = match x with
| [] -> a
| (h::t) -> f (a+(h*h)) t in
let base = 0 in
List.fold_left f base xs
Error: Unbound value f


let _ = sqsum []
Error: Unbound value sqsum


let _ = sqsum [1;2;3;4]
Error: Unbound value sqsum


let _ = sqsum [(-1); (-2); (-3); (-4)]
Error: Unbound value sqsum


let sqsum xs = 
let f a x = match x with
| []     -> a
| (h::t) -> sqsum (a+(h*h)) t in
let base = 0 in
List.fold_left f base xs
Error: Unbound value sqsum


let sqsum xs = 
let f a x = match x with
| []     -> a
| (h::t) -> f (a+(h*h)) t in
let base = 0 in
List.fold_left f base xs
Error: Unbound value f


let sqsum xs = 
let f a x = match x with
| []     -> a
| (h::t) -> f a+(h*h) t in
let base = 0 in
List.fold_left f base xs
Error: Unbound value f


let sqsum xs = 
let f a x = match x with
| []     -> a
| (h::t) -> f (a+(h*h)) t in
let base = 0 in
List.fold_left f base xs
Error: Unbound value f



hw3 sqsum

fix:
let sqsum xs = 
let f a x = (a + (x*x)) in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a + x*x
Error: Syntax error


let base = 0 in
List.fold_left f base xs
Error: Unbound value f



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = x in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = x a in
let base = fs in
List.fold_left f base fs
Error: This expression has type 'a but an expression was expected of type
         ('a -> 'a) list
       The type variable 'a occurs inside ('a -> 'a) list


let pipe fs = 
let f a x = x 'a in
let base = fs in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x a in
let base = a in
List.fold_left f base fs
Error: Unbound value a



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = 3 in
List.fold_left f base fs

let _ = pipe []

bad:
let _ = pipe [] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let pipe fs = 
let f a x = x 'a in
let base = 'a in
List.fold_left f base fs
Error: Syntax error


let _ = pipe [] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let pipe fs = 
let f a x = x a in
let base = a in
List.fold_left f base fs
Error: Unbound value a


let _ = pipe [] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let pipe fs = 
let f a x = x a in
let base = 'a in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs num = 
let f a x = x a in
let base = num in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = b in
List.fold_left f base fs
Error: Unbound value b



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun 'a in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x a in
let base = fun 'a -> fs 'a in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x a in
let base = fun a -> fs a in
List.fold_left f base fs
Error: This expression has type 'a -> 'b
       but an expression was expected of type (('a -> 'b) -> 'a -> 'b) list


let pipe fs = 
let f a x = x a in
let base = in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x a in
let base = base in
List.fold_left f base fs
Error: Unbound value base


let pipe fs = 
let f a x = x a in
let base = fs 'a in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x a in
let base = List.hd fs in
List.fold_left f base fs
Error: This expression has type 'a list
       but an expression was expected of type ('a -> 'a) list
       The type variable 'a occurs inside 'a -> 'a



hw3 pipe

fix:
let pipe = fun x -> fun2 (fun1 x)

bad:
let pipe = fun x -> fun (fun y)
Error: Syntax error: operator expected.



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = _ in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x a in
let base = 'a in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x a in
let base = 'b in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x a in
let base = int in
List.fold_left f base fs
Error: Unbound value int



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = [] in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe = fun x -> fun2 (fun1 x)

let _ = pipe 3

let pipe fs = 
let f a x = x a in
let base = fun p = p in
List.fold_left f base fs

bad:
let pipe = let base = x in fun x -> fun2 (fun1 base)
Error: Unbound value x


let _ = pipe 3
Error: This expression has type int but an expression was expected of type
         ('a list -> 'a list) list


let pipe = let base = fun x in fun x -> fun2 (fun1 base)
Error: Syntax error


let _ = pipe 3
Error: This expression has type int but an expression was expected of type
         ('a list -> 'a list) list


let pipe = let base =  in fun x -> fun2 (fun1 base)
Error: Syntax error


let _ = pipe 3
Error: This expression has type int but an expression was expected of type
         ('a list -> 'a list) list


let pipe fs = 
let f a x = x a in
let base = fun p = p in
List.fold_left f base fs
Error: Syntax error


let pipe = fun x -> fun2 (fun1 base)
Error: Unbound value base


let _ = pipe 3
Error: This expression has type int but an expression was expected of type
         ('a list -> 'a list) list


let pipe fs = 
let f a x = x a in
let base = fun p = p in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let pipe fs = 
let f a x = x a in
let base = p -> p in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let _ = pipe fun1 fun2 3

let pipe fs = 
let f a x = x a in
let base = fun p -> p in
List.fold_left f base fs

let _ = pipe [] 3

bad:
let _ = pipe fun1 fun2
Error: This expression has type int -> int
       but an expression was expected of type (int -> int) -> 'a
       Type int is not compatible with type int -> int 


let _ = pipe fun1 fun2 3
Error: This expression has type int -> int
       but an expression was expected of type (int -> int) -> 'a -> 'b
       Type int is not compatible with type int -> int 



hw3 pipe

fix:
let pipe = fun x -> fun2 (fun1 x)

bad:
let pipe = fun2 fun1
Error: This expression has type int -> int
       but an expression was expected of type int


let pipe = fun x -> fun2 fun1
Error: This expression has type int -> int
       but an expression was expected of type int


let pipe = fun x -> fun2 fun1 x
Error: This function has type int -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe = fun x -> fun2 (fun1 x)

bad:
let pipe = fun x -> fun2 x -> (fun1 x)
Error: Syntax error


let pipe = fun x -> fun2 x (fun1 x)
Error: This function has type int -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 pipe

fix:
let rec pipe fs = 
match fs with
| [] -> 0
| (h::t) -> h (pipe t)

bad:
let rec pipe fs = 
let fsrev = List.rev fs in
match fsrev with
| [] -> x -> x
| (h::t) -> h (pipe t)
Error: Syntax error


let rec pipe fs = 
let fsrev = List.rev fs in
match fsrev with
| [x] -> x 
| (h::t) -> h (pipe t)
Error: This expression has type 'a -> 'b
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'b


let rec pipe fs = 
match fs with
| [x] -> x 
| (h::t) -> h (pipe t)
Error: This expression has type 'a -> 'b
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'b


let rec pipe fs = 
match fs with
| [x] -> x 
| (h::t) -> h (pipe t)
Error: This expression has type 'a -> 'b
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'b


let rec pipe fs = 
match fs with
| [] -> x 
| (h::t) -> h (pipe t)
Error: Unbound value x



hw3 pipe

fix:
let rec pipe fs = 
match fs with
| [] -> fun x -> x
| (h::t) -> h (pipe t)

bad:
let rec pipe fs = 
match fs with
| [] -> fun
| (h::t) -> h (pipe t)
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x (a _) in
let base = fun y -> y in
List.fold_left f base fs
Error: Syntax error: operator expected.



hw3 stringOfList

fix:
let stringOfList f l = sepConcat "; " (List.map f l)

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

bad:
let stringOfList f l = List.map f sepConcat l
Error: This function has type ('a -> 'b) -> 'a list -> 'b list
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: Unbound value stringOfList


let _ = stringOfList (fun x -> x) ["foo"]
Error: Unbound value stringOfList


let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]
Error: Unbound value stringOfList


let stringOfList f l = sepConcat (List.map f)
Error: This expression has type 'a list -> 'b list
       but an expression was expected of type string


let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: Unbound value stringOfList


let _ = stringOfList (fun x -> x) ["foo"]
Error: Unbound value stringOfList


let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]
Error: Unbound value stringOfList


let stringOfList f l = sepConcat "; " (List.map f)
Error: This expression has type 'a list -> 'b list
       but an expression was expected of type string list


let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: Unbound value stringOfList


let _ = stringOfList (fun x -> x) ["foo"]
Error: Unbound value stringOfList


let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]
Error: Unbound value stringOfList



hw3 padZero

fix:
let _ = padZero [9;9] [1;2]

bad:
let _ padZero [9;9] [1;2]
Error: Syntax error



hw3 pipe

fix:
let pipe fs p = 
let f a x = x a in
let base = p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = let p = fun x -> x in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x a in
let base = let p = fun x -> x in
List.fold_left f base fs
Error: Syntax error



hw3 ???

fix:
let x = 2

let (_, test) = x + 1 in test

bad:
let (_, test) = x + 1 in test
Error: Unbound value x



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let prevN (n1, n2) = n1 in
let prev = prevN a in
let sumlist (p1, p2) = p2 in
let sum = sumlist a in
let add (m,n) = m + n in
let digit = (add x) + prev in
if digit > 10 then (1, (digit-10)::sum) else (0, (digit)::sum) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let prevN (n1, n2) in
let prev = prevN a in
let sumlist (p1, p2) = p2 in
let sum = sumlist a in
let add (m,n) = m + n in
let digit = (add x) + prev in
if digit > 10 then (1, (digit-10)::sum) else (0, (digit)::sum) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error



hw3 ???

fix:
let getTail l = match l with 
| [] -> []
| (h::t) -> if t = [] then [h] else t

let _ = getTail [0]

bad:
let getTail l = match l with 
| [] -> []
| (h::t) -> if t = [] then [h] else t in

let _ = getTail [0]
Error: Syntax error



hw3 bigMul

fix:
let _ = bigMul [1] [0]

bad:
let _ bigMul [1] [0]
Error: Syntax error



hw1 digitsOfInt

fix:
let rec digitsOfInt n =
if n < 0 then []
else n :: digitsOfInt n

bad:
let rec digitsOfInt n =
if n < 0 then []
else a :: [] -> digitsOfInt n :: []
Error: Syntax error


let rec digitsOfInt n =
if n < 0 then []
else a :: [] -> digitsOfInt n :: []
Error: Syntax error


let rec digitsOfInt n =
if n < 0 then []
else a :: [] -> digitsOfInt n :: []
Error: Syntax error


let rec digitsOfInt n =
if n < 0 then []
else a :: [] -> a :: digitsOfInt n
Error: Syntax error


let rec digitsOfInt n =
if n < 0 then []
else a :: digitsOfInt n
Error: Unbound value a



hw1 digitsOfInt

fix:
let rec digitsOfInt n =
if n < 0 then []
else digitsOfInt (n/10)

bad:
let rec digitsOfInt n =
if n < 0 then []
else n%10
Error: Unbound value %


let rec digitsOfInt n =
if n < 0 then []
else n mod 10
Error: This expression has type int but an expression was expected of type
         'a list


let rec digitsOfInt n =
if n < 0 then []
else h:: digitsOfInt n mod 10
Error: Unbound value h


let rec digitsOfInt n =
if n < 0 then []
else digitsOfInt n mod 10
Error: This expression has type 'a list
       but an expression was expected of type int


let rec digitsOfInt n =
if n < 0 then []
else digitsOfInt (n/10) mod 10 :: []
Error: This expression has type 'a list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let _ = digitsOfInt 98*-1

bad:
let _ = digitsOfInt 98
Error: This expression has type int -> int list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let digitsOfInt n = 
if n < 0 then []
else
let rec digit n acc =
if n < 10 then n::acc
else digit ((n mod 10)::acc) (n/10) in
digit [] n

bad:
let _ = digitsOfInt -9
Error: Unbound value *-


let _ = digitsOfInt ~-9
Error: This expression has type int -> int list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let digitsOfInt n = 
if n < 0 then []
else
(*let rec digit acc n =
if n < 10 then n::acc
else digit ((n mod 10)::acc) (n/10) in
digit [] n*)
let rec digit n acc = 
if n < 10 then n::acc
else digit (n/10) (n mod 10::acc) in 
match n with
| 0 -> [0]
| _ -> digit n []

bad:
let digitsOfInt n = 
if n < 0 then []
else
(*let rec digit acc n =
if n < 10 then n::acc
else digit ((n mod 10)::acc) (n/10) in
digit [] n*)
let rec digit n acc = 
if n < 10 then n::acc
else digit (n/10) (n mod 10::acc) in 
digit [] n
Error: Syntax error


let digitsOfInt n = 
if n < 0 then []
else
(*let rec digit acc n =
if n < 10 then n::acc
else digit ((n mod 10)::acc) (n/10) in
digit [] n*)
let rec digit n acc = 
if n < 10 then n::acc
else digit (n/10) (n mod 10::acc) in 
n [] digit
Error: This expression has type 'a list
       but an expression was expected of type int


let digitsOfInt n = 
if n < 0 then []
else
(*let rec digit acc n =
if n < 10 then n::acc
else digit ((n mod 10)::acc) (n/10) in
digit [] n*)
let rec digit n acc = 
if n < 10 then n::acc
else digit (n/10) (n mod 10::acc) in 
digit [] digit
Error: This expression has type int
       This is not a function; it cannot be applied.


let digitsOfInt n = 
if n < 0 then []
else
(*let rec digit acc n =
if n < 10 then n::acc
else digit ((n mod 10)::acc) (n/10) in
digit [] n*)
let rec digit n acc = 
if n < 10 then n::acc
else digit (n/10) (n mod 10::acc) in 
match n with
| 0 -> [0]
| _ -> digit n []
Error: This expression has type 'a list
       but an expression was expected of type int



hw1 additivePersistence

fix:
let _ = additivePersistence 9876

bad:
let additivePersistence n =
if n < 10 then 0  
else 
let rec addTimes n =
let rec digits n = 
if n <= 0 then 0
else ((n mod 10) + digits (n/10)) in
let x = digits n in
if x > 9 then 1 + addTimes x
else 1
Error: Syntax error


let additivePersistence n =
if n < 10 then 0  
else 
let rec addTimes n =
let rec digits n = 
if n <= 0 then 0
else ((n mod 10) + digits (n/10)) in
let x = digits n in
if x > 9 then 1 + addTimes x
else 1 in
addTimes n
Error: Syntax error



hw1 digitalRoot

fix:
let rec digitalRoot n = 
if n <= 0 then 0
else (n mod 10) + digitalRoot(n/10)

bad:
let rec digitalRoot n = 
if n <= 0 then 0
else (n mod 10) + digitalRoot(n/10)
Error: Unbound value n



hw1 digitalRoot

fix:
let _ = digitalRoot 9876

bad:
let digitalRoot n = 
let rec digits n = 
if n <= 0 then 0
else (n mod 10) + digits(n/10)
Error: Syntax error


let digitalRoot n = 
let rec digits n = 
if n <= 0 then 0
else (n mod 10) + digitalRoot (n/10)
Error: Syntax error


let digitalRoot n = 
if n <= 0 then 0
else (n mod 10) + digitalRoot (n/10)
Error: Syntax error



hw1 digitalRoot

fix:
let digitalRoot n =
if n < 10 then 0
else 
let rec addTimes n =
let rec digits n = 
if n <= 0 then 0
else ((n mod 10) + digits (n/10)) in
let x = digits n in
if x > 9 then 1 + addTimes x
else 1 in
addTimes n

bad:
let rec digitalRoot n = 
let rec digits n = 
if n <= 0 then 0
else (n mod 10) + digits (n/10) in
let x = digits n in 
if x > 9 then digitalRoot x
else x in digitalRoot n
Error: Syntax error


let rec digitalRoot n = 
let rec digits n = 
if n <= 0 then 0
else ((n mod 10) + digits (n/10)) in
let x = digits n in 
if x > 9 then digitalRoot x
else x in digitalRoot n
Error: Unbound value n


let rec digitalRoot n = 
let rec digits n = 
if n <= 0 then 0
else ((n mod 10) + digits (n/10)) in
let x = digits n in 
if x > 9 then digitalRoot x
else 1 in digitalRoot x
Error: Unbound value n


let digitalRoot n =
if n < 10 then 0
else 
let rec addTimes n =
let rec digits n = 
if n <= 0 then 0
else ((n mod 10) + digits (n/10)) in
let x = digits n in
if x > 9 then 1 + addTimes x
else 1 in
addTimes n
Error: Unbound value x



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l = match l with
| [] -> []
| hd::l' -> 1 + listReverse l'
Error: This expression has type 'a list
       but an expression was expected of type int


let rec listReverse l = match l with
| [] -> 0
| hd::l' -> 1 + listReverse l'
Error: This expression has type 'a list
       but an expression was expected of type int



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4; 9]

bad:
let rec listReverse l = match l with
| [] -> 0
| _::tl -> 1 + listReverse tl
Error: Syntax error



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4; 9]

bad:
let rec listReverse l = match l with
| [] -> []
| _::tl -> listReverse _ + tl
Error: Syntax error


let rec listReverse l = match l with
| [] -> []
| _::tl -> listReverse tl + tl
Error: Syntax error


let rec listReverse l = match l with
| 0 -> []
| _::tl -> listReverse tl + tl
Error: This expression has type 'a list
       but an expression was expected of type int


let rec listReverse l = match l with
| [] -> []
| _::tl -> listReverse tl + tl
Error: This pattern matches values of type 'a list
       but a pattern was expected which matches values of type int


let rec listReverse l = match l with
| [] -> []
| _::tl -> listReverse tl
Error: This expression has type 'a list
       but an expression was expected of type int



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4; 9]

bad:
let listReverse l = 
let rec reverseHelper tl l = match l with
| [] -> []
| _::tl -> reverseHelper tl l
Error: Syntax error


let listReverse l = 
let rec reverseHelper l tl = match l with
| [] -> []
| _::t -> reverseHelper t l
Error: Syntax error


let rec listReverse l =
match l with
| [] -> []
| hd::l -> listReverse l
Error: Syntax error



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4; 9]

let _ = listReverse ["a"; "b"; "c"; "d"]

bad:
let listReverse l = 
let rec reverseHelper acc = 
if [] then acc
else reverseHelper (h::acc) t in
reverseHelper [] l
Error: Syntax error


let listReverse l = 
let rec reverseHelper acc = 
| [] -> acc
| h::t -> reverseHelper (h::acc) t in
reverseHelper [] l
Error: This variant expression is expected to have type bool
       The constructor [] does not belong to type bool


let listReverse l = 
let rec reverseHelper acc = match acc with 
| [] -> acc
| h::t -> reverseHelper (h::acc) t in
reverseHelper [] l
Error: Syntax error


let listReverse l = 
let rec reverseHelper acc = function
| [] -> acc
| h::t -> reverseHelper (h::acc) t in
reverseHelper [] l
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 palindrome

fix:
let _ = palindrome "malayalam"

bad:
let palindrome w = 
if explode w = listReverse w then true
else false
Error: This expression has type string but an expression was expected of type
         'a list


let palindrome w = 
if explode w = listReverse (explode w) then true
else false
Error: This expression has type string but an expression was expected of type
         'a list



hw1 palindrome

fix:
let _ = palindrome "_"

bad:
let _ = palindrome ""
Error: Syntax error



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4; 9]

bad:
let listReverse l = 
let rec reverseHelper acc = function 
| [] -> acc
| h::t -> reverseHelper (h::acc) t in
reverseHelper [] l
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4; 9]

bad:
let listReverse l = 
(*let rec reverseHelper acc = function 
| [] -> acc
| h::t -> reverseHelper (h::acc) t in
reverseHelper [] l *)
let rec reverseHelper ln lo =
match ln with
| [] -> lo
| h::t -> reverseHelper t (h::lo) in
reverseHelper l []
Error: Unbound value acc



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a*a + x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a + x in
let base = [] in
List.fold_left f base xs
Error: This expression has type 'a list
       but an expression was expected of type int


let sqsum xs = 
let f a x = a*a + x in
let base = a in
List.fold_left f base xs
Error: Unbound value a



hw3 pipe

fix:
let pipe fs = 
let f a x = fun y -> y |> a |> x in
let base = fun y -> y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun inner -> y |> a |> x in
let base = fun y -> y in
List.fold_left f base fs
Error: Unbound value y



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep^a in
let base = h in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep^a t in
let base = h in
let l = sl in
List.fold_left f base l
Error: This expression has type (string list -> string) -> 'a -> string
       but an expression was expected of type
         (string list -> string) -> 'a -> string list -> string
       Type string is not compatible with type string list -> string 



hw3 stringOfList

fix:
let stringOfList f l = List.map f l

bad:
let stringOfList f l = in List.map f sepConcat " " l
Error: Syntax error



hw3 stringOfList

fix:
let stringOfList f l = sepConcat "[" (List.map f l)

bad:
let stringOfList f l = sepConcat "[" List.map f l
Error: This function has type string -> string list -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 stringOfList

fix:
let stringOfList f l = sepConcat "; " (List.map f l)

bad:
let stringOfList f l = sepConcat "; " List.map f l
Error: This function has type string -> string list -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 padZero

fix:
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 then true
else false

bad:
let padZero l1 l2 = 
let f a l = a+1 l in 
let base = a
in List.fold_left f base
Error: This expression has type int
       This is not a function; it cannot be applied.


let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) acc l1
Error: Syntax error


let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) acc l1
Error: Syntax error


let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) acc l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) acc l2 in
if length1 < length2 then true
else false
Error: Unbound value acc



hw3 padZero

fix:
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 = length2 
then (l1,l2)
else 
if length1 < length2
then (List.append (clone 0 (length2 - length1)) l1, l2)
else (l1, (List.append (clone 0 (length1 - length2)) l2))

bad:
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 
then clone (length2-length1) 0 
else if length2 < length1
then clone (length1-length2) 0
Error: This expression has type int list
       but an expression was expected of type unit


let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 
then clone (length2 - length1) 0 
else if length2 < length1
then clone (length1-length2) 0
Error: This expression has type int list
       but an expression was expected of type unit


let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 
then clone (length2 - length1) 0 
else if length2 < length1
then clone (length1 - length2) 0
Error: This expression has type int list
       but an expression was expected of type unit


let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 
then clone 0 (length2 - length1) 
else if length2 < length1
then clone 0 (length1 - length2)
Error: This expression has type int list
       but an expression was expected of type unit


let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 
then let pad1 = clone 0 (length2 - length1) in
else if length2 < length1
then let pad2 = clone 0 (length1 - length2) in
List.append pad1 l1
Error: Syntax error


let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 
then let pad1 = clone 0 (length2 - length1) in
else if length2 < length1
then let pad2 = clone 0 (length1 - length2) in
List.append pad1 l1
Error: Syntax error


let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 
then let pad1 = clone 0 (length2 - length1)
else if length2 < length1
then let pad2 = clone 0 (length1 - length2) in
List.append pad1 l1
Error: Syntax error


let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 
then let pad1 = clone 0 (length2 - length1)
else if length2 < length1
then let pad2 = clone 0 (length1 - length2) in
List.append pad1 l1
Error: Syntax error



hw3 removeZero

fix:
let rec removeZero l = match l with
| [] -> l
| x::l' -> 
if x=0 
then removeZero l'
else l

bad:
let rec removeZero l = match l with
| [] -> 0
| x::l' -> if x = 0
then List.fold_left (fun acc x -> acc+1) 0 l
Error: This expression has type int but an expression was expected of type
         unit



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = 
let (carry, acc) = a in
let (fact, dig)  = x in
let prod = mulByDigit dig l1 @ clone 0 carry in
let result = bigAdd prod acc in
(carry+1, result) in
let base =  (0, []) in
let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (carry, acc) = a in
let (fact, dig)  = x in
let prod = mulByDigit dig l1 @ clone 0 carry in
let result = bigAdd prod acc in
(i+1, result) in
let base =  in
let args = in
let (_, res) = List.fold_left f base args in
res
Error: Syntax error


let bigMul l1 l2 = 
let f a x = 
let (carry, acc) = a in
let (fact, dig)  = x in
let prod = mulByDigit dig l1 @ clone 0 carry in
let result = bigAdd prod acc in
(i+1, result) in
let base =  (0, []) in
let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value i
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value i



hw1 ???

fix:
List.tl [1;2;3]

bad:
tl [1;2;3]
Error: Unbound value tl



hw1 sumList

fix:
let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs)

bad:
let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList List.tl xs
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 digitsOfInt

fix:
let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt n)

bad:
let rec digitsOfInt n = if n<0 [] else match n with f::b -> f
Error: Syntax error


let rec digitsOfInt n = if n<0 then [] else match n with f::b -> f
Error: This pattern matches values of type 'a list
       but a pattern was expected which matches values of type int


let rec digitsOfInt n = if n<0 then [] else (n mod 10)::digitsOfInt n*10
Error: This expression has type int list
       but an expression was expected of type int


let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt n*10)
Error: This expression has type int list
       but an expression was expected of type int



hw1 sumList

fix:
let rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x))

bad:
let rec persistenceHelper q = let x = sumList q in
Error: Syntax error



hw1 additivePersistence

fix:
let _ = additivePersistence 9876

bad:
let _ = additivePersistence -9876
Error: This expression has type int -> int
       but an expression was expected of type int



hw1 additivePersistence

fix:
let _ = additivePersistence 9

bad:
let _ = additivePersistence -9876
Error: This expression has type int -> int
       but an expression was expected of type int



hw1 digitalRoot

fix:
let _ = digitalRoot (-45)

bad:
let _ = digitalRoot -4
Error: This expression has type int -> int
       but an expression was expected of type int
Error: Unbound value digits
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int -> int
       but an expression was expected of type int


let _ = digitalRoot -434
Error: This expression has type int -> int
       but an expression was expected of type int
Error: Unbound value digits
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int -> int
       but an expression was expected of type int



hw1 digitalRoot

fix:
let _ = digitalRoot 459

bad:
let _ = digitalRoot -459
Error: This expression has type int -> int
       but an expression was expected of type int
Error: Unbound value digits
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int -> int
       but an expression was expected of type int



hw1 ???

fix:
let poop = [1; 2; 3; 4]

match poop with h::t

bad:
let poop = [1; 2; 3; 4]
match poop with h::t
Error: Syntax error



hw1 palindrome

fix:
let palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true else false

bad:
let palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true esle false
Error: Syntax error



hw1 ???

fix:
let rec append list1 list2 = match list1 with [] -> list2 | a::b -> a::(append b list2)

bad:
let rec @ list1 list2 = match list1 with [] -> list2 | a::b -> a::(@ b list2)
Error: Syntax error


let rec append list1 list2 = match list1 with [] -> list2 | a::b -> a::(@ b list2)
Characters 71-72:
  let rec append list1 list2 = match list1 with [] -> list2 | a::b -> a::(@ b list2);;
                                                                         ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then seen else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen' then seen' else h::seen' in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: Unbound value seen'
Hint: Did you mean seen?



hw2 fixpoint

fix:
et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let fixpoint (f,b) = wwhile ((let func x = if (f x)= x then (x,false) else (f x,true) ),b)
Error: Unbound value wwhile


let fixpoint (f,b) = wwhile ((let func x = if (f x)= x then (x,false) else (f x,true)),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ((let func x = (if (f x)= x then (x,false) else (f x,true))),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ((let func x = (if (f x)= x then (x,false) else ((f x),true))),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ((let func x = (if ((f x)= x) then (x,false) else (f x,true))),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile (((if ((f x)= x) then (x,false) else (f x,true))),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ((let func x = (if ((f x)= x) then (x,false) else (f x,true)) in func x),b)
Error: Unbound value wwhile


let fixpoint (f,b) = wwhile ((let func x = (if ((f x)= x) then (x,false) else (f x,true)) in func),b)
Error: Unbound value wwhile



hw2 exprToString

fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

let _ = exprToString sampleExpr1

bad:
let rec exprToString e = match e with VarX -> "x"
| VarY -> "y"
| Sine ex -> "sin(pi*"^ exprToString ex ^")"
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times ex1 ex2 -> ex1^"*"^ex2
| Thresh ex1 ex2 ex3 ex4 -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"
Error: Syntax error


let rec exprToString e = match e with VarX -> "x"
| VarY -> "y"
| Sine ex -> "sin(pi*"^ exprToString ex ^")"
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> ex1^"*"^ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"
Error: Syntax error


let rec exprToString e = match e with VarX -> "x"
| VarY -> "y"
| Sine ex -> "sin(pi*"^ exprToString ex ^")"
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"
Error: This expression has type expr but an expression was expected of type
         string



hw2 eval

fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"

bad:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*. exprToString ex )
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*. eval ex )
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"
Error: This expression has type string but an expression was expected of type
         float


let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*. eval ex x y )
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"
Error: This expression has type expr but an expression was expected of type
         expr * 'a * 'a


let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval ex x y )
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"
Error: This expression has type expr but an expression was expected of type
         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)


let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval ex x y )
Error: This expression has type expr but an expression was expected of type
         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)


let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval ex x y )
Error: This expression has type expr but an expression was expected of type
         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)


let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval ex x y )
Error: This expression has type expr but an expression was expected of type
         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)


let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex x y) )
Error: This expression has type expr but an expression was expected of type
         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)


let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
Error: This expression has type expr
       This is not a function; it cannot be applied.



hw2 eval

fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)

)

bad:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"
Error: This expression has type string but an expression was expected of type
         float


let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((exprToString (ex1,x,y)+.exprToString (ex2,x,y))/.2)
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"
Error: This expression has type string but an expression was expected of type
         float


let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2)
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"
Error: This expression has type 'a * 'b * 'c
       but an expression was expected of type expr


let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/2)
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"
Error: This expression has type int but an expression was expected of type
         float


let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"
Error: This expression has type string but an expression was expected of type
         float


let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) -> (eval (ex1,x,y)<eval (ex2,x,y) ? eval (ex3,x,y): eval (ex4,x,y))
Error: This expression has type string but an expression was expected of type
         float


let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) -> (eval (ex1,x,y)<eval (ex2,x,y)? eval (ex3,x,y): eval (ex4,x,y))
Error: Syntax error


let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) -> (eval (ex1,x,y)<eval (ex2,x,y)?eval (ex3,x,y): eval (ex4,x,y))
Error: Syntax error


let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) -> (eval(ex1,x,y)<eval(ex2,x,y) ? eval(ex3,x,y):eval(ex4,x,y))
Error: Syntax error


let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y) then eval(ex3,x,y) else eval(ex4,x,y)
Error: Syntax error


)
Characters 283-284:
  | Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y) then eval(ex3,x,y) else eval(ex4,x,y);;
                                    ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  (eval(ex1,x,y)<eval(ex2,x,y)) ? eval(ex3,x,y):eval(ex4,x,y)
Error: Syntax error


)
Error: Syntax error


let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  (eval(ex1,x,y)<eval(ex2,x,y)) ? eval(ex3,x,y) : eval(ex4,x,y)
Error: Syntax error


)
Error: Syntax error



hw2 eval

fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr,0.5,0.2)

bad:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)
Error: Syntax error



hw2 eval

fix:
let _ = eval (sampleExpr,0.5,0.2)

bad:
let _ = eval (sampleExpr1,0.5,0.2)
Error: Unbound value sampleExpr
Hint: Did you mean sampleExpr1?
Error: Unbound value sampleExpr
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value sampleExpr
Hint: Did you mean sampleExpr1?



hw2 eval

fix:
 rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)

bad:
let _ = eval (sampleExpr,0.5,0.2)
Error: Unbound value l



hw2 build

fix:
let rec assoc (d,k,l) = match l with []-> d
| (str,key)::ls-> if k=str then key
else 
assoc (d,k,ls)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then seen else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) = match f b with (num,boo)-> 
if boo then wwhile (f,num)
else num

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) = wwhile ((let func x = (if ((f x)= x) then (x,false) else (f x,true)) in func),b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

type expr = 
VarX
| VarY
| Sine     of expr
| Cosine   of expr
| Average  of expr * expr
| Times    of expr * expr
| Thresh   of expr * expr * expr * expr

let rec exprToString e = match e with VarX -> "x"
| VarY -> "y"
| Sine ex -> "sin(pi*"^ exprToString ex ^")"
| Cosine ex -> "cos(pi*"^ exprToString ex ^")"
| Average (ex1,ex2) -> "(("^exprToString ex1^"+"^exprToString ex2^")/2)"
| Times (ex1,ex2) -> exprToString ex1^"*"^exprToString ex2
| Thresh (ex1,ex2,ex3,ex4) -> "("^exprToString ex1^"<"^exprToString ex2^"?"^exprToString ex3^":"^ exprToString ex4^")"

let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

let _ = exprToString sampleExpr1

let buildX()                       = VarX

let buildY()                       = VarY

let buildSine(e)                   = Sine(e)

let buildCosine(e)                 = Cosine(e)

let buildAverage(e1,e2)            = Average(e1,e2)

let buildTimes(e1,e2)              = Times(e1,e2)

let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)

let pi = 4.0 *. atan 1.0

let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)

let sampleExpr =
buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(
buildX()),buildTimes(buildCosine (buildCosine (buildAverage
(buildTimes (buildY(),buildY()),buildCosine (buildX())))),
buildCosine (buildTimes (buildSine (buildCosine
(buildY())),buildAverage (buildSine (buildX()), buildTimes
(buildX(),buildX()))))))),buildY())))

let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr,0.5,0.2)

let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv

let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))

let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))

bad:
let rec build (rand, depth) = if depth= 0 then (let case = rand(0,1)) 
else let case = rand(0,6)in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))
Error: Syntax error


let rec build (rand, depth) = if depth= 0 then (let case = rand(0,1)) else let case = rand(0,6)in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))
Error: Syntax error: operator expected.


let rec build (rand, depth) = (if depth= 0 then (let case = rand(0,1)) else let case = rand(0,6)) in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))
Error: Syntax error: operator expected.


let rec build (rand, depth) = if depth= 0 then let case = rand(0,1) in  else let case = rand(0,6) in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))
Error: Syntax error: operator expected.


let rec build (rand, depth) = if depth= 0 then (let case = rand(0,1) in)  else let case = rand(0,6) in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))
Error: Syntax error


let rec build (rand, depth) = let case = 0 in if depth= 0 then ( case = rand(0,1) in
Error: Syntax error: operator expected.


)  else let case = rand(0,6) in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))
Characters 63-64:
  let rec build (rand, depth) = let case = 0 in if depth= 0 then ( case = rand(0,1) in;;
                                                                 ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let rec build (rand, depth) = let case = 0 in if depth= 0 then case = rand(0,1) in  else let case = rand(0,6) in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))
Error: Syntax error


let rec build (rand, depth) = let case = 0 in if depth= 0 then case = rand(0,1)  else let case = rand(0,6) in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))
Error: Syntax error


let rec build (rand, depth) = let case = 0 in if depth= 0 then case = rand(0,1)  else let case = rand(0,6) in
match case with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))
Error: This expression has type unit -> expr
       but an expression was expected of type bool


let rec build (rand, depth) = if depth= 0 then let case = rand(0,1) else let case = rand(0,6) in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))
Error: This expression has type expr but an expression was expected of type
         bool


let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))
Error: Syntax error


let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in
match case with
| 0 -> buildX
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))
Error: This expression has type unit -> expr
       but an expression was expected of type unit



hw2 build

fix:
let rec build (rand, depth) = let case = rand(0,6)

let if depth= 0 then let case = rand(0,1) in
match case with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))

bad:
let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in
match case with
| 0 -> buildX()
| 1 -> buildY
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))
Error: This expression has type unit -> expr
       but an expression was expected of type unit


let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in
match case with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))
Error: This expression has type expr but an expression was expected of type
         unit


let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in
match case with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))
Error: This expression has type expr but an expression was expected of type
         unit


let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in
match case with
| 0 -> VarX
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))
Error: This expression has type expr but an expression was expected of type
         unit


let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in
match case with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))
Error: This variant expression is expected to have type unit
       The constructor VarX does not belong to type unit


let rec build (rand, depth) = let case = rand(0,6) in 
match case with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))
Error: This expression has type expr but an expression was expected of type
         unit



hw2 build

fix:
let rec build (rand, depth) = if depth=0 then(
match rand(0,5) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))
else
match rand(0,0) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = let case = rand(0,6)
Error: Syntax error


let if depth= 0 then let case = rand(0,1) in
match case with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))
Error: Syntax error


let rec build (rand, depth) = if depth=0 then(
match rand(0,6) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))
else
match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()
Error: Syntax error



hw2 eval

fix:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)
| FiboPlus (ex1,ex2,ex3,ex4,ex5) -> ((eval (ex1,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)+.eval (ex4,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)+.eval (ex4,x,y)+.eval (ex5,x,y)))
| TheThing (ex1,ex2,ex3) -> ((eval (ex1,x,y)*.sin(pi*. eval (ex2,x,y))*.cos(pi*. eval (ex3,x,y)))/.2.)

bad:
let rec eval (e,x,y) = match e with VarX -> x
| VarY -> y
| Sine ex -> sin(pi*.eval (ex,x,y) )
| Cosine ex -> cos(pi*. eval (ex,x,y) )
| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)
| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)
| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)
| FiboPlus (ex1,ex2,ex3,ex4,ex5) -> ((eval (ex1,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)+.eval (ex4,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)+.eval (ex4,x,y)+.eval (ex5,x,y)))
| TheThing (ex1,ex2,ex3) -> ((eval (ex1,x,y)*.sin(pi*. eval (ex2,x,y))*.cos(pi*. eval (ex3,x,y)))/.2.)
Error: This expression has type float but an expression was expected of type
         int



hw2 build

fix:
let rec build (rand, depth) = if depth>0 then(
match rand(0,8) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))
| 7 -> buildSixtyNine(build (rand,depth-1))
| 8 -> buildTheThing(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))
else
match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = if depth>0 then(
match rand(0,8) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))
| 7 -> buildSixtyNine(build (rand,depth-1))
| 8 -> buildTheThing(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))
else
match rand(0,1) with
| 0 -> buildX()
| 1 -> buildY()
Error: This expression has type expr but an expression was expected of type
         expr * expr



hw3 pipe

fix:
let pipe fs = 
let f a x = x(a) in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x(a) in
let base = 'a in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = x(a) in
let base = fun fs->fs in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x(fs) in
let base = a in
List.fold_left f base fs
Error: Unbound value a


let pipe fs = 
let f a x = x(fs) in
let base = _ in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x(fs) in
let base = 'a->'a in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x(fs) in
let base = 0 in
List.fold_left f base fs
Error: This expression has type 'a but an expression was expected of type
         ('a -> int) list
       The type variable 'a occurs inside ('a -> int) list


let pipe fs = 
let f a x = x(fs) in
let base = fs in
List.fold_left f base fs
Error: This expression has type 'a but an expression was expected of type
         ('a -> 'a) list
       The type variable 'a occurs inside ('a -> 'a) list


let pipe fs = 
let f a x = x(fs) in
let base = a in
List.fold_left f base fs
Error: Unbound value a


let pipe fs = 
let f a x = a+x(fs) in
let base = a in
List.fold_left f base fs
Error: Unbound value a


let pipe fs = 
let f a x = x(a) in
let base =  in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x(a) in
let base =  a'-> fs in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x(a) in
let base =  'a-> fs in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x(a) in
let base =  'a-> fs in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x(a) in
let base =  'a -> fs in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x(a) in
let base = fs in
List.fold_left f base fs
Error: This expression has type 'a but an expression was expected of type
         ('a -> 'a) list
       The type variable 'a occurs inside ('a -> 'a) list


let pipe fs = 
let f a x = x(a) in
let base = fs->fs in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x(a) in
let base = fs(fs) in
List.fold_left f base fs
Error: This expression has type 'a -> 'b
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x =  x in
let base = fun q->q in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  in
let base = fun q->q in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x =  x(a) in
let base = (fun q->q) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  a(x) in
let base = (fun q->q) in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x =  x(a) in
let base = (fun q->q) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  a(x) in
let base = (fun q->q) in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = x(a) in
let base = (fun q->q) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  f x(a) in
let base = (fun q->q) in
List.fold_left f base fs
Error: Unbound value f



hw3 pipe

fix:
let pipe fs = 
let f a x = fun w -> x(a) in
let base = (fun q->q) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> a in
let base = (fun q->q) in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'c -> 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'c -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x = fun w -> x(a) in
let base = (fun a->a) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun w -> x(a) in
let base = (fun a->q) in
List.fold_left f base fs
Error: Unbound value q



hw3 pipe

fix:
let pipe fs = 
let f a x = x a  in
let base = fun a -> a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = (fun a->a) in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = fun a -> a x in
let base = (fun a->a) in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = fun a -> a x in
let base = (fun 'a->'a) in
List.fold_left f base fs
Error: Syntax error: operator expected.


let pipe fs = 
let f a x =  match x with x:xs in
let base = (fun a->a) in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x =  match x with x:fs in
let base = (fun a->a) in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x =  match fs with x::xs in
let base = (fun a->a) in
List.fold_left f base fs
Error: Syntax error: pattern expected.


let pipe fs = 
let f a x = x a  in
let base = a in
List.fold_left f base fs
Error: Unbound value a


let pipe fs = 
let f a x = x a  in
let base = fun s -> a s in
List.fold_left f base fs
Error: Unbound value a



hw3 pipe

fix:
let pipe fs = 
let f a x = fun w -> x(a(w))   in
let base = fun a -> a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a(x)   in
let base = fun a -> a in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = a x   in
let base = fun a -> a in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = a x   in
let base =  a in
List.fold_left f base fs
Error: Unbound value a


let pipe fs = 
let f a x = a x   in
let base =  x in
List.fold_left f base fs
Error: Unbound value x



hw3 stringOfList

fix:
let stringOfList f l = "["^(sepConcat "; " (List.map f l))^"]"

bad:
let stringOfList f l = "["^(sepConcat "; "(List.map f "" l))^"]"
Error: This function has type ('a -> 'b) -> 'a list -> 'b list
       It is applied to too many arguments; maybe you forgot a `;'.


let stringOfList f l = "["^(sepConcat "; " (List.map f "" l))^"]"
Error: This function has type ('a -> 'b) -> 'a list -> 'b list
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 clone

fix:
let rec clone x n = if n<1 then [] 
else 
let rec helper acc f x = match x with 
| 0 -> acc
| _ -> helper (f::acc) f (x-1)
in helper [] x n

bad:
let rec clone x n = if n<1 then return [] 
else 
let rec helper acc f x = match x with 
| 0 -> acc
| _ -> helper (f::acc) f x-1
in helper [] x n
Error: Unbound value return


let rec clone x n = if n<1 then [] 
else 
let rec helper acc f x = match x with 
| 0 -> acc
| _ -> helper (f::acc) f x-1
in helper [] x n
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 padZero

fix:
let padZero l1 l2 = let x = (List.length l1 - List.length l2) in 
if x!=0 then
if x<0 then
(((clone 0 (abs x))@l1),l2)
else 
(l1,((clone 0 (abs x))@l2))
else 
(l1,l2)

bad:
let padZero l1 l2 = let x = (List.length l1 - List.length l2) in 
if x then
if x<0 then
(((clone 0 (abs x))@l1),l2)
else 
(l1,((clone 0 (abs x))@l2))
else 
(l1,l2)
Error: This expression has type int but an expression was expected of type
         bool



hw3 removeZero

fix:
let rec removeZero l = match l with
| x::xs -> if x=0 then removeZero xs
else xs
| _ -> l

bad:
let rec removeZero l = match l with
| x:xs -> if x=0 then removeZero xs
else xs
| _ -> l
Error: Syntax error



hw3 ???

fix:
let _ =  18 mod 10

bad:
let _ = mod 18 10
Error: Syntax error



hw3 clone

fix:
let _ =List.combine (clone 7 7)(List.combine [0;0;0;1;0;0;2][0;0;0;1;0;0;2])

bad:
let _ =List.combine ((clone 7 7)(List.combine [0;0;0;1;0;0;2][0;0;0;1;0;0;2]) )
Error: This expression has type int list
       This is not a function; it cannot be applied.



hw3 bigAdd

fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = fun w -> x(a(w))   in
let base = fun a -> a in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = "["^(sepConcat "; " (List.map f l))^"]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n = if n<1 then [] 
else 
let rec helper acc f x = match x with 
| 0 -> acc
| _ -> helper (f::acc) f (x-1)
in helper [] x n

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let padZero l1 l2 = let x = (List.length l1 - List.length l2) in 
if x!=0 then
if x<0 then
(((clone 0 (abs x))@l1),l2)
else 
(l1,((clone 0 (abs x))@l2))
else 
(l1,l2)

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

let rec removeZero l = match l with
| x::xs -> if x=0 then removeZero xs
else l
| _ -> l

let _ = removeZero [0;0;0;1;0;0;2]

let _ = removeZero [9;9]

let _ = removeZero [0;0;0;0]

let _ =List.combine (clone 7 7)(List.combine [0;0;0;1;0;0;2][0;0;0;1;0;0;2])

let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d,(b,c)) -> let sum= b+c in 
if sum<10 then 
match a with 
| [] -> sum::a
| x'::xs' -> 
if (x'=(-1)) then
if (sum=9) then
-1::0::xs'
else
(sum+1)::xs'
else 
sum::a
else
match a with 
| [] -> -1::(sum mod 10)::a
| x'::xs' -> 
if (x'=(-1)) then
-1::(sum mod 10)::a
else 
-1::(sum mod 10)::a

in
let base = [] in
let args = List.combine (clone (List.length l1) (List.length l1)) (List.combine (List.rev l1) (List.rev l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d,(b,c)) -> let sum= b+c in 
if sum<10 then 
match a with 
| [] -> sum::a
| x'::xs' -> 
if (x'=(-1)) then
if (sum=9) then
-1::0::xs'
else
(sum+1)::xs'
else 
sum::a
else
match a with 
| [] -> -1::(sum mod 10)::a
| x'::xs' -> 
if (x'=(-1)) then
-1::(sum mod 10)::a
else 
-1::(sum mod 10)::a

in
let base = [] in
let args = List.combine (clone (List.length l1) (List.length l1)) (List.combine (List.rev l1) (List.rev l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list
       but an expression was expected of type 'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d,(b,c)) -> let sum= b+c in 
if sum<10 then 
match a with 
| [] -> sum::a
| x'::xs' -> 
if (x'=(-1)) then
if (sum=9) then
-1::0::xs'
else
(sum+1)::xs'
else 
sum::a
else
match a with 
| [] -> -1::(sum mod 10)::a
| x'::xs' -> 
if (x'=(-1)) then
-1::(sum mod 10)::a
else 
-1::(sum mod 10)::a

in
let base = [] in
let args = List.combine (clone (List.length l1) (List.length l1)) (List.combine (List.rev l1) (List.rev l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list
       but an expression was expected of type 'a * 'b



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (b,c) -> let sum= b+c in 
if sum<10 then 
match a with 
| (len,[]) -> (len,[sum])
| (len,x'::xs') -> 
if (x'=(-1)) then
if (sum=9) then
(len,-1::0::xs')
else
(len,(sum+1)::xs')
else 
(len,sum::x'::xs')
else
match a with 
| (len,[]) -> (len,-1::[(sum mod 10)])
| (len,x'::xs') -> 
if (x'=(-1)) then
(len,-1::((sum mod 10)+1)::xs')
else 
(len,-1::(sum mod 10)::x'::xs')

in
let base = (List.length l1,[]) in
let args = (List.combine (List.rev l1) (List.rev l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d,(b,c)) -> let sum= b+c in 
if sum<10 then 
match a with 
| [] -> sum::a
| x'::xs' -> 
if (x'=(-1)) then
if (sum=9) then
-1::0::xs'
else
(sum+1)::xs'
else 
sum::a
else
match a with 
| [] -> -1::(sum mod 10)::a
| x'::xs' -> 
if (x'=(-1)) then
-1::(sum mod 10)::a
else 
-1::(sum mod 10)::a

in
let base = (List.length l1,[]) in
let args = List.combine (clone (List.length l1) (List.length l1)) (List.combine (List.rev l1) (List.rev l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int * 'a list
       but an expression was expected of type int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (b,c) -> let sum= b+c in 
if sum<10 then 
match a with 
| (len,[]) -> (len,[sum])
| (len,x'::xs') -> 
if (x'=(-1)) then
if (sum=9) then
(len,-1::0::xs')
else
(len,(sum+1)::xs')
else 
(len,sum::a)
else
match a with 
| (len,[]) -> (len,-1::[(sum mod 10)])
| (len,x'::xs') -> 
if (x'=(-1)) then
-1::((sum mod 10)+1)::a
else 
(len,-1::(sum mod 10)::x'::xs')

in
let base = (List.length l1,[]) in
let args = (List.combine (List.rev l1) (List.rev l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * int list
       but an expression was expected of type int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (b,c) -> let sum= b+c in 
if sum<10 then 
match a with 
| (len,[]) -> (len,[sum])
| (len,x'::xs') -> 
if (x'=(-1)) then
if (sum=9) then
(len,-1::0::xs')
else
(len,(sum+1)::xs')
else 
(len,sum::x'::xs')
else
match a with 
| (len,[]) -> (len,-1::[(sum mod 10)])
| (len,x'::xs') -> 
if (x'=(-1)) then
-1::((sum mod 10)+1)::a
else 
(len,-1::(sum mod 10)::x'::xs')

in
let base = (List.length l1,[]) in
let args = (List.combine (List.rev l1) (List.rev l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type 'b * int list



hw3 mulByDigit

fix:
let rec mulByDigit i l = let lre = List.rev l in
let rec helper carry accum lrev =  
match lrev with
| [] -> removeZero accum
| x::xs -> 
if(carry=1) then
match accum with x1'::xs' -> 
let num = (x*i)+ x1' in
if(num<10) then
helper 0 (num::xs') xs
else
helper 1 (((num/10) mod 10)::(num mod 10)::xs') xs
else
let num = (x*i) in
if(num<10) then
helper 0 (num::accum) xs
else
helper 1 (((num/10) mod 10)::(num mod 10)::accum) xs
in helper 0 [] lre

bad:
let rec mulByDigit i l = let lrev = List.rev l in
let rec helper carry accum lrev =  
match lrev with
| [] -> removeZero accum
| x::xs -> 
if(carry=1) then
match accum with x1'::xs' -> 
let num = (x*i)+ x1' in
if(num<10) then
helper 0 num::xs' xs
else
helper 1 ((num/10) mod 10)::(num mod 10)::xs' xs
else
let num = (x*i) in
if(num<10) then
helper 0 num::accum xs
else
helper 1 ((num/10) mod 10)::(num mod 10)::accum::xs
Error: Syntax error


let rec mulByDigit i l = let lre = List.rev l in
let rec helper carry accum lrev =  
match lrev with
| [] -> removeZero accum
| x::xs -> 
if(carry=1) then
match accum with x1'::xs' -> 
let num = (x*i)+ x1' in
if(num<10) then
helper 0 num::xs' xs
else
helper 1 ((num/10) mod 10)::(num mod 10)::xs' xs
else
let num = (x*i) in
if(num<10) then
helper 0 num::accum xs
else
helper 1 ((num/10) mod 10)::(num mod 10)::accum xs
in helper 0 [] lre
Error: This expression has type int but an expression was expected of type
         int list


let rec mulByDigit i l = let lre = List.rev l in
let rec helper carry accum lrev =  
match lrev with
| [] -> removeZero accum
| x::xs -> 
if(carry=1) then
match accum with x1'::xs' -> 
let num = (x*i)+ x1' in
if(num<10) then
helper 0 num::xs' xs
else
helper 1 ((num/10) mod 10)::(num mod 10)::xs' xs
else
let num = (x*i) in
if(num<10) then
helper 0 num::accum xs
else
helper 1 ((num/10) mod 10)::(num mod 10)::accum xs
in helper 0 [] lre
Error: This expression has type int but an expression was expected of type
         int list


let rec mulByDigit i l = let lre = List.rev l in
let rec helper carry accum lrev =  
match lrev with
| [] -> removeZero accum
| x::xs -> 
if(carry=1) then
match accum with x1'::xs' -> 
let num = (x*i)+ x1' in
if(num<10) then
helper 0 (num::xs') xs
else
helper 1 ((num/10) mod 10)::(num mod 10)::xs' xs
else
let num = (x*i) in
if(num<10) then
helper 0 num::accum xs
else
helper 1 ((num/10) mod 10)::(num mod 10)::accum xs
in helper 0 [] lre
Error: This expression has type int but an expression was expected of type
         int list



hw1 digitsOfInt

fix:
let _ = digitsOfInt 0

bad:
let_ = digitsOfInt 0
Error: Unbound value let_



hw1 additivePersistence

fix:
let rec additivePersistence n = 
let newList = digitsOfInt n in 1 + 2

bad:
let rec additivePersistence n = 
let newList = digitsOfInt n
Error: Syntax error



hw1 digitalRoot

fix:
let _ = digitalRoot 9876

bad:
let _ = digitalRoot2 9876
Error: Unbound value digitalRoot2
Hint: Did you mean digitalRoot?
Error: Unbound value digitalRoot2
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value digitalRoot2
Hint: Did you mean digitalRoot?



hw1 additivePersistence

fix:
let rec additivePersistence2 n = 
let newList = digitsOfInt n in
let sum = sumList newList in 
let count = 2 in
if(sum < 10) then count
else 1 + additivePersistence2 sum

bad:
let rec additivePersistence2 n = 
let newList = digitsOfInt n in
let sum = sumList newList in 
let count 2 in = 
if(sum < 10) then count
else 1 + additivePersistence2 sum
Error: Syntax error



hw2 wwhile

fix:
let rec assoc (d,k,l) = failwith "to be written"

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if(List.mem h seen = false) then h::seen 
else seen in  (* any way to not use else statement? *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) = 
let (b', c') = f b in
if c' = true then wwhile (f b')
else c'

bad:
let rec wwhile (f,b) = 
let (b', c') = f b in
if c' = true then wwhile (f b')
else c'
Error: This expression has type 'a * bool
       but an expression was expected of type ('a -> 'a * bool) * 'a



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((f b),b)

bad:
(
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Characters 0-1:
  (
  ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw2 fixpoint

fix:
let rec wwhile (f,b) = 
let (b', c') = f b in
if c' = true then wwhile (f,b')
else b'

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) = wwhile ((f b),b)

bad:
let fixpoint (f,b) = wwhile ((f (neg b)),b)
Error: Unbound value neg


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: This expression has type int -> int
       but an expression was expected of type int -> int -> int * bool
       Type int is not compatible with type int -> int * bool 



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ( (f b),b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: This expression has type int -> int
       but an expression was expected of type bool -> bool -> bool * bool
       Type int is not compatible with type bool 



hw2 ???

fix:
let f x = let xx = x*x*x in (xx, xx < 100)

bad:
(xx, xx < 100)
Error: Unbound value xx


let xx = x*x*x in (xx, xx < 100)
Error: Unbound value x



hw2 eval

fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> sin(eval(e1,x,y))

eval(Sine(VarY), 11.0 ,0)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> sin(pi * eval(e1,x,y))
Error: This expression has type float but an expression was expected of type
         int


eval(Sine(VarY), 11.0 ,0)
Error: This expression has type int but an expression was expected of type
         float



hw2 eval

fix:
let _ = eval (Times(Sine(VarX),Cosine(Average(VarX,VarY))), 0.5, 0.2)

bad:
let _ = eval ((Times(Sine(VarX),Cosine(Average(VarX,VarY))))), 0.5, 0.2
Error: This expression has type expr but an expression was expected of type
         expr * float * float


)
Error: Syntax error


)
Error: Syntax error



hw2 eval

fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> begin let ans = sin(pi *. eval(e1,x,y)); Printf.printf "sine is "; end
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end

let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.printf "sine is "
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end
Error: This expression has type unit but an expression was expected of type
         float


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.sprintf "sine is "
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end
Error: This expression has type string but an expression was expected of type
         float


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.printf "sine is "
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end
Error: This expression has type unit but an expression was expected of type
         float



hw2 eval

fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> sin(pi *. eval(e1,x,y))
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end

let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr1,0.5,0.2)

let _ = eval ( Thresh(  VarX,  VarY,  VarX,  (Times(Sine(VarX),Cosine(Average(VarX,VarY))))), 0.5, 0.2)

let _ = eval (Times( Sine(VarX),Cosine(Average(VarX,VarY)) ), 0.5, 0.2)

let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)); Printf.printf "sine is "; 
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end
Error: Syntax error


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> if(1) then begin let ans = sin(pi *. eval(e1,x,y)); Printf.printf "sine is "; end
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end
Error: Syntax error


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> if(1) then begin sin(pi *. eval(e1,x,y)); Printf.printf "sine is "; end
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end
Error: This expression has type int but an expression was expected of type
         bool


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> if(true) then begin let ans = sin(pi *. eval(e1,x,y)); Printf.printf "sine is "; end
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end
Error: Syntax error


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> if(true) then let ans = sin(pi *. eval(e1,x,y)); Printf.printf "sine is ";
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end
Error: Syntax error


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> if(true) then begin let ans = sin(pi *. eval(e1,x,y)); Printf.printf "sine is "; end else 1.0
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then 
begin  
Printf.printf "hi";
eval(a_less, x, y);
end
else 
begin
Printf.printf "bye";
eval(b_less, x, y);
end
Error: Syntax error



hw2 build

fix:
let _ = build(makeRand(2,3), 2)

bad:
let _ = build(rand(2,3), 2)
Error: Unbound value rand
Hint: Did you mean land?



hw2 build

fix:
let rec assoc (d,k,l) = match l with
|[] -> d
|(ki, vi) :: t -> 
if ki = k then vi
else assoc (d, k, t)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
|[] -> seen
| h::t -> 
let seen' = if(List.mem h seen = false) then h::seen 
else seen in  (* any way to not use else statement? *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) = 
let (b', c') = f b in
if c' = true then wwhile (f,b')
else b'

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) = wwhile ((failwith "to be written"),b)

type expr = 
VarX
| VarY
| Sine     of expr
| Cosine   of expr
| Average  of expr * expr
| Times    of expr * expr
| Thresh   of expr * expr * expr * expr

let rec exprToString e = match e with 
| VarX -> "x"
| VarY ->  "y"
| Sine (e1) -> "sin(pi*" ^ exprToString e1 ^ ")"
| Cosine (e1) -> "cos(pi*" ^ exprToString e1 ^ ")"
| Average (e1, e2) -> "((" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ ")/2)"
| Times (e1, e2) -> exprToString e1 ^ "*" ^exprToString e2
|Thresh (e1, e2, e3, e4) -> "(" ^ exprToString e1 ^ "<" ^ exprToString e2 
^ "?" ^ exprToString e3 ^ ":" ^ exprToString e4 ^ ")"

let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

let _ = exprToString sampleExpr1

let buildX()                       = VarX

let buildY()                       = VarY

let buildSine(e)                   = Sine(e)

let buildCosine(e)                 = Cosine(e)

let buildAverage(e1,e2)            = Average(e1,e2)

let buildTimes(e1,e2)              = Times(e1,e2)

let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)

let pi = 4.0 *. atan 1.0

let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e1) -> sin(pi *. eval(e1,x,y))
| Cosine(e1) -> cos(pi *. eval(e1, x, y))
| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)
| Thresh(a, b, a_less, b_less) -> 
if(eval(a, x, y) < eval(b, x, y)) then eval(a_less, x, y)
else eval(b_less, x, y)

let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv

let sampleExpr =
buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(
buildX()),buildTimes(buildCosine (buildCosine (buildAverage
(buildTimes (buildY(),buildY()),buildCosine (buildX())))),
buildCosine (buildTimes (buildSine (buildCosine
(buildY())),buildAverage (buildSine (buildX()), buildTimes
(buildX(),buildX()))))))),buildY())))

let _ = eval (sampleExpr,0.5,0.2)

let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))

let rec build (rand, depth) = match rand(1,3) with
|1 -> 1
|2 -> 2
|3->3
|_ -> 4

let g1 () = failwith "to be implemented"

let g2 () = failwith "to be implemented"

let g3 () = failwith "to be implemented"

let c1 () = failwith "to be implemented"

let c2 () = failwith "to be implemented"

let c3 () = failwith "to be implemented"

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let _ = let rand = makeRand(1,3) in 
let x = rand(1,3) in build(rand, 1)

bad:
let _ = let rand = makeRand(1,3) in 
let x = rand(1,3) in build(rand 1)
Error: This expression has type int but an expression was expected of type
         int * int


let _ = let rand = makeRand(1,3) in 
let x = rand(1,3) in build(rand, 1)
Error: This expression has type int * int -> int
       but an expression was expected of type int



hw2 build

fix:
let rec build (rand, depth) = match (rand,depth)  with
|(_,0) -> if((rand mod 2) == 0) then buildY()
else buildX()
|(_,_) -> buildX()

bad:
let rec build (rand, depth) = match (r,d)  with
|(_,0) -> if((r mod 2) == 0) then buildY()
else buildX()
|(_,_) -> buildX()
Error: Unbound value r


let rec build (rand, depth) = match (rand,depth)  with
|(_,0) -> if((r mod 2) == 0) then buildY()
else buildX()
|(_,_) -> buildX()
Error: Unbound value r



hw2 build

fix:
let rec build (rand, depth) = match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )

bad:
let rec build (rand, depth) = match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
| (_, 2) -> buildTimes( (build(rand*3), depth - 1), build((rand +1), depth - 1) )
| (_, _) ->
if(depth > 10 && ((rand mod 7) == 0)) then 
buildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))
else if (rand mod 5 == 0) then
build(rand + 3 ,depth -1)
else 
build(rand + 1, depth - 1)
Error: This expression has type 'a * 'b
       but an expression was expected of type expr


let rec build (rand, depth) = match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
| (_, 2) -> buildTimes( (build(rand), depth - 1), build((rand +1), depth - 1) )
| (_, _) ->
if(depth > 10 && ((rand mod 7) == 0)) then 
buildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))
else if (rand mod 5 == 0) then
build(rand + 3 ,depth -1)
else 
build(rand + 1, depth - 1)
Error: This expression has type 'a * 'b
       but an expression was expected of type expr


let rec build (rand, depth) = match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
(*| (_, 2) -> buildTimes( (build(rand), depth - 1), build((rand +1), depth - 1) )*)
| (_, _) ->
if(depth > 10 && ((rand mod 7) == 0)) then 
buildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))
else if (rand mod 5 == 0) then
build(rand + 3 ,depth -1)
else 
build(rand + 1, depth - 1)
Error: This expression has type expr but an expression was expected of type
         expr * expr


let rec build (rand, depth) = match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
| (_, 2) -> buildTimes( (build(rand), depth - 1), build((rand +1), depth - 1) )
Error: This expression has type 'a * 'b
       but an expression was expected of type expr



hw2 build

fix:
let rec build (rand, depth) = match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )

| (_, _) ->
if(depth > 10 && ((rand mod 7) == 0)) then 
buildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), build(rand, depth - 1))
else 
build(rand + 1, depth - 1)

bad:
let rec build (rand, depth) = match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )

| (_, _) ->
if(depth > 10 && ((rand mod 7) == 0)) then 
buildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))
else if (rand mod 5 == 0) then
build(rand + 3 ,depth -1)
else 
build(rand + 1, depth - 1)
Error: This expression has type expr but an expression was expected of type
         expr * expr


let rec build (rand, depth) = match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )

| (_, _) ->
if(depth > 10 && ((rand mod 7) == 0)) then 
buildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), 
build(rand, depth - 1);
else if (rand mod 5 == 0) then
build(rand + 3 ,depth -1)
else 
build(rand + 1, depth - 1)
Characters 380-381:
  buildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), 
            ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let rec build (rand, depth) = match (rand,depth)  with
| (_,0) -> 
if((rand mod 2) == 0) then buildY()
else buildX()
| (_,1) ->
if( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )
else buildCosine(build(rand, depth - 1))
| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )

| (_, _) ->
if(depth > 10 && ((rand mod 7) == 0)) then 
buildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), build(rand, depth - 1)); 
else 
build(rand + 1, depth - 1)
Error: Syntax error



hw2 ???

fix:
let g = makeRand(1, 3)

bad:
let g = makeRand(seed1, seed2)
Error: Unbound value seed1



hw2 build

fix:
let rec build (rand, depth) = match depth with 
| 0 -> buildX() 
| 1 ->  let x = rand(1, 2) in 
if (x > 1) then buildCosine( build(rand, depth - 1) )
else buildSine( build(rand, depth - 1))
| _ -> buildCosine( build(rand, depth - 1) )

bad:
let rec build (rand, depth) = match depth with 
| 0 -> buildX() 
| 1 ->  let x = rand(_, _) in 
if (x > 1) then buildCosine( build(rand, depth - 1) )
else buildSine( build(rand, depth - 1))
| _ -> buildCosine( build(rand, depth - 1) )
Error: Syntax error: operator expected.



hw2 build

fix:
let rec build (rand, depth) = match depth with
| 0 -> let z = 2 in rand(1,z)

bad:
let rec build (rand, depth) = match rand with
| (x* y-> z) -> buildX()
Characters 48-49:
  | (x* y-> z) -> buildX();;
    ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let rec build (rand, depth) = match depth with |
| 0 -> let z = 2 in rand
Error: Syntax error


let rec build (rand, depth) = match depth with |
| 0 -> let z = 2 in rand(1,z)
Error: Syntax error



hw2 build

fix:
let rec build (rand, depth) = match depth with
| 0 -> let z = rand in
if( z > 1) then buildX()
else buildY()

bad:
let rec build (rand, depth) = match depth with
| 0 -> let z = rand in rand in 
if( z > 1) then buildX()
else buildY()
Error: Unbound value z



hw2 build

fix:
let rec build (rand, depth) = match depth with
| 0 -> let num = rand(1,5) in 
if( num > 3) then buildSine( build( rand, depth - 1))
else buildCosine( build(rand, depth - 1))
| _ -> buildX()

bad:
let rec build (rand, depth) = match depth with |
| 0 -> let num = rand(1,5) in 
if( num > 3) then buildSine( build( rand, depth - 1))
else buildCosine( build(rand, depth - 1))
Error: Syntax error



hw2 build

fix:
let rec build (rand, depth) = match depth with
| 0 -> let num = rand(1,5) in 
if( num > 3) then buildX()
else buildY()
| 1 -> let num = rand(1, 10) in 
if( num mod 2 = 0) then buildSine( build(rand, depth - 1) )
else buildCosine( build(rand, depth - 1) )
| 2 -> let num = rand(1, 3) in
if( num mod 2 == 0) then
buildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )
else 
buildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )
| 3 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), 
build(rand, depth - 1))

bad:
let rec build (rand, depth) = match depth with
| 0 -> let num = rand(1,5) in 
if( num > 3) then buildX()
else buildY()
| 1 -> let num = rand(1, 10) in 
if( num mod 2 = 0) then buildSine( build(rand, depth - 1) )
else buildCosine( build(rand, depth - 1) )
| 2 -> let num = rand(1, 3) in
if( num mod 2 == 0) then
buildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )
else 
buildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )
| 3 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)))
Error: This expression has type expr but an expression was expected of type
         expr * expr



hw2 build

fix:
let rec build (rand, depth) = match depth with
| 0 -> let num = rand(1,10) in 
if( num > 3) then buildX()
else buildY()

| 1 -> let num = rand(1, 10) in 
if( num mod 2 = 0) then buildSine( build(rand, depth - 1) )
else buildCosine( build(rand, depth - 1) )

| 2 -> let num = rand(1, 30) in
if( num mod 2 == 0) then
buildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )
else 
buildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )

| 3 -> let num = rand (1, 50) in 
if (num mod 2 = 0) then 
buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), 
buildCosine(build(rand, depth - 1)))
else 
buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), 
buildSine(build(rand, depth - 1)))

| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))

| 5 -> let num = rand(1, 10) in
if(num = 1) then 
buildSine(buildSine(buildSine( build(rand, depth - 1))))
else if(num = 2) then 
buildCosine(buildCosine(buildCosine( build(rand, depth - 1))))
else if (num = 3) then
buildSine(buildCosine( build(rand, depth - 1)))
else buildCosine(buildSine( build(rand, depth - 1)))
| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))

| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) 

| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), 
buildSine(build(rand, depth - 1)))


| _ -> let num = rand(1, 3) in build(rand, depth - num )

bad:
let rec build (rand, depth) = match depth with
| 0 -> let num = rand(1,10) in 
if( num > 3) then buildX()
else buildY()

| 1 -> let num = rand(1, 10) in 
if( num mod 2 = 0) then buildSine( build(rand, depth - 1) )
else buildCosine( build(rand, depth - 1) )

| 2 -> let num = rand(1, 30) in
if( num mod 2 == 0) then
buildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )
else 
buildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )

| 3 -> let num = rand (1, 50) in 
if (num mod 2 = 0) then 
buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), 
buildCosine(build(rand, depth - 1)))
else 
buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), 
buildSine(build(rand, depth - 1)))

| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))

| 5 -> let num = rand(1, 10) in
if(num = 1) then 
buildSine(buildSine(buildSine( build(rand, depth - 1))))
else if(num = 2) then 
buildCosine(buildCosine(buildCosine( build(rand, depth - 1))))
else if (num = 3) then
buildSine(buildCosine( build(rand, depth - 1)))
else buildCosine(buildSine( build(rand, depth - 1)))
| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))

| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) 

| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), 
buildSine(build(rand, depth - 1)))


| _ -> let num = rand(1, 3) in build(rand, depth num )
Error: This expression has type int
       This is not a function; it cannot be applied.



hw2 build

fix:
let g1 () = failwith "to be implemented"

let g2 () = failwith "to be implemented"

let g3 () = failwith "to be implemented"

let c1 () = failwith "to be implemented"

let c2 () = failwith "to be implemented"

let c3 () = failwith "to be implemented"

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = doRandomGray(8, 72, 2140)

let _ = doRandomGray(9, 72, 2140)

let _ = doRandomGray(10, 72, 2140)

bad:
let rec build (rand, depth) = 
if(depth = 0) then
let num = rand(1, 10) in
if( num > 4) then buildX()
else buildY()
else 
let num = rand(1, 10) in match num with
| 1 | 2 -> buildSine(build(rand, depth - 1))
| 3 | 4 -> buildCosine(build(rand, depth - 1))
| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))
| 7 | 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))
| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),
build(rand, depth - 1), build(rand, depth - 1))
| _ -> build(rand, depth - 1)
Error: Syntax error



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile (let g x = let xx = f x in (xx, xx != b) in g,b)
Error: Syntax error: operator expected.



hw3 sqsum

fix:
let sqsum xs = 
let f a x = x * x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = match x with
| [] -> a
| h:: t -> (h*h) + sqsum t in
let base = 0 in
List.fold_left f base xs
Error: This expression has type int list
       but an expression was expected of type 'a list list
       Type int is not compatible with type 'a list 


let sqsum xs = 
let f a x = match x with
| [] -> a
| h:: t -> (h*h) + f base t
Error: Syntax error


let base = 0 in
List.fold_left f base xs
Error: Unbound value f


let sqsum xs = 
let f a x = match x with
| [] -> a
| h:: t -> (h*h) + f base t in 
let base = 0 in
List.fold_left f base xs
Error: Unbound value f


let sqsum xs = 
let f a x = match x with
| [] -> a
| h:: t -> (h*h) + List.fold_left f base t in 
let base = 0 in
List.fold_left f base xs
Error: Unbound value f


let sqsum xs = 
let f a x = fun x -> x * x in
let base = 0 in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         int -> int


let sqsum xs = 
let f a x = fun _ x -> x * x in
let base = 0 in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         'a -> int -> int


let sqsum xs = 
let f a x = fun a x -> x * x in
let base = 0 in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         'a -> int -> int



hw3 sqsum

fix:
let sqsum xs = 
let f a x = x * x + a in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = g a x = x * x + a in
let base = 0 in
List.fold_left g base xs
Error: Unbound value g



hw3 sqsum

fix:
let sqsumL xs = 
let rec helper acc rest = match rest with
| [] -> acc * acc
| h :: t -> h + helper (acc + h) t
in helper 0 xs

bad:
let sqsumL xs = 
let rec helper acc rest = match xs with
| [] -> []
| h :: t -> h
Error: Syntax error


let sqsumL xs = 
let rec helper acc xs = match xs with
| [] -> acc * acc
| h :: t -> h + helper (acc + h) t
Error: Syntax error



hw3 ???

fix:
let rec fold_l f base xs = match xs with 
| [] -> base 
| h :: t ->  fold_l (f) base t

bad:
let rec fold_l base xs = match xs with 
| [] -> base 
| h :: t ->  fold_l base t f h
Error: Unbound value f


let rec fold_l f base xs = match xs with 
| [] -> base 
| h :: t ->  fold_l f base t f h
Error: This expression has type 'a but an expression was expected of type
         'b -> 'c -> 'a
       The type variable 'a occurs inside 'b -> 'c -> 'a


let rec fold_l f base xs = match xs with 
| [] -> base 
| h :: t ->  fold_l (f h) base t
Error: This expression has type 'a but an expression was expected of type
         'b -> 'a
       The type variable 'a occurs inside 'b -> 'a



hw3 ???

fix:
let rec fold_l f base xs = match xs with 
| [] -> base 
| h :: t ->  let temp = fold_l f base t 
in f h temp

bad:
let rec fold_l f base xs = match xs with 
| [] -> base 
| h :: t ->  f h fold_l f base t
Error: This expression has type
         ('a -> 'b -> 'c -> 'd -> 'e -> 'f) -> 'g -> 'a list -> 'g
       but an expression was expected of type 'b
       The type variable 'b occurs inside
       ('a -> 'b -> 'c -> 'd -> 'e -> 'f) -> 'g -> 'a list -> 'g


let rec fold_l f base xs = match xs with 
| [] -> base 
| h :: t ->  (f h) fold_l f base t
Error: This expression has type
         ('a -> 'b -> 'c -> 'd -> 'e -> 'f) -> 'g -> 'a list -> 'g
       but an expression was expected of type 'b
       The type variable 'b occurs inside
       ('a -> 'b -> 'c -> 'd -> 'e -> 'f) -> 'g -> 'a list -> 'g



hw3 ???

fix:
let rec fold_l f base xs = match xs with 
| [] -> base 
| h :: t ->  (f h) (fold_l f base t)

bad:
let rec fold_l f base xs = match xs with 
| [] -> base 
| h :: t ->  f h fold_l f base t
Error: This expression has type
         ('a -> 'b -> 'c -> 'd -> 'e -> 'f) -> 'g -> 'a list -> 'g
       but an expression was expected of type 'b
       The type variable 'b occurs inside
       ('a -> 'b -> 'c -> 'd -> 'e -> 'f) -> 'g -> 'a list -> 'g



hw3 ???

fix:
let rec fold_l f base xs = match xs with 
| [] -> base 
| h :: t -> let temp = fold_l f base t 
in f h temp

bad:
let rec fold_l f base xs = match xs with 
| [] -> base 
| h :: t -> (fold_l f base t) (f h)
Error: This expression has type 'a but an expression was expected of type
         'b -> 'a
       The type variable 'a occurs inside 'b -> 'a


let rec fold_l f base xs = match xs with 
| [] -> base 
| h :: t -> let temp = fold_l f base t 
in temp f h
Error: This expression has type 'a but an expression was expected of type
         'b -> 'c -> 'a
       The type variable 'a occurs inside 'b -> 'c -> 'a


let rec fold_l f base xs = match xs with 
| [] -> base 
| h :: t -> let temp = fold_l f base t 
in temp (f h)
Error: This expression has type 'a but an expression was expected of type
         'b -> 'a
       The type variable 'a occurs inside 'b -> 'a



hw3 ???

fix:
let rec fold_l f base xs = match xs with 
| [] -> base 
| h :: t -> f h (fold_l f base t)

bad:
let rec fold_l f base xs = match xs with 
| [] -> base 
| h :: t -> f h fold_l f base t
Error: This expression has type
         ('a -> 'b -> 'c -> 'd -> 'e -> 'f) -> 'g -> 'a list -> 'g
       but an expression was expected of type 'b
       The type variable 'b occurs inside
       ('a -> 'b -> 'c -> 'd -> 'e -> 'f) -> 'g -> 'a list -> 'g



hw3 ???

fix:
let list =  ["hi" ; "iris" ; "elephant"]

let list2 = sumListL []

let _ =  [1;2;3;4]

let _ =  [(-1); (-2); (-3); (-4)]

let _ =  [1]

let _ =  [0;0;0;0]

let sumListL = fold_l (fun h temp -> temp ^ h) "" list

let concatL = fold_l (fun h temp -> temp + h*h) 0 list2

bad:
let _ = concatL ["hi" ; "iris" ; "elephant"]
Error: Unbound value concatL
Hint: Did you mean concat?
Error: Unbound value concatL
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value concatL
Hint: Did you mean concat?


let _ = sumListL []
Error: Unbound value sumListL


let _ = sumListL [1;2;3;4]
Error: Unbound value sumListL


let _ = sumListL [(-1); (-2); (-3); (-4)]
Error: Unbound value sumListL


let _ = sumListL [1]
Error: Unbound value sumListL


let _ = sumListL [0;0;0;0]
Error: Unbound value sumListL


let sumListL = fold_l (fun h temp -> temp ^ h) "" list
Error: Unbound value list


let concatL = fold_l (fun h temp -> temp + h*h) 0 list2
Error: Unbound value list2



hw3 ???

fix:
let test = fun x -> x * x

test 3

bad:
let fun x -> x * x
Error: Syntax error


fun 3
Error: Syntax error



hw3 ???

fix:
let hi = fun x -> x + x in
let g = fun x -> x + 3 in
hi 3

bad:
let fun x -> x + x in
let fun x -> x + 3 in
fun 3
Error: Syntax error


let hi = fun x -> x + x in
let fun x -> x + 3 in
hi 3
Error: Syntax error


let hi = fun x -> x + x in
fun x -> x + 3 in
hi 3
Error: Syntax error



hw3 ???

fix:
let hi = fun x -> x + x in
let temp = fun x -> x + 3 in
temp 3

bad:
let hi = fun x -> x + x in
x + 3 in
hi 3
Error: Syntax error


let hi = fun x -> x + x in
x -> x + 3 in
hi 3
Error: Syntax error


let hi = fun x -> x + x in
fun x -> x + 3 in
hi 3
Error: Syntax error



hw3 ???

fix:
let hi = fun x -> x + x in
let temp = fun x -> hi 3 in
temp 3

bad:
let hi = fun x -> x + x in
let temp = fun x -> hi + 3 in
temp 3
Error: This expression has type int -> int
       but an expression was expected of type int



hw3 ???

fix:
let hi = fun x -> x + x in
let temp = fun x -> x + 3 in
hi (temp 3)

bad:
let hi = fun x -> x + x in
let temp = fun x -> x + 3 in
hi temp 3
Error: This function has type int -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 ???

fix:
let hi = fun x -> x + 3 in
let temp = fun x -> x + x in
hi (temp 3)

bad:
let hi = fun x -> x + x in
let temp = fun x -> x + 3 in
hi temp 3
Error: This function has type int -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let sqsum xs = 
let f a x = x * x + a in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let _ = sqsum [0;0;0]

let pipe fs = 
let f a x =  failwith "TBD" in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  failwith "TBD"
Error: Syntax error


let base = a in
List.fold_left f base fs
Error: Unbound value a


let pipe fs = 
let f a x =  failwith "TBD" in
let base = a in
List.fold_left f base fs
Error: Unbound value a



hw3 pipe

fix:
let sqsum xs = 
let f a x = x * x + a in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let _ = sqsum [0;0;0]

let pipe fs = 
let f a x =  failwith "TBD" in
let base = fun x -> x
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  failwith "TBD" in
let base = a in
List.fold_left f base fs
Error: Unbound value a



hw3 ???

fix:
let firstF = fun x -> x + x in
let secondF = fun x' -> x' + 3 in
secondF(firstF 3)

bad:
let fun x -> x + x in
let secondF = fun x' -> x' + 3 in
secondF 3
Error: Syntax error


fun x -> x + x in
let secondF = fun x' -> x' + 3 in
secondF 3
Error: Syntax error



hw3 ???

fix:
fun x -> x + x =
let g = fun y -> y + y
in g 2

bad:
fun x -> x + x in
fun y -> y + 3 in 3
Error: Syntax error


fun x -> x + x =
let g = a + b 
in g 2 2
Error: Unbound value a


fun x -> x + x =
let g = 2 + 2
in g 2
Error: This expression has type int
       This is not a function; it cannot be applied.



hw3 ???

fix:
let plus x y = x + y

let plus1 = plus1

plus1 1

bad:
plus1 1
Error: Unbound value plus1
Hint: Did you mean plus?
Error: Unbound value plus1
Hint: Did you mean flush?
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value plus1
Hint: Did you mean plus?



hw3 ???

fix:
let plus x y = x + y

let plus1 = plus1

plus1 1

bad:
plus1 1
Error: Unbound value plus1
Hint: Did you mean plus?
Error: Unbound value plus1
Hint: Did you mean flush?
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value plus1
Hint: Did you mean plus?



hw3 ???

fix:
plus1 (plus1 2)

bad:
plus1 plus1 2
Error: This function has type int -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe fs = 
let f a x =  a x in
let base = fun x -> x in 
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let test = fun x -> x * x 
in test 3

let firstF = fun x -> x + x in
let secondF = fun x' -> x' + 3 in

secondF(firstF 3)

bad:
let pipe fs = 
let f a x =  a (f x) in
let base = fun x -> x in 
List.fold_left f base fs
Error: Unbound value f


let pipe fs = 
let f a x =  a (x) in
let base = fun x -> x in 
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x =  a x in
let base = fun x -> x in 
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x =  fun x' = a x in
let base = fun x -> x in 
List.fold_left f base fs

let _ = pipe [] 3

bad:
let pipe fs = 
let f a x =  let existing = a in 
let next x in 
existing(next) in
let base = fun x -> x in 
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x =  let existing = a in 
let next = x in 
existing(next) in
let base = fun x -> x in 
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x =  fun x' -> a x in
let base = fun x -> x in 
List.fold_left f base fs

let _ = pipe [] 3

bad:
let pipe fs = 
let f a x =  fun x' = a x in
let base = fun x -> x in 
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x =  fun x' -> a x in
let base = fun x -> x in 
List.fold_left f base fs

let _ = pipe [] 3

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         int -> int


let _ = pipe [(fun x -> x+x)] 3
Error: This expression has type int but an expression was expected of type
         int -> int



hw3 pipe

fix:
let pipe fs = 
let f a x =  fun x' -> (a x) in
let base = fun x -> x in 
List.fold_left f base fs

let _ = pipe [] 3

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         int -> int



hw3 pipe

fix:
let pipe fs = 
let f a x =  a (f x) in
let base = fun x -> x in 
List.fold_left f base fs

let _ = pipe [] 3

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         int -> int



hw3 pipe

fix:
let pipe fs = 
let f a x =  failwith "hi" in
let base = fun x -> x in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  fun y -> fun x -> a in
let base = fun x -> x in 
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'c -> 'd -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x =  let g x = a x in
let base = fun x -> x in 
List.fold_left f base fs

let _ = pipe [] 3

bad:
let pipe fs = 
let f a x =  let g a = let xx = f x in g in
let base = fun x -> x in 
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x =  let g x = a x in
let base = fun x -> x in 
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x =  fun a -> fun x ->  a x in
let base = fun x -> x in 
List.fold_left f base fs

let _ = pipe [] 3

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x =  fun g -> a x in
let base = fun x -> x in
List.fold_left f base fs

let _ = pipe [] 3

bad:
let pipe fs = 
let f a x =  let f g = fun x -> f (a x) in
let base = fun x -> x in
List.fold_left f base fs
Error: Syntax error


let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'b


let pipe fs = 
let f a x =  let g y = a (g x) in
let base = fun x -> x in
List.fold_left f base fs
Error: Syntax error



hw3 ???

fix:
let f y z = x a

a

bad:
let f y z = x a
Error: This expression has type int -> int
       but an expression was expected of type int



hw3 ???

fix:
let f y z = fun x -> x + x in fun x' -> x' + 3

bad:
let f y z = fun x -> x + x -> fun x' -> x' + 3
Error: Syntax error



hw3 ???

fix:
let f y z = fun x -> x + x in fun x' -> x' + 3

f a x

bad:
let f y z = y in z
Error: Unbound value z



hw3 ???

fix:
let f y z = fun x -> (y z)

f a x

bad:
f a x
Error: This expression has type int -> int
       but an expression was expected of type int



hw3 ???

fix:
let f y z = fun x -> x + x in fun x' -> x' + 3

f a x

bad:
f a x
Error: This expression has type int -> int
       but an expression was expected of type int



hw3 ???

fix:
let test = fun x -> x * x 
in test 3

let firstF = fun x -> x + x in
let secondF = fun x' -> x' + 3 in
secondF(firstF 3)

let t = fun x -> x + 1

bad:
test a x
Error: This expression has type int -> int
       but an expression was expected of type int



hw3 ???

fix:
let _ = t "hi"

let a = fun x -> x + x

let x = fun x' -> x' + 3

x(a 3)

let test f g = fun x -> f (f g)

bad:
let _ = t "hi"
Error: This expression has type string but an expression was expected of type
         int



hw3 ???

fix:
let pick_one n =
if n > 0 then (fun x -> x + 1) 
else (fun x -> x - 1)

(pick_one -5 6)

bad:
let test f g = fun x -> fun -> y
Error: Syntax error


test a x
Error: This expression has type int -> int
       but an expression was expected of type int



hw3 sepConcat

fix:
let _ = sepConcat "hi" []

bad:
let _ = sepConcat sep []
Error: Unbound value sep



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x ^ a in
let base = sep in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = if x = "a" then x :: a in
let base = sep in
let l = t in
List.fold_left f base l
Error: This variant expression is expected to have type unit
       The constructor :: does not belong to type unit


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = if x = "a" then x :: a 
else a in
let base = sep in
let l = t in
List.fold_left f base l
Error: This expression has type string list
       but an expression was expected of type string


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = if x = "a" then a ^ x in
let base = sep in
let l = t in
List.fold_left f base l
Error: This expression has type string but an expression was expected of type
         unit



hw3 sepConcat

fix:
let rec fold_l f acc xs = match xs with 
| [] -> acc 
| h :: t -> fold_l f (f acc h) t

let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let _ = sqsum [0;0;0]

let pipe fs = 
let f a x = let g n = x(a n) in g in
let base = fun x -> x in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ x  ^ sep in
let base = "" in
let l = sl in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = if a = "a" then a ^ x  ^ sep in
let base = "" in
let l = sl in
List.fold_left f base l
Error: This expression has type string but an expression was expected of type
         unit



hw3 stringOfList

fix:
let stringOfList f l = List.map (sepConcat f) l

bad:
let stringOfList f l = List.map sepConcat f l
Error: This function has type ('a -> 'b) -> 'a list -> 'b list
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 stringOfList

fix:
let stringOfList f l = List.map (f sepConcat ) l

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: This expression has type int -> string
       but an expression was expected of type string


let _ = stringOfList (fun x -> x) ["foo"]
Error: This expression should not be a function, the expected type is
string


let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]
Error: This expression has type int -> string
       but an expression was expected of type string



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =
let carry = 
match a with
| (x,y) -> x in
match x with 
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
let args = padZero l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list * int list
       but an expression was expected of type 'a list



hw3 bigMul

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
let args =  in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

let rec mulByDigit i l = failwith "to be implemented"

let bigMul l1 l2 = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res

let key = ""

let prefix130 = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)^"\n"); ErrorCode "exception")

let explode s = 
let rec _exp i = 
if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in
_exp 0

let implode cs = 
String.concat "" (List.map (String.make 1) cs)

let drop_paren s = 
implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))

let eq_real p (r1,r2) = 
(r1 -. r2) < p || (r2 -. r1) < p

let wrap_curried_2 f (a,b) = f a b

bad:
let bigMul l1 l2 = 
let f a x = 
let (index, result) = a in
let (list1,list2) = x in
match list2 with
| [] -> []
| h::t ->
let resList = mulByDigit h list1 in
let newIndex = (index + 1) in 
let newRes = bigAdd result (mulByDigit (int_of_float (10.0 ** (float (newIndex -1)))) resList) in
(newIndex, newRes)
in
let base = (0, []) in
let args = ((List.rev l1),(List.rev l2)) in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "hi" in
let base = failwith "to be implemented" in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = x in carry in
let base = failwith "to be implemented" in
let args =  List.rev List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = x in carry in
let base = failwith "to be implemented" in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
1
Error: Syntax error


let base = failwith "to be implemented" in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
x
Error: Syntax error


let base = failwith "to be implemented" in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x
Error: Syntax error


let base = failwith "to be implemented" in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = failwith "to be implemented" in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         int list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =
let carry = 
match a with
| (x,y) -> x in
match x with 
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
|(x, y) -> x in
let base = (0, []) in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b -> 'c -> 'a
       but an expression was expected of type 'a * 'b -> 'c -> 'a * 'b
       The type variable 'a occurs inside 'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
|(x, y) -> x in
let base = (0, []) in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
|(x, y) -> x in carry in
let base = (0, []) in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b -> 'c -> 'a
       but an expression was expected of type 'a * 'b -> 'c -> 'a * 'b
       The type variable 'a occurs inside 'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = [] in
let base = (0, []) in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int * 'a list
       but an expression was expected of type 'b list



hw3 ???

fix:
let x = let y = 10 in x

bad:
let x = let y = 10
Error: Syntax error



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (x,y) -> x in
match x with
|(add1, add2) -> let newCarry = (carry + add1 + add2) mod 10 in
let num = (carry + add1 + add2) / 10 in
match a with 
|(x,y) -> (newCarry, num :: y) in
let base = (0, []) in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =
let carry = match a with
| (x,y) -> x in
match x with 
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in carry in 
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value carry


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (x,y) -> x in
match x with
|(add1, add2) -> let newCarry = (carry + add1 + add2) mod 10 in
let num = (carry + add1 + add2) / 10 in
match a with 
|(x,y) -> (newCarry, num :: y in
let base = (0, []) in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Characters 235-236:
  |(x,y) -> (newCarry, num :: y in
            ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (c,_) -> c in
match x with
|(add1, add2) -> let newCarry = (carry + add1 + add2) / 10 in
let num = (carry + add1 + add2) mod 10 in
match a with 
|(x,y) -> (newCarry, num :: y) in
let base = (0, []) in
let args =  List.rev (List.combine (0::l1) (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (c,_) -> c in
match x with
|(add1, add2) -> let newCarry = (carry + add1 + add2) / 10 in
let num = (carry + add1 + add2) mod 10 in
match a with 
|(x,y) -> (newCarry, num :: y) in
let base = (newCarry, []) in
let args =  List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value newCarry



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = failwith "to be implemented" in
let base = failwith "tbd" in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 =
let g =
let f b x = ((mulByDigit x l1)@(clone 0 (List.length b)))::b in
let base = [] in
let args = List.rev l2 in
let (_,res) = (List.fold_left f base args) in
res
in
List.fold_left bigAdd [] g
Error: This expression has type int list list
       but an expression was expected of type 'a * 'b
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int list list
       but an expression was expected of type 'a * 'b


let bigMul l1 l2 = 
let f a x = 
let (index, result) = a in
let (list1,list2) = x in
match list2 with
| [] -> []
| h::t ->
let resList = mulByDigit h list1 in
let newIndex = (index + 1) in 
let newRes = bigAdd result (mulByDigit (int_of_float (10.0 ** (float (newIndex -1)))) resList) in
(newIndex, newRes)
in
let base = (0, []) in
let args = ((List.rev l1),(List.rev l2)) in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = match a with
|(num, prod) -> (num + 1, bigAdd ((mulByDigit x (List.rev l1)) @ clone 0 num) prod) in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = match a with
|(num, prod) -> (num + 1, bigAdd ((mulByDigit x List.rev l1) @ clone 0 num) prod) in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This function has type int -> int list -> int list
       It is applied to too many arguments; maybe you forgot a `;'.
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This function has type int -> int list -> int list
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 padZero

fix:
let _ = padZero [1;2;3] []

bad:
let _ padZero [1;2;3] []
Error: Syntax error



hw3 pipe

fix:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x); (fun x -> x + 1)] 3

bad:
let _ = pipe [(fun x -> x + 3);(fun x-> x + x); (fun y -> x = 2); fun x -> x + 1] 3
Error: This expression has type bool but an expression was expected of type
         int


let _ = pipe [(fun x -> x + 3);(fun x-> x + x); (fun y -> x = 2); (fun x -> x + 1)] 3
Error: This expression has type bool but an expression was expected of type
         int



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base =  fun y ->  y in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

bad:
let pipe fs = 
let f a x = x a in
let base =  fun y ->  in
List.fold_left f base fs
Error: Syntax error



hw3 stringOfList

fix:
let stringOfList f l = "[" ^ sepConcat ";" (List.map f l) ^ "]"

bad:
let stringOfList f l = "[" ^ sepConcat ";" List.map f l ^ "]"
Error: This function has type string -> string list -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 clone

fix:
let rec clone x n = 
let rec helper a x n =
if x <= 0 then []
else 
let a' = x::a in
helper a' x (n-1)
in helper [] x n

bad:
let rec clone x n = 
let helper a x n =
if x <= 0 then []
else 
let a' = x::a in
helper a' x (n-1)
in helper [] x n
Error: Unbound value helper



hw3 padZero

fix:
let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

bad:
let padZero l1 l2 = 
let length1 = List.length l1 in
let length2 = List.length l2 in
if length1 > length2 then 
(l1, List.append (clone 0 (length1 - length2)) l2)
else if length2 > length1 then 
(List.append (clone 0 (length1 - length2)) l1, l2)
else (l1,l2)
Error: This expression has type int
       This is not a function; it cannot be applied.



hw3 bigAdd

fix:
let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = 0 in
let args = 
let rec pair list1 list2 = match (list1, list2) with
| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2
| ([], []) -> []
in pair l1 l2
in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = 0 in
let args = 
let rec pair list1 list2 = match (list1, list2) with
| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2
| (_ , _) -> []
in pair l1 l2
in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
(x1, x2) -> 
match a with
(o , z)if o + x1 + x2 > 9 
then (1, ((o + x1 + x2) mod 10)::z )
else (0, (o + x1 + x2)::z)
in
let base = (0, []) in
let args = 
let rec pair list1 list2 = 
match (List.rev list1, List.rev list2) with
| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2
| (_ , _) -> []
in pair l1 l2
in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
(x1, x2) -> 
match a with
(o , z) -> if o + x1 + x2 > 9 
then (1, ((o + x1 + x2) mod 10)::z )
else (0, (o + x1 + x2)::z)
in
let base = (0, []) in
let args = 
let rec pair list1 list2 = 
match (List.rev list1, List.rev list2) with
| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2
| (_ , _) -> []
in pair l1 l2
in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error



hw3 mulByDigit

fix:
let _ = mulByDigit 9 [9;9;9;9]

bad:
let rec mulByDigit i l =
let rec helper a i l = match l with
| [] -> a
| h::t -> let a' = h*i::a in
helper a' i t
in helper [] i l
Error: Unbound value helper



hw3 mulByDigit

fix:
let _ = mulByDigit 9 [9;9;9;9]

bad:
let rec mulByDigit i l =
let rec helper acc carry i l = match l with
| [] -> acc
| h::t -> let x = (h*i + carry) in 
let n = if x > 9 then x mod 10 else x in
let carry' = if x > 9 then x - 10 else 0 in
let acc' = n::acc in
helper acc' carry' i t
in helper [] 0 i (List.rev l)
Error: Unbound value a



hw3 bigAdd

fix:
let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
(x1, x2) -> 
match a with
(o , z) -> if o + x1 + x2 > 9 
then (1, ((o + x1 + x2) mod 10)::z )
else (0, (o + x1 + x2)::z)
in
let base = (0, []) in
let args = 
let rec pair acc list1 list2 = 
match (list1, list2) with
| (h1::t1, h2::t2) -> pair ((h1,h2)::acc) t1 t2
| (_ , _) -> acc
in pair [(0,0)] (List.rev l1) (List.rev l2)
in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list -> 'b list -> 'c list
       but an expression was expected of type 'c
       The type variable 'c occurs inside 'a list -> 'b list -> 'c list



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x =  bigAdd a x in
let base = [] in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
(let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1)) in
buildZeros [] place in 
let acc' = List.append (mulByDigit h l2) placeHolders) in
digitProducts acc' (place+1) t l2
Error: Syntax error: operator expected.


) in
let (_, res) = List.fold_left f base args in
res
Error: Syntax error: operator expected.


let bigMul l1 l2 = 
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
(let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in
buildZeros [] place) in 
let acc' = List.append (mulByDigit h l2) placeHolders) in
digitProducts acc' (place+1) t l2) in
let (_, res) = List.fold_left f base args in
res
Error: Syntax error


let bigMul l1 l2 = 
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
(let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in
buildZeros [] place) in 
let acc' = List.append (mulByDigit h l2) placeHolders in
digitProducts acc' (place+1) t l2)) in
let (_, res) = List.fold_left f base args in
res
Error: Syntax error: operator expected.


let bigMul l1 l2 = 
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
(let placeHolders = 
(let rec buildZeros a places = if places = 0 then a else buildZeros (0::a) (places-1) in buildZeros [] place) in 
let acc' = List.append (mulByDigit h l2) placeHolders in
digitProducts acc' (place+1) t l2)) in
let (_, res) = List.fold_left f base args in
res
Error: Syntax error: operator expected.


let bigMul l1 l2 = 
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let acc' = List.append (mulByDigit h l2) placeHolders in
digitProducts acc' (place+1) t l2) in
let (_, res) = List.fold_left f base args in
res
Error: Syntax error: operator expected.


let bigMul l1 l2 = 
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = List.append (mulByDigit h l2) placeHolders in
digitProducts a::acc (place+1) t l2) in
let (_, res) = List.fold_left f base args in
res
Error: Syntax error: operator expected.


let bigMul l1 l2 = 
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = List.append (mulByDigit h l2) placeHolders in
digitProducts a::acc (place+1) t l2+) in
let (_, res) = List.fold_left f base args in
res
Error: Syntax error: operator expected.


let bigMul l1 l2 = 
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = List.append (mulByDigit h l2) placeHolders in
digitProducts a::acc (place+1) t l2) 
in
let (_, res) = List.fold_left f base args in
res
Error: Syntax error: operator expected.


let bigMul l1 l2 = 
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = List.append (mulByDigit h l2) placeHolders in
digitProducts a::acc (place+1) t l2
Error: Syntax error: operator expected.


) 
in
let (_, res) = List.fold_left f base args in
res
Error: Syntax error: operator expected.


let bigMul l1 l2 = 
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = List.append (mulByDigit h l2) placeHolders in
digitProducts a::acc (place+1) t) 
in
let (_, res) = List.fold_left f base args in
res
Error: Syntax error


let bigMul l1 l2 = 
let f a x = a in
let base = failwith "to be implemented" in
let args = 
(let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts a::acc (place+1) t l2) 
in
let (_, res) = List.fold_left f base args in
res
Error: Syntax error: operator expected.


let bigMul l1 l2 = 
let f a x = a in
let base = failwith "to be implemented" in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts a::acc (place+1) t l2 in
digitsProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res
Error: Syntax error: operator expected.


let bigMul l1 l2 = 
let f a x = a in
let base = failwith "to be implemented" in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitsProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int -> int list -> int list -> int list
       but an expression was expected of type int


let bigMul l1 l2 = 
let f a x = a in
let base = failwith "to be implemented" in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value digitsProducts
Hint: Did you mean digitProducts?



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x =  match a with 
| (_, z) -> (0, bigAdd z x) in
let base = (0, []) in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x =  match a with 
| (_, z) -> (0, bigAdd z x)
| _ -> (0, 0) in
let base = [] in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list
       but an expression was expected of type 'a * 'b


let bigMul l1 l2 = 
let f a x =  match a with 
| (_, z) -> (0, bigAdd z x)
| _ -> (0, []) in
let base = [] in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int but an expression was expected of type
         int list


let bigMul l1 l2 = 
let f a x =  match a with 
| (_, z) -> (0, bigAdd z x)
| _ -> (0, []) in
let base = (0, []) in
let args = 
let rec digitProducts acc place l1 l2 = match l1 with
| [] -> acc
| h::t -> 
let placeHolders = 
(let rec buildZeros a places = 
if places = 0 then a else buildZeros (0::a) (places-1) in 
buildZeros [] place) in 
let a = 
(List.append (mulByDigit h l2) placeHolders) in
digitProducts (a::acc) (place+1) t l2 in
digitProducts [] 0 l1 l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a list
       but an expression was expected of type int * int list



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = let ass y -> y in
ass y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = function y -> y in
List.fold_left f base fs
Error: Unbound value y



hw3 pipe

fix:
let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

bad:
let pipe fs = 
let f a x =  fun b -> x (a b) in
let base = fun b -> b in
List.fold_left f base fs
Error: This expression has type 'a -> 'b
       but an expression was expected of type int



hw1 listReverse

fix:
let digitsOfInt n = 
let explodeNum n =
if (n > 0)
then (n mod 10) :: (digitsOfInt (n/10))
else []
in listReverse (explodeNum n)

bad:
let digitsOfInt n = 
let explodeNum =
if (n > 0)
then (n mod 10) :: (digitsOfInt (n/10))
else []
in listReverse explodeNum n
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.


let digitsOfInt n = 
let explodeNum =
if (n > 0)
then (n mod 10) :: (digitsOfInt (n/10))
else []
in listReverse (explodeNum n)
Error: This expression has type int list
       This is not a function; it cannot be applied.



hw1 listReverse

fix:
let listReverse l = 
let rec r e a =
match a with
| [] -> []
| (x::l') -> x :: e :: r e l'
in r [] l

bad:
let rec listReverse l = 
match l with
| [] -> []
| (x::l') -> (listReverse l') :: x :: []
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 listReverse

fix:
let listReverse l = 
let rec rev o = function
| [] -> o
| h::t -> rev (h::o) t
in rev [] l

bad:
let listReverse l = 
let rec rev [] o = o
| (hd::tl) -> rev tl (hd::o)
in rev l []
Error: Syntax error


let listReverse l = 
let rec rev o = 
| [] -> o
| h::t -> rev (h::o) t
in rev [] l
Error: Syntax error



hw1 listReverse

fix:
let listReverse l = 
let rec rev o = function
| [] -> o
| h::t -> rev (h::o) t
in rev [] l

bad:
let listReverse l = 
let rec rev o = fun
| [] -> o
| h::t -> rev (h::o) t
in rev [] l
Error: Syntax error



hw1 digitsOfInt

fix:
let digitsOfInt n =
let rec digits o a = 
if (a > 0)
then digitsOfInt ((a mod 10)::o) (a/10)
else []
in digits [] n

let _ = digitsOfInt 3124

bad:
let digitsOfInt n =
let rec digits o a = 
if (a > 0)
then (digitsOfInt ((a mod 10)::o) (a/10))
else []
in digits [] n;

let _ = digitsOfInt 3124
Error: Syntax error



hw2 assoc

fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| (s,i)::t -> if s = k then i else assoc (d,k,t)

bad:
let rec assoc (d,k,l) = match l with
| [] -> d
| (s,i)::t -> if s = k i else assoc (d,k,t)
Error: Syntax error



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile (f,b)

bad:
let fixpoint (f,b) = wwhile (fixpoint(f,b),b)
Error: This expression has type 'a -> 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'a * bool
Error: Unbound value wwhile
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type 'a -> 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'a * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = let helper x = 
if b = f b then (b, false) else (b, true) 
in
wwhile (helper,b)

bad:
let fixpoint (f,b) = wwhile (if b = f b then b else f(b),b)
Error: This expression has type ('a -> 'a * bool) * 'a
       but an expression was expected of type 'a -> 'a * bool


let fixpoint (f,b) = wwhile (if b = f b then b else f b,b)
Error: This expression has type ('a -> 'a * bool) * 'a
       but an expression was expected of type 'a -> 'a * bool


let fixpoint (f,b) = wwhile (if b = (f b) then b else (f b),b)
Error: This expression has type ('a -> 'a * bool) * 'a
       but an expression was expected of type 'a -> 'a * bool


let fixpoint (f,b) = wwhile (if b = (f b) then (b,false) else ((f b),true),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type bool -> bool * bool


let fixpoint (f,b) = wwhile (if x = f x then (b, false) else (b, true),b)
Error: Unbound value x


let fixpoint (f,b) = wwhile (if x = f x then (x, false) else (x, true),b)
Error: Unbound value x


let fixpoint (f,b) = wwhile (if b = f b then (b, false) else (b, true),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type bool -> bool * bool


let fixpoint (f,b) = wwhile ((if b = f b then (b, false) else (b, true)),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = let helper x = 
if b = f b then (b, false) else (b, true) 
in
wwhile (helper b,b)
Error: This expression has type 'a * bool
       but an expression was expected of type 'b -> 'b * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = let helper x = 
if b = (f b) then (b, false) else (f b, true) in
wwhile (helper,b)

l

bad:
et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value l



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((if b = (f b) then (b, false) else (f b, true)),b)

l

bad:
et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value l



hw2 fixpoint

fix:
et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 
| 1 -> 1 
| _ when n mod 2 = 0 -> n/2 
| _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let fixpoint (f,b) = wwhile ((if x = (f x) then (x, false) else (f x, true)),b)
Error: Unbound value fixpoint


l
Error: Unbound value wwhile


let fixpoint (f,b) = wwhile (x->(if x = (f x) then (x, false) else (f x, true)),b)
Error: Unbound value l


l
Characters 28-29:
  let fixpoint (f,b) = wwhile (x->(if x = (f x) then (x, false) else (f x, true)),b);;
                              ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let fixpoint (f,b) = let helper x = 
if x = (f x) then (x, false) else (f x, true) in
wwhile (helper,b)
Error: Unbound value l


l
Error: Unbound value wwhile



hw2 exprToString

fix:
let rec exprToString e = match e with
| VarX      -> "x"
| VarY      -> "y"
| Sine e    -> "sin(pi*" ^ exprToString e ^ ")"
| Cosine e  -> "cos (pi*" ^ exprToString e ^ ")"
| Average e1 e2 -> "((" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ ")/2)"

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e -> "sin (pi*" + exprToString e
Error: Unbound constructor Varx
Hint: Did you mean VarX or VarY?


let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e -> "sin (pi*" ^ exprToString e
Error: This expression has type string but an expression was expected of type
         int



hw2 exprToString

fix:
let rec exprToString e = match e with
| VarX      -> "x"
| VarY      -> "y"
| Sine e    -> "sin(pi*" ^ exprToString e ^ ")"
| Cosine e  -> "cos (pi*" ^ exprToString e ^ ")"
| Average (e1,e2) -> "((" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ ")/2)"
| Times (e1,e2) -> exprToString e1 ^ "*" ^ exprToString e2
| Thresh (e1,e2,e3,e4) -> "(" ^ exprToString e1 ^ "<" ^ exprToString e2 ^ "?" ^ exprToString e3 ^ ":" ^ exprToString e4 ^ ")"

bad:
let rec exprToString e = match e with
| VarX      -> "x"
| VarY      -> "y"
| Sine e    -> "sin(pi*" ^ exprToString e ^ ")"
| Cosine e  -> "cos (pi*" ^ exprToString e ^ ")"
| Average (e1,e2) -> "((" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ ")/2)"
Error: Syntax error



hw2 build

fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| (s,i)::t -> if s = k then i else assoc (d,k,t)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc ("not found",3,[(1,"found 1");(2,"found 2");(3,"found 3")])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then seen else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9;1;2;3;4;2;4;45]

let _ = removeDuplicates ["james";"james";"ding";"guan";"ding"]

let rec wwhile (f,b) = match f b with
| (i,true) -> wwhile(f,i)
| (i, false) -> i

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let f x = let xx = x*x*x in (xx, xx < 28) in
wwhile (f, 3)

let fixpoint (f,b) = let helper x = 
if x = (f x) then (x, false) else (f x, true) in
wwhile (helper,b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 
| 1 -> 1 
| _ when n mod 2 = 0 -> n/2 
| _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

type expr = 
VarX
| VarY
| Sine     of expr
| Cosine   of expr
| Average  of expr * expr
| Times    of expr * expr
| Thresh   of expr * expr * expr * expr

let rec exprToString e = match e with
| VarX		        -> "x"
| VarY		        -> "y"
| Sine e	        -> "sin(pi*" ^ exprToString e ^ ")"
| Cosine e		-> "cos (pi*" ^ exprToString e ^ ")"
| Average (e1,e2)       -> "((" ^ exprToString e1 ^ "+" ^ exprToString e2 ^ ")/2)"
| Times (e1,e2)	        -> exprToString e1 ^ "*" ^ exprToString e2
| Thresh (e1,e2,e3,e4)  -> "(" ^ exprToString e1 
^ "<" ^ exprToString e2 
^ "?" ^ exprToString e3 
^ ":" ^ exprToString e4 ^ ")"

let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

let _ = exprToString sampleExpr1

let buildX()                       = VarX

let buildY()                       = VarY

let buildSine(e)                   = Sine(e)

let buildCosine(e)                 = Cosine(e)

let buildAverage(e1,e2)            = Average(e1,e2)

let buildTimes(e1,e2)              = Times(e1,e2)

let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)

let pi = 4.0 *. atan 1.0

let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*eval (e1,x,y))
| Cosine e1		-> cos(pi*eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)
| Times (e1,e2)	        -> eval (e1,x,y) * eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)

) else (eval(e4,x,y))

bad:
let rec eval (e,x,y) = match e with
| buildX()		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*eval (e1,x,y))
| Cosine e1		-> cos(pi*eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)
| Times (e1,e2)	        -> eval (e1,x,y) * eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)
Error: Syntax error


) e
Error: Syntax error


let rec eval (e,x,y) = match e with
| buildX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*eval (e1,x,y))
| Cosine e1		-> cos(pi*eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)
| Times (e1,e2)	        -> eval (e1,x,y) * eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)
Error: Syntax error


) e
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| buildX	                -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*eval (e1,x,y))
| Cosine e1		-> cos(pi*eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)
| Times (e1,e2)	        -> eval (e1,x,y) * eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)
Error: Syntax error


) e
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| buildX                -> x
| buildY	        -> y 
| Sine e1	        -> sin(pi*eval (e1,x,y))
| Cosine e1		-> cos(pi*eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)
| Times (e1,e2)	        -> eval (e1,x,y) * eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)
Error: Syntax error


) e
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| buildX                -> x
| buildY	        -> y 
| buildSine(e1)	        -> sin(pi*eval (e1,x,y))
| Cosine e1		-> cos(pi*eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)
| Times (e1,e2)	        -> eval (e1,x,y) * eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)
Error: Syntax error


) e
Error: Syntax error


let rec eval (e,x,y) = match e with
| buildX                -> x
| buildY	        -> y 
| buildSine e1	        -> sin(pi*eval (e1,x,y))
| Cosine e1		-> cos(pi*eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)
| Times (e1,e2)	        -> eval (e1,x,y) * eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)
Error: Syntax error


) e
Error: Syntax error



hw2 eval

fix:
let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)

)

bad:
let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*eval (e1,x,y))
| Cosine e1		-> cos(pi*eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)
Error: Syntax error


let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*eval (e1,x,y))
| Cosine e1		-> cos(pi*eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)
Error: This expression has type int but an expression was expected of type
         float


let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)
Error: Unbound value <.


let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> eval (e1,x,y)<eval (e2,x,y)?eval (e3,x,y)
Error: This expression has type float but an expression was expected of type
         unit


):(eval(e4,x,y))
Error: This function has type expr * float * float -> float
       It is applied to too many arguments; maybe you forgot a `;'.


let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> eval (e1,x,y)<eval (e2,x,y)?(eval (e3,x,y)):(eval(e4,x,y))
Error: Syntax error


let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> (eval (e1,x,y)<eval (e2,x,y))?(eval (e3,x,y)):(eval(e4,x,y))
Error: Syntax error


let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)
Error: Syntax error


let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)
Error: Unbound value <.



hw2 eval

fix:
let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)
| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)>=eval (e2,x,y)->  eval (e4,x,y)

bad:
let rec eval (e,x,y) = match e with
| VarX		        -> x
| VarY		        -> y 
| Sine e1	        -> sin(pi*.eval (e1,x,y))
| Cosine e1		-> cos(pi*.eval (e1,x,y))
| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)
| Times (e1,e2)	        -> eval (e1,x,y) *. eval (e2,x,y)
| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)
Error: Syntax error



hw2 build

fix:
let rec build (rand, depth) = 
let e = build(rand,depth') in
if depth > 0 then match rand 0 4 with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildTimes(e,e,e,e)
else match rand 0 1 with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = match rand (depth>0?(rand 0 1):(rand 2 6)) with
| 0 -> buildX()
Error: Syntax error


let rec build (rand, depth) = match (depth>0?(rand 0 1):(rand 2 6)) with
| 0 -> buildX()
Error: Syntax error: operator expected.


let rec build (rand, depth) = match rand (depth>0?0:2) (depth>0?1:6) with
| 0 -> buildX()
Error: Syntax error: operator expected.


let rec build (rand, depth) = if depth > 0 then match rand 0 4 with
| 0 -> buildX()
else match rand 0 1 with
| 0 -> buildX()
Error: Syntax error: operator expected.



hw2 build

fix:
let rec build (rand, depth) = 
let e = build(rand,depth-1) in
if depth > 1 then match rand 0 4 with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildThresh(e,e,e,e)
else match rand 0 1 with
| 0 -> buildX()
| 1 -> buildY()

bad:
let rec build (rand, depth) = 
let e = build(rand,depth-1) in
if depth > 0 then match rand 0 4 with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildTimes(e,e,e,e)
else match rand 0 1 with
| 0 -> buildX()
| 1 -> buildY()
Error: Unbound value depth'
Hint: Did you mean depth?


let rec build (rand, depth) = 
let e = build(rand,depth-1) in
if depth > 0 then match rand 0 4 with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildThresh(e,e,e,e)
else match rand 0 1 with
| 0 -> buildX()
| 1 -> buildY()
Error: This expression has type 'a * 'b * 'c * 'd
       but an expression was expected of type expr * expr



hw2 build

fix:
let rec build (rand, depth) = 
let e = build(rand,depth-1) in
if depth > 1 then match rand (0,4) with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildThresh(e,e,e,e)
else match rand (0,1) with
| 0 -> buildX()
| 1 -> buildY()

let g1 () = failwith "to be implemented"

let g2 () = failwith "to be implemented"

let g3 () = failwith "to be implemented"

let c1 () = failwith "to be implemented"

let c2 () = failwith "to be implemented"

let c3 () = failwith "to be implemented"

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let emitColor (f1,f2,f3,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_c_"^name) in
let chan = open_out (fname^".ppm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P6 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z1 = f1 (x,y) in
let z2 = f2 (x,y) in
let z3 = f3 (x,y) in

(* Convert the result to a grayscale value *)
let iz1 = toIntensity(z1) in
let iz2 = toIntensity(z2) in
let iz3 = toIntensity(z3) in

(* Emit one byte per color for this pixel *)
output_char chan (char_of_int iz1);
output_char chan (char_of_int iz2);
output_char chan (char_of_int iz3);
)) in  
close_out chan;
ignore(Sys.command ("convert "^fname^".ppm  "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".ppm"))

let doRandomColor (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand (seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e1 = build (g, depth) in
let e2 = build (g, depth) in
let e3 = build (g, depth) in

let _ = Format.printf "red   = %s \n" (exprToString e1) in
let _ = Format.printf "green = %s \n" (exprToString e2) in
let _ = Format.printf "blue  = %s \n" (exprToString e3) in

let f1 = eval_fn e1 in
let f2 = eval_fn e2 in
let f3 = eval_fn e3 in

(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitColor (f1,f2,f3,n,name)

type test = unit -> string

let key = ""

let prefix130 = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)); ErrorCode "exception")

let explode s = 
let rec _exp i = 
if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in
_exp 0

let implode cs = 
String.concat "" (List.map (String.make 1) cs)

let drop_paren s = 
implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))

let eq_real p (r1,r2) = 
(r1 -. r2) < p || (r2 -. r1) < p

let scoreMsg () = 
Format.sprintf "Results: Score/Max = %d / %d \n" !score !max

bad:
let rec build (rand, depth) = 
let e = build(rand,depth-1) in
if depth > 1 then match (rand (0 4)) with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildThresh(e,e,e,e)
else match rand (0 1) with
| 0 -> buildX()
| 1 -> buildY()
Error: This expression has type int
       This is not a function; it cannot be applied.


let rec build (rand, depth) = 
let e = build(rand,depth-1) in
if depth > 1 then match (rand(0 4)) with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildThresh(e,e,e,e)
else match rand (0 1) with
| 0 -> buildX()
| 1 -> buildY()
Error: This expression has type int
       This is not a function; it cannot be applied.


let rec build (rand, depth) = 
let e = build(rand,depth-1) in
if depth > 1 then match rand (0,4) with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildThresh(e,e,e,e)
else match rand (0,1) with
| 0 -> buildX()
| 1 -> buildY()
Error: This expression has type int
       This is not a function; it cannot be applied.



hw2 build

fix:
let rec build (rand, depth) = 
let e = build(rand,depth-1) in
if depth > 1 then match rand (0,4) with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildThresh(e,e,e,e)
else match rand (0,1) with
| 0 -> buildX()
| 1 -> buildY()

let g1 () = (8,8,8)

let g2 () = (8,8,8)

let g3 () = (8,8,8)

let c1 () = (12,12,12)

let c2 () = (12,12,12)

let c3 () = (12,12,12)

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

bad:
let _ = build(rand,2)
Error: This expression has type int * int -> int * int -> int
       but an expression was expected of type int * int -> int
       Type int * int -> int is not compatible with type int 


let rec build (rand, depth) = 
let e = build(rand,depth-1) in
if depth > 1 then match rand (0,4) with
| 0 -> buildSine(e)
| 1 -> buildCosine(e)
| 2 -> buildAverage(e,e)
| 3 -> buildTimes(e,e)
| 4 -> buildThresh(e,e,e,e)
else match rand (0,1) with
| 0 -> buildX()
| 1 -> buildY()
Error: Unbound value rand
Hint: Did you mean land?



hw2 ???

fix:
let _ = doRandomGray (g2())

bad:
let _ = doRandomGray g1()
Error: Unbound value doRandomGrayscale


let _ = doRandomGray g1()
Error: This function has type int * int * int -> unit
       It is applied to too many arguments; maybe you forgot a `;'.
Error: Unbound constructor VarX
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This function has type int * int * int -> unit
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = doRandomGray g1
Error: This function has type int * int * int -> unit
       It is applied to too many arguments; maybe you forgot a `;'.
Error: Unbound constructor VarX
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This function has type int * int * int -> unit
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = doRandomGray (g1())
Error: This expression has type unit -> int * int * int
       but an expression was expected of type int * int * int
Error: Unbound constructor VarX
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type unit -> int * int * int
       but an expression was expected of type int * int * int



hw2 build

fix:
let rand = makeRand(10,39)

let _ = build (rand, 8)

bad:
let rand = makeRand(10,39) in 
build (rand, 8);

(* g1,g2,g3,c1,c2,c3 : unit -> int * int * int
* these functions should return the parameters needed to create your 
* top three color / grayscale pictures.
* they should return (depth,seed1,seed2)
*)

let g1 () = (8,54765,10000)
Error: Syntax error


let rand = makeRand(10,39) in 
let _ = build (rand, 8);

(* g1,g2,g3,c1,c2,c3 : unit -> int * int * int
* these functions should return the parameters needed to create your 
* top three color / grayscale pictures.
* they should return (depth,seed1,seed2)
*)

let g1 () = (8,54765,10000)
Error: Syntax error



hw2 ???

fix:
let rec recu r = if rand(0,4) != 4 then recu else r

bad:
let yes = rand(0,4) in
let rec recu = if yes != 4 then recu else true
Error: Syntax error


let yes = rand(0,4) in
let rec recu = if yes != 4 then recu
Error: Syntax error


let yes = rand(0,4) in
let rec recu = if yes != 4 then recu else true
Error: Syntax error


let yes = rand(0,4) in
let rec recu = if yes != 4 then recu else 1
Error: Syntax error


let rec recu = if rand(0,4) != 4 then recu else 1
Error: Syntax error



hw2 ???

fix:
let _ = recu 5

bad:
let rec recu r = if rand(0,4) != 4 then recu r else r
Error: This expression has type 'a -> 'b
       but an expression was expected of type 'b
       The type variable 'b occurs inside 'a -> 'b



hw2 ???

fix:
let g1 () = (10,39,12)

let g2 () = (10,123213,567567)

let g3 () = (12,20,50000)

let c1 () = (12,12,12)

let c2 () = (12,12,12)

let c3 () = (12,12,12)

let _ = doRandomGray (12,40,312)

bad:
let _ = doRandomGray (8,10,12)
Error: Unbound value doRandomGray


let _ = doRandomGray (8,39,12)
Error: Unbound value doRandomGray


let _ = doRandomGray (9,39,12)
Error: Unbound value doRandomGray


let _ = doRandomGray (10,39,12)
Error: Unbound value doRandomGray



hw2 build

fix:
let rand = makeRand(10,12)

let _ = build(rand,12)

let rec recu r = if rand(0,4) != 3 then recu r else r

let _ = recu 5

let g1 () = (10,39,12)

let g2 () = (12,40,312)

let g3 () = (11,21,76)

let c1 () = (12,12,12)

let c2 () = (9,34,927)

let c3 () = (8,98,42)

let _ = doRandomGrey (g1())

bad:
let rec build (rand, depth) = 
if depth > 1 then match rand (0,16) with
| 0        ->  buildX()
| 1	   -> buildY()
| 3|4      -> buildSine(build(rand,depth-1))
| 5|6      -> buildCosine(build(rand,depth-1))
| 7|8|9    -> buildAverage(build(rand,depth-1),build(rand,depth-1))
| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
| 13|14|15 -> buildThresh(build(rand,depth-1),
build(rand,depth-1),
build(rand,depth-1),
build(rand,depth-1))
| 16|17    -> buildDivide(build(rand,depth-1),build(rand,depth-1))
| _        -> buildMultDiv(build(rand,depth-1),
build(rand,depth-1),
build(rand,depth-1))

else match rand (0,2) with
| 0 -> buildX()
| _ -> buildY()
Error: Unbound value doRandomGrey



hw2 eval

fix:
let _ = eval_fn (Square VarX) (2.,2.)

bad:
let _ = eval_fn (Square 5) (1,1)
Error: This function has type expr -> float * float -> float
       It is applied to too many arguments; maybe you forgot a `;'.
Error: Unbound constructor VarX
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This function has type expr -> float * float -> float
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = eval_fn (Square VarX) (1,1)
Error: This expression has type int but an expression was expected of type
         expr
Error: Unbound constructor VarX
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int but an expression was expected of type
         expr


let _ = eval_fn (Square VarX) (1.,1.)
Error: This expression has type int but an expression was expected of type
         float
Error: Unbound constructor VarX
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int but an expression was expected of type
         float



hw2 eval

fix:
let _ = eval (Square VarX,0.9,0.9)

bad:
let _ = eval (Square VarX,0.5,0.25)
Error: Syntax error: operator expected.



hw2 eval

fix:
let _ = eval_fn (Square VarX) (2.,1.)

bad:
let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
Format.sprintf("%d" !rv)
Error: This expression has type float but an expression was expected of type
         ('a, unit, string) format =
           ('a, unit, string, string, string, string)
           CamlinternalFormatBasics.format6


let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
Format.sprintf "%d" !rv
Error: This expression has type string
       This is not a function; it cannot be applied.


let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
Format.sprintf "%f" !rv
Error: This expression has type float but an expression was expected of type
         'a ref


let eval_fn e (x,y) = 
let rv = eval (e,x,y) in

let _ = eval_fn (Square VarX) (2.,1.)
Error: This expression has type float but an expression was expected of type
         'a ref


let eval_fn e (x,y) = 
let rv = eval (e,x,y)
Error: Syntax error


let eval_fn e (x,y) = 
let _ = eval (e,x,y)
Error: Syntax error


let eval_fn e (x,y) =  eval (e,x,y)
Error: Syntax error



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a**2. +. x in
let base = 0. in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

bad:
let sqsum xs = 
let f a x = a**2 + x in
let base = 0 in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         float


let _ = sqsum []
Error: Unbound value sqsum


let _ = sqsum [1;2;3;4]
Error: Unbound value sqsum


let _ = sqsum [(-1); (-2); (-3); (-4)]
Error: Unbound value sqsum


let sqsum xs = 
let f a x = a**2. + x in
let base = 0 in
List.fold_left f base xs
Error: This expression has type float but an expression was expected of type
         int


let sqsum xs = 
let f a x = a**2. +. x in
let base = 0 in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         float



hw3 pipe

fix:
let pipe fs = 
let f a x = x in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = a x in
let base = x' in
List.fold_left f base fs
Error: Unbound value x'


let pipe fs = 
let f a x = a x in
let base = (f s = s) in
List.fold_left f base fs
Error: Unbound value s


let pipe fs = 
let f a x = a x in
let base = (fun x -> x) in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = a (x) in
let base = (fun x -> x) in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = a x in
let base = (fun x -> x) in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = (a x) in
let base = (fun x -> x) in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = a -> x in
let base = (fun x -> x) in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = a x in
let base = (fun x -> x) in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = (x) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x in
let base = fun x -> x in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = x in
let base = () in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x in
let base = x in
List.fold_left f base fs
Error: Unbound value x



hw3 pipe

fix:
let pipe fs = 
let f a x = x in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x in
let base = base in
List.fold_left f base fs
Error: Unbound value base


let pipe fs = 
let f a x = a x in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = x in
let base = fun x y -> x y in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun x y -> x y in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = fun y -> a (x y) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun x y -> x y in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = a x in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = fun y -> a (x y) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun y -> a (x y) in
let base = fun x -> y in
List.fold_left f base fs
Error: Unbound value y



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ x in
let base = "" in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ x in
let base = "" in
let l = l in
List.fold_left f base l
Error: Unbound value l



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = if a != "" then a ^ sep ^ x else x in
let base = "" in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = (fun x -> match x with
| sep ^ y -> y
| _ -> x) in
let l = sl in
List.fold_left f base l
Error: Syntax error: operator expected.



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = (^) h in
let l = t in
List.fold_left f base l
Error: This expression has type string -> string
       but an expression was expected of type string


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = sep ^ x in
let base = (^) h in
let l = t in
List.fold_left f base l
Error: This expression has type string -> string
       but an expression was expected of type string


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = sep ^ x in
let base = fun x-> h ^ x in
let l = t in
List.fold_left f base l
Error: This expression has type string -> string
       but an expression was expected of type string



hw3 clone

fix:
let rec clone x n =
if n > 0 then
x :: clone x (n-1)
else
[]

bad:
let rec clone x n =
if n > 0 then
x :: clone x n-1
else
[]
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 padZero

fix:
let padZero l1 l2 = if (List.length l1) > (List.length l2) then
(l1,(clone 0 ((List.length l1) - (List.length l2)))::l2)
else
((clone 0 ((List.length l2) - (List.length l1)))::l1,l2)

bad:
let _ = padZero [9;9] [1;0;0;2]
Error: This expression has type int but an expression was expected of type
         int list



hw3 ???

fix:
let rec combine x1 x2 = match (x1,x2) with
| (h1::t1,h2::t2) -> (h1,h2)::combine t1 t2
| _ -> []
in combine [0;0;9;9] [1;0;0;2]

bad:
let _ = []::3
Error: This expression has type int but an expression was expected of type
         'a list list


let combine x1 x2 match (x1,x2) with
| (h1::t1,h2::t2) -> (h1,h2)::combine t1 t2
| _ -> []
in combine [0;0;9;9] [1;0;0;2]
Error: Syntax error


let combine x1 x2 = match (x1,x2) with
| (h1::t1,h2::t2) -> (h1,h2)::combine t1 t2
| _ -> []
in combine [0;0;9;9] [1;0;0;2]
Error: Unbound value combine
Hint: Did you mean compare?



hw3 ???

fix:
let _ = List.rev (List.combine [0;0;9;9] [1;0;0;2])

bad:
let _ = List.rev List.combine [0;0;9;9] [1;0;0;2]
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match (a,x) with
| ((b,c),(d,e)) -> (b,(d+e)::c) 
in
let base = ([], [0]) in
let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match (a,x) with
| ((b,c),(d,e)) -> (b,((d+e)::c) 
in
let base = ([], [0]) in
let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Characters 88-89:
  | ((b,c),(d,e)) -> (b,((d+e)::c) 
                     ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match (a,x) with
| ((b,c),(d,e)) -> ((d+e)/10,(d+e+b) mod 10::c) 
in
let base = (0, []) in
let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match (a,x) with
| ((b,c),(d,e)) -> ((d+e)/10,(d+e+h) mod 10::c) 
in
let base = (0, []) in
let args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value h



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match (a,x) with
| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) 
in
let base = (0, []) in
let args = List.rev (List.combine (0::l1) (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match (a,x) with
| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) 
in
let base = (0, []) in
let args = List.rev (List.combine (0::l1) 0::l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a list



hw3 mulByDigit

fix:
let rec mulByDigit i l = if i > 0
then
mulByDigit (i-1) (bigAdd l l)
else
0

bad:
let rec mulByDigit i l = mulByDigit i-1 bigAdd l l
Error: This expression has type 'a -> 'b
       but an expression was expected of type int


let rec mulByDigit i l = mulByDigit (i-1) bigAdd l l
Error: This expression has type 'a but an expression was expected of type
         (int list -> int list -> int list) ->
         (int list -> int list -> int list) -> 'a
       The type variable 'a occurs inside
       (int list -> int list -> int list) ->
       (int list -> int list -> int list) -> 'a


let rec mulByDigit i l = if i > 0
then
mulByDigit (i-1) bigAdd l l
else
0
Error: This expression has type 'a but an expression was expected of type
         (int list -> int list -> int list) ->
         (int list -> int list -> int list) -> 'a
       The type variable 'a occurs inside
       (int list -> int list -> int list) ->
       (int list -> int list -> int list) -> 'a



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = match (a,x) with
| ((b,c),d) -> (b+1,(mulByDigit d l1)::(clone 0 b))
in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = match (a,x) with
| ((b,c),d) -> d 
in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value mulByDigit



hw3 bigMul

fix:
let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

let key = ""

let prefix130 = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)^"\n"); ErrorCode "exception")

let explode s = 
let rec _exp i = 
if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in
_exp 0

let implode cs = 
String.concat "" (List.map (String.make 1) cs)

let drop_paren s = 
implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))

let eq_real p (r1,r2) = 
(r1 -. r2) < p || (r2 -. r1) < p

let wrap_curried_2 f (a,b) = f a b

bad:
let bigMul l1 l2 = 
let f a x = match (a,x) with
| ((b,c),d) -> (b+1,List.append (mulByDigit d l1) (clone 0 b))
in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value mulByDigit


let _ = bigMul [9;9;9;9] [9;9;9;9]
Error: Unbound value mulByDigit


let _ = bigMul [4;0] [1;0]
Error: This expression has type int but an expression was expected of type
         int * 'a list


let _ = bigMul [4;0] [1;1]
Error: This expression has type int but an expression was expected of type
         int * 'a list


let bigMul l1 l2 = 
let f a x = match (a,x) with
| ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)
in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int but an expression was expected of type
         int * 'a list


let _ = bigMul [4;0] [1;1]
Error: Unbound value bigAdd


let _ = bigMul [9;9;9;9] [9;9;9;9]
Error: This expression has type int but an expression was expected of type
         int * 'a list


let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]
Error: This expression has type int but an expression was expected of type
         int * 'a list



hw1 sumList

fix:
let rec sumList xs = 
match xs with
| [] -> []
| _ -> List.hd xs

bad:
let rec sumList xs = 
match xs with
| [] -> []
| _ -> List.hd xs + sumList List.tl
Error: This expression has type 'a list -> 'a list
       but an expression was expected of type int list


let rec sumList xs = 
match xs with
| _ -> List.hd xs + sumList List.tl
| [] -> []
Error: This expression has type 'a list -> 'a list
       but an expression was expected of type int list


let rec sumList xs = 
match xs with
| [] -> []
| _ -> List.hd xs + List.tl sumList
Error: This expression has type int list -> 'a list
       but an expression was expected of type 'b list



hw1 sumList

fix:
let rec sumList xs = 
match xs with
| [] -> []
| (x::xs') -> x

bad:
let rec sumList xs = 
match xs with
| [] -> []
| _ -> List.hd xs + 2
Error: This expression has type int but an expression was expected of type
         'a list


let rec sumList xs = 
match xs with
| _ -> List.hd xs + 2
| [] -> []
Error: This expression has type 'a list
       but an expression was expected of type int


let rec sumList xs = 
match xs with
| [] -> []
| _ -> List.hd xs + (sumList List.tl xs)
Error: This function has type int list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.


let rec sumList xs = 
match xs with
| [] -> []
| _ -> List.hd xs + sumList List.tl xs
Error: This function has type int list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 sumList

fix:
let _ = sumList []

bad:
let _ = sumList [1; 2; 3; 4]
Error: This expression has type int but an expression was expected of type
         'a list



hw1 sumList

fix:
let rec sumList xs = 
match xs with
| [] -> 0
| xs -> (List.hd xs + (sumList (List.tl xs)))

bad:
let rec sumList xs = 
match xs with
| [] -> []
| List.hd xs -> x
Error: Syntax error


let rec sumList xs = 
match xs with
| [] -> []
| List.hd xs -> 1
Error: Syntax error


let rec sumList xs = 
match xs with
| [] -> []
| List.hd xs -> 1
Error: Syntax error


let rec sumList xs = 
match xs with
| [] -> []
| xs -> List.hd xs + sumList List.tl xs
Error: This function has type int list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.


let rec sumList xs = 
match xs with
| [] -> 0
| xs -> List.hd xs + sumList List.tl xs
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let rec sumList xs = 
match xs with
| [] -> 0
| xs -> (List.hd xs + (sumList (List.tl xs))
Characters 54-55:
  | xs -> (List.hd xs + (sumList (List.tl xs));;
          ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw1 sumList

fix:
let _ = sumList [1; 3; 5; 7; 9; 11]

bad:
let _ = sumList [1; 3; 5; 7; 9; 11]
(* uncomment and run AFTER you have implemented sumList

let _ = sumList [1; 2; 3; 4]
let _ = sumList [1; -2; 3; 5]
let _ = sumList [1; 3; 5; 7; 9; 11]

*)
List.hd 55
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 ???

fix:
55 mod 10

bad:
55 % 10
Error: Unbound value %



hw1 ???

fix:
3124 - 4

bad:
3124 - mod 10
Error: Syntax error



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
match n with
| n -> 5

bad:
let rec digitsOfInt n = 
match n with
| n <= 0 -> []
Error: Syntax error


let rec digitsOfInt n = 
match n with
| n (<=) 0 -> []
Error: Syntax error


let rec digitsOfInt n = 
match n with
| n < 0 -> []
Error: Syntax error


let rec digitsOfInt n = 
match n with
| (n < 0) -> []
Characters 40-41:
  | (n < 0) -> [];;
    ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let rec digitsOfInt n = 
match n with
| (n < 0) -> []
| n -> 5
Characters 40-41:
  | (n < 0) -> []
    ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
match n with
| n -> n :: []

bad:
let rec digitsOfInt n = 
match n with
| n -> 5
| (n < 0) -> []
Characters 49-50:
  | (n < 0) -> [];;
    ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let rec digitsOfInt n = 
match n with
| n -> 5
| n < 0 -> []
Error: Syntax error


let rec digitsOfInt n = 
match n with
| n -> 5
| 0 -> []
Error: This expression has type 'a list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
match n with
| (n::ns) -> n :: ns

bad:
let rec digitsOfInt n = 
match n with
| 0 -> [] :: ns
| n -> n :: ns
Error: Unbound value ns


let rec digitsOfInt n = 
match n with
| n -> n :: ns
Error: Unbound value ns



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
match n with
| n::ns -> (n::ns)

bad:
let rec digitsOfInt n = 
match n with
| n -> (n::ns)
Error: Unbound value ns



hw1 digitsOfInt

fix:
let ns = []

let rec digitsOfInt n = 
match n with
| n -> (n::ns)

bad:
let _ = digitsOfInt 3124
Error: This expression has type int but an expression was expected of type
         'a list



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| n -> List.hd ((n mod 10)::ns)

bad:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| n -> List.hd (n mod 10)::ns
Error: This expression has type int but an expression was expected of type
         'a list



hw1 digitsOfInt

fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> 0
| n -> ((n mod 10)::(digitsOfInt (n / 10)))
Error: This expression has type int list
       This is not a function; it cannot be applied.


let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> 0
| n -> ((n mod 10)::(digitsOfInt (n / 10)))::ns
Error: This expression has type 'a list
       but an expression was expected of type int


let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> 0::ns
| n -> ((n mod 10)::(digitsOfInt (n / 10)))
Error: This expression has type 'a list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> 0::ns
| n -> ((digitsOfInt (n / 10))::((n mod 10)::ns))
Error: This expression has type int list
       but an expression was expected of type int


let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> 0::ns
| n -> (digitsOfInt (n / 10))::((n mod 10)::ns)
Error: This expression has type int list
       but an expression was expected of type int


)
Error: This expression has type int list
       but an expression was expected of type int


let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> 0::ns
| n -> (digitsOfInt (n / 10))::((n mod 10)::ns)
Error: Syntax error


let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> 0::ns
| n -> ((n mod 10)::(digitsOfInt (n / 10)))
Error: This expression has type int list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> 0::ns
| n -> (digitsOfInt (n / 10))::(n mod 10)
Error: This expression has type int list
       but an expression was expected of type int


let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> 0::ns
| n -> (digitsOfInt (n / 10))::(n mod 10)
Error: This expression has type int list
       but an expression was expected of type int


let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> 0::ns
| n -> ((n mod 10)::(digitsOfInt (n / 10)))
Error: This expression has type int list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
digitsOfInt (-1)

bad:
digitsOfInt -5
Error: This expression has type int -> int list
       but an expression was expected of type int


digitsOfInt (-5)
Error: This expression has type int -> int list
       but an expression was expected of type int



hw1 digitalRoot

fix:
let rec additivePersistence n =

let rec digitalRoot n = sumList (digitsOfInt n)

bad:
let rec additivePersistence n =
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let rec digitalRoot n = 
sumList digitsOfInt n
Error: Syntax error


let rec additivePersistence n =
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let rec digitalRoot n = 
sumList (digitsOfInt n)
Error: Syntax error



hw1 digitalRoot

fix:
digitalRoot 9876

bad:
let rec digitalRoot n = 
sumList (digitsOfInt n)
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l = 
let l' = [] in
match l with
| [] -> l'
| h::t -> (List.hd l)::(listReverse (List.tl l))
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4]

let _ = listReverse ["a"; "b"; "c"; "d"]

bad:
let rec listReverse l = 
let rec lr l' =
match l with
| [] -> l'
| h::t -> lr (h::l') t in
lr [] listReverse
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec listReverse l = 
let rec lr l' = function
match l with
| [] -> l'
| h::t -> lr (h::l') t in
lr [] listReverse
Error: This expression has type 'a list
       but an expression was expected of type 'b -> 'c


let rec listReverse l = 
let rec lr l' = function
| [] -> l'
| h::t -> lr (h::l') t in
lr [] listReverse
Error: Syntax error


let listReverse l = 
let rec lr l' = function
| [] -> l'
| h::t -> lr (h::l') t in
lr [] listReverse
Error: This expression has type 'a -> 'b
       but an expression was expected of type 'c list


let listReverse l = 
let rec lr l' = function
| [] -> l'
| h::t -> lr (h::l') t in
lr [] l
Error: This expression has type 'a list -> 'a list
       but an expression was expected of type 'b list



hw1 palindrome

fix:
let palindrome w = 
explode w = listReverse (explode w )

bad:
palindrome "hello"
Error: Unbound value hello



hw1 additivePersistence

fix:
additivePersistence 98765

bad:
additivePersistence 1111
Error: Syntax error



hw1 listReverse

fix:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else ((n mod 10) :: (listReverse ( digitsOfInt (n / 10))) )

bad:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else ((n mod 10) :: listReverse ((( digitsOfInt (n / 10) ) )
Characters 94-95:
  else ((n mod 10) :: listReverse (( digitsOfInt (n / 10) ) );;
       ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else ((n mod 10) :: listReverse ( digitsOfInt (n / 10) )
Characters 121-122:
  else ((n mod 10) :: listReverse ((( digitsOfInt (n / 10) ) );;
                                  ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else ((n mod 10) :: listReverse ( digitsOfInt (n / 10) )
Characters 94-95:
  else ((n mod 10) :: listReverse ( digitsOfInt (n / 10) );;
       ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else ((n mod 10) :: listReverse ( digitsOfInt (n / 10) ) )
Characters 94-95:
  else ((n mod 10) :: listReverse ( digitsOfInt (n / 10) );;
       ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw1 digitsOfInt

fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else ((n mod 10) ::  ( digitsOfInt (n / 10) :: []) )
Error: This expression has type int list
       but an expression was expected of type int


let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else ((n mod 10) ::  ( digitsOfInt (n / 10)) ) :: []
Error: This expression has type int list
       but an expression was expected of type int


let rec digitsOfInt n = 
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else ((n mod 10) ::  ( digitsOfInt (n / 10)) )
Error: This expression has type int list list
       but an expression was expected of type int list
       Type int list is not compatible with type int 



hw1 listReverse

fix:
let rec digitsOfInt n =
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else let rev = listReverse ns' in
((n mod 10) ::  ( digitsOfInt (n / 10)) )

bad:
let listReverse l = 
let rec lr l' = function
| [] -> l'
| h::t -> lr (h::l') t in
lr [] l
Error: Unbound value ns'
Hint: Did you mean ns?



hw1 listReverse

fix:
let rec digitsOfInt n =
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else let listReverse ns in
((n mod 10) ::  ( digitsOfInt (n / 10)) )

bad:
let rec digitsOfInt n =
let ns = [] in 
match n with
| 0 -> ns
| n -> 
if n < 0
then []
else let rev = listReverse ns in
((n mod 10) ::  ( digitsOfInt (n / 10)) )
Error: Unbound value ns'
Hint: Did you mean ns?



hw1 listReverse

fix:
let rec sumList xs = 
match xs with
| [] -> 0
| xs -> (List.hd xs + (sumList (List.tl xs)))

let digitsOfInt n = 
let xxx = function 
match n with
| 0 -> []
| n -> 
if n < 0
then []
else ((n mod 10) ::  ( digitsOfInt (n / 10)))
in listReverse (xxx n)

bad:
let rec digitsOfInt n = 
let this = function
match n with
| 0 -> []
| n -> 
if n < 0
then []
else ((n mod 10) ::  ( digitsOfInt (n / 10)))
in this listReverse n
Error: This pattern matches values of type int
       but a pattern was expected which matches values of type 'a list


let rec digitsOfInt n = 
let this = function
match n with
| 0 -> []
| n -> 
if n < 0
then []
else ((n mod 10) ::  ( digitsOfInt (n / 10)))
in this listReverse n
Error: Syntax error


let rec digitsOfInt n = 
let this = 
match n with
| 0 -> []
| n -> 
if n < 0
then []
else ((n mod 10) ::  ( digitsOfInt (n / 10)))
in this listReverse n
Error: Syntax error



hw1 listReverse

fix:
let rec digitsOfInt n = 
let xxx =
match n with
| 0 -> []
| n -> 
if n < 0
then []
else ((n mod 10) :: ( digitsOfInt (n / 10)))
in listReverse (xxx n)

bad:
let digitsOfInt n = 
let xxx =
match n with
| 0 -> []
| n -> 
if n < 0
then []
else ((n mod 10) ::  ( digitsOfInt (n / 10)))
in listReverse (xxx n)
Error: Syntax error


let digitsOfInt n = 
let xxx =
match n with
| 0 -> []
| n -> 
if n < 0
then []
else ((n mod 10) :: ( xxx (n / 10)))
in listReverse (xxx n)
Error: This expression has type int list
       This is not a function; it cannot be applied.


let digitsOfInt n = 
let rec xxx =
match n with
| 0 -> []
| n -> 
if n < 0
then []
else ((n mod 10) :: ( xxx (n / 10)))
in listReverse (xxx n)
Error: Unbound value xxx


let rec digitsOfInt n = 
let xxx =
match n with
| 0 -> []
| n -> 
if n < 0
then []
else ((n mod 10) :: ( digitsOfInt (n / 10)))
in listReverse (xxx n)
Error: This expression has type int list
       This is not a function; it cannot be applied.


let listReverse l = 
let rec lr l' = function
| [] -> l'
| h::t -> lr (h::l') t in
lr [] l
Error: This expression has type int list
       This is not a function; it cannot be applied.



hw2 ???

fix:
let rec bssoc (d,k,l) = 
match d with
d -> d

bad:
let rec bssoc (d,k,l) = 
match d with
d -> v
Error: Unbound value v



hw2 ???

fix:
let rec bssoc (d,k,l) = 
match d with
| h :: t -> l
| _ -> d

bad:
let rec bssoc (d,k,l) = 
match d with
h :: t -> l
_ -> d
Error: Syntax error



hw2 ???

fix:
let rec bssoc (d,k,l) = 
match d with
| h :: t -> if h = k
then h

bad:
let rec bssoc (d,k,l) = 
match d with
| h :: t -> if h = k
then h
| _ -> d
Error: This expression has type unit list
       but an expression was expected of type unit



hw2 ???

fix:
let rec bssoc (d,k,l) = 
match l with 
| [] -> d
| h :: t ->
match h with
| (k', d') -> d'

bad:
let rec bssoc (d,k,l) = 
match l with 
| [] -> v
| h :: t ->
match h with
| (k, d) -> d
Error: Unbound value v



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = failwith "to be written" in
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = failwith "to be written" in
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))

removeDuplicates [1;6;2;4;12;2;13;6;9]
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.



hw2 ???

fix:
List.mem 1 seal = true

bad:
if List.mem 1 seal
then 4 :: seal
Error: This variant expression is expected to have type unit
       The constructor :: does not belong to type unit


if List.mem 1 seal
then 3
Error: This expression has type int but an expression was expected of type
         unit


if (List.mem 1 seal)
then 3
Error: This expression has type int but an expression was expected of type
         unit


if (List.mem 1 seal)
then (3)
Error: This expression has type int but an expression was expected of type
         unit


if List.mem 1 seal = true
then 12
Error: This expression has type int but an expression was expected of type
         unit


if List.mem 1 seal = true
then false
Error: This variant expression is expected to have type unit
       The constructor false does not belong to type unit


if List.mem 1 seal = true
Error: Syntax error



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen;
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = h in
if List.mem seen' seen = false
then seen' :: seen
Error: Syntax error


let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: Syntax error


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = h in
if List.mem seen' seen = false
then seen' :: seen
Error: Syntax error


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = h in
if List.mem seen' seen = false
then seen' :: seen
Error: Syntax error


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = h in
if (List.mem seen' seen = false)
then seen' :: seen
Error: Syntax error


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = h in
if (List.mem seen' seen = false)
then seen' :: seen
Error: Syntax error


let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: Syntax error


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = h in
if (List.mem seen' seen = false)
then (seen' :: seen)
Error: Syntax error


if 1 < 2
then 12
Error: This expression has type int but an expression was expected of type
         unit


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen
Error: Syntax error


let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: Syntax error


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen
Error: Syntax error



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen;
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen
Error: Syntax error



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen;
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen;
let rest' = t
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: Syntax error


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen;
let rest' = t
helper (seen',rest'); 
in
List.rev (helper ([],l))
Error: Syntax error


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = seen in
match List.mem h seen with
true -> h :: seen
| false -> seen;
let rest' = t
helper (seen',rest')
Error: Syntax error



hw2 wwhile

fix:
let rec wwhile (f,b) =
let f' = f b in 
match f' with
| (b', false) -> b'
| (b', true) -> wwhile (f, b')

bad:
let rec wwhile (f,b) =
let b' =
match x' with
| (b', false) -> b'
| (b', true) -> wwhile (f, b')
in f b
Error: Unbound value x'


let rec wwhile (f,b) =
let b' =
match b' with
| (b', false) -> b'
| (b', true) -> wwhile (f, b')
in f b
Error: Unbound value b'



hw2 fixpoint

fix:
let rec wwhile (f,b) =
let f' = f b in 
match f' with
| (b', false) -> b'
| (b', true) -> wwhile (f, b')

let fixpoint (f,b) = wwhile ((failwith "to be written"),b)

let fixpoint (f,b) = wwhile ((let f x = let xx = x*x*x in (xx, xx < 100)),b)

let g x = truncate (1e6 *. cos (1e-6 *. float x))

let collatz n = 
match n with 
1 -> 1 
| _ when 
n mod 2 = 0 -> n/2 | _ -> 3*n + 1

collatz 3

let f x = let xx = x*x*x in (xx,xx<100)

bad:
let fixpoint (f,b) = wwhile ((let f x = let xx = x*x*x in (xx, xx < 100),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ((let f x = let xx = x*x*x in (xx, xx < 100)),b)
Error: Syntax error: operator expected.



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile (
(let f' f b = let g f b =  g(b) in (b , b = g'),b))

let g x = truncate (1e6 *. cos (1e-6 *. float x))

let collatz n = 
match n with 
1 -> 1 
| _ when 
n mod 2 = 0 -> n/2 | _ -> 3*n + 1

collatz 3

let f x = let xx = x*x*x in (xx,xx<100)

let f b = let g' = g(b) in (b, b = g')

f collatz

bad:
let fixpoint (f,b) = wwhile (
(let f' f b =
let f b = let g' = g(b) in (b , b = g')
),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile (
(let f' f b =
let f b = let g' = g(b) in (b , b = g')
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile (
(let f' f b = let f b = let g' = g(b) in (b , b = g')),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile (
(let f' f b = let g f b =  g(b) in (b , b = g')),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile (
(let f' f b = let g f b =  g(b) in (b , b = g'),b)
Error: Syntax error: operator expected.



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile (let whilesFun f' b' = let fOfB = f(b) in (b , b = fOfB) in whilesFun (f, b), b)

bad:
let fixpoint (f,b) = wwhile (
(let whilesFun = let fOfB = f(b) in (b , b = fOfB),b))
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ((let whilesFun = let fOfB = f(b) in (b , b = fOfB)), b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile (let whilesFun = let fOfB = f(b) in (b , b = fOfB), b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile (let whilesFun = let fOfB = f(b) in (b , b = fOfB)), b
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ((let whilesFun = let fOfB = f(b) in (b , b = fOfB)), b)
Error: Syntax error: operator expected.



hw2 fixpoint

fix:
let rec assoc (d,k,l) = 
match l with 
| [] -> d
| (k', d') :: t ->
if k = k'
then d'
else assoc (d, k, t)

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = 
match List.mem h seen with
true -> seen
| false -> h :: seen
in

let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

let rec wwhile (f,b) =
let f' = f b in 
match f' with
| (b', false) -> b'
| (b', true) -> wwhile (f, b')

let fixpoint (f,b) = wwhile ((failwith "to be written"),b)

let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f'(b') in (b' , b' = fOfB) in whilesFun (f, b)), b)

bad:
let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b' , b' = fOfB) in whilesFun (f, b)), b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c


let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f'(b') in (b' , b' = fOfB) in whilesFun (f, b)), b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b' , b' = fOfB) in whilesFun f), b)

bad:
let fixpoint (f,b) = wwhile ((let whilesFun f' = let fOfB = f'(b') in (b' , b' = fOfB) in whilesFun f), b)
Error: Unbound value b'



hw2 ???

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x))

let whilesFun f' b' = let fOfB = f' (b') in (b' , b' = fOfB) in whilesFun g

)

bad:
let whilesFun f' b' = let fOfB = f' (b') in (b' , b' = fOfB) in whilesFun f
Error: This expression has type int -> int * bool
       but an expression was expected of type int -> int
       Type int * bool is not compatible with type int 


)
Error: Syntax error



hw2 ???

fix:
let whilesFun f' b' = let fOfB = f' (b') in (b' , b' = fOfB) in whilesFun g

bad:
let whilesFun f' = let fOfB = f' (b') in (b' , b' = fOfB) in whilesFun g
Error: Unbound value b'



hw2 ???

fix:
let whilesFun f' b' = let fOfB = f' (b') in (b' , b' = fOfB)

bad:
let fOfB = f' (b') in (b' , b' = fOfB)
Error: Unbound value f'


let fOfB = g (b') in (b' , b' = fOfB)
Error: Unbound value b'


let fOfB b' = g (b') in (b' , b' = fOfB)
Error: Unbound value b'


let fOfB b' = g (b') in (b', b' = fOfB)
Error: Unbound value b'


let fOfB b' = g (b') in (x, b' = fOfB)
Error: Unbound value b'
Error: Unbound value h
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value b'


let fOfB b' = let b' = g (b') in (b', b' = fOfB)
Error: Unbound value fOfB



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun (f)), b)

bad:
let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun f), b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x))

fixpoint (g,0)

bad:
let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB b' = f' (b') in (b', fOfB = b') in whilesFun (f)), b)
Error: Unbound value b'



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((let whilesFun f' b' = (b', f' (b') = b') in whilesFun (f)), b)

bad:
let fixpoint (f,b) = wwhile ((let whilesFun f' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun (f)), b)
Error: This expression has type int but an expression was expected of type
         int -> int


let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun (f)), b)
Error: Unbound value b'



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x))

fixpoint (g,0)

bad:
let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' b in (fOfB, fOfB = b') in whilesFun (f)), b)
Error: Unbound value fixpoint



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x))

fixpoint (g,0)

bad:
let fixpoint (f,b) = wwhile ((let whilesFun f' = let fOfB = f' b in (fOfB, fOfB = b) in whilesFun (f)), b)
Error: Unbound value fixpoint


let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' b') in (fOfB, fOfB = b') in whilesFun (f)
Error: Unbound value wwhile


let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (fOfB, fOfB = b') in whilesFun (f)), b)
Error: Syntax error: operator expected.



hw2 ???

fix:
VarX

bad:
VarX
Error: The constructor VarX expects 0 argument(s),
       but is applied here to 1 argument(s)



hw2 ???

fix:
let VarX = 2

bad:
Sine VarX
Error: The constructor Sine expects 1 argument(s),
       but is applied here to 0 argument(s)



hw2 ???

fix:
VarX

bad:
int
Error: Unbound value expr
Hint: Did you mean exp?


int 2
Error: Unbound value int


2
Error: Unbound value int



hw2 ???

fix:
let mars k = match k with
| Sine x -> x
in mars (Sine VarX)

type tree = 
| Leaf of int
| Node of tree * tree

bad:
Sine Cosine VarX
Error: The constructor Cosine expects 1 argument(s),
       but is applied here to 0 argument(s)


Sine (Cosine VarX)
Error: Syntax error



hw2 exprToString

fix:
let rec exprToString e = match e with
| VarX -> e

exprToString 2

bad:
let rec exprToString e = match e with
| VarX -> x
Error: The constructor VarX expects 0 argument(s),
       but is applied here to 1 argument(s)


let rec exprToString e = match e with
| VarX -> e
Error: Unbound value x



hw2 exprToString

fix:
let rec exprToString e = match e with
| VarX -> "x"

bad:
exprToString VarX
Error: This expression has type int but an expression was expected of type
         expr



hw2 exprToString

fix:
exprToString VarX

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e1 -> "Sin(" ^ (exprToString e1) ^ ")"
Error: The constructor Sine expects 1 argument(s),
       but is applied here to 0 argument(s)



hw2 exprToString

fix:
exprToString (VarX, VarY)

bad:
exprToString (Sine VarX)
Error: This function has type expr -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw2 exprToString

fix:
exprToString (Sine VarX)

bad:
exprToString (Sine (Sine VarX))
Error: This expression has type 'a * 'b
       but an expression was expected of type expr



hw2 exprToString

fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e1 -> "sin(pi*" ^ (exprToString e1) ^ ")"
| Cosine e1 -> "cos(pi*" ^ (exprToString e1) ^ ")"
| Average (e1, e2) -> "((" ^ (exprToString e1) ^ "+" ^ (exprToString e2) ^ ")" ^ "/2)"

bad:
exprToString (Average(VarX,VarY))
Error: This function has type expr -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw2 exprToString

fix:
exprToString (Sine (Cosine VarX))

exprToString (Sine VarX)

exprToString (Average(VarX,VarY))

exprToString (Times(VarX,VarY))

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e1 -> "sin(pi*" ^ (exprToString e1) ^ ")"
| Cosine e1 -> "cos(pi*" ^ (exprToString e1) ^ ")"
| Average (e1, e2) -> "((" ^ (exprToString e1) ^ "+" ^ (exprToString e2) ^ ")" ^ "/2)"
| Times (e1, e2) -> (exprToString e1) ^ "*" ^ (exprToString e2)
Error: This variant pattern is expected to have type expr
       The constructor Time does not belong to type expr
Hint: Did you mean Times?



hw2 eval

fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
Error: Syntax error



hw2 eval

fix:
eval ((VarX * VarY), 1, 2)

bad:
eval
Error: This expression has type expr but an expression was expected of type
         int



hw2 eval

fix:
eval (Times (VarX,VarY), 1, 2)

bad:
eval (Times(VarX,VarY), 1, 2)
Error: This expression has type expr but an expression was expected of type
         int



hw2 eval

fix:
eval ((Sine (VarY)), 0.2, 0.3)

bad:
eval (Sine (VarX,VarY), 0.2, 0.3)
Error: This expression has type 'a * 'b
       but an expression was expected of type expr


eval ((Sine (VarX,VarY)), 0.2, 0.3)
Error: This expression has type 'a * 'b
       but an expression was expected of type expr


eval ((Sine (VarX, VarY)), 0.2, 0.3)
Error: This expression has type 'a * 'b
       but an expression was expected of type expr


eval ((Sine (VarX)), 0.2, 0.3)
Error: This expression has type 'a * 'b
       but an expression was expected of type expr



hw2 eval

fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1, x, y))
| Cosine e1 -> cos(pi *. eval (e1, x, y))
| Average (e1, e2) -> (eval (e1, x, y) +. eval (e2, x, y)) /. 2.0
| Times (e1, e2) -> (eval (e1, x, y) *. eval (e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if ((eval (e1, x, y)) < (eval (e1, x, y))
then x
else y

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1, x, y))
| Cosine e1 -> cos(pi *. eval (e1, x, y))
| Average (e1, e2) -> (eval (e1, x, y) +. eval (e2, x, y)) /. 2.0
| Times (e1, e2) -> (eval (e1, x, y) *. eval (e2, x, y))
Error: Syntax error



hw2 eval

fix:
eval ((Sine (VarX)), 1.0, 0.3)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e1 -> sin(pi *. eval (e1, x, y))
| Cosine e1 -> cos(pi *. eval (e1, x, y))
| Average (e1, e2) -> (eval (e1, x, y) +. eval (e2, x, y)) /. 2.0
| Times (e1, e2) -> (eval (e1, x, y) *. eval (e2, x, y))
| Thresh (e1, e2, e3, e4) -> 
if (eval (e1, x, y)) < (eval (e1, x, y))
then x
else y
Characters 298-299:
  if ((eval (e1, x, y)) < (eval (e1, x, y))
     ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw3 sqsum

fix:
let sqsum xs = 
let f a x = x * x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = x * x +  in
let base = a in
List.fold_left f base xs
Error: Syntax error


let sqsum xs = 
let f a x = x * x in
let base = a in
List.fold_left f base xs
Error: Unbound value a



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = base + (x * x) in
let base = 0 in
List.fold_left f base xs
Error: Unbound value base


let sqsum xs = 
let f a x = f base (x * x) in
let base = 0 in
List.fold_left f base xs
Error: Unbound value f



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a + (x * x) in
let base = a in
List.fold_left f base xs
Error: Unbound value a



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
(* Should this be able to hand strings or other types? *)
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
(* Should this be able to hand strings or other types? *)
let base = 0
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x a in
(* Should this be able to hand strings or other types? *)
let base = 0
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
(* Should this be able to hand strings or other types? *)
let base = 0 in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let pipe fs = 
let f a x = x f in
(* Should this be able to hand strings or other types? *)
let base = 0 in
List.fold_left f base fs
Error: Unbound value f



hw3 ???

fix:
let hi = fun x -> x + x

(hi)

bad:
(_)
Error: Syntax error: operator expected.



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = pipe in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
(* Should this be able to hand strings or other types? *)
let base = x in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = x a in
let base = x in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = x a in
let base = x in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = x a in
let base = base in
List.fold_left f base fs
Error: Unbound value base



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         (int -> int) list



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x  in
let base = "" in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x  in
let base = [] in
let l = sl in
List.fold_left f base l
Error: This expression has type 'a list
       but an expression was expected of type string



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x  in
let base = "" in
let l = h :: t in
List.fold_left f base l

bad:
let _ = sepConcat ", " ["foo";"bar";"baz"]
Error: This expression has type string but an expression was expected of type
         string list



hw3 sepConcat

fix:
let _ = sepConcat "X" ["hello"]

bad:
let _ = sepConcat "X" ["hello"]

*
Error: Syntax error



hw3 stringOfList

fix:
let stringOfList f l = 
List.map (sepConcat "; ") l

bad:
let stringOfList f l = 
List.map sepConcat ("; ")
Error: This expression has type string but an expression was expected of type
         string list


let stringOfList f l = 
List.map sepConcat ("; " l)
Error: This expression has type string
       This is not a function; it cannot be applied.


let stringOfList f l = 
List.map sepConcat "; " l
Error: This function has type ('a -> 'b) -> 'a list -> 'b list
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 stringOfList

fix:
let stringOfList f l = 
sepConcat "; " (List.map f l)

bad:
let stringOfList f l = 
List.map (sepConcat "; ") l l
Error: This function has type ('a -> 'b) -> 'a list -> 'b list
       It is applied to too many arguments; maybe you forgot a `;'.


let stringOfList f l = 
List.map (sepConcat "; " l) l
Error: This expression has type string but an expression was expected of type
         'a -> 'b


let stringOfList f l = 
List.map (sepConcat ("; " l)) l
Error: This expression has type string
       This is not a function; it cannot be applied.


let stringOfList f l = 
List.map (sepConcat ("; " l))
Error: This expression has type string
       This is not a function; it cannot be applied.


let stringOfList f l = 
List.map (sepConcat "; " l)
Error: This expression has type string but an expression was expected of type
         'a -> 'b


let stringOfList f l = 
sepConcat "; " List.map f l
Error: This function has type string -> string list -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 stringOfList

fix:
let stringOfList f l = 
"[" ^ sepConcat "; " (List.map f l) ^ "]"

bad:
let stringOfList f l = 
"[" ^ sepConcat "; " (List.map f l) "]"
Error: This function has type string -> string list -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = x in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = x a in
let base = a in
List.fold_left f base fs
Error: Unbound value a


let pipe fs = 
let f a x = x a in
let base = fs in
List.fold_left f base fs
Error: This expression has type 'a but an expression was expected of type
         ('a -> 'a) list
       The type variable 'a occurs inside ('a -> 'a) list



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = () in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = _ in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun x in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

pipe [] 3
Error: This expression has type
         (((((int -> int) -> int -> int) list -> int -> int) ->
           ((int -> int) -> int -> int) list -> int -> int) ->
          (((int -> int) -> int -> int) list -> int -> int) ->
          ((int -> int) -> int -> int) list -> int -> int)
         list -> int
       but an expression was expected of type
         (((((int -> int) -> int -> int) list -> int -> int) ->
           ((int -> int) -> int -> int) list -> int -> int) ->
          (((int -> int) -> int -> int) list -> int -> int) ->
          ((int -> int) -> int -> int) list -> int -> int)
         list -> 'a -> 'b
       Type int is not compatible with type 'a -> 'b 


let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

pipe [] 3
Error: This expression has type
         (((((int -> int) -> int -> int) list -> int -> int) ->
           ((int -> int) -> int -> int) list -> int -> int) ->
          (((int -> int) -> int -> int) list -> int -> int) ->
          ((int -> int) -> int -> int) list -> int -> int)
         list -> int
       but an expression was expected of type
         (((((int -> int) -> int -> int) list -> int -> int) ->
           ((int -> int) -> int -> int) list -> int -> int) ->
          (((int -> int) -> int -> int) list -> int -> int) ->
          ((int -> int) -> int -> int) list -> int -> int)
         list -> 'a -> 'b
       Type int is not compatible with type 'a -> 'b 



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = function e -> e in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun ee in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x a in
let base = fun e in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x a in
let base = fun in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x a in
let base = function e in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x (a) in
let base = [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = [] in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = 3 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fs in
List.fold_left f base fs
Error: This expression has type 'a but an expression was expected of type
         ('a -> 'a) list
       The type variable 'a occurs inside ('a -> 'a) list


let pipe fs = 
let f a x = x a in
let base = base in
List.fold_left f base fs
Error: Unbound value base


let pipe fs = 
let f a x = x a in
let base = base' in
List.fold_left f base fs
Error: Unbound value base'



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  Nil in
List.fold_left f base fs
Error: Unbound constructor Nil



hw3 pipe

fix:
let pipe fs = 
let f a x = fun a -> a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = let x a = a in
let base = fun x -> x in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = fun x -> a in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'c -> 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'c -> 'a


let pipe fs = 
let f a x = fun x -> a in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'c -> 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'c -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x = fun a -> a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> a in
let base = fun x -> a in
List.fold_left f base fs
Error: Unbound value a



hw3 pipe

fix:
let pipe fs = 
let f a x = fun a -> x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         int -> int



hw3 pipe

fix:
let pipe fs = 
let f a x = fun x -> a x in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> x a in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside ('a -> 'c) -> 'c



hw3 pipe

fix:
let pipe fs = 
let f a x = fun x -> fun a -> x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> x x in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'b
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'b


let pipe fs = 
let f a x = fun a -> x x in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'b
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = fun x -> fun a -> a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'b


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = fun x -> fun a -> x (a) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> fun a -> x in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'b -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x = fun x a -> a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> fun x -> x a in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> ('a -> 'b) -> 'b
       The type variable 'a occurs inside ('a -> 'b) -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = fun a -> a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> a in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'c -> 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'c -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x = fun x a -> x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun (x a) -> a in
let base = fun x -> x in
List.fold_left f base fs
Characters 31-32:
  let f a x = fun (x a) -> a in
                  ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw3 pipe

fix:
let pipe fs = 
let f a x = fun x -> x in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = let x a = a in
let base = fun x -> x in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = fun a in
let base = fun x -> x in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = fun x in
let base = fun x -> x in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = fun x a in
let base = fun x -> x in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = fun x a
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x(a) in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a x -> a in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'b -> 'a


let pipe fs = 
let f a x = fun a x -> a in
let base =  in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = fun a x -> a in
let base = 0 in
List.fold_left f base fs
Error: This expression has type int but an expression was expected of type
         'a -> 'b -> 'a


let pipe fs = 
let f a x = fun x a -> a in
let base = 0 in
List.fold_left f base fs
Error: This expression has type int but an expression was expected of type
         'a -> 'b -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = x(a) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x(a) in
let base = let f x = x in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x(a) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x(a) in
let base = fun x -> b in
List.fold_left f base fs
Error: Unbound value b



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = let a = x(a) in
let base = fun x -> x in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = let a = x in x(a) in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'b
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'b


let pipe fs = 
let f a x = let a = x in a(a) in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'b
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'b


let pipe fs = 
let f a x = let a = x in a(x) in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'b
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'b


let pipe fs = 
let f a x = let a = x in x(x) in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'b
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = fun x -> fun a -> x(a) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> fun a in
let base = fun x -> x in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = fun x -> a in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'c -> 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'c -> 'a


let pipe fs = 
let f a x = fun x -> x(a) in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside ('a -> 'c) -> 'c


let pipe fs = 
let f a x = fun x -> x a in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside ('a -> 'c) -> 'c



hw3 pipe

fix:
let pipe fs = 
let f a x = fun a -> fun a -> x(a) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> fun a -> a(a) in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'b
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'b


let pipe fs = 
let f a x = fun a -> fun a -> x(x) in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'b
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> fun x -> f x a in
let base = fun x -> x in
List.fold_left f base fs
Error: Unbound value f


let pipe fs = 
let f a x = fun a -> fun x -> x a in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> ('a -> 'b) -> 'b
       The type variable 'a occurs inside ('a -> 'b) -> 'b


let pipe fs = 
let f a x = fun a -> fun x -> x (a) in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> ('a -> 'b) -> 'b
       The type variable 'a occurs inside ('a -> 'b) -> 'b


let pipe fs = 
let f a x = fun x -> (x a)  in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside ('a -> 'c) -> 'c


let pipe fs = 
let f a x = fun x -> (x a) in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside ('a -> 'c) -> 'c


let pipe fs = 
let f a x = fun x -> (x (a)) in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside ('a -> 'c) -> 'c


let pipe fs = 
let f a x = fun x - in
let base = fun x -> x in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = fun x  in
let base = fun x -> x in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = fun x in
let base = fun x -> x in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x in
let base = a in
List.fold_left f base fs
Error: Unbound value a


let pipe fs = 
let f a x = x in
let base = f x
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x in
let base = f x in 
List.fold_left f base fs
Error: Unbound value x



hw3 pipe

fix:
let pipe fs = 
let f a x = x in
let base = fun x -> fun a -> a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x in
let base = fun x -> fun a in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x(a) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x(x) in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'b
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = x in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a(x) in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 padZero

fix:
let rec padZero l1 l2 = 
(clone 0 (List.length l1 - List.length l2)) @ l2

bad:
let rec padZero l1 l2 = 
(clone 0 List.len l1 - l2)
Error: This function has type 'a -> int -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.


let rec padZero l1 l2 = 
(clone 0 (List.len l1 - l2)) @ smaller
Error: Unbound value List.len


let rec padZero l1 l2 = 
(clone 0 (List.length l1 - l2)) @ smaller
Error: Unbound value smaller


let rec padZero l1 l2 = 
(clone 0 (List.length l1 - l2)) @ l2
Error: This expression has type int but an expression was expected of type
         int list



hw3 pipe

fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = let x' = x' x a in 
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = let a = x(a) in 
let base = fun x -> x in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = let a = x a in 
let base = fun x -> x in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = fun x' -> a x in 
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = let x' = x' (x a) in 
let base = fun x -> x in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = let x' = x' (x a) in x' x a in 
let base = fun x -> x in
List.fold_left f base fs
Error: Unbound value x'



hw3 pipe

fix:
let pipe fs = 
let f a x = fun x' -> x (a x') in 
let base = fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         int -> int


let pipe fs = 
let f a x = fun x' -> x' (a x) in 
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type ('a -> 'a) -> 'a -> 'a
       but an expression was expected of type ('a -> 'a) -> 'a
       The type variable 'a occurs inside 'a -> 'a


let pipe fs = 
let f a x = fun x' -> x' (x a) in 
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 padZero

fix:
let rec padZero l1 l2 = 
if List.length l1 > List.length l2
then (l1, (clone 0 (List.length l1 - List.length l2)) @ l2)
else (clone 0 (List.length l2 - List.length l1) @ l1, l2)

let _ = padZero [9;9] [1;0;0;2]

bad:
let rec padZero l1 l2 = 
if List.length l1 > List.length l2
then (l1, (clone 0 (List.length l1 - List.length l2)) @ l2)
else (clone 0 (List.length l2 - List.length l1) @ l1, l2)

padZero [9;9] [8;8;8]
Error: This expression has type int list * int list
       This is not a function; it cannot be applied.



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
let args = l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list * int list
       but an expression was expected of type ('a -> 'b list) * 'a
       Type int list is not compatible with type 'a -> 'b list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
let args = (l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list * int list
       but an expression was expected of type ('a -> 'b list) * 'a
       Type int list is not compatible with type 'a -> 'b list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
let args = (l1, l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base =  [0], [0]in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = (0, 0) in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = [0] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list
       but an expression was expected of type 'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = [] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type 'b * 'c


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = [a] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value a


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = [] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type 'b * 'c


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = [0, 0] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type (int * int) list
       but an expression was expected of type 'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = [_, _] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = [,] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base = [(), ()] in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type (unit * unit) list
       but an expression was expected of type 'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in
let base =  res in
let args = failwith "to be implemented" in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value res
Hint: Did you mean ref?



hw3 pipe

fix:
let pipe fs = 
let f a x = fun x'-> x (a x') in 
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x' x a -> x (a x') in 
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type
         'a -> ('b -> 'c) -> ('a -> 'b) -> 'c
       The type variable 'a occurs inside ('b -> 'c) -> ('a -> 'b) -> 'c



hw3 pipe

fix:
let pipe fs = 
let f a x = fun x'-> x (a x') in 
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x' a-> x (a x') in 
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> ('a -> 'b) -> 'c
       The type variable 'a occurs inside ('a -> 'b) -> 'c



hw3 ???

fix:
let c = 3

bad:
let c = 3
z + c
Error: This expression has type int
       This is not a function; it cannot be applied.



hw3 ???

fix:
let (x, y) = z

bad:
z + c
Error: This expression has type int * int
       but an expression was expected of type int



hw3 bigAdd

fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let z = (1, 2)

let c = 3

let (x, y) = z in
x + y

let pipe fs = 
let f a x = fun x' -> x (a x') in 
let base = fun x -> x in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x  in
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = 
"[" ^ sepConcat "; " (List.map f l) ^ "]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n = match n with
| n when n <= 0 -> []
| _ -> x :: (clone x (n-1))

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let rec padZero l1 l2 = 
if List.length l1 > List.length l2
then (l1, (clone 0 (List.length l1 - List.length l2)) @ l2)
else (clone 0 (List.length l2 - List.length l1) @ l1, l2)

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

let rec removeZero l = match l with
[] -> []
| h::t ->
if h = 0
then removeZero t
else l

let _ = removeZero [0;0;0;1;0;0;2]

let _ = removeZero [9;9]

let _ = removeZero [0;0;0;0]

let ee = [1;2]

let zz = [3;4]

List.combine ee zz

let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = fun c -> let (s, t) = x in 
let sum = c + s + t in
x (sum / 10) :: (sum mod 10) :: a

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = fun c -> let (s, t) = x in 
let sum = c + s + t in
(sum / 10, (sum mod 10) :: a)
in
let base =  0, [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type
         int list -> int * int -> int -> int * int list
       but an expression was expected of type
         int list -> int * int -> int list
       Type int -> int * int list is not compatible with type int list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = fun c -> let (s, t) = x in 
let sum = c + s + t in
(sum / 10, (sum mod 10) :: a)
in
let base =  0 [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int
       This is not a function; it cannot be applied.


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = fun c -> let (s, t) = x in 
let sum = c + s + t in
(sum / 10, (sum mod 10) :: a)
in
let base =  0, [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type
         int list -> int * int -> int -> int * int list
       but an expression was expected of type
         int list -> int * int -> int list
       Type int -> int * int list is not compatible with type int list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = fun c -> let (s, t) = x in 
let sum = c + s + t in
(sum / 10, (sum mod 10) :: a)
in
let base =  (0, [0]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type
         int list -> int * int -> int -> int * int list
       but an expression was expected of type
         int list -> int * int -> int list
       Type int -> int * int list is not compatible with type int list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = fun c -> let (s, t) = x in 
let sum = c + s + t in
(sum / 10, (sum mod 10) :: a)
in
let base = [0], [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type
         int list -> int * int -> int -> int * int list
       but an expression was expected of type
         int list -> int * int -> int list
       Type int -> int * int list is not compatible with type int list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = fun c -> let (s, t) = x in 
let sum = c + s + t in
(sum / 10, ((sum mod 10) :: a))
in
let base = 0, [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type
         int list -> int * int -> int -> int * int list
       but an expression was expected of type
         int list -> int * int -> int list
       Type int -> int * int list is not compatible with type int list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = fun c -> let (s, t) = x in 
let sum = c + s + t in
(sum / 10, (sum mod 10) :: a)
in
let base = 0, [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type
         int list -> int * int -> int -> int * int list
       but an expression was expected of type
         int list -> int * int -> int list
       Type int -> int * int list is not compatible with type int list 



hw3 ???

fix:
let listerine = [z;z]

bad:
(10 / 2), (8 mod 2) :: listerine
Error: This expression has type (int * int) list
       but an expression was expected of type int list
       Type int * int is not compatible with type int 


[(10 / 2), (8 mod 2)] :: listerine
Error: This expression has type (int * int) list
       but an expression was expected of type (int * int) list list
       Type int * int is not compatible with type (int * int) list 



hw3 ???

fix:
(10/2), (8 mod 2)

bad:
(10 / 2), (8 mod 2) :: listerine
Error: This expression has type (int * int) list
       but an expression was expected of type int list
       Type int * int is not compatible with type int 



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s)
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = fun c -> let (s, t) = x in 
( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a
in
let base = 0, [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type
         (int * int) list -> int * int -> int -> (int * int) list
       but an expression was expected of type
         (int * int) list -> int * int -> (int * int) list
       Type int -> (int * int) list is not compatible with type
         (int * int) list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (s, t) = x in 
( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a
in
let base = 0, [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int * 'a list
       but an expression was expected of type (int * int) list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (s, t) = x in 
( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a
in
let base = 0, [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int * 'a list
       but an expression was expected of type (int * int) list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (s, t) = x in 
( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a
in
let base = 0, [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int * int list
       but an expression was expected of type (int * int) list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (s, t) = x in 
( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a
in
let base = [0, 0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type (int * int) list
       but an expression was expected of type 'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a
in
let base = 0, [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value t


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) ) :: a
in
let base = 0, [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int * 'a
       but an expression was expected of type (int * int) list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) ) :: a
in
let base = 0, [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int * 'a
       but an expression was expected of type (int * int) list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) ) :: a
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int * 'a
       but an expression was expected of type (int * int) list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> c, (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (List.len s == List.len x)
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value List.len


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (List.lenth s == List.length x)
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value List.lenth
Hint: Did you mean length?


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (List.length s == List.length x)
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (List.length s = List.length x)
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ((List.length s) = (List.length x))
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ((List.length s) = (List.length (x)))
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ((List.length a) = (List.length x))
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ((List.length s) = (List.length x))
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ((List.length x) = (List.length s))
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ((h :: t) x = [])
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value h


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (x = [])
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type 'b * 'c


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (x = [(,)])
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error: operator expected.


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (x = [(), ()])
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type 'b * 'c


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (List.length x = 5)
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (List.length a = 5)
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (List.length s = 5)
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (s = [])
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (s != [])
then c :: s
else 
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (s != [])
then c :: s
else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (s = [])
then c :: s
else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if (s)
then c :: s
else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type bool but an expression was expected of type
         'a list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match s with
| [] -> c :: s
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match s with
| [] -> (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match s with
| [] -> ((c + x' + x'') :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match s with
| [] -> ((c + x' + x'' + 0) :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match s with
| [] -> ((c + 0) :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> ((c + 0) :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> ((c) :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
match (c, s) with
| (c, []) -> (c :: s)
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ( (List.length s) = (List.length s) )
then c, c::s
else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s

in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ( (List.length s) = (List.length a) )
then c, c::s
else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s

in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b list
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ( (List.length s) = (List.length x) )
then c, c::s
else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s

in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ( (List.length x) = (List.length x) )
then c, c::s
else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s

in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ( (List.length s) = (List.length l1) )
then c, c::s
else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s

in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ( (List.length s) = (List.length a) )
then c, c::s
else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s

in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b list
       but an expression was expected of type 'c list



hw3 mulByDigit

fix:
let rec mulByDigit i l = 
if i > 0
then bigAdd l (mulByDigit (i - 1) l)
else [0]

bad:
let rec mulByDigit i l = 
if i > 0
then bigAdd l (mulByDigit (i - 1) l)
else bigAdd [0]
Error: This expression has type int list -> int list
       but an expression was expected of type int list



hw3 bigMul

fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = fun x' -> x (a x') in 
let base = fun x -> x in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x  in
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = 
"[" ^ sepConcat "; " (List.map f l) ^ "]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n = match n with
| n when n <= 0 -> []
| _ -> x :: (clone x (n-1))

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let rec padZero l1 l2 = 
if List.length l1 > List.length l2
then (l1, (clone 0 (List.length l1 - List.length l2)) @ l2)
else (clone 0 (List.length l2 - List.length l1) @ l1, l2)

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

let rec removeZero l = match l with
[] -> []
| h::t ->
if h = 0
then removeZero t
else l

let _ = removeZero [0;0;0;1;0;0;2]

let _ = removeZero [9;9]

let _ = removeZero [0;0;0;0]

let ee = [1;2]

let zz = [3;4]

List.combine ee zz

let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (x', x'') = x in 
let (c, s) = a in
if ( (List.length s) = ((List.length l1) - 1) )
then c, ((c + x' + x'') / 10) :: ((c + x' + x'') mod 10) :: s
else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

let rec mulByDigit i l = 
if i > 0
then bigAdd l (mulByDigit (i - 1) l)
else [0]

let _ = mulByDigit 9 [9;9;9;9]

let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let () =  
let (i', l') = x in
match i' with
| [] -> l'
| h :: t -> t, bigAdd( (mulByDigit h l') l') in
let base = (h, l1) in
let args = (List.rev l2), l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = failwith "to be implemented" in
let base = (1, []) in
let args = (List.rev l2), l1 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a list * 'b
       but an expression was expected of type 'c list


let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let i' l' = a in
match i with
[] -> a
| h :: t -> mulByDigit h l' :: a
Error: Syntax error


let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let i' l' = a in
match i with
[] -> a
| h :: t -> (mulByDigit h l') :: a
Error: Syntax error


let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let i' l' = a in
match i with
[] -> a
| h :: t -> (mulByDigit h l'), t
Error: Syntax error


let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let i' l' = a in
match i with
[] -> a
| h :: t -> ((mulByDigit h l'), t)
Error: Syntax error


let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let i' l' = a in
match i with
[] -> 
| h :: t -> bigAdd( (mulByDigit h l'), l')
Error: Syntax error


let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let i' l' = a in
match i with
[] -> l'
| h :: t -> bigAdd( (mulByDigit h l'), l')
Error: Syntax error


let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let i' l' = a in
match i with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l'), l')
Error: Syntax error


let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let i', l' = a in
match i with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l'), l')
Error: Syntax error


let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let (i', l') = a in
match i with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l'), l')
Error: Syntax error


let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let (i', l') = a in
match i' with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l'), l')
Error: Syntax error


let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let (i', l') = a in
match i' with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l'), l')
Error: Syntax error


let base = (1, l1) in
let args = (List.rev l2), l1 in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value l1


let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let (i', l') = a in
match i with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l'), l')
Error: Syntax error


let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let (i', l') = a in
match i with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l') l')
Error: Syntax error


let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let (i', l') = a in
match i with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l') l') in
let base = (1, l1) in
let args = (List.rev l2), l1 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list
       This is not a function; it cannot be applied.


let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let (i', l') = a in
match i with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l'), l') in
let base = (1, l1) in
let args = (List.rev l2), l1 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a * 'b
       but an expression was expected of type int list


let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let (i', l') = a in
match i with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l') l') in
let base = (1, l1) in
let args = (List.rev l2), l1 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list
       This is not a function; it cannot be applied.


let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let (i', l') = a in
match i' with
| [] -> l'
| h :: t -> bigAdd( (mulByDigit h l') l') in
let base = (1, l1) in
let args = (List.rev l2), l1 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list
       This is not a function; it cannot be applied.


let bigMul l1 l2 = 
let f a x = let (i, l) = x in
let (i', l') = a in
match i' with
| [] -> l'
| h :: t -> t, bigAdd( (mulByDigit h l') l') in
let base = (1, l1) in
let args = (List.rev l2), l1 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list * 'a
       but an expression was expected of type int list



hw3 bigMul

fix:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1, a')
| h :: t -> bigAdd (mulByDigit (h l1')) a' in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list -> int list
       but an expression was expected of type int list


let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1, a')
| h :: t -> bigAdd ((mulByDigit (h l1')) a)' in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
Error: Syntax error


let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1, a')
| h :: t -> bigAdd ((mulByDigit (h l1')) a') in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list -> int list
       but an expression was expected of type 'a * int list


let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1, a')
| h :: t -> bigAdd (mulByDigit (h l1') a') in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list -> int list
       but an expression was expected of type 'a * int list


let bigMul l1 l2 = 

let f a x = let (l1', a') = x in
match a with
| [] -> (l1, a')
| h :: t -> bigAdd (mulByDigit (h l1') a') in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list -> int list
       but an expression was expected of type 'a * int list


let bigMul l1 l2 = 

let f a x = let (l1', a') = x in
match a with
| [] -> (l1, a')
| h :: t -> bigAdd (mulByDigit (h l1') a') in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list -> int list
       but an expression was expected of type 'a * int list


let bigMul l1 l2 = 

let f a x = let (l1', a') = x in
match a with
| [] -> (l1', a')
| h :: t -> bigAdd (mulByDigit (h l1') a') in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list -> int list
       but an expression was expected of type 'a * int list


let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> bigAdd (mulByDigit (h l1') a') in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list -> int list
       but an expression was expected of type 'a * int list


let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> bigAdd (mulByDigit (h l1') a') in
let base = (l1, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list -> int list
       but an expression was expected of type 'a * int list


let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> bigAdd (mulByDigit h (l1') a') in
let base = (l1, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
Error: This function has type int -> int list -> int list
       It is applied to too many arguments; maybe you forgot a `;'.


let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> bigAdd (mulByDigit h (l1')) a'
Error: Syntax error


let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> li', bigAdd (mulByDigit h (l1')) a'
Error: Syntax error


let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> li', (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value li'
Hint: Did you mean l1'?



hw3 bigMul

fix:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let _ = bigMul [9;9;9;9] [9;9;9;9]
Error: This expression has type int but an expression was expected of type
         int list


let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]
Error: This expression has type int but an expression was expected of type
         int list



hw3 bigMul

fix:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let _ = bigMul [9;9;9;9] [9;9;9;9]
Error: This expression has type int but an expression was expected of type
         int list


let _ = bigMul [9;9;9;9] [9;9;9;9]
Error: This expression has type int but an expression was expected of type
         int list


let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]
Error: This expression has type int but an expression was expected of type
         int list



hw3 bigMul

fix:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, [0]) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let _ = bigMul [9;9;9;9] [9;9;9;9]
Error: This expression has type int but an expression was expected of type
         int list


let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, 0) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list * int
       but an expression was expected of type int list * int list
       Type int is not compatible with type int list 



hw3 bigMul

fix:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, [0]) in
let args = (List.hd (List.rev l2)) in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, [0]) in
let args = (List.hd (List.rev List.hd l2)) in
let (_, res) = List.fold_left f base args in
res
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 bigMul

fix:
let bigMul l1 l2 = 

let f a x = let (l1', a') = a in
match x with
| [] -> (l1', a')
| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in
let base = (l1, []) in
let args = (List.hd (List.rev l2)) in
let (_, res) = List.fold_left f base args in
res

bad:
let _ = bigMul [9;9;9;9] [9;9;9;9]
Error: This expression has type int but an expression was expected of type
         int list list


let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]
Error: This expression has type int but an expression was expected of type
         int list list



hw2 assoc

fix:
let assoc (d,k,l) = 
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t
| _ -> 0
in
helper d k l

bad:
let assoc (d,k,l) = 
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki tt
| _ -> 0
in
helper d k l
Error: This expression has type 'a list
       but an expression was expected of type 'a list list
       The type variable 'a occurs inside 'a list



hw2 assoc

fix:
let assoc (d,k,l) = 
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t
| _ -> 0
in
helper d k l

bad:
let assoc (d,k,l) = 
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t
| _ -> 0
Error: Syntax error


| _ -> 0
Error: Syntax error


let assoc (d,k,l) = 
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t
| _ -> 0
Error: Syntax error


| _ -> 0
in
helper d k l
Error: Syntax error


let assoc (d,k,l) = 
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t
| _ -> 0
Error: Syntax error


let assoc (d,k,l) = 
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t
| _ -> 0
Error: Syntax error


in
helper d k l
Error: Syntax error



hw2 assoc

fix:
let assoc (d,k,l) = 
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t

| _ -> 0
in
helper d k l

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])
Error: This expression has type 'a * 'b
       but an expression was expected of type string list


let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])
Error: This expression has type 'a * 'b
       but an expression was expected of type string list


let assoc (d,k,l) = 
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t
Error: Syntax error


| _ -> 0
in
helper d k l
Error: Syntax error



hw2 assoc

fix:
let assoc (d,k,l) = 
match l with
| h::t -> h

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])
Error: This expression has type 'a * 'b
       but an expression was expected of type string list


let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])
Error: This expression has type 'a * 'b
       but an expression was expected of type string list



hw2 assoc

fix:
let rec assoc (d,k,l) = 
match l with
| h::t -> let (name,age) = h in
if name = k then d
else assoc(d,k,t)
| _-> d

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let assoc (d,k,l) = 
match l with
| h::t ->
let rec helper di ki li = 
let (name,age) = li in
if name = ki then di
else 
match li with
| h::t -> helper di ki t
| _-> di
in
helper d k h
Error: This pattern matches values of type 'a list
       but a pattern was expected which matches values of type 'b * 'c


let assoc (d,k,l) = 
match l with
| h::t -> let (name,age) = h in
if name = k then d
else assoc(d,k,t)
| _-> d

in
helper d k h
Error: This expression has type ('a * 'b) list
       but an expression was expected of type 'c list list
       Type 'a * 'b is not compatible with type 'c list 


let assoc (d,k,l) = 
match l with
| h::t -> let (name,age) = h in
if name = k then d
else assoc(d,k,t)
| _-> d

in
helper d k h
Error: This expression has type ('a * 'b) list
       but an expression was expected of type 'c list list
       Type 'a * 'b is not compatible with type 'c list 



hw2 wwhile

fix:
let rec wwhile (f,b) = let func = f b in
let (value,boo) = func in
if boo then wwhile (f,value)
else value

bad:
let rec wwhile (f,b) = let func = f b in
let (value,boo) = func in
if boo then wwhile (func, boo)
else value
Error: This expression has type 'a * bool
       but an expression was expected of type 'b -> 'a * bool


let rec wwhile (f,b) = let func = f b in
let (value,boo) = func in
if boo then wwhile (func)
else value
Error: This expression has type 'a * bool
       but an expression was expected of type ('b -> 'a * bool) * 'b


let rec wwhile (f,b) = let func = f b in
let (value,boo) = func in
if boo then wwhile (f)
else value
Error: This expression has type 'a -> 'b * bool
       but an expression was expected of type ('a -> 'b * bool) * 'a



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)

bad:
let fixpoint (f,b) = wwhile (let xx = x*x*x in (xx, xx < 100),b)
Error: Unbound value x


let fixpoint (f,b) = wwhile (let xx = f b in (xx, xx = b),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile ((f b, xx = b),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile ((let xx = f b, xx = b),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ((let xx = (f b), xx = b),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ((f b, xx = b),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile (((let xx = f b), xx = b),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile (((let xx = (f b), xx = b),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ((let xx = (f b), xx = b),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile (let xx = x*x*x in (xx, xx < 100),b)
Error: Unbound value x


let fixpoint (f,b) = wwhile (let xx = b*b*b in (xx, xx < 100),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile (let f x = let xx = x*x*x in (xx, xx < 100),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile (let f b = let xx = x*x*x in (xx, xx < 100),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile (let xx = x*x*x in (xx, xx < 100),b)
Error: Unbound value x


let fixpoint (f,b) = wwhile ((b*b*b, b*b*b < 100),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile ((b*b*b, b < 100),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile ((f b, false),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile ((let f b = let xx = f b in (xx, xx = b)),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ((let f b = let xx = b*b*b in (xx, xx = b)),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ((let f b = let xx = b*b*b in (xx, xx = b)),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ((let f b = let xx = b*b*b in xx, xx = b),b)
Error: Syntax error: operator expected.



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((let d x = let xx = f x in (xx, xx = b) in d),b)

bad:
let fixpoint (f,b) = wwhile ((let d x = let xx = f x in (xx, xx = b) in d b),b)
Error: This expression has type 'a * bool
       but an expression was expected of type 'b -> 'b * bool



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let fixpoint (f,b) = wwhile ((let g x = let xx = f x in (xx, xx = b) in g),b)
Error: Unbound value wwhile


let fixpoint (f,b) = wwhile ((let g x = let xx = f x in (xx, xx = b) in g),b)
Error: Unbound value wwhile


let fixpoint (f,b) = wwhile ((let g x = let xx = (f x) in (xx, xx = b) in g),b)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let fixpoint (f,b) = wwhile ((let g x = (f x, x = fx) in g,b)
Characters 28-29:
  let fixpoint (f,b) = wwhile ((let g x = (f x, x = fx) in g,b);;
                              ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let fixpoint (f,b) = wwhile ((let g x = (f x, x = fx) in g),b)
Characters 28-29:
  let fixpoint (f,b) = wwhile ((let g x = (f x, x = fx) in g,b);;
                              ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let fixpoint (f,b) = wwhile ((let g x = (f x, x = f x) in g),b)
Error: Unbound value wwhile


let fixpoint (f,b) = wwhile ((let g x = let d = f x in (d, x = d) in g),b)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let fixpoint (f,b) = wwhile ((let g x = let d = (f b) in (d, x = d) in g),b)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let fixpoint (f,b) = wwhile ((let g x = let d = let (f b) in (d, x != d) in g),b)
Error: Unbound value wwhile


let fixpoint (f,b) = wwhile ((let g x = let d = (f b) in (d, x != d) in g),b)
Characters 52-53:
  let fixpoint (f,b) = wwhile ((let g x = let d = let (f b) in (d, x != d) in g),b);;
                                                      ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let fixpoint (f,b) = wwhile ((let g x = let d = (f x) in (d, x = d) in g),b)
Error: Unbound value wwhile


let fixpoint (f,b) = wwhile ((let g x = let d = (f x) in (d, x = d) in g),b)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let rec assoc (d,k,l) = 
match l with
| h::t -> let (name,age) = h in
if name = k then age
else assoc(d,k,t)
| _-> d

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t ->  
let seen' = if List.mem h seen then seen else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) = let func = f b in
let (value,boo) = func in
if boo then wwhile (f,value)
else value

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) = wwhile ((let g x = (f x, x != f x) in g),b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let _ = fixpoint (collatz, 9001)
Error: Unbound value fixpoint



hw2 exprToString

fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

let _ = exprToString sampleExpr1

bad:
^exprToString e1^"<"^exprToString e2^" ? "^exprToString e3^" : "^exprToString e4
Error: Syntax error


let rec exprToString e = match e with 
VarX = "x"
|VarY = "y"
|Sine(e) = "sin (pi*"^exprToString e^")"
|Cosine(e) = "cos (pi*"^exprToString e^")"
|Average(e1,e2) = "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) = exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) = "("^exprToString e1^"<"^exprToString e2^" ? "^exprToString e3^" : "^exprToString e4
Error: Syntax error


let rec exprToString e = match e with 
|VarX = "x"
|VarY = "y"
|Sine(e) = "sin (pi*"^exprToString e^")"
|Cosine(e) = "cos (pi*"^exprToString e^")"
|Average(e1,e2) = "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) = exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) = "("^exprToString e1^"<"^exprToString e2^" ? "^exprToString e3^" : "^exprToString e4
Error: Syntax error


let rec exprToString e = match e with 
|VarX = x
|VarY = "y"
|Sine(e) = "sin (pi*"^exprToString e^")"
|Cosine(e) = "cos (pi*"^exprToString e^")"
|Average(e1,e2) = "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) = exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) = "("^exprToString e1^"<"^exprToString e2^" ? "^exprToString e3^" : "^exprToString e4
Error: Syntax error


let rec exprToString e = 
match e with 
|VarX = "x"
|VarY = "y"
|Sine(e) = "sin(pi*"^exprToString e^")"
|Cosine(e) = "cos(pi*"^exprToString e^")"
|Average(e1,e2) = "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) = exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) = "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4
Error: Syntax error


let rec exprToString e = 
match e with 
|VarX e = "x"
|VarY e = "y"
|Sine(e) = "sin(pi*"^exprToString e^")"
|Cosine(e) = "cos(pi*"^exprToString e^")"
|Average(e1,e2) = "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) = exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) = "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4
Error: Syntax error


let rec exprToString ex = 
match ex with 
|VarX e = "x"
|VarY e = "y"
|Sine(e) = "sin(pi*"^exprToString e^")"
|Cosine(e) = "cos(pi*"^exprToString e^")"
|Average(e1,e2) = "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) = exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) = "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4
Error: Syntax error


let rec exprToString ex = 
match ex with 
|VarX e = "x"
|VarY e = "y"
|Sine(e) = "sin(pi*"^exprToString e^")"
|Cosine(e) = "cos(pi*"^exprToString e^")"
|Average(e1,e2) = "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) = exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) = "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4
Error: Syntax error


let rec exprToString ex = 
match ex with 
(*|VarX = "x"
|VarY = "y"*)
|Sine(e) = "sin(pi*"^exprToString e^")"
|Cosine(e) = "cos(pi*"^exprToString e^")"
|Average(e1,e2) = "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) = exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) = "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4
Error: Syntax error


let rec exprToString ex = 
match ex with 
|VarX = ("x")
|VarY = "y"
|Sine(e) = "sin(pi*"^exprToString e^")"
|Cosine(e) = "cos(pi*"^exprToString e^")"
|Average(e1,e2) = "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) = exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) = "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4
Error: Syntax error


let rec exprToString ex = 
match ex with 
|VarX -> ("x")
|VarY -> "y"
|Sine(e) -> "sin(pi*"^exprToString e^")"
|Cosine(e) -> "cos(pi*"^exprToString e^")"
|Average(e1,e2) -> "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) -> exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) -> "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4
Error: Syntax error



hw2 eval

fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr,0.5,0.2)

bad:
let rec eval (e,x,y) = 
match e with 
|VarX -> x
|VarY -> y
|Sine(e) -> sin(pi *. eval (e,x,y))
|Cosine(e) -> cos(pi *. eval (e,x,y))
|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0
|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))
|Thresh (e1,e2,e3,e4) -> 
if eval (e1,x,y) < eval (e2,x,y) 
then eval (e3,x,y)
else eval (e4,x,y)
Error: Syntax error



hw2 build

fix:
let rec build (rand, depth) = 
if depth=0 then buildX() else
let randNum = rand 0 5 in
let depth = depth - 1 in
match randNum with 
|0 -> buildSine(build(makeRand(5,16), depth))
|1 -> buildCosine(build(rand, depth))
|2 -> buildTimes(build(rand, depth),build(rand, depth))
|3 -> buildAverage(build(rand, depth),build(rand, depth))
|_ -> buildY()

bad:
let random = makeRand(5,16) in
let _ = build(random,5)
Error: This expression has type int * int -> int
       but an expression was expected of type int -> int -> int
       Type int * int is not compatible with type int 


let random = makeRand(5,16) in
let _ = build(random,5)
Error: Syntax error


let random = makeRand(5,16) in
let _ = build(random,5)
Error: Syntax error


let random = makeRand(5,16) in
build(random,5)
Error: Syntax error


Let _ = let random = makeRand(5,16) in
build(random,5)
Error: This expression has type int * int -> int
       but an expression was expected of type int -> int -> int
       Type int * int is not compatible with type int 


let _ = let random = makeRand(5,16) in
build(random,5)
Error: Syntax error


let rec build (rand, depth) = 
if depth=0 then buildX() else
let randNum = rand 0 5 in
let depth = depth - 1 in
match randNum with 
|0 -> buildSine(build(rand, depth))
|1 -> buildCosine(build(rand, depth))
|2 -> buildTimes(build(rand, depth),build(rand, depth))
|3 -> buildAverage(build(rand, depth),build(rand, depth))
|_ -> buildY()
Error: This expression has type int * int -> int
       but an expression was expected of type int -> int -> int
       Type int * int is not compatible with type int 



hw2 build

fix:
let rec assoc (d,k,l) = 
match l with
| h::t -> let (name,age) = h in
if name = k then age
else assoc(d,k,t)
| _-> d

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t ->  
let seen' = if List.mem h seen then seen else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) = let func = f b in
let (value,boo) = func in
if boo then wwhile (f,value)
else value

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) = wwhile ((let g x = (f x, x != f x) in g),b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

type expr = 
VarX
| VarY
| Sine     of expr
| Cosine   of expr
| Average  of expr * expr
| Times    of expr * expr
| Thresh   of expr * expr * expr * expr

let rec exprToString ex = 
match ex with 
|VarX -> "x"
|VarY -> "y"
|Sine(e) -> "sin(pi*"^exprToString e^")"
|Cosine(e) -> "cos(pi*"^exprToString e^")"
|Average(e1,e2) -> "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) -> exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) -> "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4^")"

let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

let _ = exprToString sampleExpr1

let buildX()                       = VarX

let buildY()                       = VarY

let buildSine(e)                   = Sine(e)

let buildCosine(e)                 = Cosine(e)

let buildAverage(e1,e2)            = Average(e1,e2)

let buildTimes(e1,e2)              = Times(e1,e2)

let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)

let pi = 4.0 *. atan 1.0

let rec eval (e,x,y) = 
match e with 
|VarX -> x
|VarY -> y
|Sine(e) -> sin(pi *. eval (e,x,y))
|Cosine(e) -> cos(pi *. eval (e,x,y))
|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0
|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))
|Thresh (e1,e2,e3,e4) -> 
if eval (e1,x,y) < eval (e2,x,y) 
then eval (e3,x,y)
else eval (e4,x,y)

let sampleExpr =
buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(
buildX()),buildTimes(buildCosine (buildCosine (buildAverage
(buildTimes (buildY(),buildY()),buildCosine (buildX())))),
buildCosine (buildTimes (buildSine (buildCosine
(buildY())),buildAverage (buildSine (buildX()), buildTimes
(buildX(),buildX()))))))),buildY())))

let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))

let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr,0.5,0.2)

let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let rec build (rand, depth) = 
if depth=0 then buildX() else
let randNum = rand 0 5 in
let depth = depth - 1 in
match randNum with 
|0 -> buildSine(build(rand, depth))
|1 -> buildCosine(build(rand, depth))
|2 -> buildTimes(build(rand, depth),build(rand, depth))
|3 -> buildAverage(build(rand, depth),build(rand, depth))
|_ -> buildY()

bad:
let rec build (rand, depth) = 
if depth=0 then buildX() else
let randNum = rand 0 5 in
let depth = depth - 1 in
match randNum with 
|0 -> buildSine(build(makeRand(5,16), depth))
|1 -> buildCosine(build(makeRand(5,16), depth))
|2 -> buildTimes(build(makeRand(5,16), depth),build(makeRand(5,16), depth))
|3 -> buildAverage(build(makeRand(5,16), depth),build(makeRand(5,16), depth))
|_ -> buildY()
Error: This expression has type int * int -> int
       but an expression was expected of type int -> int -> int
       Type int * int is not compatible with type int 



hw2 exprToString

fix:
let rec exprToString ex = 
match ex with 
|VarX -> "x"
|VarY -> "y"
|Sine(e) -> "sin(pi*"^exprToString e^")"
|Cosine(e) -> "cos(pi*"^exprToString e^")"
|Average(e1,e2) -> "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) -> exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) -> "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4^")"
|MyExpr1 (e1,e2,e3) -> "(sqrt("^exprToString e1^")*sqrt("^exprToString e2^")*"^exprToString e3^")"
|MyExpr2 (e) -> "halve("^exprToString^")"

bad:
let rec exprToString ex = 
match ex with 
|VarX -> "x"
|VarY -> "y"
|Sine(e) -> "sin(pi*"^exprToString e^")"
|Cosine(e) -> "cos(pi*"^exprToString e^")"
|Average(e1,e2) -> "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) -> exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) -> "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4^")"
|MyExpr1 (e1,e2,e3) -> "(sqrt("^exprToString e1^")*sqrt("^exprToString e2^")*"^exprToString e3^")"
Error: This expression has type string
       This is not a function; it cannot be applied.



hw2 exprToString

fix:
let sampleExpr1 = MyExpr2(MyExpr1(Varx,VarY,Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))))

let _ = exprToString sampleExpr1

bad:
let rec exprToString ex = 
match ex with 
|VarX -> "x"
|VarY -> "y"
|Sine(e) -> "sin(pi*"^exprToString e^")"
|Cosine(e) -> "cos(pi*"^exprToString e^")"
|Average(e1,e2) -> "(("^exprToString e1^" + "^exprToString e2^")/2)"
|Times (e1,e2) -> exprToString e1^"*"^exprToString e2
|Thresh (e1,e2,e3,e4) -> "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4^")"
|MyExpr1 (e1,e2,e3) -> "(sqrt("^exprToString e1^")*sqrt("^exprToString e2^")*"^exprToString e3^")"
|MyExpr2 (e) -> "halve("^exprToString e^")"
Error: This expression has type expr -> string
       but an expression was expected of type string



hw2 eval

fix:
let rec eval (e,x,y) = 
match e with 
|VarX -> x
|VarY -> y
|Sine(e) -> sin(pi *. eval (e,x,y))
|Cosine(e) -> cos(pi *. eval (e,x,y))
|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0
|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))
|Thresh (e1,e2,e3,e4) -> 
if eval (e1,x,y) < eval (e2,x,y) 
then eval (e3,x,y)
else eval (e4,x,y)
|MyExpr1(e1,e2,e3) -> cos(pi*.eval (e1,x,y))*.sin(pi*.eval (e2,x,y))*.eval(e3,x,y)
|MyExpr2(e) -> sin(pi*.eval (e,x,y)*.0.5)

bad:
let rec eval (e,x,y) = 
match e with 
|VarX -> x
|VarY -> y
|Sine(e) -> sin(pi *. eval (e,x,y))
|Cosine(e) -> cos(pi *. eval (e,x,y))
|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0
|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))
|Thresh (e1,e2,e3,e4) -> 
if eval (e1,x,y) < eval (e2,x,y) 
then eval (e3,x,y)
else eval (e4,x,y)
|MyExpr1(e1,e2,e3) -> cos(pi*.eval (e1,x,y))*.sin(pi*.eval (e2,x,y))*.eval(e3,x,y)
|MyExpr2(e) -> Sine(eval (e,x,y)*.0.5)
Error: This expression has type expr but an expression was expected of type
         float


let rec eval (e,x,y) = 
match e with 
|VarX -> x
|VarY -> y
|Sine(e) -> sin(pi *. eval (e,x,y))
|Cosine(e) -> cos(pi *. eval (e,x,y))
|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0
|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))
|Thresh (e1,e2,e3,e4) -> 
if eval (e1,x,y) < eval (e2,x,y) 
then eval (e3,x,y)
else eval (e4,x,y)
|MyExpr1(e1,e2,e3) -> cos(pi*.eval (e1,x,y))*.sin(pi*.eval (e2,x,y))*.eval(e3,x,y)
|MyExpr2(e) -> sin(pi*.eval (e,x,y)*.0.5)
Error: This expression has type expr but an expression was expected of type
         float



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a + x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = ( +. ) in
let base = 0 in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         float -> float -> float


let sqsum xs = 
let f a x = ( +. ) in
let base = 0. in
List.fold_left f base xs
Error: This expression has type float but an expression was expected of type
         float -> float -> float


let sqsum xs = 
let f a x = ( +. ) in
let base = 0. in
List.fold_left f base xs
Error: This expression has type float but an expression was expected of type
         float -> float -> float


let sqsum xs = 
let f a x = ( + ) in
let base = 0 in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         int -> int -> int



hw3 pipe

fix:
let pipe fs = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
List.fold_left f base fs

let _ = pipe [] 3

bad:
let pipe fs = 
let f a x = List.map f x in
let base = 0 in
List.fold_left f base fs
Error: Unbound value f


let pipe fs = 
let f a x = List.map x in
let base = 0 in
List.fold_left f base fs
Error: This expression has type int but an expression was expected of type
         'a list -> 'b list


let pipe fs = 
let f a x = List.map x -> x in
let base = 0 in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = List.map x in
let base = 0 in
List.fold_left f base fs
Error: This expression has type int but an expression was expected of type
         'a list -> 'b list


let pipe fs = 
let f a x = List.map x in
let base = 3 in
List.fold_left f base fs
Error: This expression has type int but an expression was expected of type
         'a list -> 'b list



hw3 ???

fix:
let f x = 1

let f x = if x<2 then 1 else (x * f(x-1))

let res = f 5

bad:
let res = (x, y)
Error: Unbound value x



hw3 pipe

fix:
let pipe fs = 
let f a x = x in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = x a in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = x in
let base = x in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = x in
let base = x in
List.fold_left f base fs
Error: Unbound value x



hw3 pipe

fix:
let pipe fs = 
let f a x = fs in
let base = fs in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let pipe fs = 
let f a x = x in
let base = x -> x in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = base in
let base = base in
List.fold_left f base fs
Error: Unbound value base


let pipe fs = 
let f a x = x a in
let base = base in
List.fold_left f base fs
Error: Unbound value base


let pipe fs = 
let f a x = f x a in
let base = f x a in
List.fold_left f base fs
Error: This function has type int -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let pipe fs = 
let f a x = x a in
let base = f x a in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = a' in
let base = a' in
List.fold_left f base fs
Error: Unbound value a'



hw3 pipe

fix:
let pipe fs = 
let f a x = fun x -> x  in
let base = fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.


let pipe fs = 
let f a x = f a x in
let base = 3 in
List.fold_left f base fs
Error: This function has type int -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let pipe fs = 
let f a x = pipe a x in
let base = 3 in
List.fold_left f base fs
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.


let pipe fs = 
let f a x = pipe a x in
let base = 3 in
List.fold_left f base fs
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.


let pipe fs = 
let f a x = pipe fs in
let base = 3 in
List.fold_left f base fs
Error: This expression has type int but an expression was expected of type
         'a list


let pipe fs = 
let f a x = pipe base  in
let base = 3 in
List.fold_left f base fs
Error: Unbound value base


let pipe fs = 
let f a x = pipe fs  in
let base = 3 in
List.fold_left f base fs
Error: This expression has type int but an expression was expected of type
         'a list



hw3 pipe

fix:
let pipe fs = 
let f a x = fun a -> x  in
let base = fun a -> a in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         int -> int


let pipe fs = 
let f a x = fun a -> x  in
let base = fun a -> x in
List.fold_left f base fs
Error: Unbound value x



hw3 pipe

fix:
let pipe fs = 
let f a x = fun a -> a  in
let base = fun a -> a in
List.fold_left f base fs

let _ = pipe [] 3

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         int -> int



hw3 pipe

fix:
let pipe fs = 
let f a x = fun a -> x  in
let base = fun a -> a in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> x  in
let base = fun a -> x in
List.fold_left f base fs
Error: Unbound value x



hw3 pipe

fix:
let pipe fs = 
let f a x = pipe [] in
let base = pipe [] in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'a


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'a


let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x = fun a -> x in
let base = pipe [] in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'a


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'a


let pipe fs = 
let f a x = x -> a in
let base = pipe [] in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = a -> x in
let base = pipe [] in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = fun x -> a in
let base = pipe [] in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'c -> 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'c -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = pipe [] in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'a


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         int -> int


let pipe fs = 
let f a x = fun x a in
let base = pipe [] in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = a x in
let base = pipe [] in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'a


let pipe fs = 
let f a x = x a in
let base = x a in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = x a in
let base = fs in
List.fold_left f base fs
Error: This expression has type 'a but an expression was expected of type
         ('a -> 'a) list
       The type variable 'a occurs inside ('a -> 'a) list



hw3 pipe

fix:
let pipe fs = 
let f a x = fun x a-> a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun p -> p in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = fun x -> x a in
let base = fun p -> p in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside ('a -> 'c) -> 'c


let pipe fs = 
let f a x = fun x a-> x in
let base = fun p -> p in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'b -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'a


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x = fun x a -> x a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun d x -> g in
let base = fun p -> p in
List.fold_left f base fs
Error: Unbound value g


let pipe fs = 
let f a x = fun d x -> a in
let base = fun p -> p in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'c -> 'd -> 'a


let pipe fs = 
let f a x = fun x a -> d in
let base = fun p -> p in
List.fold_left f base fs
Error: Unbound value d


let pipe fs = 
let f a x = fun x a -> fun x a in
let base = fun p -> p in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = fun x a -> x a in
let base = pipe [] in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'b


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = fun x a -> fun d -> d in
let base = fun p -> p in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'b



hw3 pipe

fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let f x = 1

let f x = if x<2 then 1 else (x * f(x-1))

let res = f 5

let pipe fs = 
let f a x = fun p -> p

let base = pipe [] in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'b -> 'b


let pipe fs = 
let f a x = fun a x -> fun d -> d
Error: Syntax error


let base = fun p -> p in
List.fold_left f base fs
Error: This expression has type int -> int
       but an expression was expected of type int -> 'a -> int
       Type int is not compatible with type 'a -> int 


let pipe fs = 
let f a x = x a
Error: Syntax error


let base = fun p -> p in
List.fold_left f base fs
Error: This expression has type int -> int
       but an expression was expected of type int -> 'a -> int
       Type int is not compatible with type 'a -> int 


let pipe fs = 
let f a x = a x
Error: Syntax error


let base = fun p -> p in
List.fold_left f base fs
Error: This expression has type int -> int
       but an expression was expected of type int -> 'a -> int
       Type int is not compatible with type 'a -> int 


let pipe fs = 
let f a x = fun a x -> a x
Error: Syntax error


let base = fun p -> p in
List.fold_left f base fs
Error: This expression has type int -> int
       but an expression was expected of type int -> 'a -> int
       Type int is not compatible with type 'a -> int 


let pipe fs = 
let f a x = a x
Error: Syntax error


let base = fun p -> p in
List.fold_left f base fs
Error: This expression has type int -> int
       but an expression was expected of type int -> 'a -> int
       Type int is not compatible with type 'a -> int 


let pipe fs = 
let f a x = a x
Error: Syntax error


let base = (fun p -> p) in
List.fold_left f base fs
Error: This expression has type int -> int
       but an expression was expected of type int -> 'a -> int
       Type int is not compatible with type 'a -> int 


let pipe fs = 
let f a x = fun p -> p
Error: Syntax error


let base = pipe [] in
List.fold_left f base fs
Error: This expression has type int -> int
       but an expression was expected of type int -> 'a -> int
       Type int is not compatible with type 'a -> int 


let pipe fs = 
let f a x = fun p -> p
Error: Syntax error


let base = pipe [] in
List.fold_left f base fs
Error: This expression has type int -> int
       but an expression was expected of type int -> 'a -> int
       Type int is not compatible with type 'a -> int 


let pipe fs = 
let f a x = x
Error: Syntax error


let base = pipe [] in
List.fold_left f base fs
Error: This expression has type int -> int
       but an expression was expected of type int -> 'a -> int
       Type int is not compatible with type 'a -> int 


let pipe fs = 
let f a x = a
Error: Syntax error


let base = pipe [] in
List.fold_left f base fs
Error: This expression has type int -> int
       but an expression was expected of type int -> 'a -> int
       Type int is not compatible with type 'a -> int 



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a
Error: Syntax error


let base = pipe [] in
List.fold_left f base fs
Error: This expression has type int -> int
       but an expression was expected of type int -> 'a -> int
       Type int is not compatible with type 'a -> int 


let pipe fs = 
let f a x = a x
Error: Syntax error


let pipe fs = 
let f a x = a x
Error: Syntax error


let base = pipe [] in
List.fold_left f base fs
Error: This expression has type int -> int
       but an expression was expected of type int -> 'a -> int
       Type int is not compatible with type 'a -> int 


let pipe fs = 
let f a x = a x
Error: Syntax error


let pipe fs = 
let f a x = fun a x -> a x
Error: Syntax error


let base = fun d -> d in
List.fold_left f base fs
Error: This expression has type int -> int
       but an expression was expected of type int -> 'a -> int
       Type int is not compatible with type 'a -> int 


let pipe fs = 
let f a x = fun a x -> x a
Error: Syntax error


let base = fun d -> d in
List.fold_left f base fs
Error: This expression has type int -> int
       but an expression was expected of type int -> 'a -> int
       Type int is not compatible with type 'a -> int 


let pipe fs = 
let f a x = fun x a
Error: Syntax error


let base = fun d -> d in
List.fold_left f base fs
Error: This expression has type int -> int
       but an expression was expected of type int -> 'a -> int
       Type int is not compatible with type 'a -> int 


let pipe fs = 
let f a x = fun a x
Error: Syntax error


let base = fun d -> d in
List.fold_left f base fs
Error: This expression has type int -> int
       but an expression was expected of type int -> 'a -> int
       Type int is not compatible with type 'a -> int 


let pipe fs = 
let f a x = fun d -> x a
Error: Syntax error


let base = fun d -> d in
List.fold_left f base fs
Error: This expression has type int -> int
       but an expression was expected of type int -> 'a -> int
       Type int is not compatible with type 'a -> int 


let pipe fs = 
let f a x = fun d -> a x
Error: Syntax error


let base = fun d -> d in
List.fold_left f base fs
Error: This expression has type int -> int
       but an expression was expected of type int -> 'a -> int
       Type int is not compatible with type 'a -> int 


let pipe fs = 
let f a x = fun p -> a x
Error: Syntax error


let base = fun d -> d in
List.fold_left f base fs
Error: This expression has type int -> int
       but an expression was expected of type int -> 'a -> int
       Type int is not compatible with type 'a -> int 


let pipe fs = 
let f a x = a x
Error: Syntax error


let base = fun d -> d in
List.fold_left f base fs
Error: This expression has type int -> int
       but an expression was expected of type int -> 'a -> int
       Type int is not compatible with type 'a -> int 


let pipe fs = 
let f a x = a x in
let base = fun d -> d in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = fun a x -> a x in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a x -> x a in
let base = fun d -> d in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> ('a -> 'b) -> 'b
       The type variable 'a occurs inside ('a -> 'b) -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = fun b a x -> a x in
let base = fun d -> d in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'b


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = fun b a x -> a x in
let base = fun d -> d in
List.fold_left f base fs

let _ = pipe [] 3

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         ('a -> 'b) -> 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = fun x -> x in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x -> x in
let base = fun d -> d in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = fun a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> x a in
let base = fun d -> d in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside ('a -> 'c) -> 'c



hw3 pipe

fix:
let pipe fs = 
let f a x = x a  in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x a -> fun x a in
let base = fun d -> d in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = fun x a -> fun d in
let base = fun d -> d in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = fun d -> x a in
let base = fun d -> d in
List.fold_left f base fs

let _ = pipe [] 3

bad:
let pipe fs = 
let f a x = fun x a -> fun x in
let base = fun d -> d in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = fun x -> x a in
let base = fun d -> d in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs = 
let f a x = fun a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> a x in
let base = fun d -> d in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = fun a -> a x in
let base = fun d -> d in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = fun a ->  x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> fun x -> x a in
let base = fun d -> d in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> ('a -> 'b) -> 'b
       The type variable 'a occurs inside ('a -> 'b) -> 'b


let pipe fs = 
let f a x = fun a -> fun x -> x a in
let base = fun d -> d in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> ('a -> 'b) -> 'b
       The type variable 'a occurs inside ('a -> 'b) -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = fun x ->  a x in
let base = fun d-> d in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'b


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'b
       but an expression was expected of type int


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This expression has type 'a -> 'b
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs = 
let f a x = fun p a -> a x  in
let base = fun d-> d in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         ('a -> 'b) -> 'a -> 'b


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         ('a -> 'b) -> 'a -> 'b


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This expression has type int but an expression was expected of type
         ('a -> 'b) -> 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = fun a x -> x in
let base = fun d-> d in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'b


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         int -> int


let pipe fs = 
let f a x = fun a x  in
let base = fun d-> d in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = fun a -> a in
let base = fun d-> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a x -> a in
let base = fun d-> d in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'b -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x = fun d ->  x a in
let base = fun d-> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun d -> a in
let base = fun d-> d in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'c -> 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'c -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x = fun p -> fun s a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun d -> d in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = fun d x -> a x in
let base = fun d -> d in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'c -> 'a -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'c -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = fun p -> fun s a x -> a x
Error: Syntax error


let base = fun d -> d in
List.fold_left f base fs
Error: This expression has type int -> int
       but an expression was expected of type int -> 'a -> int
       Type int is not compatible with type 'a -> int 


let pipe fs = 
let f a x = fun p -> fun s a x -> x a
Error: Syntax error


let base = fun d -> d in
List.fold_left f base fs
Error: This expression has type int -> int
       but an expression was expected of type int -> 'a -> int
       Type int is not compatible with type 'a -> int 


let pipe fs = 
let f a x = fun p -> fun s a -> x a
Error: Syntax error


let base = fun d -> d in
List.fold_left f base fs
Error: This expression has type int -> int
       but an expression was expected of type int -> 'a -> int
       Type int is not compatible with type 'a -> int 


let pipe fs = 
let f a x = fun p -> fun s a -> x a
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = fun p -> fun a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'b -> 'c


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         'a -> int -> int



hw3 pipe

fix:
let pipe fs = 
let f a x = fun a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'b


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         int -> int



hw3 pipe

fix:
let pipe fs = 
let f a x = fun a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun b (fun a -> x a) -> b in
let base = fun d -> d in
List.fold_left f base fs
Error: Syntax error: operator expected.


let pipe fs = 
let f a x = fun b (a -> x a) -> b in
let base = fun d -> d in
List.fold_left f base fs
Characters 33-34:
  let f a x = fun b (a -> x a) -> b in
                    ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw3 pipe

fix:
let pipe fs = 
let f a x = fun a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> a x in
let base = fun d -> d in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = fun a d -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a x -> x a in
let base = fun d -> d in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> ('a -> 'b) -> 'b
       The type variable 'a occurs inside ('a -> 'b) -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = fun a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'b


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'b
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs = 
let f a x = fun a -> x a in
let base = fun d -> d in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> fun x -> x a in
let base = fun d -> d in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> ('a -> 'b) -> 'b
       The type variable 'a occurs inside ('a -> 'b) -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = x  in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x  in
let base = let p -> p in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = a x  in
let base = fun p -> x in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = a x  in
let base = fun p -> p in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = a x  in
let base = fun p -> p in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = fun x -> x in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> a in
let base = fun p -> p in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'c -> 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'c -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x = x in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = List.rev x in
let base = fun p -> p in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'b list



hw3 pipe

fix:
let pipe fs = 
let f a x = x in
let base = fun p -> p in
List.fold_left f base (List.rev fs)

bad:
let pipe fs = 
let f a x = x in
let base = fun p -> p in
List.fold_left f base List.rev fs
Error: This expression has type 'a list -> 'a list
       but an expression was expected of type ('b -> 'b) list


let pipe fs = 
let f a x = x in
let base = fun p -> p in
List.fold_left f base List.rev fs
Error: This expression has type 'a list -> 'a list
       but an expression was expected of type ('b -> 'b) list



hw3 pipe

fix:
let pipe fs = 
let f a x = x in
let base = fun p -> p in
List.fold_left f base (List.rev fs)

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 4)] 3

bad:
let pipe fs = 
let f a x = x in fun x-> x in
let base = fun p -> p in
List.fold_left f base (List.rev fs)
Error: This expression has type int -> int
       but an expression was expected of type int -> 'a -> int
       Type int is not compatible with type 'a -> int 



hw3 pipe

fix:
let pipe fs = 
let f a x = x a  in
let base = fun p -> p in
List.fold_left f base (List.rev fs)

bad:
let pipe fs = 
let f a x = x fs in
let base = fun p -> p in
List.fold_left f base (List.rev fs)
Error: This expression has type 'a list
       but an expression was expected of type ('a list -> 'b -> 'b) list
       The type variable 'a occurs inside 'a list -> 'b -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = fun d-> x a d in
let base = fun p -> p in
List.fold_left f base (List.rev fs)

bad:
let pipe fs = 
let f a x = fun d-> a x d in
let base = fun p -> p in
List.fold_left f base (List.rev fs)
Error: This expression has type ('a -> 'a -> 'b) -> 'a -> 'a -> 'b
       but an expression was expected of type
         ('a -> 'a -> 'b) -> 'a -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = x in
let base = fun p -> p in
List.fold_left f base (List.rev fs)

bad:
let pipe fs = 
let f a x = x in
let base = fun p -> x p in
List.fold_left f base (List.rev fs)
Error: Unbound value x


let pipe fs = 
let f a x = x in
let base = fun p ->a  p in
List.fold_left f base (List.rev fs)
Error: This expression has type int
       This is not a function; it cannot be applied.



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun a' -> a' in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun a' -> a' in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = (a x) in
let base = fun a' -> a' in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = fun p' -> a x  in
let base = fun a' -> a' in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun p' -> a  in
let base = fun a' -> a' in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'c -> 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'c -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x =  fun p -> a x in
let base = pipe [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  a x in
let base = pipe [] in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = fun p -> x a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =   in
let base = p -> p in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = fun p -> a x in
let base = p -> p in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = fun p -> x a in
let base = p -> p in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = fun l -> x a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> x a in
let base = fun p -> p in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside ('a -> 'c) -> 'c


let pipe fs = 
let f a x = fun l -> fun x -> a in
let base = fun p -> p in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'c -> 'd -> 'a


let pipe fs = 
let f a x = fun l -> fun x -> a in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'c -> 'd -> 'a


let pipe fs = 
let f a x = fun l -> fun x -> a in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'c -> 'd -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x = fun l -> x a in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun l -> fun x -> x a in
let base = fun p -> p in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'c -> ('a -> 'd) -> 'd
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'c -> ('a -> 'd) -> 'd



hw3 pipe

fix:
let pipe fs = 
let f a x = fun l -> x (a l) in
let base = fun p -> p in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun l -> l(x a) in
let base = fun p -> p in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 stringOfList

fix:
let stringOfList f l = "["^ sepConcat "; " (List.map f l) ^"]"

bad:
let stringOfList f l = List.map f (sepConcat l);


let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: Syntax error


let stringOfList f l = "["^ List.map f (sepConcat l) ^"]";


let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: Syntax error


let stringOfList f l = "["^ List.map f (sepConcat l) ^"]"
Error: This expression has type string list -> string
       but an expression was expected of type 'a list


let stringOfList f l = "["^ List.map f (sepConcat "; " l) ^"]"
Error: This expression has type string but an expression was expected of type
         'a list



hw3 clone

fix:
let rec clone x n = 
if n < 1 then 
[]
else 
x::(clone x (n-1))

bad:
let rec clone x n = 
if n > 0 then 
x @ clone x n-1
else 
[]
Error: This expression has type int but an expression was expected of type
         'a list


let rec clone x n = 
if n > 0 then 
x @ (clone x n-1)
else 
[]
Error: This expression has type int but an expression was expected of type
         'a list


let rec clone x n = 
if n < 1 then 
[]
else 
x::(clone x n-1)
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 padZero

fix:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let x = List.length l1 - List.length l2 in 
let list_p = clone 0 x in 
(l1,list_p@l2)
else if List.length l1 < List.length l2 then
let x = List.length l2 - List.length l1 in 
let list_p = clone 0 x in 
(list_p@l1,l2)
else
(l1,l2)

bad:
let padZero l1 l2 = 
if List.length l1 == List.length l2 then
(l1)@(l2)
Error: This expression has type 'a list
       but an expression was expected of type unit


let padZero l1 l2 = 
if List.length l1 = List.length l2 then
l1 @ l2
Error: This expression has type 'a list
       but an expression was expected of type unit


let padZero l1 l2 = 
if List.length l1 == List.length l2 then
l1 @ l2
Error: This expression has type 'a list
       but an expression was expected of type unit


let padZero l1 l2 = 
if List.length l1 == List.length l2 then
(l1 @ l2)
Error: This expression has type 'a list
       but an expression was expected of type unit


let padZero l1 l2 = 
if List.l1 > List.l2 then
let x = List.l1 - List.l2 in 
let list_p = clone 0 x in 
(l1,list_p@l2)
else if List.l1 < List.l2 then
let x = List.l2 - List.l1 in 
let list_p = clone 0 x in 
(list_p@l1,l2)
else
(l1,l2)
Error: Unbound value List.l1



hw3 removeZero

fix:
let rec removeZero l = match l with
| [] -> []
| h::t ->
if h == 0 then 
removeZero t
else 
l

bad:
let rec removeZero l = match l with
| [] = []
| h::t = 
if h == 0 then 
removeZero t
else 
l
Error: Syntax error



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then (1, listy @ (initsum % 10))
else (0,listy@initsum)

let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then (1, listy @ (initsum % 10))
else (0,listy@initsum)
Error: Syntax error


let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then 
(1, listy @ [initsum mod 10])
else 
(0,listy @ [initsum]) in
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) @ [(0,0)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then (1, listy @ (initsum % 10))
else (0,listy @ initsum)
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then (1, listy @ (initsum % 10))
else (0,listy @ initsum)
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then (1, listy @ [initsum mod 10])
else (0,listy @ initsum)
Error: Syntax error


let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then (1, listy @ [initsum mod 10])
else (0,listy @ [initsum])
Error: Syntax error


let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then (1, listy @ [initsum mod 10])
else (0,listy @ [initsum])
Error: Syntax error


let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) @ [(0,0)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then (1, listy @ [initsum mod 10])
else (0,listy @ initsum)
Error: Syntax error


let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) @ [(0,0)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, listy) = a in
let (num1, num2) = x in
let initsum = num1 + num2 + carry in
if initsum > 9 then 
(1, listy @ [initsum mod 10])
else 
(0,listy @ initsum) in
let base = (0,[]) in
let args =  List.rev(List.combine l1 l2) @ [(0,0)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         int list



hw3 mulByDigit

fix:
let mulByDigit i l = 
let rec helpy p q carry accList = 
let numsList = List.rev(q) in match numsList with
|[] -> accList
|h::t -> 
let initMul = (h*p) + carry in
let intKeep = initMul mod 10 in
let carrying = (initMul-intKeep) mod 100 in
let v = List.rev(t) in 
helpy p v carrying accList@[intKeep] in
removeZero(List.rev(helpy i l 0 [0;0]))

bad:
let mulByDigit i l = 
let rec helpy p q carry accList = 
let numsList = List.rev(q) in match numList with
|[] -> accList
|h::t -> let initMul = (h*p) + carry in
let intKeep = initMul mod 10 in
let carrying = (initMul-initKeep) mod 100 in
helpy p List.rev(t) carrying accList@initKeep in
removeZero(list.rev(helpy i l 0 [0,0]))
Error: Unbound value numList
Hint: Did you mean numsList?


let mulByDigit i l = 
let rec helpy p q carry accList = 
let numsList = List.rev(q) in match numsList with
|[] -> accList
|h::t -> let initMul = (h*p) + carry in
let intKeep = initMul mod 10 in
let carrying = (initMul-initKeep) mod 100 in
helpy p List.rev(t) carrying accList@initKeep in
removeZero(list.rev(helpy i l 0 [0,0]))
Error: Unbound value initKeep
Hint: Did you mean intKeep?


let mulByDigit i l = 
let rec helpy p q carry accList = 
let numsList = List.rev(q) in match numsList with
|[] -> accList
|h::t -> let initMul = (h*p) + carry in
let intKeep = initMul mod 10 in
let carrying = (initMul-intKeep) mod 100 in
helpy p List.rev(t) carrying accList@initKeep in
removeZero(list.rev(helpy i l 0 [0,0]))
Error: This expression has type 'a list -> 'a list
       but an expression was expected of type int list


let mulByDigit i l = 
let rec helpy p q carry accList = 
let numsList = List.rev(q) in match numsList with
|[] -> accList
|h::t -> 
let initMul = (h*p) + carry in
let intKeep = initMul mod 10 in
let carrying = (initMul-intKeep) mod 100 in
let v = List.rev(t) in 
helpy p v carrying accList@initKeep in
removeZero(list.rev(helpy i l 0 [0,0]))
Error: Unbound value initKeep
Hint: Did you mean intKeep?


let mulByDigit i l = 
let rec helpy p q carry accList = 
let numsList = List.rev(q) in match numsList with
|[] -> accList
|h::t -> 
let initMul = (h*p) + carry in
let intKeep = initMul mod 10 in
let carrying = (initMul-intKeep) mod 100 in
let v = List.rev(t) in 
helpy p v carrying accList@intKeep in
removeZero(list.rev(helpy i l 0 [0,0]))
Error: This expression has type int but an expression was expected of type
         'a list


let mulByDigit i l = 
let rec helpy p q carry accList = 
let numsList = List.rev(q) in match numsList with
|[] -> accList
|h::t -> 
let initMul = (h*p) + carry in
let intKeep = initMul mod 10 in
let carrying = (initMul-intKeep) mod 100 in
let v = List.rev(t) in 
helpy p v carrying accList@[intKeep] in
removeZero(list.rev(helpy i l 0 [0,0]))
Error: Unbound value list


let mulByDigit i l = 
let rec helpy p q carry accList = 
let numsList = List.rev(q) in match numsList with
|[] -> accList
|h::t -> 
let initMul = (h*p) + carry in
let intKeep = initMul mod 10 in
let carrying = (initMul-intKeep) mod 100 in
let v = List.rev(t) in 
helpy p v carrying accList@[intKeep] in
removeZero(List.rev(helpy i l 0 [0,0]))
Error: This expression has type 'a * 'b
       but an expression was expected of type int



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = 
let (upper_mult, total) = a in
let newTotal = mulByDigit x upper_mult in
let updateTotal = bigAdd newTotal total in
(upper_mult@[0],updateTotal) in
let base = (l1,[]) in
let args =  l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = in
let base =  in
let args =  in
let (_, res) = List.fold_left f base args in
res
Error: Syntax error


let bigMul l1 l2 = 
let f a x = 
let (bottom_mult, total) = a in match a with
|[] -> total
|h::t -> 
let newTotal = mulByDigit h x in
let updateTotal = bigAdd newTotal updateTotal in
(t,updateTotal)
Error: Syntax error


let base = (l1,[]) in
let args =  l2 in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value l1


let bigMul l1 l2 = 
let f a x = 
let (bottom_mult, total) = a in match bottom_mult with
|[] -> total
|h::t -> 
let newTotal = mulByDigit h x in
let updateTotal = bigAdd newTotal updateTotal in
(t,updateTotal)
Error: Syntax error


let base = (l1,[]) in
let args =  l2 in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value l1


let bigMul l1 l2 = 
let f a x = 
let (bottom_mult, total) = a in match bottom_mult with
|[] -> total
|h::t -> 
let newTotal = mulByDigit h x in
let updateTotal = bigAdd newTotal total in
(t,updateTotal)
Error: Syntax error


let bigMul l1 l2 = 
let f a x = 
let (bottom_mult, total) = a in match bottom_mult with
|[] -> total
|h::t -> 
let newTotal = mulByDigit h x in
let updateTotal = bigAdd newTotal total in
(t,updateTotal) in
let base = (l1,[]) in
let args =  l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a * 'b
       but an expression was expected of type int list



hw3 pipe

fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = fun a -> x a in
let base = fun x1->x1 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun x -> x a in
let base = fun x1->x1 in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside ('a -> 'c) -> 'c



hw3 stringOfList

fix:
let stringOfList f l = List.map (f (sepConcat " " l))

bad:
let stringOfList f l = List.map (f (sepconcat " " l))
Error: Unbound value sepconcat
Hint: Did you mean sepConcat?
Error: Unbound value sepconcat
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value sepconcat
Hint: Did you mean sepConcat?



hw3 stringOfList

fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = fun y ->  x (a y) in
let base = fun x1->x1 in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = sepConcat " " List.map(f l)

bad:
let stringOfList f l = sepConcat (" " List.map(f l))
Error: This expression has type string
       This is not a function; it cannot be applied.



hw3 stringOfList

fix:
let stringOfList f l = sepConcat " " l

bad:
let stringOfList f l = sepConcat (" " List.map(f l))
Error: This expression has type string
       This is not a function; it cannot be applied.


let stringOfList f l = sepConcat (" " (List.map(f l)))
Error: This expression has type string
       This is not a function; it cannot be applied.



hw3 clone

fix:
let rec clone x n = 
if (n <= 0) then []
else x::(clone x (n-1))

bad:
let rec clone x n = 
if (n <= 0) then []
else x::(clone x n-1)
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 bigAdd

fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = fun y ->  x (a y) in
let base = fun x1->x1 in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = "["^sepConcat "; " (List.map f l)^"]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n = 
if (n <= 0) then []
else x::(clone x (n-1))

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let padZero l1 l2 = 
if List.length l1 < List.length l2
then ((clone 0 (List.length l2 - List.length l1))@l1,l2)
else (l1,(clone 0 (List.length l1 - List.length l2))@l2)

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

let rec removeZero l = match l with
| [] -> []
| h::t -> if (h=0) then removeZero t else l

let _ = removeZero [0;0;0;1;0;0;2]

let _ = removeZero [9;9]

let _ = removeZero [0;0;0;0]

let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (x,y) -> a::[(x+y) mod 10] in
let base = [] in
let args = failwith List.combine(l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (x,y) -> a::[(x+y) mod 10 in
let base = [] in
let args = failwith List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (x,y) -> a::[(x+y) mod 10] in
let base = [] in
let args = failwith List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list -> 'b list -> ('a * 'b) list
       but an expression was expected of type string



hw3 bigAdd

fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = fun y ->  x (a y) in
let base = fun x1->x1 in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = "["^sepConcat "; " (List.map f l)^"]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n = 
if (n <= 0) then []
else x::(clone x (n-1))

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let padZero l1 l2 = 
if List.length l1 < List.length l2
then ((clone 0 (List.length l2 - List.length l1))@l1,l2)
else (l1,(clone 0 (List.length l1 - List.length l2))@l2)

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

let rec removeZero l = match l with
| [] -> []
| h::t -> if (h=0) then removeZero t else l

let _ = removeZero [0;0;0;1;0;0;2]

let _ = removeZero [9;9]

let _ = removeZero [0;0;0;0]

let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (y,z) -> let sum = y+z in
match a with 
| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t
| [] -> (sum/10)::[(sum mod 10)] in
let base = [] in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (y,z) -> let sum = y+z in
match a with 
| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t
| [] -> (sum/10)::[(sum mod 10)] in
let base = [] in
let args = failwith List.combine(l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list -> 'b list -> ('a * 'b) list
       but an expression was expected of type string


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (y,z) -> let sum = y+z in
match a with 
| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t
| [] -> (sum/10)::[(sum mod 10)] in
let base = [] in
let args = List.combine(l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list -> ('b * 'a) list
       but an expression was expected of type (int * int) list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (y,z) -> let sum = y+z in
match a with 
| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t
| _ -> (sum/10)::[(sum mod 10)] in
let base = [] in
let args = List.rev(List.combine l1 l2) in
(*let (_, res) =*) List.fold_left f base args (*in
res*)
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (y,z) -> let sum = y+z in
match a with 
| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t
| _ -> (sum/10)::[(sum mod 10)] in
let base = [] in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list
       but an expression was expected of type 'a * 'b



hw3 mulByDigit

fix:
let rec mulByDigit i l =  
let f a x = let mult = i*x in
match a with 
|h::t -> ((h+mult)/10)::(h+mult) mod 10::t
| _ -> mult/10::[mult mod 10] in
let base = [] in
removeZero (List.fold_left f base (List.rev l))

bad:
let rec mulByDigit i l = match l with 
let f a x = let mult = i*x in
match a with 
|h::t -> ((h+mult)/10)::(h+mult) mod 10::t
| _ -> mult/10::[mult mod 10] in
let base = [] in
removeZero (List.fold_left f base (List.rev l))
Error: Syntax error



hw3 bigMul

fix:
let bigMul l1 l2 = 
let g =
let f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in
let base = [] in
let args = List.rev l2 in List.fold_left f base args in
List.fold_left bigAdd [] g

bad:
let bigMul l1 l2 = 
let f a x = List.append((mulByDigit x l1) (clone 0 (List.length b)))::b in
let base = [] in
let args = List.rev l2 in List.fold_left f base args
Error: This expression has type int list
       This is not a function; it cannot be applied.


let bigMul l1 l2 = 
let g =
let f a x = List.append((mulByDigit x l1) (clone 0 (List.length b)))::b in
let base = [] in
let args = List.rev l2 in List.fold_left f base args in
List.fold_left bigAdd [] g
Error: This expression has type int list
       This is not a function; it cannot be applied.
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int list
       This is not a function; it cannot be applied.


let bigMul l1 l2 = 
let g =
let f a x = ((mulByDigit x l1)@(clone 0 (List.length b)))::b in
let base = [] in
let args = List.rev l2 in List.fold_left f base args in
List.fold_left bigAdd [] g
Error: Unbound value b
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value b



hw3 mulByDigit

fix:
let _ = mulByDigit (-9) [9;9;9;9]

bad:
let _ = mulByDigit -9 [9;9;9;9]
Error: This expression has type int -> int list -> int list
       but an expression was expected of type int



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = match a with
|(move,result) -> match x with
|(fac,dig) -> let prod = mulByDigit dig (fac @ (clone 0 move)) in
(move +1, bigAdd result prod) in 
let base = (0,[]) in
let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in 
let (_,res) = List.fold_left f base args in
res

let _ = bigMul [9;9;9;9] [9;9;9;9]

let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = match a with
|(move,result) -> match x with
|(fac,dig) -> let prod = mulByDigit dig (fac @ (clone 0 move)) in
(move +1, bigAdd result prod) in 
let base = (0,[]) in
let args = List.combine (clone l1 (List.length l2)) (List.rev 12) in 
let (_,res) = List.fold_left f base args in
res
Error: This expression has type int but an expression was expected of type
         'a list
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int but an expression was expected of type
         'a list



hw1 digitsOfInt

fix:
let rec sumList xs = match xs with
| []-> 0
| h::t -> h+sumList t

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

let rec digitsOfInt n = match n with
| [] -> []
| h::t -> if (n< 0) then []

bad:
let rec digitsOfInt n = match n with
if( h % 2) = 0 
then [] 
else tail
Error: Syntax error


let rec digitsOfInt n = 
if( h % 2) = 0 
then [] 
else tail
Error: Unbound value %


let rec digitsOfInt n = 
if( h mod 2) = 0 
then [] 
else tail
Error: Unbound value h


let rec digitsOfInt n = 
if( head mod 2) = 0 
then [] 
else tail
Error: Unbound value head


let rec digitsOfInt n = 
if( hd mod 2) = 0 
then [] 
else tl
Error: Unbound value hd


let rec digitsOfInt n = match n with
|if( hd mod 2) = 0 
then [] 
else tl
Error: Syntax error


let rec digitsOfInt n = match n with
|if( n < 0) -> []
Error: Syntax error


let rec digitsOfInt n = match n with
|( n < 0) -> []
Characters 38-39:
  |( n < 0) -> [];;
   ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let rec digitsOfInt n = match n with
| n < 0 -> []
Error: Syntax error


let rec digitsOfInt n = match n with
| (n < 0) -> []
Characters 39-40:
  | (n < 0) -> [];;
    ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let rec digitsOfInt n = 
if n < 0 -> []
Error: Syntax error


let rec digitsOfInt n = 
if (n < 0) then []
Error: This variant expression is expected to have type unit
       The constructor [] does not belong to type unit



hw1 digitsOfInt

fix:
let rec sumList xs = match xs with
| []-> 0
| h::t -> h+sumList t

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

let rec digitsOfInt n = match n with
| [] -> []
| h::t -> if n < 0 then []

bad:
let rec digitsOfInt n = match n with
| [] -> []
| h::t -> if (n < 0) then []
Error: This expression has type int but an expression was expected of type
         'a list



hw1 digitsOfInt

fix:
let rec sumList xs = match xs with
| []-> 0
| h::t -> h+sumList t

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

let rec digitsOfInt n = match n with
| _ when n < 0 -> []

bad:
let rec digitsOfInt n = match n with
| [] -> []
| _ -> if n < 0 then []
Error: This expression has type int but an expression was expected of type
         'a list


let rec digitsOfInt n = match n with
| _ -> if n < 0 then []
Error: This variant expression is expected to have type unit
       The constructor [] does not belong to type unit



hw1 digitsOfInt

fix:
let digitsOfInt n = 
if n <= 0 
then []
else
digitsOfInt(n/10)::[]

bad:
let digitsOfInt n = 
if n < 0 
then []
else if n < 10
then n:: []
else
digitsOfInt (n mod 10)
Error: This expression has type (int * int) list list
       but an expression was expected of type int list
       Type (int * int) list is not compatible with type int 


let digitsOfInt n = 
if n < 0 
then []
else if n < 10
then n:: []
else
digitsOfInt (n / 10)
Error: This expression has type (int * int) list list
       but an expression was expected of type int list
       Type (int * int) list is not compatible with type int 



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n <= 0 
then []
else
digitsOfInt (n/10) @ (n mod 10)::[]

bad:
let rec digitsOfInt n = 
if n <= 0 
then []
else
digitsOfInt (n/10) ::[]
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 digitsOfInt

fix:
let rec sumList xs = match xs with
| []-> 0
| h::t -> h+sumList t

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

let rec digitsOfInt n = 
let myList = [] in
if n <= 0 
then []
else
digitsOfInt (n/10) -> n mod 10 :: []

bad:
let rec digitsOfInt n = 
if n <= 0 
then []
else
digitsOfInt (n/10)::[]
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec digitsOfInt n = 
if n <= 0 
then []
else
digitsOfInt (n mod 10)::[]
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec digitsOfInt n = 
if n <= 0 
then []
else
digitsOfInt (n mod 10)::[]::[]
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec digitsOfInt n = 
let myList = []
if n <= 0 
then []
else
digitsOfInt (n mod 10)::[]
Error: Syntax error


let rec digitsOfInt n = 
let myList = [] in
if n <= 0 
then []
else
digitsOfInt (n mod 10)::[]
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec digitsOfInt n = 
let myList = [] in
if n <= 0 
then []
else
digitsOfInt n mod 10::[]
Error: This expression has type 'a list
       but an expression was expected of type int


let rec digitsOfInt n = 
let myList = [] in
if n <= 0 
then []
else
digitsOfInt (n mod 10) :: digitsOfInt(n / 10) :: []
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 ???

fix:
56554 mod 3

bad:
56554 % 3
Error: Unbound value %



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
let myList = [] in
if n <= 0 
then []
else
if n < 10
then [n]
else
digitsOfInt (n/10) @ n mod 10 :: []

bad:
let rec digitsOfInt n = 
let myList = [] in
if n <= 0 
then []
else
if n < 10
then [num]
else
digitsOfInt (n/10) @ n mod 10 :: []
Error: Unbound value num



hw1 ???

fix:
let n = 0 in
n > -300

bad:
let n = 0 in
if(n > -300)
then true
Error: This variant expression is expected to have type unit
       The constructor true does not belong to type unit


let n = 0 in
if(n > -300)
then 1
Error: This expression has type int but an expression was expected of type
         unit



hw1 listReverse

fix:
let rec listReverse l = match l with
|[] -> [];
|h::t -> listReverse(t)

let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l = match l with
|[] -> [];
|h::t -> listReverse(t) :: l
Error: Unbound value listReverse


let _ = listReverse [1; 2; 3; 4]
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 listReverse

fix:
let rec listReverse l = match l with
|[] -> [];
|h::t -> listReverse t @ [h]

let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l = match l with
|[] -> [];
|h::t -> h:: [listReverse t]
Error: This expression has type string but an expression was expected of type
         int


let _ = listReverse [1; 2; 3; 4]
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 digitsOfInt

fix:
let _ = digitsOfInt 352663

bad:
let _ = digitsOfInt 3124
Error: This expression has type int -> int list
       but an expression was expected of type int



hw1 ???

fix:
let _ = digits (-123)

bad:
let _ = digits (-1)
Error: This expression has type int -> int list
       but an expression was expected of type int



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = failwith "to be implemented" in
let base = x*x in
List.fold_left f base xs
Error: Unbound value x


let sqsum xs = 
let f a x = List.fold_left f a x in
let base = x*x in
List.fold_left f base xs
Error: Unbound value f


let sqsum xs = 
let f a x = List.fold_left f a b in
let base = x*x in
List.fold_left f base xs
Error: Unbound value f



hw3 pipe

fix:
let pipe fs = 
let f a x = function g -> a x in
let base = function x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a (x) in
let base = failwith "to be implemented" in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = a (x) in
let base = 0 in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = a (x) in
let base = a(0) in
List.fold_left f base fs
Error: Unbound value a


let pipe fs = 
let f a x = a (x) in
let base = fs in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = a (x) in
let base = match base with
|0 -> 0
|_ -> fs in
List.fold_left f base fs
Error: Unbound value base


let pipe fs = 
let f a x = a (x) in
let base = match x with
|0 -> 0
|_ -> fs in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = a (x) in
let base = match fs with
|0 -> 0
|_ -> fs in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = a (x) in
let base = 0 in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = f a x in
let base =  in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = a x in
let base =  in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = f a x in
let base = x -> x in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = f a x in
let base = fun x -> x in
List.fold_left f base fs
Error: Unbound value f



hw3 pipe

fix:
let pipe fs = 
let f a x = function g -> g in
let base = function x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = function g -> g a x in
let base = function x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> ('a -> 'b -> 'c) -> 'c
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside ('a -> 'b -> 'c) -> 'c


let pipe fs = 
let f a x = function g -> g x a in
let base = function x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> ('b -> 'a -> 'c) -> 'c
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside ('b -> 'a -> 'c) -> 'c


let pipe fs = 
let f a x = function g -> g(x a) in
let base = function x -> x in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = function g -> g(x) in
let base = function x -> x in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = function g -> x in
let base = function x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = function g -> g (a(x)) in
let base = function x -> x in
List.fold_left f base fs
Error: This expression has type ('a -> 'a) -> 'a -> 'a
       but an expression was expected of type ('a -> 'a) -> 'a
       The type variable 'a occurs inside 'a -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x = function g -> a( x g)  in
let base = function x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = function g -> g( a x) in
let base = function x -> x in
List.fold_left f base fs
Error: This expression has type ('a -> 'a) -> 'a -> 'a
       but an expression was expected of type ('a -> 'a) -> 'a
       The type variable 'a occurs inside 'a -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x = function g -> x (a g)  in
let base = function b -> b in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

bad:
let pipe fs = 
let f a x = function g -> function x (a x)  in
let base = function b -> b in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = function g -> function z (a x)  in
let base = function b -> b in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = function g -> function z (a z)  in
let base = function b -> b in
List.fold_left f base fs
Error: Syntax error



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length(t) < 2
then a ^ x 
else a ^ x ^ sep in
let base = "" in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if x.length < 2
then a ^ x in
let base = "" in
let l = sl in
List.fold_left f base l
Error: Unbound record field length


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if sl.length < 2
then a ^ x in
let base = "" in
let l = sl in
List.fold_left f base l
Error: Unbound record field length


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length < 2
then a ^ x in
let base = "" in
let l = sl in
List.fold_left f base l
Error: This expression has type int but an expression was expected of type
         'a list -> int


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length = 2
then a ^ x in
let base = "" in
let l = sl in
List.fold_left f base l
Error: This expression has type int but an expression was expected of type
         'a list -> int


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if t.length = 2
then a ^ x in
let base = "" in
let l = sl in
List.fold_left f base l
Error: Unbound record field length


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length(t) = 2
then a ^ x in
let base = "" in
let l = sl in
List.fold_left f base l
Error: This expression has type string but an expression was expected of type
         unit



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length() = 0
then a ^ x 
else a ^ x ^ sep in
let base = "" in
let l = sl in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "," ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length(l) = 0
then a ^ x 
else a ^ x ^ sep in
let base = "" in
let l = sl in
List.fold_left f base l
Error: Unbound value l



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length(t) > 2
then a ^ x ^ sep
else x ^ x in
let base = "" in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "," ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length(t) > 2
then a ^ x ^ sep
else x ^ x in
let base = "" in
let l = sepConcat sep t in
List.fold_left f base l
Error: This expression has type string but an expression was expected of type
         string list



hw3 sepConcat

fix:
let _ = sepConcat "---" ["a"]

bad:
let _ = sepConcat "---" [a]
Error: Unbound value a



hw3 stringOfList

fix:
let stringOfList f l = sepConcat ";" (List.map f l)

bad:
let stringOfList f l = sepConcat ";" List.map f l
Error: This function has type string -> string list -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 stringOfList

fix:
let stringOfList f l = 
let string str = sepConcat "; " (List.map (f) l )
in "[" ^str ^ "]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

bad:
let stringOfList f l = let
Error: Syntax error


val str = sepConcat ";" (List.map (f) l )
in "[" ^str ^ "]"
Error: Syntax error


let stringOfList f l = let
Error: Syntax error


val str = sepConcat ";" (List.map (f) l )
in "[" ^str ^ "]"
Error: Syntax error


let stringOfList f l = 
let string str = sepConcat ";" (List.map (f) l )
in "[" ^str ^ "]"
Error: Unbound value str



hw3 clone

fix:
let rec clone x n = 
if n < 1
then []
else x:: (clone x (n-1))

bad:
let rec clone x n = 
if n =< 0
then []
else h::t ->
x::clone x n-1
Error: Syntax error


let rec clone x n = match n with
|0 -> []
|h::t ->
x::clone x n-1
Error: This pattern matches values of type 'a list
       but a pattern was expected which matches values of type int


let rec clone x n = 
if n =< 0
then []
else x::clone x n-1
Error: Unbound value =<


let rec clone x n = 
if n < 1
then []
else x::clone x n-1
Error: This expression has type 'a list
       but an expression was expected of type int


let rec clone x n = 
if n < 1
then []
else x:: (clone x n-1)
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 ???

fix:
let int a = List.length([0]) - List.length([0;1])

bad:
let int a = List.length(l1) - List.length(l2)
Error: Unbound value l1



hw3 padZero

fix:
let padZero l1 l2 = 
let a = List.length(l1) - List.length(l2) in
if a > 0
then "hi"
else "bye"

bad:
let padZero l1 l2 = 
let int a = List.length(l1) - List.length(l2)
Error: Syntax error


let padZero l1 l2 = 
let int a = List.length(l1) - List.length(l2) in
if a > 0
then "hi"
else "bye"
Error: Unbound value a



hw3 padZero

fix:
let padZero l1 l2 = 
let a = List.length(l1) - List.length(l2) in
if a > 0
then (l1,(clone 0 a))
else (l1,l2)

bad:
let padZero l1 l2 = 
let a = List.length(l1) - List.length(l2) in
if a > 0
then l1 * (clone 0 a)
else "bye"
Error: This expression has type 'a list
       but an expression was expected of type int


let padZero l1 l2 = 
let a = List.length(l1) - List.length(l2) in
if a > 0
then l1 * (clone 0 a)
else l1 * l2
Error: This expression has type 'a list
       but an expression was expected of type int


let padZero l1 l2 = 
let a = List.length(l1) - List.length(l2) in
if a > 0
then (l1 * (clone 0 a))
else l1 * l2
Error: This expression has type 'a list
       but an expression was expected of type int


let padZero l1 l2 = 
let a = List.length(l1) - List.length(l2) in
if a > 0
then (l1 * (clone 0 a))
else (l1 * l2)
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 padZero

fix:
let padZero l1 l2 = 
let a = List.length(l1) - List.length(l2) in
if a > 0
then (l1,(List.append (clone 0 a) l2))
else (l1,l2)

bad:
let padZero l1 l2 = 
let a = List.length(l1) - List.length(l2) in
if a > 0
then (l1,(List.apend (clone 0 a) l2))
else (l1,l2)
Error: Unbound value List.apend
Hint: Did you mean append?



hw3 padZero

fix:
let padZero l1 l2 = 
let a = List.length(l1) - List.length(l2) in
if a > 0
then (l1,(List.append (clone 0 a) l2))
else ((List.append (clone 0 (0-a)) l1), l2)

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

bad:
let padZero l1 l2 = 
let a = List.length(l1) - List.length(l2) in
if a > 0
then (l1,(List.append (clone 0 a) l2))
else (List.append ( clone 0 (0 -a)) l2)
Error: This expression has type int list
       but an expression was expected of type 'a list * int list


let padZero l1 l2 = 
let a = List.length(l1) - List.length(l2) in
if a > 0
then (l1,(List.append (clone 0 a) l2))
else (List.append ( clone 0 (0 -a)), l2)
Error: This expression has type int list -> int list
       but an expression was expected of type 'a list



hw1 digitsOfInt

fix:
let rec digitsOfInt n =
match n < 0 with
| true -> 0
| false -> 1

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

bad:
let rec digitsOfInt n =
match n with
| < 0 0
| >= 0 1
Error: Syntax error


let _ = digitsOfInt 3124
Error: Unbound value digitsOfInt


let _ = digitsOfInt 352663
Error: Unbound value digitsOfInt


let rec digitsOfInt n =
match n with
| <0 0
| >=0 1
Error: Syntax error


let _ = digitsOfInt 3124
Error: Unbound value digitsOfInt


let _ = digitsOfInt 352663
Error: Unbound value digitsOfInt


let rec digitsOfInt n =
match n with
| 1
| _ 1
Error: Syntax error: pattern expected.


let _ = digitsOfInt 3124
Error: Unbound value digitsOfInt


let _ = digitsOfInt 352663
Error: Unbound value digitsOfInt


let rec digitsOfInt n =
match n with
| 1 0
| _ 1
Error: Syntax error


let _ = digitsOfInt 3124
Error: Unbound value digitsOfInt


let _ = digitsOfInt 352663
Error: Unbound value digitsOfInt


let rec digitsOfInt n =
match n with
| < 1 -> 0
| >= 0 -> 1
Error: Syntax error


let _ = digitsOfInt 3124
Error: Unbound value digitsOfInt


let _ = digitsOfInt 352663
Error: Unbound value digitsOfInt



hw1 digitsOfInt

fix:
let rec digitsOfInt n =
match n <= 0 with
| true -> []
| false -> []

let _ = 100 >> 2

bad:
let rec digitsOfInt n =
match n <= 0 with
| true -> []
| false -> 1
Error: This expression has type int but an expression was expected of type
         'a list


let _ = 100 >> 2
Error: Unbound value >>



hw1 digitsOfInt

fix:
let rec digitsOfInt n =
match n <= 0 with
| true -> []
| false -> digitsOfInt n div 10 :: [n mod 10]

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

bad:
let rec digitsOfInt n =
match n <= 0 with
| true -> []
| false -> (digitsOfInt n/10) @ [n%10]
Error: This expression has type 'a list
       but an expression was expected of type int


let rec digitsOfInt n =
match n <= 0 with
| true -> []
| false -> [digitsOfInt n/10] @ [n%10]
Error: This expression has type 'a list
       but an expression was expected of type int


let rec digitsOfInt n =
match n <= 0 with
| true -> []
| false -> digitsOfInt n/10 @ [n%10]
Error: This expression has type 'a list
       but an expression was expected of type int


let rec digitsOfInt n =
match n <= 0 with
| true -> []
| false -> [n%10] @ digitsOfInt n/10
Error: Unbound value %



hw1 listReverse

fix:
let rec listReverse l =
match l with
| []	    -> []
| (_ :: h :: [])  -> h :: listReverse []

let _ = listReverse [1; 2; 3; 4]

let _ = listReverse ["a"; "b"; "c"; "d"]

bad:
let rec listReverse l =
match l with
| []	    -> []
| (t :: h :: [])  -> h :: listReverse t::[]
Error: This expression has type 'a but an expression was expected of type
         'a list
       The type variable 'a occurs inside 'a list


let rec listReverse l =
match l with
| []	    -> []
| (t :: h :: [])  -> h :: listReverse t
Error: This expression has type 'a but an expression was expected of type
         'a list
       The type variable 'a occurs inside 'a list



hw1 ???

fix:
1::[2]

bad:
1::2
Error: This expression has type int but an expression was expected of type
         int list



hw1 digitsOfInt

fix:
let _ = digitsOfInt 2401

bad:
let _ = digitsOfInt -2401
Error: This expression has type int -> int list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let _ = digitsOfInt (-1)

bad:
let _ = digitsOfInt -2401
Error: This expression has type int -> int list
       but an expression was expected of type int


let _ = digitsOfInt -1
Error: This expression has type int -> int list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let _ = digitsOfInt 0

bad:
let _ = digitsOfInt asr

(* digits : int -> int list
* (digits n) is the list of digits of n in the order in which they appear
* in n
* e.g. (digits 31243) is [3,1,2,4,3]
*      (digits (-23422) is [2,3,4,2,2]
*)

let digits n = digitsOfInt (abs n)
Error: Syntax error



hw1 digitsOfInt

fix:
let _ = digitsOfInt ~-21041

bad:
let _ = digitsOfInt -21041
Error: This expression has type int -> int list
       but an expression was expected of type int



hw1 palindrome

fix:
let _ = palindrome "malayalam"

let _ = palindrome "myxomatosis"

bad:
let palindrome w = 
if (explode(w)) = (listReverse (explode(w)))
then true
else false
Error: Unbound value palindrome



hw2 wwhile

fix:
let rec wwhile (f,b) =
match f(b-1) with
| (_, false) -> b
| (bb, true) -> wwhile(f, bb)

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)
Error: Syntax error



hw2 wwhile

fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 0)

bad:
xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)
Error: Syntax error



hw2 fixpoint

fix:
ate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n =

bad:
let fixpoint (f, b) = wwhile (fun ff b -> (f(b), f(b) = f(b-1)) ,b)
Error: Syntax error: operator expected.


let fixpoint (f, b) = wwhile (fun ff b -> (f(b), f(b) != f(b-1)) ,b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a


let ff (b) =
(f(b), f(b) != f(b-1)
in
let fixpoint (f, b) = wwhile (ff ,b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a


let ff (b) =
(f(b), f(b) != f(b-1))
in
let fixpoint (f, b) = wwhile (ff ,b)
Characters 13-14:
  (f(b), f(b) != f(b-1)
  ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let ff (b) =
(f(b), f(b) != f(b-1))
in
let fixpoint (f, b) = wwhile (ff, b)
Error: Syntax error


let fixpoint (f, b) = 
let ff (b) =
(f(b), f(b) != f(b-1))
in
wwhile (ff, b)
Error: Syntax error



hw2 fixpoint

fix:
true || false

let fixpoint (f, b

bad:
ate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value trunc


let collatz n =
Error: Syntax error


 match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1
Error: Syntax error


let _ = fixpoint (collatz, 1)
Error: Unbound value n


let _ = fixpoint (collatz, 3)
Error: Unbound value collatz


let _ = fixpoint (collatz, 48)
Error: Unbound value collatz


let _ = fixpoint (collatz, 107)
Error: Unbound value collatz


let _ = fixpoint (collatz, 9001)
Error: Unbound value collatz


*
Error: Unbound value collatz


)
Error: Syntax error



hw2 fixpoint

fix:
let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

*

)

bad:
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || b != f(b-1))), b)
Error: Unbound value trunca
Hint: Did you mean truncate?


let g x = trunca
Error: Unbound value wwhile


te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value trunca
Hint: Did you mean truncate?


let collatz n =
Error: Syntax error


 match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1
Error: Syntax error


let _ = fixpoint (collatz, 1)
Error: Unbound value n


let _ = fixpoint
Error: Unbound value fixpoint



hw2 fixpoint

fix:
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || b != f b-1)), b)

let g x = trunca

bad:
te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value trunca
Hint: Did you mean truncate?


let collatz n =
Error: Syntax error



hw2 fixpoint

fix:
te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint

bad:
te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value trunca
Hint: Did you mean truncate?


let collatz n =
Error: Syntax error



hw2 fixpoint

fix:
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)), b)

let g x = trunca

bad:
 match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1
Error: Syntax error


let _ = fixpoint (collatz, 1)
Error: Unbound value n


let _ = fixpoint
Error: Unbound value fixpoint



hw2 fixpoint

fix:
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

*

)

bad:
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b))), b)
Error: Unbound value trunca
Hint: Did you mean truncate?


let g x = trunca
Characters 27-28:
  let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b))), b);;
                             ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)
Error: Unbound value trunca
Hint: Did you mean truncate?


let g x = trunca
Error: Unbound value wwhile


te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value trunca
Hint: Did you mean truncate?


let collatz n =
Error: Syntax error


 match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1
Error: Syntax error


let _ = fixpoint (collatz, 1)
Error: Unbound value n


let _ = fixpoint
Error: Unbound value fixpoint


 (collatz, 3)
Error: Unbound value fixpoint


let _ = fixpoint
Error: Unbound value collatz


 (collatz, 48)
Error: Unbound value fixpoint


let _ = fixpoint (collatz, 107)
Error: Unbound value collatz


let _ = fixpoint (collatz, 9001)
Error: Unbound value fixpoint


*
Error: Unbound value fixpoint


)
Error: Syntax error



hw2 fixpoint

fix:
exp 2.

let _ = fixpoint (

bad:
exp 2
Error: Syntax error


let _ = fixpoint (
Error: This expression has type int but an expression was expected of type
         float



hw2 fixpoint

fix:
let _ = fixpoint (exp, -1)

let _ = fixpoint

bad:
let _ = fixpoint (exp, 1)
Error: Syntax error: operator expected.


let _ = fixpoint
Error: Unbound value fixpoint


let _ = fixpoint (exp, 1.)
Error: Unbound value fixpoint


let _ = fixpoint
Error: Unbound value fixpoint



hw2 fixpoint

fix:
let _ = fixpoint ((fun b -> b ** 2), 0.)

let _ = fixpoint

bad:
let _ = fixpoint (exp, 0)
Error: Unbound value fixpoint


let _ = fixpoint
Error: Unbound value fixpoint


let _ = fixpoint (exp, 0.)
Error: Unbound value fixpoint


let _ = fixpoint
Error: Unbound value fixpoint



hw2 fixpoint

fix:
0. ** 2

let _ = fixpoint (

bad:
let _ = fixpoint ((fun b -> b ** 2.), 0.)
Error: Unbound value fixpoint


let _ = fixpoint
Error: Unbound value fixpoint



hw2 fixpoint

fix:
1. != 1.

let _ = fixpoint (

bad:
let _ = fixpoint ((fun b -> b ** 2.), 1.)
Error: Syntax error: operator expected.


let _ = fixpoint
Error: Unbound value fixpoint



hw2 fixpoint

fix:
(1. = 1.)

let _ = fixpoint (

bad:
!(1. = 1.)
Error: Syntax error: operator expected.


let _ = fixpoint (
Error: This expression has type bool but an expression was expected of type
         'a ref



hw2 fixpoint

fix:
te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

not (1. = 1.)

let _ = fixpoint (

bad:
let fixpoint(f, b) = wwhile((fun b -> (f(b), not (f(b) = b) || not (f(b) != f(f(b))))) , b)
Error: Syntax error: operator expected.


let g x = trunca
Error: Unbound value wwhile



hw2 fixpoint

fix:
 ((fun b -> b ** 4.), 0.)

let _ = fixpoint ((fun b -> b ** 4.), 1.)

let _ = fixpoint

bad:
let _ = fixpoint ((fun b -> b ** 2.), 1.)
Error: Unbound value fixpoint


let _ = fixpoint
Error: Unbound value fixpoint


let _ = fixpoint ((fun b -> b ** 2.), 0.)
Error: Unbound value fixpoint


let _ = fixpoint ((fun b -> b ** 2.), 1.)
Error: Unbound value fixpoint


let _ = fixpoint
Error: Unbound value fixpoint



hw2 fixpoint

fix:
 (sqrt, 12489124)

let _ = fixpoint

bad:
let _ = fixpoint ((fun b -> b ** 2.), 0.)
Error: Syntax error: operator expected.


let _ = fixpoint ((fun b -> b ** 2.), 1.)
Error: Unbound value fixpoint


let _ = fixpoint ((fun b -> b ** 4.), 0.)
Error: Unbound value fixpoint


let _ = fixpoint ((fun b -> b ** 4.), 1.)
Error: Unbound value fixpoint


let _ = fixpoint (sqrt, 10.)
Error: Unbound value fixpoint


let _ = fixpoint
Error: Unbound value fixpoint



hw2 exprToString

fix:
let rec exprToString e = 
match e with
| VarX _	    -> "x"
| VarY _	    -> "y"
| Sine x	    -> "sin(pi*" ^ exprToString(x) ^ ")"
| Cosine x	    -> "cos(pi*" ^ exprToString(x) ^ ")"
| Average (x,y)     -> "((" ^ exprToString(x) ^ "+" ^ exprToString(y) ^")/2)"
| Times (x,y)       -> exprToString(x) ^ "*" ^ exprToString(y)
| Thresh (a,b,c,d)  -> 
"(" ^ exprToString(a) ^ "<" exprToString(y) ^ "?" ^ 
exprToString(c) ^ ":" ^ exprToString(d)

bad:
let rec exprToString e = 
match e with
| VarX _ -> "x"
| VarY _ -> "y"
| Sine x -> "sin(pi*" ^ exprToString(x) ^ ")"
| Cosine x -> "cos(pi*" ^ exprToString(x) ^ ")"
| Average (x,y) -> "((" ^ exprToString(x) ^ "+" ^ exprToString(y) ^")/2)"
Error: Unbound value exprToStringx
Hint: Did you mean exprToString?



hw2 exprToString

fix:
let rec exprToString e = 
match e with
| VarX		    -> "x"
| VarY		    -> "y"
| Sine x	    -> "sin(pi*" ^ exprToString(x) ^ ")"
| Cosine x	    -> "cos(pi*" ^ exprToString(x) ^ ")"
| Average (x,y)     -> "((" ^ exprToString(x) ^ "+" ^ exprToString(y) ^")/2)"
| Times (x,y)       -> exprToString(x) ^ "*" ^ exprToString(y)
| Thresh (a,b,c,d)  -> 
"(" ^ exprToString(a) ^ "<" ^ exprToString(b) ^ "?" ^ 
exprToString(c) ^ ":" ^ exprToString(d)

bad:
let rec exprToString e = 
match e with
| VarX _	    -> "x"
| VarY _	    -> "y"
| Sine x	    -> "sin(pi*" ^ exprToString(x) ^ ")"
| Cosine x	    -> "cos(pi*" ^ exprToString(x) ^ ")"
| Average (x,y)     -> "((" ^ exprToString(x) ^ "+" ^ exprToString(y) ^")/2)"
| Times (x,y)       -> exprToString(x) ^ "*" ^ exprToString(y)
| Thresh (a,b,c,d)  -> 
"(" ^ exprToString(a) ^ "<" ^ exprToString(y) ^ "?" ^ 
exprToString(c) ^ ":" ^ exprToString(d)
Error: This expression has type string
       This is not a function; it cannot be applied.


let rec exprToString e = 
match e with
| VarX _	    -> "x"
| VarY _	    -> "y"
| Sine x	    -> "sin(pi*" ^ exprToString(x) ^ ")"
| Cosine x	    -> "cos(pi*" ^ exprToString(x) ^ ")"
| Average (x,y)     -> "((" ^ exprToString(x) ^ "+" ^ exprToString(y) ^")/2)"
| Times (x,y)       -> exprToString(x) ^ "*" ^ exprToString(y)
| Thresh (a,b,c,d)  -> 
"(" ^ exprToString(a) ^ "<" ^ exprToString(b) ^ "?" ^ 
exprToString(c) ^ ":" ^ exprToString(d)
Error: Unbound value y



hw2 eval

fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr,0.5,0.2)

bad:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine a -> sin (pi * eval (a,x,y))
| Cosine a -> cos (pi * eval (a,x,y))
| Average (a,b) -> (eval(a,x,y) + eval(b,x,y)) /. 2.
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)
Error: Syntax error


let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine a -> sin (pi *. eval (a,x,y))
| Cosine a -> cos (pi *. eval (a,x,y))
| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)
Error: This expression has type float but an expression was expected of type
         int



hw2 eval

fix:
let _ = eval (mySampleExpr3, 1.,2.)

let _ = eval (mySampleExpr3, 14.,14.)

let _ = eval (mySampleExpr3, 1203.,12.)

bad:
let _ = eval (mySampleExpr3, 1,2)
Error: Syntax error


let _ = eval (mySampleExpr3, 14,14)
Error: This expression has type int but an expression was expected of type
         float


let _ = eval (mySampleExpr3, 1203,12)
Error: This expression has type int but an expression was expected of type
         float



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = (fun a -> a) in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = 3 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = a in
List.fold_left f base fs
Error: Unbound value a



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = failwith "to be implemented" in
List.fold_left f base fs

let _ = pipe [] 3

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let pipe fs = 
let f a x = x a in
let base = base in
List.fold_left f base fs
Error: Unbound value base



hw3 pipe

fix:
let pipe fs = 
let f a x = x(a) in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = x in
List.fold_left f base fs
Error: Unbound value x



hw3 pipe

fix:
let pipe fs b = 
let f a x = x(a) in
let base = b in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs = 
let f a x = x(a) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x(a) in
let base =  in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x(a) in
let base = fun x in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x(a) in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x(a) in
let base = rec x in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x(a) in
let base = x in
List.fold_left f base fs
Error: Unbound value x



hw3 pipe

fix:
let pipe fs b = 
let f a x = x(a) in
let base = b in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let _ = sqsum [1;1;1;1;1;0;1;0]

let _ = sqsum [(-5); (-4); 1; 0; 7]

let _ = sqsum [1]

let _ = sqsum [0]

let pipe fs = 
let f a x = x(a) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 pipe

fix:
let _ = pipe []

bad:
let _ = pipe [] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe fs = 
let f a x = x(a) in
let base = "" in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This function has type ('a list -> 'a list) list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe fs = 
let f a x = x(a) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x(a) in
let base = a in
List.fold_left f base fs
Error: Unbound value a


let pipe fs = 
let f a x = x(a) in
let base = _ in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x(a) in
let base = fun x in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x(a) in
let base = (fun x) in
List.fold_left f base fs
Error: Syntax error: operator expected.


let pipe fs = 
let f a x = x(a) in
let base =  in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = (fun x -> x) in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 ???

fix:
let y f g = fun x -> f (g x)

bad:
let (y) f g = fun x -> f (g x)
Error: Syntax error


let (y) f g = fun x -> f (g x)
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = function | a -> a in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let pipe fs = 
let f a x = x a in
let base = int in
List.fold_left f base fs
Error: Unbound value int


let pipe fs = 
let f a x = x a in
let base = function in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = fun x' ->
let f a x = x a in
let base = x' in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let pipe fs = 
let f a x = x a in
let base = int a in
List.fold_left f base fs
Error: Unbound value int


let pipe fs = 
let f a x = x a in
let base = b of int in
List.fold_left f base fs
Error: Syntax error



hw3 stringOfList

fix:
let _ = stringOfList (fun x -> string_of_int(5*x)) [1;2;3;4;5;6]

bad:
let _ = stringOfList (string_of_int fun x -> 5*x) [1;2;3;4;5;6]
Error: Syntax error: operator expected.



hw3 clone

fix:
let rec clone x n = 
match n > 0 with
| false -> []
| true  -> x :: clone x (n-1)

bad:
let rec clone x n = 
match n > 0 with
| false -> []
| true  -> [x] @ (clone x n-1)
Error: This expression has type 'a list
       but an expression was expected of type int


let rec clone x n = 
match n > 0 with
| false -> []
| true  -> x :: (clone (x n-1))
Error: This expression has type int but an expression was expected of type
         int -> int


let rec clone x n = 
match n > 0 with
| false -> []
| true  -> x :: clone x n-1
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 padZero

fix:
let padZero l1 l2 = 
match List.length l1 = List.length l2 with
| true -> (l1, l2)
| false ->
let lendiff = List.length l1 - List.length l2 in
match lendiff > 0 with
| true  -> (l1, (clone 0 lendiff) @ l2)
| false -> ((clone 0 (-lendiff)) @ l1, l2)

bad:
let padZero l1 l2 = 
match List.length l1 = List.length l2 with
| true -> (l1, l2)
| false ->
let lendiff = List.length l1 - List.length l2 in
match lendiff > 0 with
| true  -> (l1, (clone 0 lendiff) @ l2)
| false -> ((clone 0 -lendiff) @ l1, l2)
Error: This expression has type int -> int list
       but an expression was expected of type int



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = (x + y) / 10 :: a in
let base = [] in
let args = List.combine l1 l2 in
let (res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = (x + y + a) / 10 in
let base = 0 in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = (x + y + a) / 10 in
let base = 0 in
let args = List.combine l1 l2 in
List.fold_left f base args
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = (x + y + a) / 10 in
let base = 0 in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = (x + y) / 10 :: a in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list
       but an expression was expected of type 'a * 'b



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = ((x + y) mod 10) :: a in
let base = [] in
let args = List.combine l1 l2 in
let (res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = ((x + y) % 10) :: a in
let base = [] in
let args = List.combine l1 l2 in
let (res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value %



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = ((x + y) / 10) :: a in
let base = [] in
let args = List.combine l1 l2 in
let (res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = ((x + y) % 10) :: a in
let base = [] in
let args = List.combine l1 l2 in
let (res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value %



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = 
match a with
| [] -> (x + y) :: a 
| h :: t -> [x + y + h/10; h mod 10] @ t
in
let base = [] in
let args = List.rev(List.combine l1 l2) in
let (res) = List.fold_left f base args in
res
in 
(add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = 
match a with
| [] -> (x + y) :: a 
| h :: t -> [x + y + h/10; h % 10] @ t
in
let base = [] in
let args = List.rev(List.combine l1 l2) in
let (res) = List.fold_left f base args in
res
in 
(add (padZero l1 l2))
Error: Unbound value %



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = 
match a with
| [] -> (x + y) :: a 
| h :: t -> [x + y + h/10; h mod 10] @ t
in
let base = [] in
let args = List.rev((0,0) :: List.combine l1 l2) in
let (res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = 
match a with
| [] -> (x + y) :: a 
| h :: t -> [x + y + h/10; h mod 10] @ t
in
let base = [] in
let args = List.rev((0,0) :: List.combine l1 l2) in
let (res) = List.fold_left f base args in
res
in 
removeZeros (add (padZero l1 l2))
Error: Unbound value removeZeros
Hint: Did you mean removeZero?
Error: Unbound value removeZeros
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value removeZeros
Hint: Did you mean removeZero?



hw3 mulByDigit

fix:
let rec mulByDigit i l = 
let f a x = 
match a with
| [] -> (i * x) :: a 
| h :: t -> [i * x + h/10; h mod 10] @ t
in
let base = [] in
let args = List.rev(0 :: l) in
List.fold_left f base args

bad:
let rec mulByDigit i l = 
let f a x = 
match a with
| [] -> (i * x) :: a 
| h :: t -> [x * y + h/10; h mod 10] @ t
in
let base = [] in
let args = List.rev(0 :: l) in
List.fold_left f base args
Error: This expression has type ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b
       but an expression was expected of type int



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = 
match a with
| [] -> (x + y) :: a 
| h :: t -> [x + y + h/10; h mod 10] @ t
in
let base = [] in
let args = List.rev((0,0) :: List.combine l1 l2) in
let (res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a (x,y) = 
match a with
| [] -> (x + y) :: a 
| h :: t -> [x + y + h/10; h mod 10] @ t
in
let base = [] in
let args = List.rev((0,0) :: List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list
       but an expression was expected of type 'a * 'b



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = 
match a with
| []  -> (mulByDigit x l2)
| _   -> bigAdd a (mulByDigit x l2)
in
let base = [] in
let args = List.rev l1 in
let (res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
match a with
| []      -> (mulByDigit x l2) :: a
| h :: t  -> [bigAdd (mulByDigit x l2) h/10; h mod 10] @ t 
in
let base = [] in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list
       but an expression was expected of type int


let bigMul l1 l2 = 
let f a x = 
match a with
| []      -> (mulByDigit x l2) :: a
| h :: t  -> [bigAdd (mulByDigit x l2) [h/10]; h mod 10] @ t 
in
let base = [] in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list
       but an expression was expected of type int


let bigMul l1 l2 = 
let f a x = 
match a with
| []  -> (mulByDigit x l2)
| _   -> bigAdd a (mulByDigit x l2)
in
let base = [] in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list
       but an expression was expected of type 'a * 'b



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = 
match a with
| []  -> (mulByDigit x l2)
| _   -> bigAdd (List.rev(0 :: (List.rev a))) (mulByDigit x l2)
in
let base = [] in
let args = List.rev l1 in
let (res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
match a with
| []  -> (mulByDigit x l2)
| _   -> bigAdd List.rev(0 :: (List.rev a)) (mulByDigit x l2)
in
let base = [] in
let args = List.rev l1 in
let (res) = List.fold_left f base args in
res
Error: This function has type int list -> int list -> int list
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 mulByDigit

fix:
let test = mulByDigit 1 [1;0]

List.rev test

bad:
let test = mulByDigit 1 [1;0]
List.rev test
Error: This function has type int -> int list -> int list
       It is applied to too many arguments; maybe you forgot a `;'.


let test = mulByDigit 1 [1;0]
List.rev test
Error: This function has type int -> int list -> int list
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 sumList

fix:
let rec sumList xs = 
match xs with
| [] -> 0
| x::y -> x + sumList y

bad:
let rec sumList xs = 
match xs with
| [] -> 0
| [x] -> x
| [x::y] -> x + sumList y
Error: This expression has type 'a list
       but an expression was expected of type int


let rec sumList xs = 
match xs with
| [] -> 0
| [x::y] -> x + sumList y
Error: This expression has type int list
       but an expression was expected of type int list list
       Type int is not compatible with type int list 



hw1 digitsOfInt

fix:
let rec digitsOfInt n =
if n < 0 then []
else digitsOfInt (n / 10) @ [n mod 10]

bad:
let rec digitsOfInt n =
match n with
| n < 0 -> []
| n > 0 -> (n % 10)::digitsOfInt (n / 10)
Error: Syntax error


let rec digitsOfInt n =
match n with
| n <= 0 -> []
| n > 0 -> (n % 10)::digitsOfInt (n / 10)
Error: Syntax error


let rec digitsOfInt n =
match n with
| n <= 0 -> []
| n < 10 -> [n]
| n > 0 -> (n % 10)::digitsOfInt (n / 10)
Error: Syntax error


let rec digitsOfInt n =
if n < 0 then []
else match n with
| a -> [a]
| a^b -> a::digitsOfInt b
Error: Syntax error


let rec digitsOfInt n =
if n < 0 then []
else match n with
| a -> [a]
| ab -> a::digitsOfInt b
Error: Unbound value a


let rec digitsOfInt n =
if n < 0 then []
else if n == 0 then 0
else digitsOfInt (n / 10) :: (n % 10)
Error: This expression has type int but an expression was expected of type
         'a list


let rec digitsOfInt n =
if n < 0 then []
else if n == 0 then []
else digitsOfInt (n / 10) :: (n % 10)
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec digitsOfInt n =
if n < 0 then []
else if n == 0 then 0
else  digitsOfInt (n / 10) @ [n % 10]
Error: This expression has type int but an expression was expected of type
         'a list


let rec digitsOfInt n =
if n < 0 then []
else digitsOfInt (n / 10) @ [n % 10]
Error: Unbound value %



hw1 additivePersistence

fix:
let rec additivePersistence n =
let sum = sumList (digitsOfInt n) in
if (sum < 10) then 1
else
1 + additivePersistence sum

bad:
let rec additivePersistence n =
let sum = sumList digitsOfInt n in
if (sum < 10) then 1
else
1 + additivePersistance sum
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let rec additivePersistence n =
let sum = sumList (digitsOfInt n) in
if (sum < 10) then 1
else
1 + additivePersistance sum
Error: Unbound value additivePersistance
Hint: Did you mean additivePersistence?



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4]

let _ = listReverse ["a"; "b"; "c"; "d"]

bad:
let rec listReverse l =
match l with
| [] -> []
| a :: b -> b :: listReverse a
Error: Unbound value digitalRoot


let rec listReverse l =
match l with
| [] -> []
| a :: b -> b :: listReverse [a]
Error: This expression has type 'a but an expression was expected of type
         'a list
       The type variable 'a occurs inside 'a list



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4]

let _ = listReverse ["a"; "b"; "c"; "d"]

bad:
let rec listReverse l =
match l with
| [] -> []
| a :: b -> listReverse b @ a
Error: This expression has type 'a but an expression was expected of type
         'a list
       The type variable 'a occurs inside 'a list



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4]

let _ = listReverse ["a"; "b"; "c"; "d"]

bad:
let rec listReverse l =
match l with
| [] -> []
| a :: b -> listReverse b :: a
Error: This expression has type string but an expression was expected of type
         'a list


let rec listReverse l =
match l with
| [] -> []
| a :: b -> listReverse b @ a
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4]

let _ = listReverse ["a"; "b"; "c"; "d"]

bad:
let rec listReverse l =
match l with
| [] -> []
| a :: [b] -> listReverse [b] @ a
Error: This expression has type string but an expression was expected of type
         'a list



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4]

let _ = listReverse ["a"; "b"; "c"; "d"]

bad:
let rec listReverse l =
match l with
| [] -> []
| a :: b -> listReverse (b) @ a
Error: This expression has type string but an expression was expected of type
         'a list



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4]

let _ = listReverse ["a"; "b"; "c"; "d"]

bad:
let rec listReverse l =
match l with
| [] -> []
| a :: b -> listReverse b @ a
Error: This expression has type string but an expression was expected of type
         'a list



hw1 palindrome

fix:
let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

let _ = digitsOfInt 0

let digits n = digitsOfInt (abs n)

let rec additivePersistence n =
let sum = sumList (digitsOfInt n) in
if (sum < 10) then 1
else 1 + additivePersistence sum

let _ = additivePersistence 9876

let rec digitalRoot n =
let sum = sumList (digitsOfInt n) in
if (sum < 10) then sum
else digitalRoot sum

let _ = digitalRoot 9876

let rec listReverse l =
match l with
| [] -> []
| a :: b -> listReverse b @ [a]

let _ = listReverse [1; 2; 3; 4]

let _ = listReverse ["a"; "b"; "c"; "d"]

let explode s = 
let rec go i = 
if i >= String.length s 
then [] 
else (s.[i]) :: (go (i+1)) 
in
go 0

let palindrome w =
let wList = explode (w) in
let wReverse = listReverse (explode (w)) in

if (wList = wReverse) then true
else false

let _ = palindrome "malayalam"

let _ = palindrome "myxomatosis"

bad:
let palindrome w =
let wList = explode (w) in
let wReverse = listReverse (explode (w)) in
if (true) then wList
Error: Syntax error



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4]

let _ = listReverse ["a"; "b"; "c"; "d"]

let _ = listReverse []

bad:
let rec listReverse l =
match l with
| [] -> []
(*| a :: b -> listReverse b @ [a] ;;*)
| [a] @ b -> b :: listReverse a
Error: Syntax error


let rec listReverse l =
match l with
| [] -> []
| a :: b -> listReverse b @ [a]
Error: Syntax error



hw1 digitsOfInt

fix:
let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

let _ = digitsOfInt 0

let _ = digitsOfInt (-1)

bad:
let rec digitsOfInt n =
if n < 0 then []
else if n < 10 then [n]
else (n mod 10) :: digitsOfInt (n/10)
Error: This expression has type int but an expression was expected of type
         'a list



hw1 digitsOfInt

fix:
let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

let _ = digitsOfInt 0

let _ = digitsOfInt (-1)

bad:
let rec digitsOfInt n =
if n < 0 then []
else if n < 10 then [n]
else digitsOfInt (n/10) :: [n mod 10]
Error: This expression has type int but an expression was expected of type
         'a list


let rec digitsOfInt n =
if n < 0 then []
else if n > 10 then digitsOfInt (n / 10) :: [n mod 10]
else n
Error: This expression has type int list
       but an expression was expected of type int


let rec digitsOfInt n =
if n < 0 then []
else if n = 0 then [0]
else if n > 10 then digitsOfInt(n mod 10)
else
let a = n mod 10 in
let b = n / 10 in
if b = 0 then [n]
else a :: []
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 digitsOfInt

fix:
let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

let _ = digitsOfInt 0

let _ = digitsOfInt (-1)

bad:
let rec digitsOfInt n =
if n < 0 then []
else if n = 0 then [0]
else if n > 99 then digitsOfInt(n mod 10)
else
let a = n mod 10 in
let b = n / 10 in
if b = 0 then [n]
else a :: digitsOfInt n
Error: Syntax error



hw1 digitsOfInt

fix:
let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

let _ = digitsOfInt 0

let _ = digitsOfInt (-1)

bad:
let rec digitsOfInt n =
let s = string_of_int n in
match s with
| a -> [a]
| a ^ b -> a :: digitsOfInt b
Error: This expression has type int but an expression was expected of type
         string


let rec digitsOfInt n =
let s = string_of_int n in
match s with
| a -> [a]
| a ^ b -> a :: digitsOfInt b
Error: Syntax error


let rec digitsOfInt n =
if n < 0 then []
else if n = 0 then [0]
else if n < 10 then [n]
else (n mod 10) :: digitsOfInt (n / 10)
Error: Syntax error



hw1 digitsOfInt

fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n =
if n < 0 then []
else
let a = n / 10 in
let b = n mod 10 in
let c = [a; b] in
c
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 digitsOfInt

fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n =
if n < 0 then []
else
let a = n / 10 in
let b = n mod 10 in
let c = [a; b] in
if a < 10 then c
else digitsOfInt (a / 10)
Error: This variant expression is expected to have type unit
       The constructor :: does not belong to type unit



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4]

let _ = listReverse ["a"; "b"; "c"; "d"]

let _ = listReverse []

bad:
let rec listReverse l =
match l with
| [] -> []
| a :: b -> listReverse b @ [a]
Error: This expression has type 'a but an expression was expected of type
         'a list
       The type variable 'a occurs inside 'a list



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4]

let _ = listReverse ["a"; "b"; "c"; "d"]

let _ = listReverse []

bad:
match l with
| [] -> []
| a :: b -> let c = listReverse b in
Error: Unbound value b


let rec listReverse l =
match l with
| [] -> []
| a :: b -> let c = listReverse b in
match c with
| [] -> []
| d :: e -> [d; a]
Error: Syntax error



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l =
match l with
| [] -> []
| a :: b -> [listReverse b ; [a]]
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec listReverse l =
match l with
| [] -> []
| b :: [] -> b :: []
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l =
match l with
| [] -> []
| [a;b] -> 0
Error: Unbound value s


let rec listReverse l =
match l with
| [] -> []
| [a;b] -> [a]
Error: This expression has type int but an expression was expected of type
         'a list



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4]

let _ = listReverse ["a"; "b"; "c"; "d"]

let _ = listReverse []

bad:
let rec listReverse l =
let last t =
match t with
| [] -> []
| [a] -> a
| a :: b -> last b
in
last t :: listReverse l
Error: Syntax error


let rec listReverse l =
match l with
| [] -> []
| a :: b -> listReverse b
Error: Unbound value last



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l =
match l with
| [] -> []
| a :: b -> listReverse [a]
Error: This function has type 'a list -> 'b list
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let rec listReverse l =
let last t = function
match t with
| [] -> []
| [a] -> [a]
| b :: c -> last c
in last l
Error: Unbound value last


let rec listReverse l =
let last t = function
| [] -> []
| [a] -> [a]
| b :: c -> last c
in last l
Error: Syntax error


let rec listReverse l =
let rec last t =
match t with
| [] -> []
| [a] -> [a]
| b :: c -> last c
in last l
Error: Unbound value last



hw1 listReverse

fix:
let rec listReverse l =
let a = [] in
let get b = function
| [] -> []
| x :: xs -> x :: a
in get l

bad:
let rec listReverse l =
let a = [] in
let getHead b = function
match b with
| [] -> []
| x :: xs ->
x :: a
getHead xs
in getHead l
Error: This expression has type 'a list
       This is not a function; it cannot be applied.


let rec listReverse l =
let a = [] in
let getHead b = function
| [] -> []
| x :: xs ->
x :: a
getHead xs
in getHead l
Error: Syntax error


let rec listReverse l =
let a = [] in
let rec get a =
match a with
| [] -> []
| x :: xs -> get xs :: [x]
in get l
Error: This expression has type 'a list
       This is not a function; it cannot be applied.


let rec listReverse l =
let a = [] in
let get a = function
| [] -> []
| x :: xs -> x :: a
in get l
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 listReverse

fix:
let _ = listReverse ["a"; "b"; "c"; "d"]

bad:
let _ = listReverse [1; 2; 3; 4]
Error: Syntax error



hw1 digitsOfInt

fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n =
let rec integers a b =
match a with
| [] -> b
| x :: xs -> integers xs ((a mod 10)::b)
in integers n []
Error: This expression has type int but an expression was expected of type
         'a list


let rec digitsOfInt n =
let rec integers a b =
if a = 0 then b
else integers (a/10) ((a mod 10)::b)
in integers n []
Error: This expression has type 'a list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n =
if n = 0 then [0]
else 
let rec integers a b =
if a = 0 then b
else integers (a/10) ((a mod 10)::b)
in integers n []
Error: This expression has type int but an expression was expected of type
         int list



hw1 digitsOfInt

fix:
let rec digitsOfInt n =
if n < 0 then []
else if n = 0 then [0]
else 
let rec integers a b =
if a = 0 then b
else integers (a/10) ((a mod 10)::b)
in integers n []

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

let _ = digitsOfInt 0

let _ = digitsOfInt (-10)

bad:
et _ = digitsOfInt 3124
Error: Syntax error


let _ = digitsOfInt 3124
Error: Syntax error



hw2 assoc

fix:
let rec assoc (d,k,l) = match l with
| []      ->
d
| h :: t  ->
match h with
| (s,l) ->
if d = s then l
else assoc (d, k, t)

bad:
let rec assoc (d,k,l) = match l with
| []      ->
d
| h :: t  ->
match h with
| s * l ->
if d = s then l
else assoc (d, k, t)
Error: Syntax error


let rec assoc (d,k,l) = match l with
| []      ->
d
| h :: t  ->
match h with
| (s * l) ->
if d = s then l
else assoc (d, k, t)
Characters 80-81:
  | (s * l) ->
    ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw2 assoc

fix:
let rec assoc (d,k,l) = match l with
| []      ->
d
| h :: t  ->
match h with
| (s,l) ->
if k = s then l
else assoc (d, k, t)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])
Error: This expression has type string but an expression was expected of type
         int


let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])
Error: This expression has type string but an expression was expected of type
         int



hw2 wwhile

fix:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with
| []    ->
seen
| h::t  ->
let seen' =
if (List.mem h seen) then seen
else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) =
match (f b) with
| (b',c') -> 0

bad:
let rec wwhile (f,b) =
match (b',c')=(f b) in
Error: Syntax error


let rec wwhile (f,b) =
match (f b) in
| (b',c') -> 0
Error: Syntax error



hw2 fixpoint

fix:
let fixpoint (f,b) =
wwhile (f ? false : true,b)

*
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let fixpoint (f,b) =
wwhile (f f b,b)
Error: This expression has type 'a -> 'b -> 'c
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'b -> 'c


let fixpoint (f,b) =
wwhile (,b)
Error: Syntax error: operator expected.



hw2 fixpoint

fix:
let fixpoint (f,b) =
wwhile ((f b) b,b)

bad:
let fixpoint (f,b) =
wwhile (f b = b,b)
Error: This expression has type bool but an expression was expected of type
         'a -> 'a * bool


let fixpoint (f,b) =
wwhile (fun x -> f x = b,b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a


let fixpoint (f,b) =
wwhile (fun x -> (f x = b,b),b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a



hw2 fixpoint

fix:
let fixpoint (f,b) =0

*
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
*
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Syntax error



hw2 fixpoint

fix:
let fixpoint (f,b) =
wwhile ((f b) b,b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
*
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Syntax error



hw2 fixpoint

fix:
let rec assoc (d,k,l) =
match l with
| []      ->
d
| h :: t  ->
match h with
| (s,l) ->
if k = s then l
else assoc (d, k, t)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with
| []    ->
seen
| h::t  ->
let seen' =
if (List.mem h seen) then seen
else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) =
match (f b) with
| (b',c') ->
if c' then wwhile (f,b')
else b'

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) =
wwhile (not f,b)

bad:
let fixpoint (f,b) =
wwhile (equ f b,b)
Error: This expression has type bool but an expression was expected of type
         'a -> 'a * bool


let fixpoint (f,b) =
wwhile (if b=(f b) then true else false,b)
Error: This expression has type bool but an expression was expected of type
         ('a -> 'a * bool) * 'a


let fixpoint (f,b) =
wwhile ((b,f b = b),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) =
wwhile (fun b -> (b,f b = b),b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a


let fixpoint (f,b) =
wwhile (fun b -> (b,(f b) = b),b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a


let fixpoint (f,b) =
wwhile ((f b <> b),b)
Error: This expression has type bool but an expression was expected of type
         'a -> 'a * bool


let fixpoint (f,b) =
wwhile (fun b -> (f b <> b),b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a


let fixpoint (f,b) =
wwhile (match (f,b) with | (b',c') -> (f b' <> b'),b)
Error: This expression has type 'a -> 'b
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'b



hw2 fixpoint

fix:
let fixpoint (f,b) =
wwhile (f,b)

bad:
let fixpoint (f,b) =
wwhile (not ((f b)=b),b)
Error: This expression has type bool but an expression was expected of type
         'a -> 'a * bool


let fixpoint (f,b) =
wwhile ((not f),((f b)=b),b)
Error: This expression has type 'a * 'b * 'c
       but an expression was expected of type ('d -> 'd * bool) * 'd


let fixpoint (f,b) =
wwhile (fun x -> not x,(f b)=b),b
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a


)
Error: Syntax error


let fixpoint (f,b) =
wwhile (x -> not x,(f b)=b),b
Characters 28-29:
  wwhile (x -> not x,(f b)=b),b;;
         ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


)
Error: Syntax error


let fixpoint (f,b) =
wwhile ((x -> not x,(f b)=b),b)
Characters 29-30:
  wwhile ((x -> not x,(f b)=b),b);;
          ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let fixpoint (f,b) =
wwhile ((f,(f b)=b),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool



hw2 fixpoint

fix:
let fixpoint (f,b) =
wwhile (f b,b)

bad:
let fixpoint (f,b) =
let
wwhile (fun f -> (f,(f b)=b),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) =
wwhile (fun f -> (f,(f b)=b),b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a


let fixpoint (f,b) =
wwhile ((f,(f b) = b),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) =
wwhile (f -> (not f,(f b) = b),b)
Characters 28-29:
  wwhile (f -> (not f,(f b) = b),b);;
         ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let fixpoint (f,b) =
wwhile (let x -> not f in (x,(f b) = b),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) =
wwhile (let x = not f in (x,(f b) = b),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool



hw2 fixpoint

fix:
let fixpoint (f,b) =
wwhile (let func x = fun x -> (0,true) in func b,b)

bad:
let fixpoint (f,b) =
wwhile (fun x y -> (y,true) in func f b,b
Characters 28-29:
  wwhile (fun x y -> (y,true) in func f b,b;;
         ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


)
Error: Syntax error


let fixpoint (f,b) =
wwhile (let func x = fun x -> (0,true) in func f b,b)
Error: This expression has type int * bool
       but an expression was expected of type 'a -> 'a * bool



hw2 fixpoint

fix:
let fixpoint (f,b) =
wwhile (let func x = fun x -> (f b,(f b) = b) in func b,b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let fixpoint (f,b) =
wwhile (let rec func x = fun x -> (f b,not ((f b) = b)) in func b,b)

bad:
let fixpoint (f,b) =
wwhile (let func x = fun x -> (f b,(f b) = b) in func b,b)
Error: Unbound value wwhile


let fixpoint (f,b) =
wwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b)
Error: Unbound value wwhile


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let fixpoint (f,b) =
wwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b)
Error: Unbound value wwhile


let fixpoint (f,b) =
wwhile (let _ = fun x -> (f b,not ((f b) = b)) in func b,b)
Error: Unbound value wwhile


let fixpoint (f,b) =
wwhile (fun x -> (f b,not ((f b) = b)),b)
Error: Unbound value wwhile


let fixpoint (f,b) =
wwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b)
Error: Unbound value wwhile


let fixpoint (f,b) =
wwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b)
Error: Unbound value wwhile


let fixpoint (f,b) =
wwhile (let func x = fun x -> (f b,f b = b),b)
Error: Unbound value wwhile


let fixpoint (f,b) =
wwhile (let func x = fun x -> (f b,f b = b) in func,b)
Error: Syntax error: operator expected.


let fixpoint (f,b) =
wwhile (let func x = fun x -> (f x,f x = x),b)
Error: Unbound value wwhile


let fixpoint (f,b) =
wwhile (let func x = fun x -> (f x,f x = x) in func,b)
Error: Syntax error: operator expected.


let fixpoint (f,b) =
wwhile (let func = fun x -> (f x,f x = x) in func,b)
Error: Unbound value wwhile


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile


let fixpoint (f,b) =
wwhile (let func = fun x -> (f x,f x <> x) in func,b)
Error: Unbound value fixpoint


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 exprToString

fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

let _ = exprToString sampleExpr1

bad:
let rec exprToString e =
match e with
VarX				      ->
"x"
| VarY					->
"y"
| Sine    of				->
"sin(" ^ exprToString expr ^ ")"
| Cosine  of expr			->
"cos(" ^ exprToString expr ^ ")"
| Average of expr * expr		->
"(" ^ exprToString expr ^ "+" ^ exprToString expr ^ ")/2)"
| Times   of expr * expr		->
| Thresh  of expr * expr * expr * expr  ->
Error: Syntax error


let rec exprToString e =
match e with
VarX				      ->
"x"
| VarY					->
"y"
| Sine    of expr			->
"sin(" ^ exprToString expr ^ ")"
| Cosine  of expr			->
"cos(" ^ exprToString expr ^ ")"
| Average of expr * expr		->
"(" ^ exprToString expr ^ "+" ^ exprToString expr ^ ")/2)"
| Times   of expr * expr		->
| Thresh  of expr * expr * expr * expr  ->
Error: Syntax error


let rec exprToString e =
match e with
VarX				      ->
"x"
| VarY					->
"y"
| Sine    of expr			->
"sin(" ^ exprToString expr ^ ")"
| Cosine  of expr			->
"cos(" ^ exprToString expr ^ ")"
| Average of expr * expr		->
"(" ^ exprToString expr ^ "+" ^ exprToString expr ^ ")/2)"
| Times   of expr * expr		->
"(" ^ exprToString expr ^ "*" ^ exprToString expr ^ ")"
| Thresh  of expr * expr * expr * expr  ->
"(" ^ expr ^ "<" ^ expr ^ "?" ^ expr ^ ":" ^ expr ^ ")"
Error: Syntax error


let rec exprToString e =
match e with
VarX				      ->
"x"
| VarY					->
"y"
| Sine of expr			->
"sin(" ^ exprToString expr ^ ")"
| Cosine  of expr			->
"cos(" ^ exprToString expr ^ ")"
| Average of expr * expr		->
"(" ^ exprToString expr ^ "+" ^ exprToString expr ^ ")/2)"
| Times   of expr * expr		->
"(" ^ exprToString expr ^ "*" ^ exprToString expr ^ ")"
| Thresh  of expr * expr * expr * expr  ->
"(" ^ expr ^ "<" ^ expr ^ "?" ^ expr ^ ":" ^ expr ^ ")"
Error: Syntax error


let rec exprToString e =
match e with
VarX				      ->
"x"
| VarY					->
"y"
| Sine expr			->
"sin(" ^ exprToString expr ^ ")"
| Cosine  of expr			->
"cos(" ^ exprToString expr ^ ")"
| Average of expr * expr		->
"(" ^ exprToString expr ^ "+" ^ exprToString expr ^ ")/2)"
| Times   of expr * expr		->
"(" ^ exprToString expr ^ "*" ^ exprToString expr ^ ")"
| Thresh  of expr * expr * expr * expr  ->
"(" ^ expr ^ "<" ^ expr ^ "?" ^ expr ^ ":" ^ expr ^ ")"
Error: Syntax error


let rec exprToString e =
match e with
VarX				      ->
"x"
| VarY					->
"y"
| Sine    expr			->
"sin(" ^ exprToString expr ^ ")"
| Cosine  expr			->
"cos(" ^ exprToString expr ^ ")"
| Average expr * expr		->
"(" ^ exprToString expr ^ "+" ^ exprToString expr ^ ")/2)"
| Times   expr * expr		->
"(" ^ exprToString expr ^ "*" ^ exprToString expr ^ ")"
| Thresh  expr * expr * expr * expr  ->
"(" ^ expr ^ "<" ^ expr ^ "?" ^ expr ^ ":" ^ expr ^ ")"
Error: Syntax error


let rec exprToString e =
match e with
VarX				  ->
"x"
| VarY				    ->
"y"
| Sine    expr			    ->
"sin(" ^ exprToString expr ^ ")"
| Cosine  expr			    ->
"cos(" ^ exprToString expr ^ ")"
| Average (expr * expr)	    ->
"(" ^ exprToString expr ^ "+" ^ exprToString expr ^ ")/2)"
| Times   expr * expr		    ->
"(" ^ exprToString expr ^ "*" ^ exprToString expr ^ ")"
| Thresh  expr * expr * expr * expr ->
"(" ^ expr ^ "<" ^ expr ^ "?" ^ expr ^ ":" ^ expr ^ ")"
Error: Syntax error


let rec exprToString e =
match e with
VarX				  ->
"x"
| VarY				    ->
"y"
| Sine    expr			    ->
"sin(" ^ exprToString expr ^ ")"
| Cosine  expr			    ->
"cos(" ^ exprToString expr ^ ")"
| Average (expr,expr)		    ->
"(" ^ exprToString expr ^ "+" ^ exprToString expr ^ ")/2)"
| Times   (expr,expr)		    ->
"(" ^ exprToString expr ^ "*" ^ exprToString expr ^ ")"
| Thresh  (expr,expr,expr,expr)     ->
"(" ^ expr ^ "<" ^ expr ^ "?" ^ expr ^ ":" ^ expr ^ ")"
Characters 200-201:
  | Average (expr * expr)	    ->
            ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let rec exprToString e =
match e with
VarX				  ->
"x"
| VarY				    ->
"y"
| Sine    expr0			    ->
"sin(" ^ exprToString expr0 ^ ")"
| Cosine  expr0			    ->
"cos(" ^ exprToString expr0 ^ ")"
| Average (expr0,expr1)		    ->
"(" ^ exprToString expr0 ^ "+" ^ exprToString expr1 ^ ")/2)"
| Times   (expr0,expr1)		    ->
"(" ^ exprToString expr0 ^ "*" ^ exprToString expr1 ^ ")"
| Thresh  (expr0,expr1,expr2,expr3)     ->
"(" ^ expr0 ^ "<" ^ expr1 ^ "?" ^ expr2 ^ ":" ^ expr3 ^ ")"
Error: Variable expr is bound several times in this matching


let rec exprToString e =
match e with
VarX				  ->
"x"
| VarY				    ->
"y"
| Sine    expr0			    ->
"sin(" ^ exprToString expr0 ^ ")"
| Cosine  expr0			    ->
"cos(" ^ exprToString expr0 ^ ")"
| Average (expr0,expr1)		    ->
"(" ^ exprToString expr0 ^ "+" ^ exprToString expr1 ^ ")/2)"
| Times   (expr0,expr1)		    ->
"(" ^ exprToString expr0 ^ "*" ^ exprToString expr1 ^ ")"
| Thresh  (expr0,expr1,expr2,expr3)     ->
"(" ^ exprToString expr0 ^ "<" ^ exprToString expr1 ^ "?" ^ exprToString expr2 ^ ":" ^ exprToString expr3 ^ ")"
Error: This expression has type expr but an expression was expected of type
         string



hw2 eval

fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr,0.5,0.2)

bad:
let rec eval (e,x,y) =
match e with
VarX				  ->
x
| VarY				    ->
y
| Sine    expr0			    ->
sin (eval (expr0,x,y))
| Cosine  expr0			    ->
cos (eval (expr0,x,y))
| Average (expr0,expr1)		    ->
(eval (expr0,x,y) +. eval (expr1,x,y)) /. 2.
| Times (expr0,expr1)		    ->
eval (expr0,x,y) *. eval (expr1,x,y)
| Thresh  (expr0,expr1,expr2,expr3) ->
match (eval (expr0,x,y) < eval (expr1,x,y)) with
true  ->
eval (expr2,x,y)
| false ->
eval (expr3,x,y)
Error: This expression has type int but an expression was expected of type
         float



hw2 build

fix:
let rec build (rand, depth) =
match depth with
0 ->
(match rand (0,1) with
0 -> buildX()
| 1 -> buildY()
)
| _ ->
(match rand (0,3) with
0 ->
buildSine(build(rand,depth-1))
| 1 ->
buildCosine(build(rand,depth-1))
| 2 ->
buildAverage(build(rand,depth-1),build(rand,depth-1))
| 3 ->
buildTimes(build(rand,depth-1),build(rand,depth-1))
| 4 ->
buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
)

bad:
let rec build (rand, depth) =
match depth with
0 ->
(match rand (0,1) with
0 -> buildX()
| 1 -> buildY()
)
| _ ->
(match rand (0,4) with
0 ->
buildSine(build(rand,depth-1))
| 1 ->
buildCosine(build(rand,depth-1))
| 2 ->
buildAverage(build(rand,depth-1),build(rand,depth-1))
| 3 ->
buildTimes(build(rand,depth-1),build(rand,depth-1))
| 4 ->
buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
)
Error: This expression has type expr but an expression was expected of type
         expr * expr



hw2 build

fix:
type expr = 
VarX
| VarY
| Sine     of expr
| Cosine   of expr
| Average  of expr * expr
| Times    of expr * expr
| Thresh   of expr * expr * expr * expr
| Maximum  of expr * expr * expr
| Absolute of expr

let rec exprToString e =
match e with
VarX				  ->
"x"
| VarY				    ->
"y"
| Sine    expr0			    ->
"sin(pi*" ^ exprToString expr0 ^ ")"
| Cosine  expr0			    ->
"cos(pi*" ^ exprToString expr0 ^ ")"
| Average (expr0,expr1)		    ->
"(" ^ exprToString expr0 ^ "+" ^ exprToString expr1 ^ ")/2)"
| Times   (expr0,expr1)		    ->
exprToString expr0 ^ "*" ^ exprToString expr1
| Thresh  (expr0,expr1,expr2,expr3) ->
"(" ^ exprToString expr0 ^ "<" ^ exprToString expr1 ^ "?" ^ exprToString expr2 ^ ":" ^ exprToString expr3 ^ ")"
| Maximum (expr0,expr1,expr2)	    ->
"maximum(" ^ exprToString expr0 ^ "," ^ exprToString expr1 ^ "," ^ exprToString expr2 ^ ")"
| Absolute expr0		    ->
"absolute(" ^ exprToString expr0 ^ ")"

let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

let _ = exprToString sampleExpr1

let buildX()                       = VarX

let buildY()                       = VarY

let buildSine(e)                   = Sine(e)

let buildCosine(e)                 = Cosine(e)

let buildAverage(e1,e2)            = Average(e1,e2)

let buildTimes(e1,e2)              = Times(e1,e2)

let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)

let buildMaximum(e1,e2,e3)	   = Maximum(e1,e2,e3)

let buildAbsolute(e)		   = Absolute(e)

let pi = 4.0 *. atan 1.0

let rec eval (e,x,y) =
match e with
VarX				  ->
x
| VarY				    ->
y
| Sine    expr0			    ->
sin (pi *. eval (expr0,x,y))
| Cosine  expr0			    ->
cos (pi *. eval (expr0,x,y))
| Average (expr0,expr1)		    ->
(eval (expr0,x,y) +. eval (expr1,x,y)) /. 2.
| Times (expr0,expr1)		    ->
eval (expr0,x,y) *. eval (expr1,x,y)
| Thresh  (expr0,expr1,expr2,expr3) ->
(match (eval (expr0,x,y) < eval (expr1,x,y)) with
true  ->
eval (expr2,x,y)
| false ->
eval (expr3,x,y)
)
| Maximum (expr0,expr1,expr2)       ->
(match (eval (expr0,x,y) < eval (expr1,x,y)) with
true  ->
(match (eval (expr1,x,y) < eval (expr2,x,y)) with
true  ->
eval (expr2,x,y)
| false ->
eval (expr1,x,y)
)
| false ->
(match (eval (expr0,x,y) < eval (expr2,x,y)) with
true  ->
eval (expr2,x,y)
| false ->
eval (expr0,x,y)
)
)
| Absolute (expr0)		    ->
(match (eval (expr0,x,y) < 0) with
true  ->
0.0 -. eval (expr0,x,y)
| false ->
eval (expr0,x,y)
)

let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv

let sampleExpr =
buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(
buildX()),buildTimes(buildCosine (buildCosine (buildAverage
(buildTimes (buildY(),buildY()),buildCosine (buildX())))),
buildCosine (buildTimes (buildSine (buildCosine
(buildY())),buildAverage (buildSine (buildX()), buildTimes
(buildX(),buildX()))))))),buildY())))

let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))

let _ = eval (sampleExpr,0.5,0.2)

let rec build (rand, depth) =
match depth with
0 ->
(match rand (0,1) with
0 ->
buildX()
| _ ->
buildY()
)
| _ ->
(match rand (0,6) with
0 ->
buildSine(build(rand,depth-1))
| 1 ->
buildCosine(build(rand,depth-1))
| 2 ->
buildAverage(build(rand,depth-1),build(rand,depth-1))
| 3 ->
buildTimes(build(rand,depth-1),build(rand,depth-1))
| 4 ->
buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
| 5 ->
buildMaximum(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
| 6 ->
buildAbsolute(build(rand,depth-1)
)

let g1 () = (12,0,9)

let g2 () = (11,1,8)

let g3 () = (10,2,7)

let c1 () = (9,3,6)

let c2 () = (8,4,5)

let c3 () = (7,5,4)

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))


let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

(********************* Bitmap creation code ***************)

(* 
You should not have to modify the remaining functions.
Add testing code to the bottom of the file.
*)

(* Converts an integer i from the range [-N,N] into a float in [-1,1] *)
let toReal (i,n) = (float_of_int i) /. (float_of_int n)

(* Converts real in [-1,1] to an integer in the range [0,255]  *)
let toIntensity z = int_of_float (127.5 +. (127.5 *. z))


(* ffor: int * int * (int -> unit) -> unit
Applies the function f to all the integers between low and high
inclusive; the results get thrown away.
*)

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

(* emitGrayscale :  ((real * real) -> real) * int -> unit
emitGrayscale(f, N) emits the values of the expression
f (converted to intensity) to the file art.pgm for an 
2N+1 by 2N+1 grid of points taken from [-1,1] x [-1,1].

See "man pgm" on turing for a full description of the file format,
but it's essentially a one-line header followed by
one byte (representing gray value 0..255) per pixel.
*)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

(* doRandomGray : int * int * int -> unit
Given a depth and two seeds for the random number generator,
create a single random expression and convert it to a
grayscale picture with the name "art.pgm" *)

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

(* uncomment when you have implemented `build` *)

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

bad:
let rec build (rand, depth) =
match depth with
0 ->
(match rand (0,1) with
0 ->
buildX()
| _ ->
buildY()
)
| _ ->
(match rand (0,6) with
0 ->
buildSine(build(rand,depth-1))
| 1 ->
buildCosine(build(rand,depth-1))
| 2 ->
buildAverage(build(rand,depth-1),build(rand,depth-1))
| 3 ->
buildTimes(build(rand,depth-1),build(rand,depth-1))
| 4 ->
buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
| 5 ->
buildMaximum(build(ran,depth-1),build(rand,depth-1),build(rand,depth-1))
| 6 ->
)
Error: Syntax error: operator expected.



hw2 build

fix:
let rec build (rand, depth) =
match depth with
0 ->
(match rand (0,1) with
0 ->
buildX()
| _ ->
buildY()
)
| _ ->
(match rand (0,6) with
0 ->
buildSine(build(rand,depth-1))
| 1 ->
buildCosine(build(rand,depth-1))
| 2 ->
buildAverage(build(rand,depth-1),build(rand,depth-1))
| 3 ->
buildTimes(build(rand,depth-1),build(rand,depth-1))
| 4 ->
buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
| 5 ->
buildMaximum(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
| _ ->
buildAbsolute(build(rand,depth-1))
)

bad:
let rec build (rand, depth) =
match depth with
0 ->
(match rand (0,1) with
0 ->
buildX()
| _ ->
buildY()
)
| _ ->
(match rand (0,6) with
0 ->
buildSine(build(rand,depth-1))
| 1 ->
buildCosine(build(rand,depth-1))
| 2 ->
buildAverage(build(rand,depth-1),build(rand,depth-1))
| 3 ->
buildTimes(build(rand,depth-1),build(rand,depth-1))
| 4 ->
buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
| 5 ->
buildMaximum(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
| 6 ->
buildAbsolute(build(rand,depth-1))
)
Error: This expression has type expr/2139
       but an expression was expected of type expr/3472
Error: Unbound constructor Average
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type expr/2139
       but an expression was expected of type expr/3472



hw3 pipe

fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = a x in
let base = 0 in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

bad:
let _ = pipe [] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe fs n = 
let f a x = x a in
let base n = 0 in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

bad:
let pipe fs = 
let f a x = f a x in
let base = 0 in
List.fold_left f base fs
Error: Unbound value f


let _ = pipe [] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let pipe fs = 
let f a x = a x in
let base = x in
List.fold_left f base fs
Error: Unbound value x


let _ = pipe [] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = "" in
let l =  in
List.fold_left f base l
Error: Syntax error



hw3 stringOfList

fix:
let stringOfList f l = "[ " ^ sepConcat "; " l ^ " ]"

bad:
let stringOfList f l = "[ " ^ sepConCat "; " l ^ " ]"
Error: Unbound value sepConCat
Hint: Did you mean sepConcat?
Error: Unbound value sepConCat
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value sepConCat
Hint: Did you mean sepConcat?



hw3 bigAdd

fix:
let sqsum xs = 
let f a x = a + (x * x) in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs n = 
let f a x = x a in
let base = n in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = "[" ^ (sepConcat "; " (List.map f l)) ^ "]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n =
match n > 0 with
true  ->
x :: (clone x (n - 1))
| false ->
[]

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let padZero l1 l2 =
let length1 = List.length l1 in
let length2 = List.length l2 in
match length1 >= length2 with
true  ->
let n = length1 - length2 in
let zeroes = clone 0 n in
(l1, List.append zeroes l2)

| false ->
let n = length2 - length1 in
let zeroes = clone 0 n in
(List.append zeroes l1, l2)

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

let rec removeZero l =
match l with
[]    ->
[]
| h::t  -> match h with
0 ->
removeZero t
| _ -> t

let _ = removeZero [0;0;0;1;0;0;2]

let _ = removeZero [9;9]

let _ = removeZero [0;0;0;0]

let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =
match a with
(carry,result)  ->
match x with
(h1::t1, h2::t2)  ->
((h1+h2+carry)/10,  ((h1+h2) mod 10)::result)
in
let base = (0, []) in
let args = (l1,l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = 0 in
let args = (l1, l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = 0 in
let args = [l1;l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = 0 in
let args = [l1;l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = (0,0) in
let args = [l1;l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int * int
       but an expression was expected of type int


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (0, a + x) in
let base = (0,0) in
let args = [l1;l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int -> int -> int * int
       but an expression was expected of type int -> int -> int
       Type int * int is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = (0,0) in
let args = [l1;l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int * int
       but an expression was expected of type int


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = l1 in
let args = [l1;l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = l1 in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = l1 in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = (_, l1) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error: operator expected.


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = (0, l1) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int * 'a
       but an expression was expected of type int


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = l1 in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = in
let base = in
let args = in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = l1 in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (a, a+x) in
let base = 0 in
let args = 1 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int -> int -> int * int
       but an expression was expected of type int -> int -> int
       Type int * int is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (a, a+x) in
let base = 0 in
let args = [1] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int -> int -> int * int
       but an expression was expected of type int -> int -> int
       Type int * int is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =
match a with 
ah::at  ->
match x with
xh::xt  ->
ah+at
in
let base = l1 in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list
       but an expression was expected of type int


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =
match a with 
ah::at  ->
match x with
xh::xt  ->
ah+xh
in
let base = l1 in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list -> int list -> int
       but an expression was expected of type
         int list -> int list -> int list
       Type int is not compatible with type int list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =
match x with 
(ah::at, bh::bt)  ->
(1,(ah+bh)::a)
in
let base = [] in
let args = (l1, l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type
         int list -> int list * int list -> int * int list
       but an expression was expected of type
         int list -> int list * int list -> int list
       Type int * int list is not compatible with type int list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =
match x with 
(ah::at, bh::bt)  ->
(1,(ah+bh)::a)
in
let base = (0, []) in
let args = (l1, l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type
         int list -> int list * int list -> int * int list
       but an expression was expected of type
         int list -> int list * int list -> int list
       Type int * int list is not compatible with type int list 



hw3 padZero

fix:
let padZero l1 l2 =
let length1 = List.length l1 in
let length2 = List.length l2 in
match length1 >= length2 with
true  ->
let n = length1 - length2 in
let zeroes = clone 0 n in
(l1, List.append zeroes l2)

| false ->
let n = length2 - length1 in
let zeroes = clone 0 n in
(List.append zeroes l1, l2)

bad:
let padZero l1 l2 =
let length1 = List.length l1 in
let length2 = List.length l2 in
match length1 >= length2 with
true  ->
let n = length1 - length2 in
let zeroes = clone 0 n in
(l1, List.append (zeroes l2))

| false ->
let n = length2 - length1 in
let zeroes = clone 0 n in
(List.append (zeroes l1, l2))
Error: This expression has type int list
       This is not a function; it cannot be applied.


let padZero l1 l2 =
let length1 = List.length l1 in
let length2 = List.length l2 in
match length1 >= length2 with
true  ->
let n = length1 - length2 in
let zeroes = clone 0 n in
(l1, List.append (zeroes l2))

| false ->
let n = length2 - length1 in
let zeroes = clone 0 n in
(List.append (zeroes l1), l2)
Error: This expression has type int list
       This is not a function; it cannot be applied.



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
(*
let f a x = (0,[]) in
let base = (l1, []) in
let args = l2 in*)
let (_, res) = (0,[0;0;0;0])(*List.fold_left f base args*) in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
(*
let f a x = (0,[]) in
let base = (l1, []) in
let args = l2 in*)
let (_, res) = (0;[0;0;0;0])(*List.fold_left f base args*) in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type 'b * 'c



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = (0,[0;0;0;0]) in
let base = (0,[0;0;0;0]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = (0,[0;0;0;0]) in
let base = (l1, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type int list * int list
       but an expression was expected of type int * 'a list
       Type int list is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = (0,[0;0;0;0]) in
let base = (l1) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type int list * int list
       but an expression was expected of type (int * int list) * 'a list
       Type int list is not compatible with type int * int list 


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = (0,[0;0;0;0]) in
let base = l1 in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type int list * int list
       but an expression was expected of type (int * int list) * 'a list
       Type int list is not compatible with type int * int list 



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = (0,[0;0;0;0]) in
let base = (0,l1) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = (0,[0;0;0;0]) in
let base = (0,[]) in
let args = (l1,l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =(*
match a with
[]  ->
([],[])
| h1::t1  ->*)
(l1,[0;0;0;0])
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = function  ->
match a with
[]  ->
([],[])
| h1::t1  ->
(l1,[0;0;0;0])
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = function
match a with
[]  ->
([],[])
| h1::t1  ->
(l1,[0;0;0;0])
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = fun
match a with
[]  ->
([],[])
| h1::t1  ->
(l1,[0;0;0;0])
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
match a with
[]  ->
([],[])
| h1::t1  ->
(l1,[0;0;0;0])
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list -> 'b -> 'c list * int list
       but an expression was expected of type 'a list -> 'b -> 'a list
       Type 'c list * int list is not compatible with type 'a list 



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
match a with
(h1::t1,_)  ->
(l1,[0;0;0;0])
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
match a with
[]  ->
(l1,[0;0;0;0])
| h1::t1  ->
(l1,[0;0;0;0])
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list -> 'b -> 'c * int list
       but an expression was expected of type 'a list -> 'b -> 'a list
       Type 'c * int list is not compatible with type 'a list 


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
match a with
h1::t1  ->
(l1,[0;0;0;0])
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list -> 'b -> 'c * int list
       but an expression was expected of type 'a list -> 'b -> 'a list
       Type 'c * int list is not compatible with type 'a list 



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
match a with
(h1::t1, rh::rt)  ->
(t1,((h1+x+rh) mod 10)::rt)
in
let base = (l1,[0]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
Printf.printf(%d, a)
match a with
(h1::t1, rh::rt)  ->
(t1,((h1+x+rh) mod 10)::rt)
in
let base = (l1,[0]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Characters 64-65:
  Printf.printf(%d, a)
               ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
match a with
(h1::t1, rh::rt)  ->
(t1,(h1+x+rh)/10::((h1+x+rh) mod 10)::rt)
in
let base = (l1,[0]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
match a with
(h1::t1, rh::rt)  ->
(t1,(h1+x+rh)/10)::((h1+x+rh) mod 10)::rt
Error: Syntax error


)
in
let base = (l1,[0]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: Syntax error



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
match a with
(h1::t1, [])      ->
(List.tl (List.rev (h1::t1)), (h1+x)/10::((h1+x) mod 10)::[])
| (h1::t1, rh::rt)  ->
(List.tl (List.rev (h1::t1)), (h1+x+rh)/10::((h1+x+rh) mod 10)::rt)
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
match a with
(h1::t1, [])      ->
(List.tl List.rev h1::t1, (h1+x)/10::((h1+x) mod 10)::[])
| (h1::t1, rh::rt)  ->
(List.tl List.rev h1::t1, (h1+x+rh)/10::((h1+x+rh) mod 10)::rt)
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
match a with
(h1::t1, [])      ->
let h2::t2 = List.rev (h1::t1) in
(List.rev t2, (h2+x)/10::((h2+x) mod 10)::[])
| (h1::t1, rh::rt)  ->
let h2::t2 = List.rev (h1::t1) in
(List.rev t2, (h2+x+rh)/10::((h2+x+rh) mod 10)::rt)
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
match a with
(h1::t1, [])      ->
let h2::t2 = List.rev h1::t1 in
(List.rev t2, (h2+x)/10::((h2+x) mod 10)::[])
| (h1::t1, rh::rt)  ->
let h2::t2 = List.rev h1::t1 in
(List.rev t2, (h2+x+rh)/10::((h2+x+rh) mod 10)::rt)
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type int


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x =
match a with
(h1::t1, [])      ->
let h2::t2 = List.rev h1::t1 in
(List.rev t2, (h2+x)/10::((h2+x) mod 10)::[])
| (h1::t1, rh::rt)  ->
let h2::t2 = List.rev h1::t1 in
(List.rev t2, (h2+x+rh)/10::((h2+x+rh) mod 10)::rt)
in
let base = (l1,[]) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = match a with
(h1::t1, rh::rt)  ->
(t1, bigAdd (mulByDigit h1 (rh::rt)) rt)
in
let base = (List.rev l1, [0]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = match a with
(h1::t1, rh::rt)  ->
(t1, bigAdd (mulByDigit h1 rh::rt) rt)
in
let base = (List.rev l1, [0]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list
       but an expression was expected of type int


let _ = bigMul [9;9;9;9] [9;9;9;9]
Error: Unbound value bigMul



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = match a with
(h1::t1, r) ->
(h1::t1, bigAdd (mulByDigit x (h1::t1)) r)
| _	      ->
(* Should not get here *) ([], [])
in
let base = (List.rev l1, [1]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

let _ = bigMul [2] [1]

bad:
let bigMul l1 l2 = 
let f a x = match a with
(h1::t1, r) ->
(h1::t1, bigAdd (mulByDigit x h1::t1) r)
| _	      ->
(* Should not get here *) ([], [])
in
let base = (List.rev l1, [1]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list
       but an expression was expected of type int


let _ = bigMul [2] [1]
Error: This expression has type int but an expression was expected of type
         int list



hw3 pipe

fix:
let pipe fs n =
let f a x = x a in
let base = n in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = n in
List.fold_left f base fs
Error: Unbound value n


let pipe fs = fun
let f a x = x a in
let base = n in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x =
match x with
[]  ->

| _   ->
x a
in
let base = n in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

bad:
let pipe fs = 
let f a x = x a in
let base = fun x in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x =
match x with
[]  ->
1
| _   ->
0

in
let base = f 0 [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =
let g b y n =
match n with
[]  ->
n
| _   ->
y b
in g a x
in
let base = f 0 [] in
List.fold_left f base fs
Error: This expression has type 'a list
       but an expression was expected of type int -> 'b list



hw3 pipe

fix:
let pipe fs = 
let f a x =
match a with
[]  ->
[]
| _   ->
x a
in
let base = f [] (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =
match x with
[]  ->
1
| _   ->
x a
in
let base = f 0 [] in
List.fold_left f base fs
Error: This expression has type 'a list
       This is not a function; it cannot be applied.


let pipe fs = 
let f a x =
match x with
[]  ->
[]
| _   ->
x a
in
let base = f 0 [] in
List.fold_left f base fs
Error: This expression has type 'a list
       This is not a function; it cannot be applied.



hw3 pipe

fix:
let pipe fs = 
let f a x =
fun a x ->
match x with
x',y  ->
x' a
in
let base = f 0 [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =
match x with
[]  ->
[]
| _   ->
x a
in
let base = f 0 [] in
List.fold_left f base fs
Error: This expression has type 'a list
       This is not a function; it cannot be applied.


let pipe fs = 
let f a x =
match x with
[] ->
a
| _  ->
x a
in
let base = f 0 [] in
List.fold_left f base fs
Error: This expression has type 'a list
       This is not a function; it cannot be applied.


let pipe fs = 
let f a x =
fun g b y z ->
match y with
[] ->
z
| _  ->
b a
in
let base = f 0 [] in
List.fold_left f base fs
Error: This expression has type
         'a -> 'b -> 'c -> ('a -> 'd) -> 'e list -> 'd -> 'd
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside
       'c -> ('a -> 'd) -> 'e list -> 'd -> 'd


let pipe fs = 
let f a x =
fun a x ->
match x with
x' y  ->
match x' with
[]  ->
y
| _   ->
x' a
in
let base = f 0 [] in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x =
fun a x ->
match x with
x',y  ->
match x' with
[]  ->
y
| _   ->
x' a
in
let base = f 0 [] in
List.fold_left f base fs
Error: This expression has type 'a list
       This is not a function; it cannot be applied.



hw3 pipe

fix:
let pipe fs = 
let f a x =
match x with
[]  ->
0
| _   ->
1
in
let base = 0 in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

bad:
let _ = pipe [] 3
Error: This function has type 'a list list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This function has type 'a list list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This function has type 'a list list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let pipe fs = 
let f a x =
match x with
[]  ->
0
| _   ->
1
in
let base = [] in
List.fold_left f base fs
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs = 
let f a x =
x a
in
let base = 0 in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

bad:
let pipe fs = 
let f a x =
match x with
[]  ->
a
| _   ->
x a
in
let base = 0 in
List.fold_left f base fs
Error: This expression has type 'a list
       This is not a function; it cannot be applied.



hw3 pipe

fix:
let pipe fs n = 
let f a x = x a in
let base = n in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

bad:
let pipe fs = 
let f a x =
x
in
let base = a in
List.fold_left f base fs
Error: Unbound value a


let pipe fs = 
let f a x =
x
in
let base = f x in
List.fold_left f base fs
Error: Unbound value x



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun x y -> y in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

bad:
let pipe fs = 
let f a x = x a in
let base =match fs with
(fn,n)  -> n in
List.fold_left f base fs
Error: This expression has type 'a * 'b
       but an expression was expected of type ('b -> 'b) list



hw3 pipe

fix:
let pipe fs =
let f a x = fun fn -> fun x a -> fn in
let base = fun b -> b in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

bad:
let pipe fs =
let f a x = let fn = fun x a in fn in
let base = fun b -> b in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs =
let f a x = fun y -> x a in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = fun y -> x base in
let base = fun b -> b in
List.fold_left f base fs
Error: Unbound value base



hw3 pipe

fix:
let pipe fs =
let f a x = fun y -> fun z -> y z in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = match x with
fun y -> y a in
let base = fun b -> b in
List.fold_left f base fs
Error: Syntax error


let pipe fs =
let f a x = match x with
(fun y) -> y a in
let base = fun b -> b in
List.fold_left f base fs
Error: Syntax error: operator expected.


let pipe fs =
let f a x = match x with
(function y) -> y a in
let base = fun b -> b in
List.fold_left f base fs
Error: Syntax error: operator expected.



hw3 pipe

fix:
let pipe fs =
let f a x = fun y -> x a in
let base = fun b -> b in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'b


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'b


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'b



hw3 pipe

fix:
let pipe fs =
let f a x = fun y -> x a in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = fun y -> x a in
let base = b in
List.fold_left f base fs
Error: Unbound value b


let pipe fs =
let f a x = fun y -> x a in
let base = fun b in
List.fold_left f base fs
Error: Syntax error


let pipe fs =
let f a x = fun y -> x a in
let base = fun b -> fun b in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs =
let f a x = let an = a in x an in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = fun y -> fun z -> z (fun r -> y) in
let base = fun b -> b in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> (('b -> 'a) -> 'c) -> 'c
       The type variable 'a occurs inside (('b -> 'a) -> 'c) -> 'c


let pipe fs =
let f a x = fun y -> fun z -> z (fun r -> y) in
let base = fun b -> b in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> (('b -> 'a) -> 'c) -> 'c
       The type variable 'a occurs inside (('b -> 'a) -> 'c) -> 'c


let pipe fs =
let f a x = fun y -> fun z -> z y in
let base = fun b -> b in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> ('a -> 'b) -> 'b
       The type variable 'a occurs inside ('a -> 'b) -> 'b



hw3 pipe

fix:
let pipe fs =
let f a x = let y = a in x y in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = let fun y z = fun xn -> fun an -> xn an in y in
let base = fun b -> b in
List.fold_left f base fs
Error: Syntax error


let pipe fs =
let f a x = let y z = fun xn -> xn a in y in
let base = fun b -> b in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'c -> ('a -> 'd) -> 'd
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'c -> ('a -> 'd) -> 'd


let pipe fs =
let f a x = let y z = fun xn -> xn a in y in
let base = fun b -> b in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'c -> ('a -> 'd) -> 'd
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'c -> ('a -> 'd) -> 'd



hw3 pipe

fix:
let pipe fs =
let f a x = let y = pipe x a in y in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = let y = pipe x a in x y in
let base = fun b -> b in
List.fold_left f base fs
Error: This expression has type (('a -> 'a) -> 'a -> 'a) list
       This is not a function; it cannot be applied.



hw3 pipe

fix:
let pipe fs =
let f a x = x(a) in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = f x(a) in
let base = fun b -> b in
List.fold_left f base fs
Error: Unbound value f



hw3 pipe

fix:
let pipe fs =
let f a x = fun y z -> z (x (a)) in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = fun c y z -> z (a (c)) in
let base = fun b -> b in
List.fold_left f base fs
Error: This expression has type
         ('a -> 'b) -> 'c -> 'a -> 'd -> ('b -> 'e) -> 'e
       but an expression was expected of type ('a -> 'b) -> 'c -> 'a -> 'b
       The type variable 'b occurs inside 'd -> ('b -> 'e) -> 'e


let pipe fs =
let f a x = fun y z -> z (a (c)) in
let base = fun b -> b in
List.fold_left f base fs
Error: Unbound value c



hw3 pipe

fix:
let pipe fs =
let f a x = fun c -> x (a) in
let base = fun b -> b in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = fun c -> c (x (a)) in
let base = fun b -> b in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs =
let f a x = fun c -> x c in
let base = fun b -> b in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs =
let f a x = fun c -> fun d -> x c in
let base = fun b -> b in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'b


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         int -> int


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This expression has type int but an expression was expected of type
         int -> int



hw3 pipe

fix:
let pipe fs =
let f a x = fun c -> x (fun d -> a) in
let base = fun b -> b in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'b


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'b
       but an expression was expected of type int


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This expression has type 'a -> 'b
       but an expression was expected of type int


let pipe fs =
let f a x = fun c -> fun d -> d c in
let base = fun b -> b in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> ('a -> 'b) -> 'b
       The type variable 'a occurs inside ('a -> 'b) -> 'b


let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'b


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'b
       but an expression was expected of type int


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This expression has type 'a -> 'b
       but an expression was expected of type int


let pipe fs =
let f a x = fun c -> a in
let base = fun b -> b in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'c -> 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'c -> 'a


let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'b


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'b
       but an expression was expected of type int


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This expression has type 'a -> 'b
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs =
let f a x = fun c -> x in
let base = fun b -> b in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         'a -> 'b


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         int -> int


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This expression has type int but an expression was expected of type
         int -> int



hw2 assoc

fix:
let rec assoc (d,k,l) = 
match l with
| [] -> k
| (s,i)::xs -> if k = s then i else assoc (d,k,xs)

bad:
let rec assoc (d,k,l) = 
match l with
| [] -> k
| (s,i):xs -> if k = s then i else assoc (d,k,xs)
Error: Syntax error


let rec assoc (d,k,l) = 
match l with
| [] -> k
| x:xs -> let x = (s,i) in
if k = s then i else assoc (d,k,xs)
Error: Syntax error


let rec assoc (d,k,l) = 
match l with
| [] -> k
| x::xs -> let x = (s,i) in
if k = s then i else assoc (d,k,xs)
Error: Unbound value s



hw2 assoc

fix:
let rec assoc (d,k,l) = 
match l with
| [] -> d
| (s,i)::xs -> if k = s then i else assoc (d,k,xs)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])
Error: This expression has type int but an expression was expected of type
         string


let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])
Error: This expression has type int but an expression was expected of type
         string



hw2 wwhile

fix:
let rec wwhile (f,b) = 
let calc = f b in
let (b',c') = calc in
if c' then wwhile (f,b') else b'

bad:
let rec wwhile (f,b) = 
let calc = f b in
let (b',c') = calc in
if c' then f b' else b'
Error: This expression has type 'a but an expression was expected of type
         'a * bool
       The type variable 'a occurs inside 'a * bool


let rec wwhile (f,b) = 
let calc = f b in
let (b',c') = calc in
if c' then f (b') else b'
Error: This expression has type 'a but an expression was expected of type
         'a * bool
       The type variable 'a occurs inside 'a * bool


let rec wwhile (f,b) = 
let calc = f b in
let (b',c') = calc in
if c' then (f b') else b'
Error: This expression has type 'a but an expression was expected of type
         'a * bool
       The type variable 'a occurs inside 'a * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((f),b)

bad:
 fixpoint (f,b) = wwhile ((f b),b)
Error: Unbound value f
Error: Unbound value wwhile
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value f


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: This expression has type int -> int
       but an expression was expected of type int -> int -> int * bool
       Type int is not compatible with type int -> int * bool 



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((let f x = f x in f b),b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: This expression has type int -> int
       but an expression was expected of type int -> int * bool
       Type int is not compatible with type int * bool 



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((fun x -> f b),b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: This expression has type int -> int
       but an expression was expected of type int -> int -> int * bool
       Type int is not compatible with type int -> int * bool 


let fixpoint (f,b) = wwhile ((let f x = wwhile(f,x) in f b),b)
Error: This expression has type 'a -> 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'a * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((let f x = f b in f),b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: This expression has type int -> int
       but an expression was expected of type int -> int * bool
       Type int is not compatible with type int * bool 



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((fun x -> (f x,f x!=x)),b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile


let fixpoint (f,b) = wwhile ((fun x -> (f x,f x!=b)),b)
Error: Unbound value fixpoint


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 exprToString

fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine x -> "sin(pi*%s)" x
| Cosine x -> "cos(pi*%s)" x
| Average x y -> "((%s+%s)/2)" x y
| Times x y -> "%s*%s" x y
| Thresh x y z a -> "%s<%s?%s:%s" x y z a

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
Error: The constructor VarX expects 0 argument(s),
       but is applied here to 1 argument(s)



hw2 exprToString

fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

let _ = exprToString sampleExpr1

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine x -> "sin(pi*%s)" x
| Cosine x -> "cos(pi*%s)" x
| Average (x,y) -> "((%s+%s)/2)" x y
| Times (x,y) -> "%s*%s" x y
| Thresh (x,y,z,a) -> "%s<%s?%s:%s" x y z a
Error: Syntax error


let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine x -> sprintf "sin(pi*%s)" x
| Cosine x -> sprintf "cos(pi*%s)" x
| Average (x,y) -> sprintf "((%s+%s)/2)" x y
| Times (x,y) -> sprintf "%s*%s" x y
| Thresh (x,y,z,a) -> sprintf "%s<%s?%s:%s" x y z a
Error: This expression has type string
       This is not a function; it cannot be applied.


let rec exprToString e = match e with
| VarX -> Printf.sprintf "x"
| VarY -> Printf.sprintf "y"
| Sine x -> Printf.sprintf "sin(pi*%s)" x
| Cosine x -> Printf.sprintf "cos(pi*%s)" x
| Average (x,y) -> Printf.sprintf "((%s+%s)/2)" x y
| Times (x,y) -> Printf.sprintf "%s*%s" x y
| Thresh (x,y,z,a) -> Printf.sprintf "%s<%s?%s:%s" x y z a
Error: Unbound value sprintf


let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine x -> "sin(pi*" ^ exprToString x ^ ")"
| Cosine x -> "cos(pi*" ^ exprToString x ^ ")"
| Average (x,y) -> "((" ^ exprToString x ^ "+" ^ exprToString y ^ ")/2)"
| Times (x,y) -> exprToString x ^ "*" ^ exprToString y
| Thresh (x,y,z,a) -> exprToString x ^ "<" ^ expToString y ^ "?" ^ exprToString z ^ ":" ^ exprToString a
Error: This expression has type expr but an expression was expected of type
         string


let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine x -> "sin(pi*" ^ exprToString x ^ ")"
| Cosine x -> "cos(pi*" ^ exprToString x ^ ")"
| Average (x,y) -> "((" ^ exprToString x ^ "+" ^ exprToString y ^ ")/2)"
| Times (x,y) -> exprToString x ^ "*" ^ exprToString y
| Thresh (x,y,z,a) -> exprToString x ^ "<" ^ exprToString y ^ "?" ^ exprToString z ^ ":" ^ exprToString a
Error: Unbound value expToString
Hint: Did you mean exprToString?



hw2 eval

fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr,0.5,0.2)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine a -> sin(pi * eval(a,x,y))
| Cosine a -> cos(pi * eval(a,x,y))
| Average (a,b) -> (eval(a,x,y) + eval(b,x,y)) / 2
| Times (a,b) -> eval(a,x,y) * eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
Error: Syntax error


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine a -> sin(pi *. eval(a,x,y))
| Cosine a -> cos(pi * eval(a,x,y))
| Average (a,b) -> (eval(a,x,y) + eval(b,x,y)) / 2
| Times (a,b) -> eval(a,x,y) * eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine a -> sin(pi *. eval(a,x,y))
| Cosine a -> cos(pi *. eval(a,x,y))
| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine a -> sin(pi *. eval(a,x,y))
| Cosine a -> cos(pi *. eval(a,x,y))
| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
Error: This expression has type int but an expression was expected of type
         float



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a + (x*x) in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

bad:
let sqsum xs = 
let f a x = match x with
| []   -> a
| h::t -> List.fold_left f (a + (h*h)) t in
let base = 0 in
List.fold_left f base xs
Error: Unbound value f


let _ = sqsum []
Error: Unbound value sqsum


let _ = sqsum [1;2;3;4]
Error: Unbound value sqsum


let _ = sqsum [(-1); (-2); (-3); (-4)]
Error: Unbound value sqsum



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = a in
List.fold_left f base fs
Error: Unbound value a


let _ = pipe [] 3
Error: Unbound value pipe


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: Unbound value pipe


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: Unbound value pipe



hw3 padZero

fix:
let padZero l1 l2 =
let diff = (List.length l1 - List.length l2) in
if diff >= 0 then (l1, (clone 0 diff) @ l2)
else ((clone 0 (abs diff)) @ l1, l2)

bad:
let padZero l1 l2 =
let diff = (List.length l1 - List.length l2) in
if diff >= 0 then (l1, (clone 0 diff) @ l2)
else ((clone 0 -diff) @ l1, l2)
Error: This expression has type int -> int list
       but an expression was expected of type int


let _ = padZero [9;9] [1;0;0;2]
Error: Unbound value padZero


let _ = padZero [1;0;0;2] [9;9]
Error: Unbound value padZero


let padZero l1 l2 =
let diff = (List.length l1 - List.length l2) in
if diff >= 0 then (l1, (clone 0 diff) @ l2)
else ((clone 0 abs diff) @ l1, l2)
Error: This function has type 'a -> int -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (arg1, arg2) = x in
match a with
| []   -> 
if ((arg1 + arg2) > 9)
then [1] @ [(arg1 + arg2) mod 10] @ a
else ((arg1 + arg2)::a)
| h::t -> 
if ((arg1 + arg2 + h) > 9)
then [1] @ [(arg1 + arg2 + h) mod 10] @ a
else ((arg1 + arg2 + h)::a)
in
let base = [] in
let args = List.rev (List.combine l1 l2) in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (arg1, arg2) = x in
match a with
| []   -> 
if ((arg1 + arg2) > 9)
then [1] @ [(arg1 + arg2) mod 10] @ a
else ((arg1 + arg2)::a)
| h::t -> 
if ((arg1 + arg2 + h) > 9)
then [1] @ [(arg1 + arg2 + h) mod 10] @ a
else ((arg1 + arg2 + h)::a)
in
let base = [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list
       but an expression was expected of type 'a * 'b



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (arg1, arg2) = x in
match a with
| (0,[])   -> 
if ((arg1 + arg2) > 9)
then (1, [(arg1 + arg2) mod 10])
else (0,[arg1 + arg2])
| (1,_::t) -> 
if ((arg1 + arg2 + 1) > 9)
then (1, [(arg1 + arg2 + 1) mod 10] @ t)
else (0, ((arg1 + arg2 + 1)::t))
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_,res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (arg1, arg2) = x in
match a with
| (0,[])   -> 
if ((arg1 + arg2) > 9)
then (1, [(arg1 + arg2) mod 10])
else (0,[arg1 + arg2])
| (1,_::t) -> 
if ((arg1 + arg2 + h) > 9)
then (1, [(arg1 + arg2 + 1) mod 10] @ t)
else (0, ((arg1 + arg2 + 1)::t))
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_,res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value h



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (arg1, arg2) = x in
match a with
| (0,[])   -> 
if ((arg1 + arg2) > 9)
then (1, [(arg1 + arg2) mod 10])
else (0,[arg1 + arg2])
| (1, h::t) -> 
if ((arg1 + arg2 + 1) > 9)
then (1, [(arg1 + arg2 + 1) mod 10] @ t)
else (0, ((arg1 + arg2 + 1)::t))
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_,res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (arg1, arg2) = x in
match a with
| (0,[])   -> 
if ((arg1 + arg2) > 9)
then (1, [(arg1 + arg2) mod 10])
else (0,[arg1 + arg2])
| (1, _) -> 
if ((arg1 + arg2 + 1) > 9)
then (1, [(arg1 + arg2 + 1) mod 10] @ t)
else (0, ((arg1 + arg2 + 1)::t))
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_,res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value t


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (arg1, arg2) = x in
match a with
| (0,[])   -> 
if ((arg1 + arg2) > 9)
then (1, [(arg1 + arg2) mod 10])
else (0,[arg1 + arg2])
| (1, [h] @ [t]) -> 
if ((arg1 + arg2 + 1) > 9)
then (1, [(arg1 + arg2 + 1) mod 10] @ t)
else (0, ((arg1 + arg2 + 1)::t))
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_,res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error: pattern expected.



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (arg1, arg2) = x in
match a with
| (0, acc) -> 
if ((arg1 + arg2) > 9)
then (1, ((arg1 + arg2) mod 10)::acc)
else (0,(arg1 + arg2)::acc)
| (0, [])  ->
if ((arg1 + arg2) > 9)
then (1, [(arg1 + arg2) mod 10])
else (0, [arg1 + arg2])
| (_, acc) -> 
if ((arg1 + arg2 + 1) > 9)
then (1, ((arg1 + arg2 + 1) mod 10)::acc)
else (0, ((arg1 + arg2 + 1)::acc))
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_,res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (arg1, arg2) = x in
match a with
| (0,_)   -> 
if ((arg1 + arg2) > 9)
then (1, [(arg1 + arg2) mod 10])
else (0,[arg1 + arg2])
| (_, _) -> 
if ((arg1 + arg2 + 1) > 9)
then (1, [(arg1 + arg2 + 1) mod 10] @ a)
else (0, ((arg1 + arg2 + 1)::a))
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_,res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int * 'a
       but an expression was expected of type int list



hw3 mulByDigit

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (arg1, arg2) = x in
let (carry, acc) = a in 
if ((arg1 + arg2 + carry) > 9)
then (1, ((arg1 + arg2 + carry) mod 10)::acc)
else (0, ((arg1 + arg2 + carry)::acc))
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (fin,res) = List.fold_left f base args in
fin::res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

let mulByDigit i l = 
let saved = l in
let rec helper i' l' = 
| 1 -> l'
| _ -> helper (i'-1) (bigAdd saved l')
in helper i l

bad:
let mulByDigit i l = 
let rec helper i' l' = 
match i' with
| 1 -> l'
| _ -> mulByDigit (i'-1) (bigAdd l l')
Error: Syntax error


let mulByDigit i l = 
let rec helper i' l' = 
match i' with
| 1 -> l'
| _ -> helper (i'-1) (bigAdd l l')
Error: Syntax error


let mulByDigit i l = 
let rec helper i l' = 
match i with
| 1 -> l'
| _ -> helper (i-1) (bigAdd l l')
Error: Syntax error



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = a in(*let (acc, l) = a in*)
(*match l with
| []   -> ([], [])
| h::t -> let (first, second) = padZero [h] acc in
let f_rev = List.rev first in
(0::acc, mulByDigit x f_rev) *)
let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = let (acc, l) = a in
match l with
| []   -> ([], [])
| h::t -> let (first, second) = padZero [h] acc in
let f_rev = List.rev first in
(0::acc, (mulByDigit x f_rev))
Error: Syntax error


let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value l1


let bigMul l1 l2 = 
let f a x = let (acc, l) = a in
match l with
| []   -> ([], [])
| h::t -> let (first, second) = padZero [h] acc in
let f_rev = List.rev first in
(0::acc, [](*mulByDigit x f_rev*))
Error: Syntax error


let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value l1


let bigMul l1 l2 = 
let f a x =
let (acc, l) = a in
let h::t = l in
([],[])
Error: Syntax error


let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value l1


let bigMul l1 l2 = 
let f a x = ([], [])
Error: Syntax error


let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value l1


let bigMul l1 l2 = 
let f a x = (0, [])
Error: Syntax error


let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value l1


let bigMul l1 l2 = 
let f a x = a
Error: Syntax error


let base = ([0], List.rev l1) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value l1



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = 
let (padding, l, acc) = a in
let rec pow10 exp =
match exp with
| 0 -> 1
| n -> 10 * (pow10 n-1) in
let padded_x = x * pow10 ((List.length padding) - 1) in
match l with
| []   -> 
([], [], acc)
| h::t -> 
let (first, second) = padZero [h] padding in
let f_rev = List.rev first in
(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (padding, l, acc) = a in
let padded_x = x*10^((List.length padding) - 1) in
match l with
| []   -> 
([], [], acc)
| h::t -> 
let (first, second) = padZero [h] padding in
let f_rev = List.rev first in
(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res
Error: This expression has type int but an expression was expected of type
         string
Error: Unbound value padZero
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int but an expression was expected of type
         string


let bigMul l1 l2 = 
let f a x = 
let (padding, l, acc) = a in
let padded_x = x*10**((List.length padding) - 1) in
match l with
| []   -> 
([], [], acc)
| h::t -> 
let (first, second) = padZero [h] padding in
let f_rev = List.rev first in
(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res
Error: This expression has type int but an expression was expected of type
         float
Error: Unbound value padZero
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int but an expression was expected of type
         float


let bigMul l1 l2 = 
let f a x = 
let (padding, l, acc) = a in
let padded_x = x*10.**((List.length padding) - 1) in
match l with
| []   -> 
([], [], acc)
| h::t -> 
let (first, second) = padZero [h] padding in
let f_rev = List.rev first in
(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res
Error: This expression has type int but an expression was expected of type
         float
Error: Unbound value padZero
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int but an expression was expected of type
         float



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = 
let (padding, l, acc) = a in
let rec pow10 exp =
match exp with
| 0 -> 1
| n -> 10 * (pow10 (n-1)) in
let padded_x = x * pow10 ((List.length padding) - 1) in
let rec helper padding l acc padded_x = 
match l with
| []   ->
[]
| h::t ->
let (first, second) = padZero [h] padding in
let f_rev = List.rev first in
bigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x) in
let result = helper padding l acc padded_x in
([0], l, result) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
let (padding, l, acc) = a in
let rec pow10 exp =
match exp with
| 0 -> 1
| n -> 10 * (pow10 (n-1)) in
let padded_x = x * pow10 ((List.length padding) - 1) in
let rec helper padding l acc padded_x = 
match l with
| []   ->
[]
| h::t ->
let (first, second) = padZero [h] padding in
let f_rev = List.reverse first in
bigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x in
let result = helper padding l acc padded_x in
([0], t, result) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res
Characters 382-383:
  bigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x in
                                     ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let bigMul l1 l2 = 
let f a x = 
let (padding, l, acc) = a in
let rec pow10 exp =
match exp with
| 0 -> 1
| n -> 10 * (pow10 (n-1)) in
let padded_x = x * pow10 ((List.length padding) - 1) in
let rec helper padding l acc padded_x = 
match l with
| []   ->
[]
| h::t ->
let (first, second) = padZero [h] padding in
let f_rev = List.reverse first in
let this_guy = bigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x in
let result = helper padding l acc padded_x in
([0], t, result) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res
Characters 397-398:
  let this_guy = bigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x in
                                                    ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let bigMul l1 l2 = 
let f a x = 
let (padding, l, acc) = a in
let rec pow10 exp =
match exp with
| 0 -> 1
| n -> 10 * (pow10 (n-1)) in
let padded_x = x * pow10 ((List.length padding) - 1) in
let rec helper padding l acc padded_x = 
match l with
| []   ->
[]
| h::t ->
let (first, second) = padZero [h] padding in
let f_rev = List.reverse first in
bigAdd (mulByDigit (padded_x) (f_rev)) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x in
let result = helper padding l acc padded_x in
([0], t, result) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res
Characters 386-387:
  bigAdd (mulByDigit (padded_x) (f_rev)) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x in
                                         ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let bigMul l1 l2 = 
let f a x = 
let (padding, l, acc) = a in
let rec pow10 exp =
match exp with
| 0 -> 1
| n -> 10 * (pow10 (n-1)) in
let padded_x = x * pow10 ((List.length padding) - 1) in
let rec helper padding l acc padded_x = 
match l with
| []   ->
[]
| h::t ->
let (first, second) = padZero [h] padding in
let f_rev = List.reverse first in
bigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x) in
let result = helper padding l acc padded_x in
([0], t, result) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res
Error: Unbound value List.reverse
Error: Unbound value padZero
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value List.reverse


let bigMul l1 l2 = 
let f a x = 
let (padding, l, acc) = a in
let rec pow10 exp =
match exp with
| 0 -> 1
| n -> 10 * (pow10 (n-1)) in
let padded_x = x * pow10 ((List.length padding) - 1) in
let rec helper padding l acc padded_x = 
match l with
| []   ->
[]
| h::t ->
let (first, second) = padZero [h] padding in
let f_rev = List.rev first in
bigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x) in
let result = helper padding l acc padded_x in
([0], t, result) in
let base = ([0], List.rev l1, []) in
let args = List.rev l2 in
let (_, _, res) = List.fold_left f base args in
res
Error: Unbound value t
Error: Unbound value padZero
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value t



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x =
let (padding, acc) = a in
(padding+1, bigAdd acc ((mulByDigit x l1) @ (clone 0 padding))) in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x =
let (padding, acc) = a in
(padding+1, l1, bigAdd acc ((mulByDigit x l1) @ (clone 0 padding))) in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type
         int * int list -> int -> int * int list * int list
       but an expression was expected of type
         int * int list -> int -> int * int list
       Type int * int list * int list is not compatible with type
         int * int list 
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type
         int * int list -> int -> int * int list * int list
       but an expression was expected of type
         int * int list -> int -> int * int list
       Type int * int list * int list is not compatible with type
         int * int list 



hw1 digitsOfInt

fix:
let rec digitsOfInt n = if n > 0
then
(n mod 10) :: (digitsOfInt (n/10))
else
[]

bad:
let rec digitsOfInt n = if n > 0
then
(digitsOfInt (n/10)) :: n mod 10
else
0
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec digitsOfInt n = if n > 0
then
(digitsOfInt (n/10)) :: n mod 10
else
[]
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 listReverse

fix:
let rec listReverse l = function
| [] -> l
| (h::t) -> listReverse (h::l) t

bad:
let rec listReverse l = function
| [] -> l
| (h::t) -> listReverse (h::l) t
Error: Unbound value listReverse



hw1 listReverse

fix:
let rec listReverse l = match l with
| [] -> l
| [other::tail::[]] -> tail :: other

bad:
let rec listReverse l = function
| [] -> l
| (h::t) -> listReverse (h::l) t in
listReverse [] l
Error: Unbound value l


let rec listReverse l = match l with
| [] -> l
| [_::tail::[]] -> l
Error: Unbound value l



hw1 listReverse

fix:
let rec listReverse l =
let rec listReverseHelper l ans = match ans with
| [] -> []
| (h::t) -> ans :: listReverseHelper t ans

bad:
let rec listReverseHelper l ans = 
[] -> [];
(h::t) -> ans :: listReverseHelper t ans
Error: This expression has type 'a but an expression was expected of type
         'a list
       The type variable 'a occurs inside 'a list


let rec listReverse l =
listReverseHelper l []
Error: Syntax error


let rec listReverseHelper l ans = 
| [] -> []
| (h::t) -> ans :: listReverseHelper t ans
Error: Unbound value listReverseHelper


let rec listReverseHelper l ans = match l with
| [] -> []
| (h::t) -> ans :: listReverseHelper t ans
Error: Syntax error



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4]

let _ = listReverse ["a"; "b"; "c"; "d"]

bad:
let rec listReverse l =
let rec listReverseHelper l ans = match ans with
| [] -> []
| h::t -> listReverseHelper t (h::ans)

listReverseHelper l []
Error: Syntax error


let rec listReverse l =
let rec listReverseHelper l ans = match ans with
| [] -> []
| h::t -> listReverseHelper t (h::ans) in 

listReverseHelper l []
Error: Syntax error



hw1 additivePersistence

fix:
let _ = additivePersistence 9876

bad:
let rec additivePersistence n = 
let rec sumDigits n1 = 
if n < 10 then 
n 
else
n1 mod 10 + sumDigits (n1 / 10) in 
if (n < 10) then
0
else
1 + additivePersistence (sumDigits n)
Error: Unbound value %



hw1 digitalRoot

fix:
let _ = digitalRoot 9873

bad:
let rec digitalRoot n = 
if (n > 10) then 
digitalRoot (sumDigits n)
else
n
Error: This expression has type int -> int
       but an expression was expected of type int



hw1 palindrome

fix:
let palindrome w = (explode w) = (listReverse (explode w))

bad:
let palindrome w = (explode w) = (listReverse (explode w))
Error: This expression has type string but an expression was expected of type
         'a list



hw2 fixpoint

fix:
let rec fixpoint (f,x) = 
let x' = f x in
if x' = x then x else fixpoint (f, x')

bad:
let rec fixpoint (f,x) = 
let x' = f x in
if x' = x then x else fixpoint f x'
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type
         (('a -> 'b) -> 'a -> 'b) * ('a -> 'b)



hw2 fixpoint

fix:
let rec fixpoint (f,x) = 
let x' = f x in
let g x = (x', x' = x) in 
wwhile (g,x)

bad:
let rec fixpoint (f,x) = 
let x' = f x in
let g x = (f, x' = x) in 
wwhile (g,x)
Error: This expression has type 'a -> ('b -> 'a) * bool
       but an expression was expected of type 'a -> 'a * bool
       The type variable 'a occurs inside 'b -> 'a



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 2)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, .2)
Error: Syntax error: operator expected.



hw2 eval

fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine     (e1) -> sin(pi *. (eval (e1, x, y)))
| Cosine   (e1) -> cos(pi *. (eval (e1, x, y)))
| Average  (e1, e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y)))/.2.
| Times    (e1, e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))
| Thresh   (e1, e2, e3, e4) 
-> if (eval (e1, x, y)) < (eval (e2, x, y)) then
(eval (e3, x, y)) else
(eval (e4, x, y))

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine     (e1) -> sin(pi *. (exprToString e1))
| Cosine   (e1) -> cos(pi *. (exprToString e1))
| Average  (e1, e2) -> ((exprToString e1) +. (exprToString e2))/.2.
| Times    (e1, e2) -> (exprToString e1) *. (exprToString e2)
| Thresh   (e1, e2, e3, e4) 
-> if (exprToString e1) < (exprToString e2) then
(exprToString e3) else
(exprToString e4)
Error: This expression has type string but an expression was expected of type
         float


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine     (e1) -> sin(pi *. (eval e1))
| Cosine   (e1) -> cos(pi *. (eval e1))
| Average  (e1, e2) -> ((eeval e1) +. (eval e2))/.2.
| Times    (e1, e2) -> (eval e1) *. (eval e2)
| Thresh   (e1, e2, e3, e4) 
-> if (eval e1) < (eval e2) then
(eval e3) else
(eval e4)
Error: This expression has type expr but an expression was expected of type
         expr * 'a * 'a



hw2 eval

fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine     (e1) -> sin(pi *. (eval (e1, x, y)))
| Cosine   (e1) -> cos(pi *. (eval (e1, x, y)))
| Average  (e1, e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y)))/.2.
| Times    (e1, e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))
| Thresh   (e1, e2, e3, e4) 
-> if (eval (e1, x, y)) < (eval (e2, x, y)) then
(eval (e3, x, y)) else
(eval (e4, x, y))
| AbsThresh (e1, e2, e3) -> let s = eval (e3, x, y) in
if abs_float (eval (e1, x, y)) < abs_float (eval (e2, x, y)) then
s else
abs_float s
| ModThresh (e1, e2, e3) -> 
if (truncate (100. *. (eval (e1, x, y)))) mod 5 = 0 then
(eval (e2, x, y)) else
(eval (e3, x, y))

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine     (e1) -> sin(pi *. (eval (e1, x, y)))
| Cosine   (e1) -> cos(pi *. (eval (e1, x, y)))
| Average  (e1, e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y)))/.2.
| Times    (e1, e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))
| Thresh   (e1, e2, e3, e4) 
-> if (eval (e1, x, y)) < (eval (e2, x, y)) then
(eval (e3, x, y)) else
(eval (e4, x, y))
| AbsThresh (e1, e2, e3) -> let s = eval (e3, x, y) in
if abs_float (eval (e1, x, y)) < abs_float (eval (e2, x, y)) then
s else
abs_float s
| ModThresh (e1, e2, e3) -> 
if (truncate (100 *. (eval (e1, x, y)))) mod 5 = 0 then
(eval (e2, x, y)) else
(eval (e3, x, y))
Error: This expression has type int but an expression was expected of type
         float



hw2 build

fix:
let _ = buildY()

bad:
let rec build (rand, depth) = 
let r = rand (0,99) in
if depth = 0 then
if (r < 50) then
buildX
else
buildY
else
if (r < 5) then
buildX()
else if (r < 10) then
buildY()
else if (r < 30) then 
buildSine (build (rand, depth - 1))
else if (r < 50) then 
buildCosine (build (rand, depth - 1))
else if (r < 60) then 
buildAverage (build (rand, depth - 1), build (rand, depth - 1))
else if (r < 70) then 
buildTimes (build (rand, depth - 1), build (rand, depth - 1))
else if (r < 80) then 
buildThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1), build (rand, depth - 1))
else if (r < 90) then 
buildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1))
else if (r < 90) then 
buildModThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1))
Error: This expression has type expr but an expression was expected of type
         unit -> expr


let rec build (rand, depth) = 
let r = rand (0,99) in
if depth = 0 then
if (r < 50) then
buildX()
else
buildY()
else
if (r < 5) then
buildX()
else if (r < 10) then
buildY()
else if (r < 30) then 
buildSine (build (rand, depth - 1))
else if (r < 50) then 
buildCosine (build (rand, depth - 1))
else if (r < 60) then 
buildAverage (build (rand, depth - 1), build (rand, depth - 1))
else if (r < 70) then 
buildTimes (build (rand, depth - 1), build (rand, depth - 1))
else if (r < 80) then 
buildThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1), build (rand, depth - 1))
else if (r < 90) then 
buildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1))
else if (r < 90) then 
buildModThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1))
Error: This expression has type expr but an expression was expected of type
         unit



hw2 build

fix:
let rec build (rand, depth) = 
let r = rand (0,99) in
if depth = 0 then
if (r < 50) then
buildX()
else
buildY()
else
buildY()

bad:
let rec build (rand, depth) = 
let r = rand (0,99) in
if depth = 0 then
if (r < 50) then
buildX() : expr
else
buildY()
else
if (r < 5) then
buildX()
else if (r < 10) then
buildY()
else if (r < 30) then 
buildSine (build (rand, depth - 1))
else if (r < 50) then 
buildCosine (build (rand, depth - 1))
else if (r < 60) then 
buildAverage (build (rand, depth - 1), build (rand, depth - 1))
else if (r < 70) then 
buildTimes (build (rand, depth - 1), build (rand, depth - 1))
else if (r < 80) then 
buildThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1), build (rand, depth - 1))
else if (r < 90) then 
buildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1))
else if (r < 90) then 
buildModThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1))
Error: Syntax error


let rec build (rand, depth) = 
let r = rand (0,99) in
if depth = 0 then
if (r < 50) then
buildX() :: expr
else
buildY()
else
if (r < 5) then
buildX()
else if (r < 10) then
buildY()
else if (r < 30) then 
buildSine (build (rand, depth - 1))
else if (r < 50) then 
buildCosine (build (rand, depth - 1))
else if (r < 60) then 
buildAverage (build (rand, depth - 1), build (rand, depth - 1))
else if (r < 70) then 
buildTimes (build (rand, depth - 1), build (rand, depth - 1))
else if (r < 80) then 
buildThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1), build (rand, depth - 1))
else if (r < 90) then 
buildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1))
else if (r < 90) then 
buildModThresh (build (rand, depth - 1), build (rand, depth - 1),
build (rand, depth - 1))
Error: Unbound value expr
Hint: Did you mean exp?
Error: Unbound constructor AbsThresh
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value expr
Hint: Did you mean exp?



hw3 padZero

fix:
let padZero l1 l2 = 
let dif = (List.length l1) - (List.length l2) in
if (dif = 0) then
(l1, l2)
else if (dif < 0) then (*l2 is bigger*)
((clone 0 (0-dif)) @ l1, l2)
else
(l1, ((clone 0 dif) @ l2))

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

let _ = padZero [1;0;0;2] [9;9;9;9]

bad:
let padZero l1 l2 = 
let dif = (List.length l1) - (List.length l2) in
if (dif = 0) then
(l1, l2)
else if (dif < 0) then (*l2 is bigger*)
((clone 0 (0-diff)) @ l1, l2)
else
(l1, ((clone 0 diff) @ l2))
Error: Unbound value diff
Hint: Did you mean dif?


let _ = padZero [9;9] [1;0;0;2]
Error: Unbound value padZero


let _ = padZero [1;0;0;2] [9;9]
Error: Unbound value padZero


let _ = padZero [1;0;0;2] [9;9;9;9]
Error: Unbound value padZero



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, rest) = a in
let (d1, d2) = x in
let sum = d1 + d2 + carry in
if (sum > 9) then
(1, (sum - 10)::rest)
else
(0, sum::rest) in
let base = (0, []) in
let args = List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (carry, rest) = a in
let (d1, d2) = x in
let sum = d1 + d2 + carry in
if (sum > 9) then
(1, (sum - 10)::rest)
else
(0, sum::rest) in
let base = (0, []) in
let args = List.combine (list.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value list



hw3 bigMul

fix:
let _ = bigMul [0;99] []

bad:
let _ = bigMul [0,99] []
Error: This expression has type 'a * 'b
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if (n <= 0) 
then []
else 
n :: []

bad:
let rec digitsOfInt n = 
if (n <= 0) 
then []
else 
|
Error: Syntax error


let rec digitsOfInt n = 
if (n <= 0) 
then []
else 
n mod 10
Error: This expression has type int but an expression was expected of type
         'a list


let rec digitsOfInt n = 
if (n <= 0) 
then []
else 
n mod 10
n::[]
Error: This expression has type int
       This is not a function; it cannot be applied.



hw1 digitsOfInt

fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

let rec digitsOfInt n = 
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)

bad:
let rec digitsOfInt n = 
if (n <= 0) 
then []
else 
(n mod 10) :: [digitsOfInt n]
Error: This expression has type int list
       but an expression was expected of type int


let rec digitsOfInt n = 
if (n <= 0) 
then []
else 
(n mod 10) :: digitsOfInt n :: []
Error: This expression has type int list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
n mod 10 :: myList

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)
toAdd@[]
Error: Syntax error


let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)
toAdd@myList
Error: Syntax error


let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)
toAdd@myList
Error: Syntax error


let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)
toAdd@myList
Error: Syntax error


let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)
toAdd@myList
Error: Syntax error


let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)
toAdd@myList
Error: Syntax error


let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)
toAdd@myList
hi
Error: Syntax error


let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)
Error: Syntax error


let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)
Error: Syntax error


toAdd@myList
Error: Unbound value toAdd


let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
let toAdd = (n mod 10)
Error: Syntax error


let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else (
let toAdd = (n mod 10)
Error: Syntax error: operator expected.


toAdd@myList
Error: Unbound value toAdd


let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else (
(n mod 10)@myList
Characters 70-71:
  else (
       ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


)
Error: Syntax error


let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else (
(n mod 10)@myList
Characters 70-71:
  else (
       ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


)
Error: Syntax error


let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else (
n mod 10 @myList
Characters 70-71:
  else (
       ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


)
Error: Syntax error


let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else (
n mod 10 @myList
Characters 70-71:
  else (
       ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


)
Error: Syntax error


let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else 
n mod 10 @myList
Error: This expression has type int but an expression was expected of type
         'a list



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []

let _ = 1

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
Error: This variant expression is expected to have type unit
       The constructor [] does not belong to type unit


let _ = 1;l
n mod 10 :: myList
Error: Unbound value l



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
else []

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []

n mod 10 :: myList
Error: This variant expression is expected to have type unit
       The constructor :: does not belong to type unit


let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
Error: This variant expression is expected to have type unit
       The constructor [] does not belong to type unit


let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then []
Error: This variant expression is expected to have type unit
       The constructor [] does not belong to type unit


let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then ->[]
Error: Syntax error


let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) 
then -> []
Error: Syntax error



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else
n mod 10 :: myList

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
Error: This variant expression is expected to have type unit
       The constructor [] does not belong to type unit


let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else
Error: Syntax error



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else
n mod 10 :: myList

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []

n mod 10 :: myList
Error: This variant expression is expected to have type unit
       The constructor :: does not belong to type unit


let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
Error: This variant expression is expected to have type unit
       The constructor [] does not belong to type unit


n mod 10 :: myList
Error: Unbound value n



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else
n mod 10 :: myList

n mod 100 :: myList

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else
n mod 10 :: myList
n mod 100 :: myList
Error: This expression has type 'a list
       This is not a function; it cannot be applied.



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else 
(n mod 10 :: myList) :: digitsOfInt n

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else
n = n - (n mod 10);
(n :: myList) :: digitsOfInt
Error: This expression has type bool but an expression was expected of type
         'a list


let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else
let n = n - (n mod 10);
(n :: myList) :: digitsOfInt
Error: Syntax error


let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else
let n = n - (n mod 10);
(n :: myList) :: digitsOfInt
Error: Syntax error


let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else (
let n = n - (n mod 10);
(n :: myList) :: digitsOfInt
)
Error: Syntax error: operator expected.


let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else (
let n = n - (n mod 10);
(n :: myList) :: digitsOfInt
)
Error: Syntax error: operator expected.


let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else (
let n = n - (n mod 10);
(n :: myList) :: digitsOfInt
Error: Syntax error: operator expected.


)
Error: Syntax error


let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else (
(n mod 10 :: myList) :: digitsOfInt
)
Error: This expression has type int -> int list list
       but an expression was expected of type int list list



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else 
(n mod 10 :: myList) :: digitsOfInt (n - n mod 10)

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else 
(n mod 10 :: myList) :: digitsOfInt
Error: This expression has type int -> int list list
       but an expression was expected of type int list list



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else 
(n mod 10 :: digitsOfInt (n / 10))

bad:
let rec digitsOfInt n = 
let myList = [] in
if (n <= 0) then []
else 
(n mod 10 :: digitsOfInt (n / 10)
Characters 70-71:
  (n mod 10 :: digitsOfInt (n / 10);;
  ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw1 digitsOfInt

fix:
let rec digitsOfInt n =
if (n <= 0) then []
else 
List.rev (n mod 10 :: digitsOfInt (n / 10))

bad:
let rec digitsOfInt n =
if (n <= 0) then []
else 
rev (n mod 10 :: digitsOfInt (n / 10))
Error: Unbound value rev
Hint: Did you mean ref?



hw1 digitsOfInt

fix:
let rec digitsOfInt n =
if (n <= 0) then []
else 
(n mod 10 :: digitsOfInt (n / 10))

bad:
let rec digitsOfInt n =
if (n <= 0) then []
else 
(n mod 10 :: List.rev digitsOfInt (n / 10))
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 digitsOfInt

fix:
let rec digitsOfInt n =
if (n <= 0) then []
else 
(n mod 10 :: digitsOfInt (n / 10))

bad:
let rec digitsOfInt n =
if (n <= 0) then []
else 
let _ = (n mod 10 :: digitsOfInt (n / 10))
Error: Syntax error



hw1 digitsOfInt

fix:
let rec digitsOfInt n =
if (n <= 0) then []
else 
(n mod 10 :: digitsOfInt (n / 10))

bad:
let rec digitsOfInt n =
if (n <= 0) then []
else 
(n mod 10 :: digitsOfInt (n / 10))
List.rev
Error: This expression has type int list
       This is not a function; it cannot be applied.



hw1 digitsOfInt

fix:
let rec digitsOfInt n =
if (n <= 0) then []
else 
(n mod 10 :: List.rev (digitsOfInt (n / 10)))

bad:
let rec digitsOfInt n =
if (n <= 0) then []
else 
(n mod 10 :: List.rev digitsOfInt (n / 10))
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.


let rec digitsOfInt n =
if (n <= 0) then []
else 
(n mod 10 :: (List.rev digitsOfInt (n / 10)))
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 additivePersistence

fix:
let rec additivePersistence n = 
(digitsOfInt n)

bad:
let rec additivePersistence n = 
- = digitsOfInt n
Error: Syntax error


let rec additivePersistence n = 
let a = (digitsOfInt n)
Error: Syntax error



hw1 additivePersistence

fix:
let rec additivePersistence n = 
match (digitsOfInt n) with
| [] -> 0
| _ -> sumList (digitsOfInt n)

bad:
let rec additivePersistence n = 
match (digitsOfInt n) with
| [] -> 0
| (h::t) -> h + t
Error: This expression has type int list
       but an expression was expected of type int


let rec additivePersistence n = 
match (digitsOfInt n) with
| [] -> 0
| _ -> sumList digitsOfInt n
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let rec additivePersistence n = 
match (digitsOfInt n) with
| [] -> 0;
| _ -> sumList digitsOfInt n
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let rec additivePersistence n = 
match (digitsOfInt n) with
| [] -> 0
| _ -> sumList digitsOfInt n;
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 additivePersistence

fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) > 9) then additivePersistence (sumList (digitsOfInt n))

)

bad:
let rec additivePersistence n = 
let _ = sumList (digitsOfInt n)
Error: Syntax error


let rec additivePersistence n = 
let _ = sumList (digitsOfInt n)
Error: Syntax error


let rec additivePersistence n = 
let _ = 2
Error: Syntax error


let rec additivePersistence n = 
let _ = 2
Error: Syntax error



hw1 additivePersistence

fix:
let rec additivePersistence n = 
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then  
additivePersistence (sumList (digitsOfInt n))
else sumList count

bad:
let rec additivePersistence n = 
let count = 1 in
if (sumList (digitsOfInt n) > 9) 
then  
count++
else
sumList (digitsOfInt n)
Error: Syntax error


let rec additivePersistence n = 
let count = 1 in
if (sumList (digitsOfInt n) > 9) 
then  
count++
Error: Syntax error


let rec additivePersistence n = 
let count = 1 in
if (sumList (digitsOfInt n) > 9) 
then  
count = count + 1
Error: This expression has type bool but an expression was expected of type
         unit


let rec additivePersistence n = 
let count = 1 in
if (sumList (digitsOfInt n) > 9) 
then  
let count = count + 1
Error: Syntax error


let rec additivePersistence n = 
let count = 1 in
if (sumList (digitsOfInt n) > 9) 
then  
let count = 9
Error: Syntax error


let rec additivePersistence n = 
let count = 1 in
if (sumList (digitsOfInt n) > 9) 
then  
let co = 9
Error: Syntax error


let rec additivePersistence n = 
let count = [] in
if (sumList (digitsOfInt n) > 9) 
then  
1::count
additivePersistence (sumList (digitsOfInt n))
Error: This variant expression is expected to have type unit
       The constructor :: does not belong to type unit


let rec additivePersistence n = 
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then  
1::count
additivePersistence (sumList (digitsOfInt n))
Error: This variant expression is expected to have type unit
       The constructor :: does not belong to type unit


let rec additivePersistence n = 
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then  
1::count
additivePersistence (sumList (digitsOfInt n))
else sumList count
Error: This expression has type int list
       This is not a function; it cannot be applied.



hw1 additivePersistence

fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

let rec digitsOfInt n = 
if (n <= 0) then []
else 
List.rev (n mod 10 :: List.rev (digitsOfInt (n/10)))

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

let digits n = digitsOfInt (abs n)

let rec additivePersistence n = 
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then 
1::count 
additivePersistence (sumList (digitsOfInt n))
else sumList count

bad:
let rec additivePersistence n = 
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then  
1::count
additivePersistence (sumList (digitsOfInt n))
else sumList count
Error: This expression has type int list
       This is not a function; it cannot be applied.


let rec additivePersistence n = 
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then (
1::count
additivePersistence (sumList (digitsOfInt n)))
else sumList count
Error: This expression has type int list
       This is not a function; it cannot be applied.


let rec additivePersistence n = 
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then 
1::count
else sumList count
Error: This expression has type int but an expression was expected of type
         int list



hw1 additivePersistence

fix:
let rec additivePersistence n = 
let x = 1 in x + 1;
if (sumList (digitsOfInt n) > 9) 
then 
additivePersistence (sumList (digitsOfInt n))
else x

bad:
let rec additivePersistence n = 
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then 
1::count & additivePersistence (sumList (digitsOfInt n))
else sumList count
Error: This variant expression is expected to have type bool
       The constructor :: does not belong to type bool


let rec additivePersistence n = 
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then 
1::count && additivePersistence (sumList (digitsOfInt n))
else sumList count
Error: This variant expression is expected to have type bool
       The constructor :: does not belong to type bool


let rec additivePersistence n = 
let count = [0] in
if (sumList (digitsOfInt n) > 9) 
then 
1::count &&& additivePersistence (sumList (digitsOfInt n))
else sumList count
Error: Unbound value &&&
Hint: Did you mean &&?


let rec additivePersistence n = 
let x = 1 in
if (sumList (digitsOfInt n) > 9) 
then 
x + 1
additivePersistence (sumList (digitsOfInt n))
else sumList count
Error: This expression has type int
       This is not a function; it cannot be applied.


let rec additivePersistence n = 
let x = 1 in
x = x + 1
if (sumList (digitsOfInt n) > 9) 
then 
additivePersistence (sumList (digitsOfInt n))
else sumList count
Error: Syntax error


let rec additivePersistence n = 
let x = 1 in x + 1
if (sumList (digitsOfInt n) > 9) 
then 
additivePersistence (sumList (digitsOfInt n))
else sumList count
Error: Syntax error


let rec additivePersistence n = 
let x = 1 in x + 1;
if (sumList (digitsOfInt n) > 9) 
then 
additivePersistence (sumList (digitsOfInt n))
else sumList count
Error: Unbound value count



hw1 additivePersistence

fix:
let rec additivePersistence n = 
let x = 1 in x + 1

if (sumList (digitsOfInt n) > 9) 
then 
additivePersistence (sumList (digitsOfInt n))
else x

bad:
let rec additivePersistence n = 
let x = 1 in x + 1
if (sumList (digitsOfInt n) > 9) 
then 
additivePersistence (sumList (digitsOfInt n))
else x
Error: Syntax error



hw1 additivePersistence

fix:
let rec additivePersistence n = 
let x = [0] in
if (sumList (digitsOfInt n) > 9) then begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else sumList x

bad:
let rec additivePersistence n = 
let x = 1 in
if (sumList (digitsOfInt n) > 9) 
then begin
let x = x + 1;
additivePersistence (sumList (digitsOfInt n))
end
else x
Error: Syntax error


let rec additivePersistence n = 
let x = 1 in
if (sumList (digitsOfInt n) > 9) 
then begin
let x = x + 1;
additivePersistence (sumList (digitsOfInt n))
end;
else x
Error: Syntax error


let rec additivePersistence n = 
let x = 1 in
if (sumList (digitsOfInt n) > 9) then begin
let x = x + 1
Error: Syntax error


additivePersistence (sumList (digitsOfInt n))
end;
else x
Error: Syntax error


let rec additivePersistence n = 
let x = [0] in
if (sumList (digitsOfInt n) > 9) then begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end;
else sumList x
Error: Syntax error



hw1 additivePersistence

fix:
let rec additivePersistence n = 
let x = [0] in
if (sumList (digitsOfInt n) > 9) then begin
1 :: x;
additivePersistence (sumList (digitsOfInt n))
end
else sumList x

bad:
let rec additivePersistence n = 
let x = [0] in
if (sumList (digitsOfInt n) > 9) then begin
1::x
additivePersistence (sumList (digitsOfInt n))
end
else sumList x
Error: This expression has type int list
       This is not a function; it cannot be applied.



hw1 additivePersistence

fix:
let rec additivePersistence n = 
let x = [1] in
1::x;
if (sumList (digitsOfInt n) > 9) then 
additivePersistence (sumList (digitsOfInt n))
else 
sumList x

bad:
let rec additivePersistence n = 
let x = [1]
1::x;
if (sumList (digitsOfInt n) > 9) then 
additivePersistence (sumList (digitsOfInt n))
else 
sumList x
Error: Syntax error


let rec additivePersistence n = 
let x = [1]
1::x
if (sumList (digitsOfInt n) > 9) then 
additivePersistence (sumList (digitsOfInt n))
else 
sumList x
Error: Syntax error


let rec additivePersistence n = 
let x = [1]
1::x
if (sumList (digitsOfInt n) > 9) then 
additivePersistence (sumList (digitsOfInt n))
else 
sumList x
Error: Syntax error



hw1 ???

fix:
let rec a = a+1

bad:
let rec a = a::[]
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec a -> a::[]
Error: Syntax error


let rec a = a->a+1
Error: Syntax error


let rec a = a -> a+1
Error: Syntax error


let rec a -> a+1
Error: Syntax error



hw1 ???

fix:
let a = 
a = a + 1

bad:
let rec a = 
a = a + 1
Error: This expression has type bool but an expression was expected of type
         int



hw1 ???

fix:
let frog a = a + 1

bad:
let frog a = 
a -> a + 1
Error: Syntax error



hw1 ???

fix:
let frog a = a+1

bad:
let frog a -> a + 1
Error: Syntax error



hw1 additivePersistence

fix:
let x = [1]

let rec additivePersistence n = 
1::x;
if (sumList (digitsOfInt n) > 9) then 
additivePersistence (sumList (digitsOfInt n))
else 
sumList x

bad:
let x = [1] in
let rec additivePersistence n = 
1::x;
if (sumList (digitsOfInt n) > 9) then 
additivePersistence (sumList (digitsOfInt n))
else 
sumList x
Error: Syntax error



hw1 additivePersistence

fix:
let rec additivePersistence n = 
1::x

if (sumList (digitsOfInt n) > 9) then 
additivePersistence (sumList (digitsOfInt n))
else 
sumList x

bad:
let rec additivePersistence n = 
1::x
if (sumList (digitsOfInt n) > 9) then 
additivePersistence (sumList (digitsOfInt n))
else 
sumList x
Error: Syntax error


let rec additivePersistence n = 
1::x
if (sumList (digitsOfInt n) > 9) then 
additivePersistence (sumList (digitsOfInt n))
else 
sumList x
Error: Syntax error



hw1 additivePersistence

fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

let rec digitsOfInt n = 
if (n <= 0) then []
else 
List.rev (n mod 10 :: List.rev (digitsOfInt (n/10)))

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

let digits n = digitsOfInt (abs n)

let x = [0]

let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1:x;
sumList x;
end

bad:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) then begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else begin
1:x;
sumList x
end
Characters 138-143:
  else begin
       ^^^^^
Syntax error: 'end' expected, the highlighted 'begin' might be unmatched


let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) then begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end;
else begin
1:x;
sumList x
end;
Error: Syntax error


let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) then begin
1::x
additivePersistence (sumList (digitsOfInt n))
end
else begin
1:x;
sumList x
end
Characters 137-142:
  else begin
       ^^^^^
Syntax error: 'end' expected, the highlighted 'begin' might be unmatched


let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) then begin
1::x
additivePersistence (sumList (digitsOfInt n))
end
else begin
1:x;
sumList x
Characters 137-142:
  else begin
       ^^^^^
Syntax error: 'end' expected, the highlighted 'begin' might be unmatched


let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) then begin
1::x
additivePersistence (sumList (digitsOfInt n))
end
else begin
1:x;
sumList x
end
Characters 137-142:
  else begin
       ^^^^^
Syntax error: 'end' expected, the highlighted 'begin' might be unmatched


let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) then begin
1::x
additivePersistence (sumList (digitsOfInt n))
end
else begin
1:x;
sumList x;
end
Characters 137-142:
  else begin
       ^^^^^
Syntax error: 'end' expected, the highlighted 'begin' might be unmatched


let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) then begin
1::x
additivePersistence (sumList (digitsOfInt n))
end
else begin
1:x;
sumList x;
Characters 137-142:
  else begin
       ^^^^^
Syntax error: 'end' expected, the highlighted 'begin' might be unmatched


let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) then begin
1::x
additivePersistence (sumList (digitsOfInt n))
end
else begin
1:x;
sumList x;
end
Characters 137-142:
  else begin
       ^^^^^
Syntax error: 'end' expected, the highlighted 'begin' might be unmatched


let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) then begin
1::x
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1:x;
sumList x;
end
Characters 138-143:
  begin
  ^^^^^
Syntax error: 'end' expected, the highlighted 'begin' might be unmatched


let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1:x;
sumList x;
end
Characters 141-146:
  begin
  ^^^^^
Syntax error: 'end' expected, the highlighted 'begin' might be unmatched



hw1 additivePersistence

fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 

sumList x;

bad:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1:x;
sumList x;
end
Characters 141-146:
  begin
  ^^^^^
Syntax error: 'end' expected, the highlighted 'begin' might be unmatched


end
Error: Syntax error


let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1:x;
sumList x;
end
Characters 141-146:
  begin
  ^^^^^
Syntax error: 'end' expected, the highlighted 'begin' might be unmatched


end
Error: Syntax error


end
Error: Syntax error


let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
1:x;
sumList x;
Error: Syntax error


let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
1::x;
sumList x;
Error: This expression has type int but an expression was expected of type
         int list



hw1 additivePersistence

fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x;
sumList x;
end

bad:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x;
sumList x;
Characters 141-146:
  begin
  ^^^^^
Syntax error: 'end' expected, the highlighted 'begin' might be unmatched



hw1 additivePersistence

fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x;
sumList x;
end

bad:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1:x;
sumList x;
end
Characters 141-146:
  begin
  ^^^^^
Syntax error: 'end' expected, the highlighted 'begin' might be unmatched



hw1 additivePersistence

fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x;
sumList [1;2];
end

let _ = additivePersistence 9876

bad:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x;
sumList [1:2];
end
Error: Syntax error



hw1 additivePersistence

fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x;
sumList x
end

let _ = additivePersistence 9876

bad:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x
Characters 73-78:
  begin
  ^^^^^
Syntax error: 'end' expected, the highlighted 'begin' might be unmatched


additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x
Error: Syntax error


sumList x
end
Error: Syntax error


let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x
Characters 73-78:
  begin
  ^^^^^
Syntax error: 'end' expected, the highlighted 'begin' might be unmatched


additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x
sumList x
end
Error: Syntax error



hw1 additivePersistence

fix:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
(1::x);
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
(1::x);
sumList x
end

bad:
let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x;
additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x
Characters 141-146:
  begin
  ^^^^^
Syntax error: 'end' expected, the highlighted 'begin' might be unmatched


sumList x
end
Error: Syntax error


let rec additivePersistence n = 
if (sumList (digitsOfInt n) < 9) 
then 
begin
1::x
Characters 73-78:
  begin
  ^^^^^
Syntax error: 'end' expected, the highlighted 'begin' might be unmatched


additivePersistence (sumList (digitsOfInt n))
end
else 
begin
1::x;
sumList x
end
Error: Syntax error



hw1 ???

fix:
let explode s = 
let rec go i = 
if i >= String.length s 
then [] 
else (s.[i]) :: (go (i+1)) 
in
go 0

explode "nikhil"

bad:
let explode s = 
let rec go i = 
if i >= String.length s 
then [] 
else (s.[i]) :: (go (i+1)) 
in
go 0

explode "nikhil"
Error: This function has type int -> char list
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 listReverse

fix:
let rec listReverse l = 
let explosion = explode l;

listReverse "nikhil"

bad:
let rec listReverse l = 
explode l

listReverse "nikhil"
Error: This function has type string -> char list
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 listReverse

fix:
let rec listReverse l = 
explode l

bad:
let rec listReverse l = 
let explosion = explode l
Error: Syntax error



hw1 listReverse

fix:
let rec listReverse l = match l with 
[] -> []

bad:
let rec listReverse l = 
explode l match l with
| [] -> 0
Error: Syntax error


let rec listReverse l = 
let p = explode l match p with
| [] -> 0
Error: Syntax error


let rec listReverse l = 
let p = (explode l) match p with
| [] -> 0
Error: Syntax error


let rec listReverse l = 
let p -> (explode l) match p with
| [] -> 0
Error: Syntax error


let rec listReverse l = 
let explosion = 
(explode l) match p with
| [] -> 0
Error: Syntax error



hw1 listReverse

fix:
let rec listReverse l = match l with 
|[] -> []
|[h1] -> h1::[]
|(h::t) -> h::(listReverse t)

bad:
let rec listReverse l = match l with 
|[] -> []
|(h1) -> h1::[]
|(h::t) -> h::(listReverse t)
Error: This expression has type 'a but an expression was expected of type
         'a list
       The type variable 'a occurs inside 'a list



hw1 listReverse

fix:
let rec listReverse l = match l with 
|[] -> []
|(h::t) -> h::(listReverse t)

bad:
let rec listReverse l = match l with 
|[] -> []
|(h::t) -> (listReverse t)::h
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 listReverse

fix:
let rec listReverse l = match l with 
|[] -> []
|(h::t) -> begin
(listReverse t);
h::[]
end

bad:
let rec listReverse l = match l with 
|[] -> h::[]
|(h::t) -> listReverse t
Error: Unbound value h


let rec listReverse l = match l with 
|[] -> []
|(h::t) -> listReverse t
|_ -> h::[]
Error: Unbound value h


let rec listReverse l = match l with 
|[] -> []
|(h::t) -> listReverse t
h::[]
Error: This function has type 'a list -> 'b list
       It is applied to too many arguments; maybe you forgot a `;'.


let rec listReverse l = match l with 
|[] -> []
|(h::t) -> (listReverse t)
h::[]
Error: This expression has type 'a list
       This is not a function; it cannot be applied.



hw1 ???

fix:
let rev list =
let rec aux acc =
| [] -> acc
| h::t -> aux (h::acc) t in
aux [] list

rev [1;2;3]

bad:
let rev list =
let rec aux acc = function
| [] -> acc
| h::t -> aux (h::acc)  in
aux [] list
Error: This expression has type 'a list -> 'a list
       but an expression was expected of type 'a list


let rev list =
let rec aux acc = function
| [] -> acc
| h::t -> aux (h::acc) h in
aux [] list
Error: This expression has type 'a but an expression was expected of type
         'a list
       The type variable 'a occurs inside 'a list



hw1 ???

fix:
let rec own n =
own n

bad:
let own =
let x = [];
let y = 1;
let rec own1 n =
own1 e
Error: Syntax error



hw1 ???

fix:
let own n =
let rec own1 n =
own1

;;

bad:
let rec own n =
let rec own1 n =
own1 n
Error: Syntax error


let own n =
let rec own1 n =
own1
Error: Syntax error



hw1 ???

fix:
let own n = n + 1

bad:
let own n =
let rec own1 n = in
own1 n
Error: Syntax error


let own n =
let rec own1 n in =
own1 n
Error: Syntax error



hw1 ???

fix:
let average a b = 
let sum = a + b in
sum / 2

bad:
let average a b = 
let sum = a + b;
sum / 2
Error: Syntax error


let average a b = 
let sum = a + b
sum / 2
Error: Syntax error



hw1 additivePersistence

fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

let rec digitsOfInt n = 
if (n <= 0) then []
else 
List.rev (n mod 10 :: List.rev (digitsOfInt (n/10)))

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

let digits n = digitsOfInt (abs n)

let own n = n + 1

let additivePersistence n = 
let count = 1 in
let rec apCalc n count = in
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count

bad:
let additivePersistence n = 
let count = 1 in
let rec apCalc n count = function
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

additivePersistence (sumList (digitsOfInt n))
end
else 
begin
print_string "going into else | ";

sumList x
end
Error: Syntax error


let additivePersistence n = 
let count = 1 in
let rec apCalc n count = function
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

additivePersistence (sumList (digitsOfInt n))
end
else 
begin
print_string "going into else | ";

sumList x
end
Error: Syntax error


let additivePersistence n = 
let count = 1 in
let rec apCalc n count = function
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

additivePersistence (sumList (digitsOfInt n))
end
else 
begin
print_string "going into else | ";

sumList x
end
Error: Syntax error


let additivePersistence n = 
let count = 1 in
let rec apCalc n count = function
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

additivePersistence (sumList (digitsOfInt n))
end
else 
begin
print_string "going into else | ";

sumList x
end
Error: Syntax error


let additivePersistence n = 
let count = 1
Error: Syntax error


let rec apCalc n count = function
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

additivePersistence (sumList (digitsOfInt n))
end
else 
begin
print_string "going into else | ";

sumList x
end
Error: Syntax error


let additivePersistence n = 
let count = 1 in
let rec apCalc n count = function
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

apCalc (sumList (digitsOfInt n)) (count + 1)
end
else 
begin
print_string "going into else | ";

count
end
Error: Syntax error


let additivePersistence n = 
let count = 1 in
let rec apCalc n count = fun
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

apCalc (sumList (digitsOfInt n)) (count + 1)
end
else 
begin
print_string "going into else | ";

count
end
Error: Syntax error


let additivePersistence n = 
let count = 1 in
let rec apCalc n count = 
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

apCalc (sumList (digitsOfInt n)) (count + 1)
end
else 
begin
print_string "going into else | ";

count
end
Error: Syntax error


let additivePersistence n = 
let count = 1 in
let rec apCalc n count = 
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

apCalc (sumList (digitsOfInt n)) (count + 1)
end
else 
begin
print_string "going into else | ";

count
end
in
Error: Syntax error


let additivePersistence n = 
let count = 1 in
let rec apCalc n count = in
if (sumList (digitsOfInt n) > 9) 
then 
begin
print_string "going into then | ";

apCalc (sumList (digitsOfInt n)) (count + 1)
end
else 
begin
print_string "going into else | ";

count
end
Error: Syntax error



hw1 additivePersistence

fix:
let additivePersistence n = 
let count = 1

let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count

bad:
let additivePersistence n = 
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count
Error: Syntax error


let additivePersistence n = 
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count
Error: Syntax error


let additivePersistence n = 
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else sumList count
Error: Syntax error


let additivePersistence n = 
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count
Error: Syntax error


let additivePersistence n = 
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count in
Error: Syntax error


let additivePersistence n = 
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count
in
Error: Syntax error



hw1 additivePersistence

fix:
let additivePersistence n = 
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count

;;

bad:
let additivePersistence n = 
let count = 1;
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count
Error: Syntax error


let additivePersistence n = 
let count = 1;
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count
Error: Syntax error


let additivePersistence n = 
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count
Error: Syntax error


let additivePersistence n = 
let count = 1 in
begin 
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count
end
Error: Syntax error



hw1 additivePersistence

fix:
let additivePersistence n = 
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count

let _ = additivePersistence 9876

bad:
let additivePersistence n = 
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else count
Error: Syntax error



hw1 additivePersistence

fix:
let rec sumList xs = match xs with
| [] -> 0
| (h::t) -> h + sumList t
| _ -> -1

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

let rec digitsOfInt n = 
if (n <= 0) then []
else 
List.rev (n mod 10 :: List.rev (digitsOfInt (n/10)))

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

let digits n = digitsOfInt (abs n)

let own n = n + 1

let additivePersistence n = 
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else poum

bad:
let additivePersistence n = 
let count = 1 in
let rec apCalc n count =
if (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)
else poum
Error: Syntax error



hw1 additivePersistence

fix:
let additivePersistence n = n + 1

bad:
let additivePersistence n =
Error: Syntax error



hw1 additivePersistence

fix:
let additivePersistence n a = n + a

bad:
let additivePersistence n a = n + a + b
Error: Unbound value b



hw1 additivePersistence

fix:
let additivePersistence n a = 
if (sumList (digitsOfInt n) > 9)
then additivePersistence (sumList (digitsOfInt n)) (a + 1)
else 9

bad:
let additivePersistence n a = 
if (sumList (digitsOfInt n) > 9)
then additivePersistence (sumList (digitsOfInt n)) (a + 1)
Error: This expression has type int but an expression was expected of type
         unit



hw1 additivePersistence

fix:
let _ = additivePersistence 9876

bad:
let _ = additivePersistence 9876 1
Error: This function has type int -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 ???

fix:
let rec myListReverse origList newList = match origList with
| [] -> []
| (h::t) -> myListReverse (t) (h::newList)

bad:
let rec myListReverse origList newList = match origList with
| [] -> []
| (h::t) -> myListReverse t h::newList
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw2 ???

fix:
let extract (p1, p2) = match (p1, p2) with
| _ -> p1

bad:
let extract l = match l with
| (string * int) -> string
Characters 31-32:
  | (string * int) -> string;;
    ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let extract (p1, p2) = match (p1, p2) with
| (string * int) -> p1
Characters 45-46:
  | (string * int) -> p1;;
    ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let extract (p1, p2) = match (p1, p2) with
| string * int
Error: Syntax error


) -> p1
Error: Syntax error


let extract (p1, p2) = match (p1, p2) with
| (string * int) -> p1
Characters 45-46:
  | (string * int) -> p1;;
    ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw2 ???

fix:
let extract n (p1, p2) = match (p1, p2) with
| _ -> p1

bad:
extract 1 ("bobby" 2)
Error: This expression has type string
       This is not a function; it cannot be applied.



hw2 ???

fix:
let extract n (p1, p2) = match n with
| 1 -> p1
| 2 -> p2

extract ("bobby", 2)

bad:
extract ("bobby", 2)
Error: This expression has type 'a * 'b
       but an expression was expected of type int



hw2 ???

fix:
let extract1 (p1, p2) = match (p1, p2) with
| _ -> p1

let extract2 (p1, p2) = match (p1, p2) with
| _ -> p2

bad:
extract ("bobby", 2)
Error: This expression has type 'a * 'b
       but an expression was expected of type int


let extract1 (p1, p2) = 
| _ -> p1
Error: Syntax error


let extract2 (p1, p2) =
| _ -> p2
Error: Syntax error



hw2 assoc

fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> if ((extract1 h) = k) then (extract2)
else assoc (d, k, t)

bad:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t - > if ((extract1 h) = k) then (extract2)
else assoc (d, k, t)
Error: Syntax error: pattern expected.



hw2 assoc

fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> d

bad:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
|
Error: Syntax error


let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (
Error: Syntax error: operator expected.



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h::seen) else (h::seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (mem h l) then (h :: seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: Unbound value mem


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (not l.mem h ) then (h :: seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This function has type bool -> bool
       It is applied to too many arguments; maybe you forgot a `;'.


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if not (l.mem h ) then (h :: seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: Unbound record field mem


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if !(l.mem h ) then (h :: seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: Unbound record field mem


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if !(List.mem h seen) then (h :: seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This expression has type bool but an expression was expected of type
         'a ref


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (!List.mem h seen) then (h :: seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This expression has type 'a -> 'a list -> bool
       but an expression was expected of type 'b ref


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (!(List.mem h seen)) then (h :: seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This expression has type bool but an expression was expected of type
         'a ref


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h :: seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This variant expression is expected to have type unit
       The constructor :: does not belong to type unit


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h::seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This variant expression is expected to have type unit
       The constructor :: does not belong to type unit


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h::[]) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This variant expression is expected to have type unit
       The constructor :: does not belong to type unit


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This expression has type 'a list
       but an expression was expected of type unit


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h::seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This variant expression is expected to have type unit
       The constructor :: does not belong to type unit


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then ([]) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This variant expression is expected to have type unit
       The constructor [] does not belong to type unit


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then ([2]) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This variant expression is expected to have type unit
       The constructor :: does not belong to type unit


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = 
if (List.mem h seen) then (h::seen) in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This variant expression is expected to have type unit
       The constructor :: does not belong to type unit



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then (h::seen) else seen in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if !(List.mem h seen) then (h::seen) else seen in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This expression has type bool but an expression was expected of type
         'a ref



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (not (List.mem h seen)) then (h::seen) else seen in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (!List.mem h seen) then (h::seen) else seen in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This expression has type 'a -> 'a list -> bool
       but an expression was expected of type 'b ref



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile (f,b)

bad:
let fixpoint (f,b) = wwhile (b,b)
Error: This expression has type 'a -> 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'a * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = b

bad:
let fixpoint (f,b) = wwhile (b,b)
Error: This expression has type 'a -> 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'a * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((f),b)

bad:
let fixpoint (f,b) = wwhile (f,f b)
Error: This expression has type 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((f ),b)

bad:
let fixpoint (f,b) = wwhile ((f a),b)
Error: Unbound value a



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((f b),b)

bad:
let fixpoint (f,b) = wwhile ((fixpoint (f,b)),b)
Error: This expression has type 'a -> 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'a * bool
Error: Unbound value wwhile
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type 'a -> 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'a * bool



hw2 fixpoint

fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (a = k) then b else assoc (d, k, t)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (not (List.mem h seen)) then (h::seen) else seen in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) = match (f b) with
| (a, b) -> if not(b) then a else wwhile (f, a)

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), b)

bad:
let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else fixpoint (f b, b),b))
Error: This expression has type bool but an expression was expected of type
         ('a -> 'a * bool) * 'a
Error: Unbound value wwhile
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type bool but an expression was expected of type
         ('a -> 'a * bool) * 'a


let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else fixpoint (f,f b),b))
Error: This expression has type bool but an expression was expected of type
         ('a -> 'a * bool) * 'a
Error: Unbound value wwhile
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type bool but an expression was expected of type
         ('a -> 'a * bool) * 'a


let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else (fixpoint (f,f b),b)))
Error: This expression has type bool but an expression was expected of type
         ('a -> 'a * bool) * 'a
Error: Unbound value wwhile
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type bool but an expression was expected of type
         ('a -> 'a * bool) * 'a


let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else (fixpoint (f,b))))
Error: This expression has type bool but an expression was expected of type
         ('a -> 'a * bool) * 'a
Error: Unbound value wwhile
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type bool but an expression was expected of type
         ('a -> 'a * bool) * 'a


let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else (fixpoint (f,b),b)))
Error: This expression has type bool but an expression was expected of type
         ('a -> 'a * bool) * 'a
Error: Unbound value wwhile
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type bool but an expression was expected of type
         ('a -> 'a * bool) * 'a


let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else (fixpoint (f,b),b)))
Error: This expression has type bool but an expression was expected of type
         ('a -> 'a * bool) * 'a
Error: Unbound value wwhile
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type bool but an expression was expected of type
         ('a -> 'a * bool) * 'a


let fixpoint (f,b) = wwhile (if ((f b) = b) then b else (fixpoint (f,b),b))
Error: This expression has type
         ('a -> 'a * bool) * 'a -> ('a -> 'a * bool) * 'a
       but an expression was expected of type
         ('a -> 'a * bool) * 'a ->
         ('a -> 'a * bool) * 'a -> (('a -> 'a * bool) * 'a) * bool
       Type ('a -> 'a * bool) * 'a is not compatible with type
         ('a -> 'a * bool) * 'a -> (('a -> 'a * bool) * 'a) * bool 
Error: Unbound value wwhile
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type
         ('a -> 'a * bool) * 'a -> ('a -> 'a * bool) * 'a
       but an expression was expected of type
         ('a -> 'a * bool) * 'a ->
         ('a -> 'a * bool) * 'a -> (('a -> 'a * bool) * 'a) * bool
       Type ('a -> 'a * bool) * 'a is not compatible with type
         ('a -> 'a * bool) * 'a -> (('a -> 'a * bool) * 'a) * bool 


let fixpoint (f,b) = wwhile (if ((f b) = b) then b else wwhile (f,f b))
Error: This expression has type
         ('a -> 'a * bool) * 'a -> ('a -> 'a * bool) * 'a
       but an expression was expected of type
         ('a -> 'a * bool) * 'a -> (('a -> 'a * bool) * 'a) * bool
       Type ('a -> 'a * bool) * 'a is not compatible with type
         (('a -> 'a * bool) * 'a) * bool 


let fixpoint (f,b) = wwhile (if ((f b) = b) then b, b)
Error: This expression has type 'a * 'b
       but an expression was expected of type unit


let fixpoint (f,b) = wwhile ((if ((f b) = b) then b), b)
Error: This expression has type unit but an expression was expected of type
         'a -> 'a * bool


let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b), b)
Error: This expression has type unit but an expression was expected of type
         'a -> 'a * bool


let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), b)
Error: This expression has type 'a -> 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'a * bool


let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), a)
Error: Unbound value a


let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), b)
Error: This expression has type 'a -> 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'a * bool


let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), b)
Error: This expression has type 'a -> 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'a * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((failwith "to be written"), b)

bad:
let fixpoint (f,b) = wwhile (f (if ((f b) = b) then 1 else 0), b)
Error: This expression has type int but an expression was expected of type
         'a -> 'a * bool


let fixpoint (f,b) = wwhile ((let h x = (f x) in (x, x = b), b)
Characters 28-29:
  let fixpoint (f,b) = wwhile ((let h x = (f x) in (x, x = b), b);;
                              ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let fixpoint (f,b) = wwhile ((let h x = (f x) in (x, x = b), b))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile ((fun x -> x ), b)
Error: This expression has type 'a but an expression was expected of type
         'a * bool
       The type variable 'a occurs inside 'a * bool



hw2 exprToString

fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (a = k) then b else assoc (d, k, t)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (not (List.mem h seen)) then (h::seen) else seen in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) = match (f b) with
| (a, b) -> if not(b) then a else wwhile (f, a)

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) = wwhile ((failwith "to be written"), b)

type expr = 
VarX
| VarY
| Sine     of expr
| Cosine   of expr
| Average  of expr * expr
| Times    of expr * expr
| Thresh   of expr * expr * expr * expr

let rec exprToString e = match e with
| Sine s -> printf "%s" s

bad:
let rec exprToString e = match e with
| VarX -> sprintf "%s" VarX
Error: Unbound value sprintf


let rec exprToString e = match e with
| VarX -> sprintf "%s"
Error: Unbound value sprintf


let rec exprToString e = match e with
| VarX -> printf "%s"
Error: Unbound value printf


let rec exprToString e = match e with
| VarX a -> sprintf "%s" a
Error: The constructor VarX expects 0 argument(s),
       but is applied here to 1 argument(s)


let rec exprToString e = match e with
| VarX v a -> sprintf "%s" a
Error: Syntax error


let rec exprToString e = match e with
| VarX a b -> sprintf "%s" a
Error: Syntax error


let rec exprToString e = match e with
| VarX a -> sprintf "%s" a
Error: The constructor VarX expects 0 argument(s),
       but is applied here to 1 argument(s)


let rec exprToString e = match e with
| Sine s -> sprintf "%s" s
Error: Unbound value sprintf


let rec exprToString e = match e with
| Sine s -> printf "%s" s
Error: Unbound value printf



hw2 exprToString

fix:
let rec exprToString e = match e with
| VarX -> "x"

bad:
let rec exprToString e = match e with
| Sine s -> Format.sprintf "%d" (sin (3.142 * e))
Error: This expression has type float but an expression was expected of type
         int


let rec exprToString e = match e with
| Sine s -> Format.sprintf "%d" (sin (3 * e))
Error: This expression has type expr but an expression was expected of type
         int


let rec exprToString e = match e with
| Sine s -> Format.sprintf "%d" (sin (3 * 2))
Error: This expression has type int but an expression was expected of type
         float


let rec exprToString e = match e with
| Sine s -> Format.sprintf "%d" (sin (3.0 * 2.0))
Error: This expression has type float but an expression was expected of type
         int


let rec exprToString e = match e with
| Sine s -> Format.sprintf "%d" (sin (3 * 2.0))
Error: This expression has type float but an expression was expected of type
         int


let rec exprToString e = match e with
| Sine s -> Format.sprintf "%d" (sin (3 * 2))
Error: This expression has type int but an expression was expected of type
         float


let rec exprToString e = match e with
| Sine s -> Format.sprintf "%i" (sin (3 * 2))
Error: This expression has type int but an expression was expected of type
         float


let rec exprToString e = match e with
| Sine s -> Format.sprintf "%i" (sin (3.0 * 2.0))
Error: This expression has type float but an expression was expected of type
         int



hw2 exprToString

fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ Format.sprintf "%expr" 1.0 ^ ")"

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ s ^ ")"
Error: This expression has type expr but an expression was expected of type
         string


let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ Format.sprintf "%expr" s ^ ")"
Error: This expression has type expr but an expression was expected of type
         float



hw2 exprToString

fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ (exprToString s)  ^ ")"

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ Format.sprintf "%_" s  ^ ")"
Error: invalid format "%_": at character number 2, unexpected end of format


let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ Format.sprintf "%" s  ^ ")"
Error: invalid format "%": at character number 1, unexpected end of format


let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ Format.printf "%" s  ^ ")"
Error: invalid format "%": at character number 1, unexpected end of format


let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ Format.printf "%f" s  ^ ")"
Error: This expression has type expr but an expression was expected of type
         float


let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ Format.printf "%i" s  ^ ")"
Error: This expression has type expr but an expression was expected of type
         int


let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ Format.printf "%expr" s  ^ ")"
Error: This expression has type expr but an expression was expected of type
         float


let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ Format.printf "%e" s  ^ ")"
Error: This expression has type expr but an expression was expected of type
         float



hw2 exprToString

fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ (exprToString s)  ^ ")"
| Cosine c -> "cos(pi*" ^ (exprToString c) ^ ")"
| Average (a1,a2) -> "((" ^ (exprToString a1) ^ "+" ^ (exprToString a2) ^ ")/2)"
| Times (t1,t2) -> "(" ^ (exprToString t1) ^ "*" ^ (exprToString t2) ^ ")"

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ (exprToString s)  ^ ")"
| Cosine c -> "cos(pi*" ^ (exprToString c) ^ ")"
| Average a1 a2 -> "((" ^ (exprToString a1) ^ "+" ^ (exprToString a2) ^ ")/2)"
| Times t1 t2 -> "(" ^ (exprToString t1) ^ "*" ^ (exprToString t2) ^ ")"
Error: Syntax error


let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ (exprToString s)  ^ ")"
| Cosine c -> "cos(pi*" ^ (exprToString c) ^ ")"
| Average a1 a2 -> "((" ^ (exprToString a1) ^ "+" ^ (exprToString a2) ^ ")/2)"
| Times t1 t2 -> "(" ^ (exprToString t1) ^ "*" ^ (exprToString t2) ^ ")"
Error: Syntax error


let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ (exprToString s)  ^ ")"
| Cosine c -> "cos(pi*" ^ (exprToString c) ^ ")"
| Average (a1,a2) -> "((" ^ (exprToString a1) ^ "+" ^ (exprToString a2) ^ ")/2)"
| Times t1 t2 -> "(" ^ (exprToString t1) ^ "*" ^ (exprToString t2) ^ ")"
Error: Syntax error



hw2 build

fix:
let mine = buildAverage(VarX, VarY)

bad:
let mine = buildAverage(2.0, 4.0)
Error: This expression has type float but an expression was expected of type
         expr



hw2 build

fix:
let rec eval (e,x,y) = match e with
| VarX -> x 
| VarY -> y
| Average (a1,a2) -> buildAverage(a1,a2)

bad:
let rec eval (e,x,y) = match e with
| VarX -> let vx = x in
| VarY -> let vy = y in 
| Average -> buildAverage (vx, vy)
Error: Syntax error


let rec eval (e,x,y) = match e with
| VarX -> let vx = x in 
| VarY -> let vy = y in
| Sine -> 
| Average -> buildAverage(vx,vy)
Error: Syntax error


let rec eval (e,x,y) = match e with
| VarX -> let vx = x  
| VarY -> let vy = y in
| Sine -> 
| Average -> buildAverage(vx,vy)
Error: Syntax error


let rec eval (e,x,y) = match e with
| VarX -> let vx = x  
| VarY -> let vy = y 
| Sine -> 
| Average -> buildAverage(vx,vy)
Error: Syntax error


let rec eval (e,x,y) = match e with
| VarX -> let vx = x  
| VarY -> let vy = y 
| Average -> buildAverage(vx,vy)
Error: Syntax error


let rec eval (e,x,y) = match e with
| VarX -> let vx = x in vx 
| VarY -> let vy = y in vy
| Average -> buildAverage(vx,vy)
Error: The constructor Average expects 2 argument(s),
       but is applied here to 0 argument(s)



hw2 build

fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (a, b) -> if (a = k) then b else assoc (d, k, t)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (not (List.mem h seen)) then (h::seen) else seen in
let rest' = t in
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) = match (f b) with
| (a, b) -> if not(b) then a else wwhile (f, a)

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) = wwhile ((failwith "to be written"), b)

let pi = 3.142

type expr = 
VarX
| VarY
| Sine     of expr
| Cosine   of expr
| Average  of expr * expr
| Times    of expr * expr
| Thresh   of expr * expr * expr * expr

let _ = VarX

let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine s -> "sin(pi*" ^ (exprToString s)  ^ ")"
| Cosine c -> "cos(pi*" ^ (exprToString c) ^ ")"
| Average (a1,a2) -> "((" ^ (exprToString a1) ^ "+" ^ (exprToString a2) ^ ")/2)"
| Times (t1,t2) -> (exprToString t1) ^ "*" ^ (exprToString t2)
| Thresh (h1,h2,h3,h4) -> "(" ^ (exprToString h1) ^ "<" ^ (exprToString h2) ^ 
"?" ^ (exprToString h3) ^ ":" ^ (exprToString h4) ^ ")"

let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

let _ = exprToString sampleExpr1

let buildX()                       = VarX

let buildY()                       = VarY

let buildSine(e)                   = Sine(e)

let buildCosine(e)                 = Cosine(e)

let buildAverage(e1,e2)            = Average(e1,e2)

let buildTimes(e1,e2)              = Times(e1,e2)

let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)

let pi = 4.0 *. atan 1.0

let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Average (a1,a2) -> buildAverage(a1,a2)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Average (a1,a2) -> buildAverage(a1,a2)
Error: This expression has type expr but an expression was expected of type
         float



hw2 eval

fix:
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))

bad:
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Average (a1,a2) -> (eval (VarX,a1,a2))
Error: This expression has type expr but an expression was expected of type
         float


let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Average (a1,a2) -> (a1 + a2)
Error: This expression has type expr but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Average (a1,a2) -> (eval(VarX,a1,a2) + eval(VarY,a1,a2))
Error: This expression has type expr but an expression was expected of type
         float


let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Average (a1,a2) -> (eval(VarX,x,y) + eval(VarY,a1,a2))
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,a1,a2))
Error: This expression has type expr but an expression was expected of type
         float



hw2 eval

fix:
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Sine (s1) -> sin (eval (s1,x,y))
| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))

bad:
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Sine (s1) -> sin(s1)
| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))
Error: This expression has type expr but an expression was expected of type
         float



hw2 eval

fix:
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Sine (s1) -> sin (eval (s1,x,y))
| Cosine (c1) -> cos (eval (c1,x,y))
| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.(2.0)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Sine (s1) -> sin (eval (s1,x,y))
| Cosine (c1) -> cos (eval (c1,x,y))
| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/2.0
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Sine (s1) -> sin (eval (s1,x,y))
| Cosine (c1) -> cos (eval (c1,x,y))
| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.2
Error: This expression has type int but an expression was expected of type
         float



hw2 eval

fix:
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Sine (s1) -> sin (pi *. eval(s1,x,y))
| Cosine (c1) -> cos (pi *. eval(c1,x,y))
| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.(2.0)
| Times (t1,t2) -> (eval(t1,x,y) *. eval(t2,x,y))
| Thresh (h1,h2,h3,h4) -> if (eval(h1,x,y) < eval(h2,x,y)) then eval(h3,x,y) else eval(h4,x,y)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Sine (s1) -> sin (pi *. eval(s1,x,y))
| Cosine (c1) -> cos (pi *. eval(c1,x,y))
| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.(2.0)
| Times (t1,t2) -> (eval(t1,x,y) *. eval(t2,x,y))
| Thresh (h1,h2,h3,h4) ->
Error: Syntax error



hw2 eval

fix:
let _ = eval (Sine(Average(VarX,VarY)), 0.5, -0.5)

bad:
let _ = eval (Sine(Average(Varx,VarY)), 0.5, -0.5)
Error: This variant expression is expected to have type expr
       The constructor Varx does not belong to type expr
Hint: Did you mean VarX or VarY?



hw2 ???

fix:
let _ = makeRand(0,5)

bad:
let _ = rand(0.5)
Error: Unbound value rand
Hint: Did you mean land?


let _ = rand(0,5)
Error: Unbound value rand
Hint: Did you mean land?



hw2 ???

fix:
let rand = makeRand (10,39) in
let x = rand (1,4) in x

bad:
let rand = makeRand (10,39) in
let x = rand (1,4)
Error: Syntax error


let rand = makeRand (10,39) in
let x = rand (1,4) in

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))
Error: Syntax error


let rand = makeRand (10,39) in
let x = rand (1,4) in
Error: Syntax error



hw2 build

fix:
build (makeRand (10,39), 4)

bad:
build (rand, 4)
Error: Unbound value rand
Hint: Did you mean land?



hw2 build

fix:
let rec build (rand, depth) = match (rand (1,7)) with
| 1 -> buildX()
| 2 -> buildY()
| 3 -> buildX()
| 4 -> buildY()
| 5 -> buildX()
| 6 -> buildY()
| 7 -> buildX()

bad:
let rec build (rand, depth) = match (rand (1,7)) with
| 1 -> VarX
| 2 -> 22
| 3 -> 33
| 4 -> 44
| 5 -> 55
| 6 -> 66
| 7 -> 77
Error: This expression has type int but an expression was expected of type
         expr



hw2 build

fix:
let rec build (rand, depth) = match (rand (1,7)) with
| 1 -> buildSine(buildX())
| 2 -> buildY()
| 3 -> buildX()
| 4 -> buildY()
| 5 -> buildX()
| 6 -> buildY()
| 7 -> buildX()

bad:
let rec build (rand, depth) = match (rand (1,7)) with
| 1 -> buildX(buildY())
| 2 -> buildY()
| 3 -> buildX()
| 4 -> buildY()
| 5 -> buildX()
| 6 -> buildY()
| 7 -> buildX()
Error: This expression has type expr but an expression was expected of type
         unit



hw2 build

fix:
let rec build (rand, depth) = match (rand (1,7)) with
| _ -> buildTimes(buildCosine(buildSine(buildX())), buildCosine(buildSine(buildX())))
| 1 -> buildX()
| 2 -> buildY()
| 3 -> buildSine(build(rand, depth))
| 4 -> buildCosine(build(rand, depth))
| 5 -> buildAverage(build(rand, depth), build(rand, depth))
| 6 -> buildTimes(build(rand, depth), build(rand, depth))
| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))

bad:
let rec build (rand, depth) = match (rand (1,7)) with
| _ -> buildTimes(buildCosine(buildSine(buildX())), buildCosine(buildSine(buildX())))
| 1 -> buildX()
| 2 -> buildY()
| 3 -> buildSine(buildX())
| 4 -> buildSine(buildX())
| 5 -> buildSine(buildX())
| 6 -> buildSine(buildX())
| 7 -> buildSine(buildX())
Error: This variant expression is expected to have type expr
       The constructor () does not belong to type expr



hw2 build

fix:
let rec build (rand, depth) = match (rand (1,7)) with
| 1 -> buildX()
| 2 -> buildY()
| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))
| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))
| 5 -> buildAverage ( (if (depth = 0) then buildX() else build(rand, depth - 1)), (if (depth = 0) then buildY() else build(rand, depth - 1)))
| 6 -> buildTimes(build(rand, depth), build(rand, depth))
| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))

bad:
let rec build (rand, depth) = match (rand (1,7)) with
| 1 -> buildX()
| 2 -> buildY()
| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))
| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))
| 5 -> buildAverage ( (if (depth = 0) then buildX() else build(rand, depth - 1)), if (depth = 0) then buildY() else build(rand, depth - 1))
| 6 -> buildTimes(build(rand, depth), build(rand, depth))
| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))
Error: This expression has type expr but an expression was expected of type
         expr * expr



hw2 build

fix:
let _ = build (makeRand(1,2), 0)

bad:
let rec build (rand, depth) = match (rand (1,7)) with
| _ -> rand(1,7)
| 1 -> buildX()
| 2 -> buildY()
| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))
| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))
| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), 
(if (depth = 0) then buildY() else build(rand, depth - 1)))
| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), 
(if (depth = 0) then buildY() else build(rand, depth - 1)))
| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), 
(if (depth = 0) then buildY() else build(rand, depth - 1)), 
(if (depth = 0) then buildX() else build(rand, depth - 1)),
(if (depth = 0) then buildY() else build(rand, depth - 1))))
Error: This expression has type
         ('a -> 'b, Format.formatter, unit, unit, unit, 'a -> 'b)
         CamlinternalFormatBasics.fmt
       but an expression was expected of type
         ('a -> 'b, Format.formatter, unit, unit, unit, unit)
         CamlinternalFormatBasics.fmt
       Type 'a -> 'b is not compatible with type unit 


let rec build (rand, depth) = match (rand (1,7)) with
| _ -> rand(1,7)
Error: This expression has type expr but an expression was expected of type
         int



hw2 build

fix:
let _ = build (makeRand(1, 7), 0)

bad:
let _ = build (makeRand(1, 78), 0)
Error: Syntax error: operator expected.



hw2 build

fix:
let rec build (rand, depth) = match (rand (1,7)) with
| _ -> buildThresh(VarX,VarX,VarX,VarX)
| 1 -> buildX()
| 2 -> buildY()
| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))
| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))
| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), 
(if (depth = 0) then buildY() else build(rand, depth - 1)))
| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), 
(if (depth = 0) then buildY() else build(rand, depth - 1)))
| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), 
(if (depth = 0) then buildY() else build(rand, depth - 1)), 
(if (depth = 0) then buildX() else build(rand, depth - 1)),
(if (depth = 0) then buildY() else build(rand, depth - 1))))

bad:
let rec build (rand, depth) = match (rand (1,7)) with
| _ -> buildTimes (VarX)
| 1 -> buildX()
| 2 -> buildY()
| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))
| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))
| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), 
(if (depth = 0) then buildY() else build(rand, depth - 1)))
| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), 
(if (depth = 0) then buildY() else build(rand, depth - 1)))
| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), 
(if (depth = 0) then buildY() else build(rand, depth - 1)), 
(if (depth = 0) then buildX() else build(rand, depth - 1)),
(if (depth = 0) then buildY() else build(rand, depth - 1))))
Error: This expression has type expr but an expression was expected of type
         expr * expr


let _ = build (makeRand(1,2), 0)
Error: This expression has type expr but an expression was expected of type
         expr * expr



hw2 fixpoint

fix:
let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, f b))

bad:
f 2
Error: Unbound value f


let fixpoint (f,b) = wwhile ((f,b), b)
Error: Unbound value f


let fixpoint (f,b) = wwhile ((f,b), b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile ((f, b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile (f, b)
Characters 28-29:
  let fixpoint (f,b) = wwhile ((f, b);;
                              ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ( (let f x =  in f), b)

bad:
let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, (f b)))
Error: This expression has type 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a * bool


let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, wwhile (f,b)))
Error: This expression has type 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = 
let h x = let x = b in (x, x != f x)  in
wwhile (h, b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let fixpoint (f,b) = 
let h x = (b, b != f b)  in
wwhile (h, b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let fixpoint (f,b) = 
let h b = (b, b != f b)  in
wwhile (h, b)

bad:
let fixpoint (f,b) = 
let h x = (b, b != f b)  in
wwhile (h, b)
Error: Unbound value wwhile


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let fixpoint (f,b) = 
let f x = (x, x != f x)  in
wwhile (h, b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let fixpoint (f,b) = 
let g x = let xx = (f x) in (xx, xx != b)  in
wwhile (f, b)

bad:
let fixpoint (f,b) = 
let f x = (x, x != f x)  in
wwhile (f, b)
Error: Unbound value wwhile


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let fixpoint (f,b) = 
let g x = let xx = (f x) in (xx, xx != b)  in
wwhile (f, x)
Error: Unbound value wwhile


let fixpoint (f,b) = 
let g x = let xx = (f x) in (xx, xx != b)  in
wwhile (f, b)
Error: Unbound value wwhile


let fixpoint (f,b) = 
let g x = let xx = (f x) in (xx, xx != x)  in
wwhile (f, b)
Error: Unbound value wwhile


let fixpoint (f,b) = 
let g x = let xx = (f x) in (xx, xx != x)  in
wwhile (g, b)
Error: Unbound value wwhile


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile


let fixpoint (f,b) = 
let f x = let xx = (f x) in (xx, xx != x)  in
wwhile (f, b)
Error: Unbound value fixpoint


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile


let fixpoint (f,b) = 
let a x = let xx = (f x) in (xx, xx != x)  in
wwhile (a, b)
Error: Unbound value fixpoint



hw3 ???

fix:
let rec max_list smallest lst = match lst with
| [] -> smallest
| h::t -> max_list (max smallest h) t

bad:
let mine xs = match xs with
| [] -> 0
| h::t -> t
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 sqsum

fix:
let sqsum xs = 
let f a x = (x *. x) in
let base = 0.0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a -> (x *. x) in
let base = 0 in
List.fold_left f base xs
Error: Syntax error


let sqsum xs = 
let f a x = fun a x -> (x *. x) in
let base = 0 in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         'a -> float -> float


let sqsum xs = 
let f a x = fun a x -> (x *. x) in
let base = 0.0 in
List.fold_left f base xs
Error: This expression has type float but an expression was expected of type
         'a -> float -> float



hw3 pipe

fix:
let pipe fs = 
let f a x =  x in
let base = 0 in
List.fold_left f base fs

bad:
let _ = pipe[] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe fs = 
let f a x = x + a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a -> a in
let base = 0 in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base =  "" in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x + a in
let base =  in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x + a in
let base = "" in
List.fold_left f base fs
Error: This expression has type string but an expression was expected of type
         int



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = 1 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =   in
List.fold_left f base fs
E
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe[] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let pipe fs = 
let f a x = x a in
let base = x in
List.fold_left f base fs
Error: Unbound value x



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun x in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x + 1 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = a' in
List.fold_left f base fs
Error: Unbound value a'


let pipe fs = 
let f a x = x a in
let base = fun in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base =  fun x -> x in
List.fold_left f base fs

let _ = pipe [] 3

bad:
let pipe fs = 
let f a x = x a in
let base = fs in
List.fold_left f base fs
Error: This expression has type 'a but an expression was expected of type
         ('a -> 'a) list
       The type variable 'a occurs inside ('a -> 'a) list



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base =  0 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  a in
List.fold_left f base fs
Error: Unbound value a


let pipe fs = 
let f a x = x a in
let base = h::t -> h in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x a in
let base = fun x in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x a in
let base = x in
List.fold_left f base fs
Error: Unbound value x



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun x -> a in
List.fold_left f base fs
Error: Unbound value a



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = (+) 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = _ in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = (()) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = (_) in
List.fold_left f base fs
Error: Syntax error: operator expected.



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = (+) 0 in
List.fold_left f base fs

let _ = pipe [] 3

bad:
let pipe fs = 
let f a x = x a in
let base = (+) x in
List.fold_left f base fs
Error: Unbound value x



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base =  fun x b -> b in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3
Error: This expression has type int -> int
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base =  fun x b -> 0 + b in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  fun x b in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = (+) 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = (+) x in
List.fold_left f base fs
Error: Unbound value x



hw3 pipe

fix:
let sqsum xs = 
let f a x = (x * x) + a in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = x a in
let base = (+) 0 in
List.fold_left f base fs

let _ = pipe [] 3

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3
Error: This expression has type int -> int
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = (+) 0 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3
Error: This expression has type int -> int
       but an expression was expected of type int



hw3 pipe

fix:
let _ = pipe []

bad:
let _ = pipe [] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = (+) 0   in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = 0 (+)   in
List.fold_left f base fs
Error: This expression has type int
       This is not a function; it cannot be applied.



hw3 pipe

fix:
let pipe fs = 
let f a x = (x a) a in
let base = (+) 0 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3
Error: This expression has type int -> int
       but an expression was expected of type int


let pipe fs = 
let f a x = a x in
let base = (+) 0 in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = (x a) in
let base = (+) 0 in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3
Error: This expression has type int -> int
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs = 
let f a x = (x a) a in
let base = (+) 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (a x) a in
let base = (+) 0 in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'c
       but an expression was expected of type 'b
       The type variable 'b occurs inside 'a -> 'b -> 'c


let pipe fs = 
let f a x = (a x) x in
let base = (+) 0 in
List.fold_left f base fs
Error: This expression has type ('a -> 'a -> 'b) -> 'a -> 'b
       but an expression was expected of type
         ('a -> 'a -> 'b) -> 'a -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'a -> 'b



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = (x^sep) ^ a in
let base = "" in
let l = [] in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = (x^sep) ^ a in
let base = "" in
let l = "" in
List.fold_left f base l
Error: This expression has type string but an expression was expected of type
         string list



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = (h^sep) ^ x in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = (h^sep) ^ t in
let base = "" in
let l = t in
List.fold_left f base l
Error: This expression has type string list
       but an expression was expected of type string



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = (h^sep) ^ x in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = (h^sep) ^ x in
let base = "" in
let l = h in
List.fold_left f base l
Error: This expression has type string but an expression was expected of type
         string list


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = (h^sep) ^ x in
let base = "" in
let l = a in
List.fold_left f base l
Error: Unbound value a



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = (x^sep) ^ a in
let base = "" in
let l = h in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = (x^sep) ^ a in
let base = "" in
let l = h ^ t in
List.fold_left f base l
Error: This expression has type string list
       but an expression was expected of type string



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = 3 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = List.hd fs in
List.fold_left f base fs
Error: This expression has type 'a list
       but an expression was expected of type ('a -> 'a) list
       The type variable 'a occurs inside 'a -> 'a


let pipe fs = 
let f a x = x a in
let base = List.head fs in
List.fold_left f base fs
Error: Unbound value List.head


let pipe fs = 
let f a x = x a in
let base = List.hd fs in
List.fold_left f base fs
Error: This expression has type 'a list
       but an expression was expected of type ('a -> 'a) list
       The type variable 'a occurs inside 'a -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = (+) 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = -> _ in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x a in
let base = :: 0 in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x a in
let base = (::) 0 in
List.fold_left f base fs
Error: Syntax error: operator expected.


let pipe fs = 
let f a x = x a in
let base = (::) 0 2 in
List.fold_left f base fs
Error: Syntax error: operator expected.


let pipe fs = 
let f a x = x a in
let base = (::)  in
List.fold_left f base fs
Error: Syntax error: operator expected.


let pipe fs = 
let f a x = x a in
let base = 0 (::) in
List.fold_left f base fs
Error: Syntax error: operator expected.



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = (-) 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = * 1 in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let sqsum xs = 
let f a x = (x * x) + a in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = x a in
let base =  in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = 0 + in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun y -> (+) y  in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = fun y -> (+) x  in
List.fold_left f base fs
Error: Unbound value x



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun _ -> 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = x -> 0 in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x a in
let base = fun _ ->  in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x a in
let base = fun _ -> _ in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let sqsum xs = 
let f a x = (x * x) + a in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = fun y -> x (a y) in
let base = fun z -> z in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = x -> x + 1 in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x a in
let base = x + 1 in
List.fold_left f base fs
Error: Unbound value x



hw3 clone

fix:
let rec clone x n = 
if n > 0 then clone (x) (n - 1) else []

bad:
let rec clone x n = 
if n > 0 then clone (x::[]) (n - 1) else []
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw3 clone

fix:
let rec clone x n = 
let acc = [] in
if n > 0 then clone (x@acc) (n - 1) else []

bad:
let rec clone x n = 
let acc = [] in
if n > 0 then clone (x::acc) (n - 1) else []
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw3 clone

fix:
let rec clone x n = 
let acc = [x] in
if n > 0 then clone (x) (n - 1) else []

bad:
let _ = clone 3 5
Error: This expression has type int but an expression was expected of type
         'a list


let rec clone x n = 
let acc = [] in
if n > 0 then clone (x::x) (n - 1) else []
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw3 clone

fix:
let rec clone x n = 
let acc = [0] in
if n > 0 then clone (x) (n - 1) else []

bad:
let rec clone x n = 
let acc = [x] in
if n > 0 then clone (x::acc) (n - 1) else []
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec clone x n = 
let acc = [0] in
if n > 0 then clone (x::acc) (n - 1) else []
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw3 ???

fix:
let acc = []

bad:
let acc = [0] in
Error: Syntax error



hw3 ???

fix:
let myfun x = []

bad:
let acc = [x]
Error: Unbound value x


let myfun x =
let acc = [x]
Error: Syntax error


let myfun x =
let acc = []
Error: Syntax error


let myfun x =
let acc = [x] in
Error: Syntax error



hw3 clone

fix:
let _ = clone 3 (-4)

bad:
let _ = clone 3 -4
Error: This expression has type int -> int list
       but an expression was expected of type int



hw3 ???

fix:
let three = two@one

bad:
let three = one::two
Error: This expression has type int list
       but an expression was expected of type int list list
       Type int is not compatible with type int list 


let three = two::one
Error: This expression has type int list
       but an expression was expected of type int list list
       Type int is not compatible with type int list 



hw3 padZero

fix:
let padZero l1 l2 = 
let l1_len = List.length l1 in
let l2_len = List.length l2 in
let l_diff = l1_len - l2_len in
let to_append = clone 0 l_diff in
if (l_diff < 0) then ((to_append @ l1), l2) else (l1, (to_append @ l2))

bad:
let padZero l1 l2 = 
let l1_len = List.length l1 in
let l2_len = List.length l2 in
let l_diff = l1_len - l2_len in
let to_append = clone 0 l_diff in
if (l_diff < 0) then (to_append @ l1), l2
Error: This expression has type 'a * 'b
       but an expression was expected of type unit


) else (l1, (to_append @ l2))
Error: Syntax error


let padZero l1 l2 = 
let l1_len = List.length l1 in
let l2_len = List.length l2 in
let l_diff = l1_len - l2_len in
let to_append = clone 0 l_diff in
if (l_diff < 0) then (to_append @ l1), l2
Error: This expression has type 'a * 'b
       but an expression was expected of type unit


)
Error: Syntax error


) else (l1, (to_append @ l2))
Error: Syntax error



hw3 padZero

fix:
let padZero l1 l2 = 
let l1_len = List.length l1 in
let l2_len = List.length l2 in
let l_diff = l1_len - l2_len in
if (l_diff < 0) then ((clone 0 (l_diff * (-1)) @ l1), l2) else (l1, (clone 0 l_diff @ l2))

bad:
let padZero l1 l2 = 
let l1_len = List.length l1 in
let l2_len = List.length l2 in
let l_diff = l1_len - l2_len in
if (l_diff < 0) then ((clone 0 (l_diff * (-1) @ l1), l2)) else (l1, (clone 0 l_diff @ l2))
Error: This expression has type int but an expression was expected of type
         'a list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([x+1],[x+2])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([x+1],[x+2])
in
let base = ([],[]) in
let args = (l1, l2) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type int list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([x+1],[x+2])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([x+1],[x+2])
in
let base = ([],[]) in
let args = [(l1,l2)] in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type ('a * 'b) list
       but an expression was expected of type int list
       Type 'a * 'b is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = let (a,b) = List.hd x in ([a+1],[b+2])
in
let base = ([],[]) in
let args = [(l1,l2)] in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type ('a * 'b) list
       but an expression was expected of type (int * int) list list
       Type 'a * 'b is not compatible with type (int * int) list 


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = let (a,b) = List.hd x in ([(List.hd a)+1],[(List.hd b)+2])
in
let base = ([],[]) in
let args = [(l1,l2)] in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type ('a * 'b) list
       but an expression was expected of type (int list * int list) list list
       Type 'a * 'b is not compatible with type (int list * int list) list 


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([(List.hd x)+1],[(List.hd x)+2])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list * int list
       but an expression was expected of type int list list * 'a
       Type int is not compatible with type int list 


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = let (a,b) = List.hd x in ((List.hd a)+1
Characters 76-77:
  let f a x = let (a,b) = List.hd x in ((List.hd a)+1;;
                                       ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


],(List.hd b)+2
Error: Syntax error


)
in
let base = ([],[]) in
let args = [(l1,l2)] in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = let (a,b) = List.hd x in ((List.hd a)+1,(List.hd b)+2)
in
let base = ([],[]) in
let args = [(l1,l2)] in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b list
       but an expression was expected of type int * int
       Type 'a list is not compatible with type int 



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([x+1],[x+1])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([x+a],[x+a])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int -> int -> int list * int list
       but an expression was expected of type int -> int -> int
       Type int list * int list is not compatible with type int 



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([x+1],[x+1])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [1;1;1;1] [2;2;2;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([x+a],[x+a])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int -> int -> int list * int list
       but an expression was expected of type int -> int -> int
       Type int list * int list is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([x::a],[x::a])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list -> 'a -> 'a list list * 'a list list
       but an expression was expected of type 'a list -> 'a -> 'a list
       Type 'a list list * 'a list list is not compatible with type 'a list 



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let y = List.hd l2 in
let (one,two) = a in (x::one,y::two)
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let y = l2 in
let (one,two) = a in (x::one,y::two)
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list list
       but an expression was expected of type int list
       Type int list is not compatible with type int 



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let y = List.hd l2 in
List.split  ((let (one,two) = a in (x::one,y::two)))
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [1;1;1;1] [2;2;2;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let y = List.hd l2 in
List.combine (let (one,two) = a in (x::one,y::two))
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let y = List.hd l2 in
List.split (List.combine (let (one,two) = a in (x::one,y::two)))
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let y = List.hd l2 in
(let (one,two) = a in (x::one,y::two))
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let y = List.hd l2 in
List.combine (List.split  ((let (one,two) = a in (x::one,y::two))))
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type ('c * 'd) list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> if ((fir + sec) < 10) then ([], (fir + sec)::b2)  else ([], (fir + sec)::b2)
in
let base = ([],[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = match x with
| (a, b) -> (a + b) mod 10
in
let base = (_,[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error: operator expected.


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = match x with
| (a, b) -> (a + b) mod 10
in
let base = ((_),[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error: operator expected.


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = base in 
match x with
| (a, b) -> if ((a + b) < 10) then ([], (a + b)::b2)  else ([], (a + b)::b2)
in
let base = ([],[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value base



hw3 bigAdd

fix:
let sqsum xs = 
let f a x = (x * x) + a in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = fun y -> x (a y) in
let base = fun z -> z in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [ (fun x -> x + x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ (sep ^ x) in
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = "[" ^ (sepConcat "; " (List.map f l)) ^ "]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n =
let rec helper a b acc =
if b > 0 then helper a (b - 1) (a::acc) else acc
in
helper x n []

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let padZero l1 l2 = 
let l1_len = List.length l1 in
let l2_len = List.length l2 in
let l_diff = l1_len - l2_len in
if (l_diff < 0) then ((clone 0 (l_diff * (-1)) @ l1), l2) else (l1, (clone 0 l_diff @ l2))

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

let rec removeZero l = match l with
| [] -> []
| (h::t) -> if (h = 0) then removeZero t else h::t

let _ = removeZero [0;0;0;1;0;0;2]

let _ = removeZero [9;9]

let _ = removeZero [0;0;0;0]

let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let getTail l = match l with 
| [] -> []
| (h::t) -> t in
let getCarry (c, l) = c in
let carry = getCarry a in
let getSum (c, l) = l in
let sum = 
if carry = 1 
then getTail (getSum a) 
else getSum a in
let add (m,n) = m + n in
let digit = (add x) + carry in
if digit > 9 
then (1, 1::(digit-10)::sum) 
else (0, (digit)::sum) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec) < 10) 
then ([], (fir + sec)::b2)  else ((fir + sec) / 10, (fir + sec) mod 10 ::b2)
in
let base = (0,[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec) < 10) 
then ([], (fir + sec)::b2)  else ((fir + sec) / 10, (fir + sec) mod 10 ::b2)
in
let base = (0,[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec) < 10) 
then (b1, (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)
in
let base = (0,[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec) < 10) 
then ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)
in
let base = (0,[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a list


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec) < 10) 
then ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)
in
let base = ("",[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a list


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec) < 10) 
then ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)
in
let base = ([],[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a list


let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec) < 10) 
then ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)
in
let base = (0,[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec + b1) < 10) 
then 
if (List.length b2 = List.length l1) then (0, b1::b2) else (0, (fir + sec + b1)::b2)  
else 
if (List.length b2 = List.length l1) then (0, b1::b2) else (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)
in
let base = (0,[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec + b1) < 10) 
then (0, (fir + sec + b1)::b2)  
else (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)
if (List.length b2 = List.length l1) then (0,b1::b2) else (0,b1::b2)
in
let base = (0,[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec + b1) < 10) 
then 
if (List.length b2 = List.length l1) 
then (0, b1::b2) 
else (0, (fir + sec + b1)::b2)  
else 
if (List.length b2 = List.length l1) 
then (0, b1::b2) 
else (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)
in
let base = (0,[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = 
let (b1, b2) = a in 
match x with
| (fir, sec) -> 
if ((fir + sec + b1) < 10) 
then 
if (List.length b2 = List.length l1) 
then (0, b1::b2) 
else (0, (fir + sec + b1)::b2)  
else if 
if (List.length b2 = List.length l1) 
then (0, b1::b2) 
else (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)
in
let base = (0,[]) in
let args = (List.rev (List.combine l1 l2)) in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error



hw3 mulByDigit

fix:
let rec mulByDigit i l = 
let rec helper a b acc = 
if (a > 0) 
then helper (a - 1) b (bigAdd b b)
else acc
in
helper i l []

bad:
let rec mulByDigit i l = 
let rec helper a b acc = 
if (a > 0) 
then helper (a - 1) b (bigAdd b b)
else acc
in
helper i l 0
Error: This expression has type int but an expression was expected of type
         int list



hw3 mulByDigit

fix:
let _ = mulByDigit 3 [1;7]

bad:
let _ = mulByDigit 3 [1;7]
kjlk
Error: This function has type int -> int list -> int list
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 mulByDigit

fix:
let _ = mulByDigit 9 [9;9;9;9]

let _ = mulByDigit 0 [9;9;9;9]

let _ = mulByDigit 1 [9;9;9;9]

let _ = mulByDigit 2 [9;9;9;9]

let _ = mulByDigit 3 [1;7]

bad:
let _ = mulByDigit 3 [1;7]

sdf
Error: This function has type int -> int list -> int list
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = (0,((mulByDigit x l2) @ (clone 0 ((List.length l1) - 1))))
in
let base = (0, [0]) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = 
match x with
| (h::t) -> (0,((mulByDigit h sec) @ (clone 0 ((List.length fir) - 1))))
in
let base = (0, [0]) in
let args = [l1;l2] in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value sec
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value sec


let bigMul l1 l2 = 
let f a x = (0,((mulByDigit x l2) @ (clone 0 ((List.length l1) - 1))))
in
let base = (0, [0]) in
let args = [l1;l2] in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list list
       but an expression was expected of type int list
       Type int list is not compatible with type int 
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int list list
       but an expression was expected of type int list
       Type int list is not compatible with type int 



hw2 build

fix:
let rec build (rand, depth) =
match rand with
| 0 -> 
let halff = rand in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))

bad:
let rec build (rand, depth) =
match rand with
| 0 -> 
let halff = rand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))
Error: This expression has type int
       This is not a function; it cannot be applied.


let rec build (rand, depth) =
match rand with
| 0 -> 
let halff = rand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))
Error: This expression has type int
       This is not a function; it cannot be applied.


let rec build (rand, depth) =
match rand with
| 0 -> 
let halff = makeRand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))
Error: This expression has type int but an expression was expected of type
         int * int -> int


let rec build (rand, depth) =
match rand with
| 0 -> 
let halff = let r = makeRand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))
Error: Syntax error


let rec build (rand, depth) =
match rand with
| 0 -> 
let halff = let r = makeRand(0,2) in in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))
Error: Syntax error


let rec build (rand, depth) =
match rand with
| 0 -> 
let halff = r = makeRand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))
Error: Unbound value r


let rec build (rand, depth) =
match rand with
| 0 -> 
let halff = rand in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))
Error: This expression has type int
       This is not a function; it cannot be applied.



hw2 ???

fix:
let _ = makeRand(0,8)

bad:
let _ = rand
Error: Unbound value rand
Hint: Did you mean land?



hw2 build

fix:
let rec build (rand, depth) =
match depth with
| 0 -> 
let halff = rand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))

bad:
let rec build (rand, depth) =
match rand with
| 0 -> 
let halff = rand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))
Error: This expression has type int
       This is not a function; it cannot be applied.


let rec build (rand, depth) =
match rand with
| 0 -> 
let halff = rand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))
Error: This expression has type int
       This is not a function; it cannot be applied.


let rec build (rand, depth) =
match rand with
| 0 -> 
let halff = rand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))
Error: This expression has type int
       This is not a function; it cannot be applied.


let rec build (rand, depth) =
match depth with
| 0 -> 
let halff = rand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))
Error: This expression has type int but an expression was expected of type
         int * int -> int



hw2 build

fix:
let rec build (rand, depth) =
let rdm = rand in
match rdm with
| 0 -> buildY()
| 1 -> buildX()
| 2 -> Cosine(build(rand, depth-1)) 
| 3 -> Sine(build(rand,depth-1))
| 4 -> Average(build(rand, depth-1),build(rand,depth-1))
| 5 -> Times(build(rand, depth-1), build(rand,depth-1))
| 7 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))

bad:
let rec build (rand, depth) =
let rdm = rand in
match rdm with
| 0 -> 
let halff = rand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))
| 4 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
Error: This expression has type int
       This is not a function; it cannot be applied.


let rec build (rand, depth) =
let rdm = rand in
match rdm with
| 0 -> 
let halff = rand(0,2) in
if halff = 0 then  buildY()
else buildX()
| 1 -> 
let halff = rand(0,2) in
if halff = 0 then Cosine(build(rand, depth-1)) 
else Sine(build(rand,depth-1))
| 2 -> Average(build(rand, depth-1),build(rand,depth-1))
| 3 -> Times(build(rand, depth-1), build(rand,depth-1))
| 4 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
Error: This expression has type int
       This is not a function; it cannot be applied.



hw2 build

fix:
let rec build (rand, depth) =
let rdm = rand(0,7) in
match rdm with
| 0 -> buildY()
| 1 -> buildX()
| 2 -> Cosine(build(rand, depth-1)) 
| 3 -> Sine(build(rand,depth-1))
| 4 -> Average(build(rand, depth-1),build(rand,depth-1))
| 5 -> Times(build(rand, depth-1), build(rand,depth-1))
| 6 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))

bad:
let rec build (rand, depth) =
match rand with 
| (a,b) -> 
let rdm = rand(a,b) in
match rdm with
| 0 -> buildY()
| 1 -> buildX()
| 2 -> Cosine(build(rand, depth-1)) 
| 3 -> Sine(build(rand,depth-1))
| 4 -> Average(build(rand, depth-1),build(rand,depth-1))
| 5 -> Times(build(rand, depth-1), build(rand,depth-1))
| 6 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
Error: This expression has type 'a * 'b
       This is not a function; it cannot be applied.



hw2 build

fix:
let b = build(r,5)

bad:
let b = build(rnd,5)
Error: This expression has type int but an expression was expected of type
         int * int -> int



hw1 digitsOfInt

fix:
let rec sumList xs = match xs with
| [] -> 0
| h::t -> h + sumList t

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

let rec digitsOfInt n = if n <= 0 then [] else 1

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

bad:
let rec digitsOfInt n = match n with
| n < 0 -> []
| h::t -> h
Error: Syntax error



hw1 listReverse

fix:
let rec sumList xs = match xs with
| [] -> 0
| h::t -> h + sumList t

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

let rec listReverse l = match l with
| [] -> []
| h::t -> listReverse t @ [h]

let _ = listReverse [1; 2; 3; 4]

let _ = listReverse ["a"; "b"; "c"; "d"]

let rec digitsOfInt n =
(*if n <= 0 then []*)
n mod 10 @ [digitsOfInt n/10]

bad:
let _ = listReverse ["a"; "b"; "c"; "d"]
Error: Syntax error



hw1 listReverse

fix:
let rec digitsOfInt n =
if n <= 0 then []
else let n2 = [n mod 10] @ digitsOfInt (n/10) in
listReverse n2

bad:
let rec digitsOfInt n =
if n <= 0 then []
else let n2 = [n mod 10] @ digitsOfInt (n/10) in
listReverse n2
Error: This expression has type 'a list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

bad:
let rec digitsOfInt n =
if n <= 0 then []
else (n mod 10) :: digitsOfInt (n/10)
Error: This expression has type int list
       but an expression was expected of type int



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4]

let _ = listReverse ["a"; "b"; "c"; "d"]

bad:
let rec listReverse l = match l with
| [] -> []
| h::t -> h :: listReverse l
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 listReverse

fix:
let rec myAppend l n = match l with
| [] -> [i]
| h::t -> h :: myAppend t i

let rec sumList xs = match xs with
| [] -> 0
| h::t -> h + sumList t

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

let _ = sumList []

let _ = sumList [1]

let rec listReverse l = match l with
| [] -> []
| h::t -> myAppend (listReverse l) h

bad:
let rec listReverse l = match l with
| [] -> []
| h::t -> listReverse t :: [h]
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 palindrome

fix:
let _ = palindrome "malayalam"

let _ = palindrome "myxomatosis"

bad:
let palindrome w =
listReverse (explode w) = explode w
Error: This expression has type string but an expression was expected of type
         char list



hw2 assoc

fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| s,i -> s

bad:
let rec assoc (d,k,l) = let l match with
| [] -> d
| h::t -> let h match with
| (s*i) -> s
| d
Error: Syntax error


let rec assoc (d,k,l) = l match with
| [] -> d
| h::t -> h match with
| (s*i) -> s
| d
Error: Syntax error


let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| (s*i) -> s
| d
Characters 72-73:
  | (s*i) -> s
    ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| s,i -> s
| d
Error: Syntax error



hw2 assoc

fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
| s,i -> i

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])
Error: This expression has type string but an expression was expected of type
         int



hw2 removeDuplicates

fix:
let _ = removeDuplicates []

bad:
let _ = removeDuplicates [];
let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]
Error: Syntax error



hw2 wwhile

fix:
let rec wwhile (f,b) = match (f b) with
| (f', x') -> if x' then wwhile (f, f')
else f'

bad:
let rec wwhile (f,b) = match b with
| (f', b') -> if b' then wwhile (f, f')
else f'
Error: This expression has type 'a but an expression was expected of type
         'a * bool
       The type variable 'a occurs inside 'a * bool



hw2 wwhile

fix:
let rec wwhile (f,b) = match f,b with
| (f', bool1) -> if bool1 then wwhile (f, f')
else f'

bad:
let rec wwhile (f,b) = match me b with
| (f', bool1) -> if bool1 then wwhile (f, f')
else f'
Error: Unbound value me



hw2 wwhile

fix:
let rec wwhile (f,b) = match f b with
| (f', bool1) -> if bool1 then wwhile (f, f')
else f'

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let me x = let xx = x*x*x in (xx, xx < 100) in
wwhile (me, 2)
Error: This expression has type int -> int * bool
       but an expression was expected of type bool


let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)
Error: This expression has type int -> int * bool
       but an expression was expected of type bool



hw2 fixpoint

fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| h::t -> match h with
(s,i) -> if s = k then i
else assoc (d,k,t)

let _ = assoc (-1,"hi",[])

let _ = assoc (-1,"test",[("test",99)])

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"moose",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then seen
else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates []

let _ = removeDuplicates [1]

let _ = removeDuplicates [1;2]

let _ = removeDuplicates [1;2;1]

let _ = removeDuplicates [1;1;1;1;1;1;1;1;1;1;1]

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) = match f b with
| (b',c') -> if c' then wwhile (f,b')
else b'

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 3)

let fixpoint (f,b) = wwhile (let helper = (f b,f b != helper),b)

bad:
let fixpoint (f,b) = wwhile ((let helper = (f b,f b != helper)),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile (let helper = (f b,f b != helper),b)
Error: Syntax error: operator expected.



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let fixpoint (f,b) = wwhile (let helper = if ((f b) = b) then (f b,true) else (f b, false) in helper,b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile (let helper = if ((f b) = b) then (f b,true) else (f b, false) in helper, b)
Error: This expression has type 'a * bool
       but an expression was expected of type 'b -> 'b * bool


let fixpoint (f,b) = wwhile (let helper = if ((f b) = b) then (f b,true)
else (f b, false)
in helper,b)
Error: This expression has type 'a * bool
       but an expression was expected of type 'b -> 'b * bool


let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)
Error: This expression has type 'a * bool
       but an expression was expected of type 'b -> 'b * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((let helper b =
if b = f b then (f b, false)
else (f b, true)
in helper),b)

bad:
let f x = let xx = x*x*x in (xx, xx < 100) in
fixpoint (f, 1)
Error: Unbound value f


let _ = fixpoint (collatz, 9001)
Error: This expression has type int -> int * bool
       but an expression was expected of type int -> int
       Type int * bool is not compatible with type int 



hw2 build

fix:
let rec build (rand, depth) = if depth = 0 then
if rand(0,1) = 0 then buildX()
else buildY()
else match rand(0,6) with
|0 -> build(rand,(depth - 1))
|1 -> buildSine(build(rand,(depth - 1))) 
|2 -> buildCosine(build(rand, (depth - 1)))
|3 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))
|4 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))
|5 -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),
build(rand, (depth - 1)),build(rand, (depth - 1)))

bad:
let rec build (rand, depth) = if depth = 0 then
if rand(0,1) = 0 then buildX()
else buildY()
else match rand(0,7) with
|0 -> build(rand, (depth-1))
|1 -> buildSine(build(rand, (depth-1))) 
|2 -> buildCosine(build(rand, (depth - 1)))
|3 -> buildAverage(build(rand, (depth-1)),build(rand, (depth-1)))
|4 -> buildTimes(build(rand, (depth-1)),build(rand, (depth-1)))
|5 -> buildMax(build(rand, (depth-1)),build(rand, (depth-1)))
|6 -> buildCubic(build(rand, (depth-1)),build(rand, (depth-1)),build(rand, (depth-1)))
|7 -> buildThresh(build(rand, (depth-1)),build(rand, (depth-1)),build(rand, (depth-1)),build(rand, (depth-1)))
Characters 130-131:
  |0 -> build(rand, (depth-1)
             ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let rec build (rand, depth) = if depth = 0 then
if rand(0,1) = 0 then buildX()
else buildY()
else match rand(0,5) with
|0 -> build(rand,(depth - 1))
|1 -> buildSine(build(rand,(depth - 1))) 
|2 -> buildCosine(build(rand, (depth - 1)))
|3 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))
|4 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))
|5 -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),
build(rand, (depth - 1)),build(rand, (depth - 1)))
Error: Unbound value buildMax
Hint: Did you mean build, buildY or buildX?
Error: Unbound value buildMax
Hint: Did you mean build, buildX or buildY?
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value buildMax
Hint: Did you mean build, buildY or buildX?



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let carry = (fst x + snd x) in
match a with
| h::t -> ((h+carry)/10)::((h+carry) mod 10)::t
| _ -> (carry/10)::[carry mod 10]
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let carry = (fst x + snd x) in
match a with
| h::t -> ((h+carry)/10)::((h+c) mod 10)::t
| _ -> (carry/10)::[carry mod 10]
in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value c



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match (a,x) with
| ((o,sum),[])	      -> (0,sum)
| ((o,sum),(b,c)::l') -> let d = (b + c + o) in
if d

let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match (a,x) with
| ((o,sum),[])	      -> (0,sum)
| ((o,sum),(b,c)::l') -> let d = (b + c + o) in
if d < 10 then (0, d::sum)
else (1, (d-10)::sum)
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type ('a * 'b) list
       but an expression was expected of type (int * int) list list
       Type 'a * 'b is not compatible with type (int * int) list 



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let carry = match a with (x,y) -> x in
match x with (d1,d2) -> let new_carry = (carry + d1 + d2)/10 in
let digit = (carry + d1 + d2) mod 10 in
match a with (x,y) -> (new_carry, digit::y) in
let base = (0, []) in
let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (*let carry = match a with (x,y) -> x in*)
match x with (d1,d2) -> let new_carry = (a + d1 + d2)/10 in
let digit = (a + d1 + d2) mod 10 in
match a with (x,y) -> (new_carry, digit::y) in
let base = (0, []) in
let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This pattern matches values of type 'a * 'b
       but a pattern was expected which matches values of type int


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let carry = match a with (x,y) -> x in
match x with (d1,d2) -> let new_carry = (a + d1 + d2)/10 in
let digit = (a + d1 + d2) mod 10 in
match a with (x,y) -> (new_carry, digit::y) in
let base = (0, []) in
let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type int



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let c = match a with
| ((d1,d2),sum) -> let c' = (c + d1 + d2)/10 in
let sum = (c + d1 + d2) mod 10 in
match a with (pair,sum) -> (c', digit::sum) in
let base = (0, []) in
let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let c = match a with
| ((d1,d2),sum) -> let c' = (c + d1 + d2)/10 in
let sum = (c + d1 + d2) mod 10 in
match a with (pair,sum) -> (c', digit::sum) in
let base = (0, []) in
let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let c = match a with
| ((d1,d2),sum) -> let c' = (c + d1 + d2)/10 in
let sum = (c + d1 + d2) mod 10 in
match a with (pair,sum) -> (c', digit::sum) in
let base = (0, []) in
let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let c = match a with
| ((d1,d2),sum) -> let c' = (c + d1 + d2)/10 in
let sum = (c + d1 + d2) mod 10 in
match a with (pair,sum) -> (c', digit::sum) in
let base = (0, []) in
let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let c = match a with (pair,sum) -> pair in
match x with (d1,d2) -> let c' = (c + d1 + d2)/10 in
let digit = (c + d1 + d2) mod 10 in
match a with (pair,sum) -> (c', digit::sum) in
let base = (0, []) in
let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let c = match a with (pair,sum) -> pair in
match a with ((d1,d2),sum) -> let c' = (c + d1 + d2)/10 in
let sum = (c + d1 + d2) mod 10 in
match a with (pair,sum) -> (c', digit::sum) in
let base = (0, []) in
let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type int


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let c = match a with (pair,sum) -> pair in
match pair with (d1,d2) -> let c' = (c + d1 + d2)/10 in
let digit = (c + d1 + d2) mod 10 in
match a with (pair,sum) -> (c', digit::sum) in
let base = (0, []) in
let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value pair



hw3 mulByDigit

fix:
let rec mulByDigit i l = 
if i = 1 then l
else if i = 0 then []
else if i < 0 then match (bigAdd (bigAdd l l) (mulByDigit ( (i*(-1)) -2) l)) with
| h::t -> (h*(-1))::t
| _ -> []
else bigAdd (bigAdd l l) (mulByDigit (i-2) l)

let _ = mulByDigit 9 [9;9;9;9]

let _ = mulByDigit (-9) [9;9;9;9]

bad:
let rec mulByDigit i l = 
if i = 1 then l
else if i = 0 then []
else if i < 0 then match (bigAdd (bigAdd l l) (mulByDigit ( (i*(-1)) -2) l)) with
| h::t -> (h*(-1))::t
| _ -> 0
else bigAdd (bigAdd l l) (mulByDigit (i-2) l)
Error: This expression has type int but an expression was expected of type
         int list



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = match a with
(c,sum) -> (c + 1, bigAdd ((mulByDigit x l1) @ clone 0 c) sum) in
let base = (0, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = match a with
(c,sum) -> (c + 1, bigAdd ((mulByDigit x l1) @ clone 0 c) sum) in
let base = failwith (0, []) in
let args = failwith l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a * 'b
       but an expression was expected of type string
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type 'a * 'b
       but an expression was expected of type string



hw3 ???

fix:
let foo = List.map incr [9]

bad:
let foo = List.map [incr] 9
Error: This expression has type 'a list
       but an expression was expected of type 'b -> 'c


let foo = List.map incr 9
Error: This expression has type int but an expression was expected of type
         int list



hw3 ???

fix:
let foo = (List.map incr [9])@(List.map decr [10])

bad:
let foo = List.map incr [9]::List.map decr [10]
Error: This expression has type int list
       but an expression was expected of type int list list
       Type int is not compatible with type int list 


let foo = (List.map incr [9])::(List.map decr [10])
Error: This expression has type int list
       but an expression was expected of type int list list
       Type int is not compatible with type int list 


let foo = (List.map incr 9)::(List.map decr [10])
Error: This expression has type int but an expression was expected of type
         int list


let foo = (List.map incr [9])::(List.map decr [10])
Error: This expression has type int list
       but an expression was expected of type int list list
       Type int is not compatible with type int list 



hw3 ???

fix:
let [f1;f2] = foo [(=);(<)] 2

bad:
let [f1;f2] = a[[ [(=);(<)] 2
Error: Syntax error


let [f1;f2] = a[[ [(=);(<)] 2
Error: Syntax error


let [f1;f2] = app [(=);(<)] 2
Error: Unbound value app



hw3 ???

fix:
let [f1;f2] = foo [(=);(<)] 2

f1 1

bad:
let [f1;f2] = foo [(=);(<)] 2
f1 1
Error: This function has type ('a -> 'b) list -> 'a -> 'b list
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n < 0 then []
else [1;2;3]

bad:
let rec digitsOfInt n = 
if n < 0 then -> 4
Error: Syntax error


let _ = digitsOfInt -3124
Error: This expression has type 'a -> 'b
       but an expression was expected of type int


let rec digitsOfInt n = 
if n < 0 then 4
Error: This expression has type int but an expression was expected of type
         unit


let rec digitsOfInt n = 
if n < 0 then []
Error: This variant expression is expected to have type unit
       The constructor [] does not belong to type unit


let rec digitsOfInt n = 
if n < 0 then 0
Error: This expression has type int but an expression was expected of type
         unit


let rec digitsOfInt n = 
if n < 0 then _
Error: Syntax error


let rec digitsOfInt n = 
if n < 0 then 'a
Error: Syntax error


let rec digitsOfInt n = 
if n < 0 then '
Error: Syntax error


let rec digitsOfInt n = 
if n < 0 then n
Error: This expression has type int but an expression was expected of type
         unit


let rec digitsOfInt n = 
if n < 0 then []
else n
Error: This expression has type int but an expression was expected of type
         'a list



hw1 digitsOfInt

fix:
let _ = digitsOfInt 3124

bad:
let _ = digitsOfInt -3124
Error: This expression has type int -> int list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n < 0 then []
else 
let f elem =

open Printf
Printf.printf "Element is %d\n" elem in
List.iter f n

let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n < 0 then []
else 
let f elem = 
Printf.printf "Element is %d\n" elem in
List.iter f n
Error: This expression has type int but an expression was expected of type
         int list



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n < 0 then []
else 
let rec loop n acc =
if n = 0 then acc
else loop (n/10) (n mod 10::acc) in
match n with
| _ -> loop n []

bad:
let rec digitsOfInt n = 
if n < 0 then []
else 
let f elem = 
Printf.printf "Element is %d\n" elem in
List.iter f n
Error: This expression has type int but an expression was expected of type
         int list



hw1 additivePersistence

fix:
let rec additivePersistence n = 
if n mod 10  != 0 then 
x = x + 1

let total += sumList (digitsOfInt (abs n) )
else x

let _ = additivePersistence 9876

bad:
let rec additivePersistence n =
let x = 0
if n mod 10  != 0 then 
x = x + 1
Error: Syntax error



hw1 additivePersistence

fix:
let rec additivePersistence n = 
let rec loop retVal = 
if retVal < 10 then retVal
else loop sumList(digitsOfInt retVal ) 
| 0 -> 0
| _ -> loop retVal

let _ = additivePersistence 9876

bad:
let rec additivePersistence n = 
let x = 0
if n mod 10  != 0 then 
x = x + 1
Error: Syntax error


let total += sumList (digitsOfInt (abs n) )
else x
Error: Syntax error


let rec additivePersistence n = 
if n mod 10  != 0 then 
let x = 0
Error: Syntax error


let total += sumList (digitsOfInt (abs n) )
x = x + 1
else x
Error: Syntax error


let rec additivePersistence n = 
if n mod 10  != 0 then 
let x = 0
Error: Syntax error


let rec additivePersistence n = 
if n mod 10  != 0 then 
let x = 0 in
let total += sumList (digitsOfInt (abs n) )
x = x + 1
else x
Error: Syntax error


let rec additivePersistence n = 
if n mod 10  != 0 then 
let x = 0 in
let total = sumList (digitsOfInt (abs n) )
x = x + 1
else x
Error: Syntax error



hw1 additivePersistence

fix:
let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
let addP = addP + 1 in
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n

bad:
let rec additivePersistence n = 
let rec addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
addP = addP + 1
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n
Error: This expression has type int
       This is not a function; it cannot be applied.


let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
addP = addP + 1
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n
Error: This expression has type int
       This is not a function; it cannot be applied.


let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
incr addP
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n
Error: This function has type int ref -> unit
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 additivePersistence

fix:
let rec additivePersistence n = 
let rec addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n

bad:
let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
let addP = addP + 1 in
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n
| addP
Error: Syntax error



hw1 additivePersistence

fix:
let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
let addP = addP + 1 in
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n

bad:
let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
addP -> addP + 1
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n
Error: Syntax error


let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
let addP = addP + 1
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n
Error: Syntax error



hw1 additivePersistence

fix:
let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
let addP = addP + 1 in
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n

bad:
let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
addP = addP + 1 in
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n
Error: This expression has type bool but an expression was expected of type
         int


let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
addP + 1 in
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n
Error: Unbound value retVal


let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal = 
if retVal < 10 then addP
else 
addP + 1
recursive_loop (sumList(digitsOfInt retVal )) in match n with
| 0 -> 0
| _ -> recursive_loop n
Error: This expression has type int
       This is not a function; it cannot be applied.



hw1 additivePersistence

fix:
let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal addP = 
if retVal < 10 then addP
else 
let addP = addP + 1 in
recursive_loop (sumList(digitsOfInt retVal )) addP in match n with
| 0 -> 0
| _ -> recursive_loop n addP

let _ = additivePersistence 9876

bad:
let rec additivePersistence n = 
let addP = 0 in
let rec recursive_loop retVal addP = 
if retVal < 10 then addP
else 
let addP = addP + 1 in
recursive_loop (sumList(digitsOfInt retVal )) addP in match n with
| 0 -> 0
| _ -> recursive_loop n
Error: This expression has type int -> int
       but an expression was expected of type int



hw1 listReverse

fix:
let rec listReverse l = 
let rec aux acc = function
| [] -> acc
| h::t -> aux (h::acc) t in
aux [] l

bad:
let rec listReverse l = 
let rev l =
let rec aux acc = function
| [] -> acc
| h::t -> aux (h::acc) t in
aux [] l
Error: Syntax error


let rec listReverse l = 
let rev l =
let rec aux acc = 
| [] -> acc
| h::t -> aux (h::acc) t in
aux [] l
Error: Syntax error



hw1 palindrome

fix:
let palindrome w =
let reverse = listReverse w in
if reverse = w then true
else false

bad:
let _ = palindrome "malayalam"
Error: This expression has type string but an expression was expected of type
         'a list



hw1 palindrome

fix:
let palindrome w =
let pk = explode w in
let reverse = listReverse (explode w) in
if reverse = pk then true
else false

bad:
let _ = palindrome "malayalam"
Error: This expression has type string but an expression was expected of type
         'a list


let palindrome w =
let reverse = explode (listReverse w) in
if reverse = w then true
else false
Error: This expression has type 'a list
       but an expression was expected of type string


let palindrome w =
let reverse = listReverse (explode w) in
if reverse = w then true
else false
Error: This expression has type string but an expression was expected of type
         char list


let palindrome w =
let pk = explode w in
let reverse = listReverse (explode w) in
if reverse = w then true
else false
Error: This expression has type string but an expression was expected of type
         char list



hw2 assoc

fix:
let rec assoc (d,k,l) = match l with
| [] -> d
| (num,name)::tail ->
if num = k then name
else assoc(d, k, tail)

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])
Error: This expression has type string but an expression was expected of type
         'a list



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = seen in
if List.mem h seen' then h::seen 
else 
(* If the head is NOT in the list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = h in
if List.mem h l then h::seen'
Error: Syntax error


let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: Syntax error


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = h in
if List.mem h l then h::seen'
Error: Syntax error


let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: Syntax error


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = h in
if List.mem h l then h::seen'
Error: Syntax error


let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: Syntax error


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = h in
if List.mem h l then h::seen' 
else 
(* If the head is NOT in the list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This expression has type 'a but an expression was expected of type
         'a list
       The type variable 'a occurs inside 'a list



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = l in
if List.mem h l then h::seen' 
else 
(* If the head is NOT in the list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = h in
if List.mem h seen then h::seen' 
else 
(* If the head is NOT in the list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This expression has type 'a but an expression was expected of type
         'a list
       The type variable 'a occurs inside 'a list



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t ->
(* Seen' should hold only the unique ones *)
let seen' =  
if List.mem h seen = false then h::seen
else seen
in
(* If the head is NOT in hte list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = l in 
if List.mem h seen then h::seen'
Error: Syntax error


let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: Syntax error


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = 
if List.mem h seen then h::seen'
Error: Syntax error


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = l in
if List.mem h seen' then h::seen
Error: Syntax error


let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: Syntax error


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = l in
if List.mem h l then h::seen
Error: Syntax error


let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: Syntax error


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = l in
if List.mem h l then h::seen'
Error: Syntax error


let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: Syntax error


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = l in
if List.mem h seen' then h::seen
else seen
Error: Syntax error


let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: Syntax error


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
(* Seen' should hold only the unique ones *)
let seen' = l in
if List.mem h seen' then h::seen
else h::seen
Error: Syntax error


let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: Syntax error


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t ->
(* Seen' should hold only the unique ones *)
let seen' =  
if List.mem h seen = false then h::seen
in
(* If the head is NOT in hte list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = failwith "to be written" in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This variant expression is expected to have type unit
       The constructor :: does not belong to type unit



hw2 wwhile

fix:
let rec wwhile (f,b) = match (f,b) with
| (func, param) ->
if param = true then func param 
else param
| _ -> b

bad:
let rec wwhile (f,b) = match (f,b) with
| (func, param) ->
if param = true then func param 
else num
| _ -> 0
Error: Unbound value num


let rec wwhile (f,b) = match (f,b) with
| (func, param) ->
if param = true then func param 
else num
| _ -> b
Error: Unbound value num



hw2 wwhile

fix:
let rec wwhile (f,b) = match (f,b) with
| (func, param) ->
if param = true then f param 
else 0

bad:
let rec wwhile (f,b) = match (f,b) with
| (func, param) ->
if param = true then f param 
else 0
| _ -> b
Error: This expression has type bool but an expression was expected of type
         int



hw2 wwhile

fix:
let rec wwhile (f,b) = match b with
| (e, boo) ->
if boo = true then e

bad:
let rec wwhile (f,b) = match b with
| (e, boo) ->
if boo = true then e
else wwhile f e
Error: This expression has type 'a but an expression was expected of type
         'a * (('b -> 'c) * bool)
       The type variable 'a occurs inside 'a * (('b -> 'c) * bool)


let rec wwhile (f,b) = match b with
| (e, boo) ->
if boo = true then e
else wwhile e b
Error: This expression has type 'a -> 'b
       but an expression was expected of type 'c * (('a -> 'b) * bool)


let rec wwhile (f,b) = match b with
| (e, boo) ->
if boo = true then e
else wwhile b
Error: This expression has type 'a * bool
       but an expression was expected of type 'b * ('a * bool)


let rec wwhile (f,b) = match b with
| (e, boo) ->
if boo = true then e
else wwhile f b
Error: This expression has type 'a but an expression was expected of type
         'a * (('b -> 'c) * bool)
       The type variable 'a occurs inside 'a * (('b -> 'c) * bool)



hw2 expr

fix:
let rec wwhile (f,b) = match b with
| (express, boo) ->
if boo = true then wwhile(express, b)
else express

bad:
let rec wwhile (f,b) = match b with
| (express, boo) ->
if boo = true then wwhile(f, express)
else express
Error: This expression has type 'a but an expression was expected of type
         'a * bool
       The type variable 'a occurs inside 'a * bool



hw2 wwhile

fix:
let rec wwhile (f,b) = 
let ans = f b in
match ans with
| (num, boo) ->
if boo = true then wwhile(f, num)
else num

bad:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)
Error: This expression has type int but an expression was expected of type
         (int -> int * bool) * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = 
wwhile 
((let func p = 
let cal = f p in 
if p == cal then (cal, false)
else (cal, true) in func
),b)

bad:
let fixpoint (f,b) = 
wwhile 
((let func p = 
let cal = f p in 
if p == cal then (cal, false)
else (cal, true) in xx
),b)
Error: Unbound value xx



hw2 exprToString

fix:
let rec exprToString e = match e with
| VarX -> "X"
| VarY -> "Y"
| Sine sin  -> "( sin "
| Cosine cos -> "cos"
| Average (n1, n2) ->  "( " ^ (exprToString n1) ^ "+" ^ (exprToString n2) ^ ")/2"
| Times (t1, t2) -> "(t1 * t2)"
| Thresh (th1, th2, th3, th4) -> "bullshit"

bad:
let rec exprToString e = match e with
| VarX -> "X"
| VarY -> "Y"
| Sine sin  -> "( sin "
| Cosine cos -> "cos"
| Average (n1, n2) ->  "( " ^ (exprToString n1) ^ "+" ^ (exprToString n2) ^ ")/2"
| Times (t1, t2) -> "(t1 * t2)"
| Thresh (th1, th2, th3, th4) ->
Error: Syntax error



hw2 exprToString

fix:
let rec exprToString e = match e with
VarX -> "x"
| VarY -> "y"
| Sine sin  -> "(sin(pi*" ^ (exprToString sin) ^ ")"  
| Cosine cos -> "(cos(pi*" ^ (exprToString cos) ^ ")"
| Average (n1, n2) ->  "( " ^ (exprToString n1) ^ "+" ^ (exprToString n2) ^ ")/2"
| Times (t1, t2) -> "(" ^ (exprToString t1) ^ "*" ^ (exprToString t2) ^ ")"
| Thresh (th1, th2, th3, th4) -> "bullshit"

bad:
let rec exprToString e = match e with
VarX -> "x"
| VarY -> "y"
| Sine sin  -> "(sin(pi*" ^ (exprToString sin) ^ ")"  
| Cosine cos -> "(cos(pi*" ^ (exprToString cos) ^ ")"
| Average (n1, n2) ->  "( " ^ (exprToString n1) ^ "+" ^ (exprToString n2) ^ ")/2"
| Times (t1, t2) -> "(" ^ (exprToString t1) ^ "*" (exprToString t2) ^ ")"
| Thresh (th1, th2, th3, th4) -> "bullshit"
Error: This expression has type string
       This is not a function; it cannot be applied.



hw2 exprToString

fix:
let rec assoc (d,k,l) = match l with
(* If list is empty, then return the first int *)
| [] -> d
(* If it is of this pattern, check if the number is equal to the tuple's number *)
| (name,num)::tail ->
(* If it is, return the number; else recursively call with remainder *)
if name = k then num
else assoc(d, k, tail)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t ->
(* Seen' should hold only the unique ones *)
let seen' =  
if List.mem h seen = false then h::seen
else seen
in
(* If the head is NOT in hte list, put it there, else recurse on rest of it *)
(* Rest' holds the duplicates *)
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) = 
(* Save the function and parameter into an expression *)
(*let ans = f b in
match ans with
| (num, tf) ->
(* If boolean is true, then loop again on new value *)
if tf = true then wwhile(f, num)
(* Otherwise, return old value *)
else num;;*)
let (p,k) = f(b) in
if k then wwhile(f, p) else p

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) = 
wwhile 
((let func b = 
(* Save the return value of the function to compare with b *)
let ans = f b in 
(* If it's equal, say false to quit, else keep going *)
if b = ans then (ans, false)
else (ans, true) in func
),b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

type expr = 
VarX
| VarY
| Sine     of expr
| Cosine   of expr
| Average  of expr * expr
| Times    of expr * expr
| Thresh   of expr * expr * expr * expr	
| DivAdd   of expr * expr * expr * expr
| TriMult  of expr * expr * expr

let rec exprToString e = match e with
VarX -> "x"
| VarY -> "y"
| Sine sin  -> "sin(pi*" ^ (exprToString sin) ^ ")"  
| Cosine cos -> "cos(pi*" ^ (exprToString cos) ^ ")"
| Average (n1, n2) ->  "((" ^ (exprToString n1) ^ "+" ^ (exprToString n2) ^ ")/2)"
| Times (t1, t2) -> (exprToString t1) ^ "*" ^ (exprToString t2) 
| Thresh (th1, th2, th3, th4) -> "(" ^ (exprToString th1) ^ "<" ^ 
(exprToString th2) ^ "?" ^ (exprToString th3) ^ 
":" ^ (exprToString th4) ^ ")"
| DivAdd (ds1, ds2, ds3, ds4) -> "((" ^ (exprToString ds1) ^ "+" ^
(exprToString ds2) ^ ") / (" ^ (exprToString ds3) ^
"+" ^ (exprToString ds4) ^ "))"
| TriMult (tm1, tm2, tm3) -> "(" ^ (exprToString tm1) ^ "*" ^ (exprToString tm2) ^
"*" (exprToString tm3) ^ ")"

bad:
let rec exprToString e = match e with
VarX -> "x"
| VarY -> "y"
| Sine sin  -> "sin(pi*" ^ (exprToString sin) ^ ")"  
| Cosine cos -> "cos(pi*" ^ (exprToString cos) ^ ")"
| Average (n1, n2) ->  "((" ^ (exprToString n1) ^ "+" ^ (exprToString n2) ^ ")/2)"
| Times (t1, t2) -> (exprToString t1) ^ "*" ^ (exprToString t2) 
| Thresh (th1, th2, th3, th4) -> "(" ^ (exprToString th1) ^ "<" ^ 
(exprToString th2) ^ "?" ^ (exprToString th3) ^ 
":" ^ (exprToString th4) ^ ")"
| DivAdd (ds1, ds2, ds3, ds4) -> "((" ^ (exprToString ds1) ^ "+" ^
(exprToString ds2) ^ ") / (" ^ (exprToString ds3) ^
"+" ^ (exprToString ds4) "))"
| TriMult (tm1, tm2, tm3) -> "(" ^ (exprToString tm1) ^ "*" ^ (exprToString tm2) ^
"*" (exprToString tm3) ^ ")"
Error: This expression has type string
       This is not a function; it cannot be applied.



hw3 pipe

fix:
let pipe fs = 
let f a x = x a  in
let base = f  in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a  in
let base = f x a in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = x a  in
let base = f a in
List.fold_left f base fs
Error: Unbound value a



hw3 pipe

fix:
let pipe fs = 
let f a x = x a  in
let base =  3 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a  in
let base = a  in
List.fold_left f base fs
Error: Unbound value a



hw3 pipe

fix:
let pipe fs = 
let f a x = x a  in
let base =  f 3 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a  in
let base =  x 3 in
List.fold_left f base fs
Error: Unbound value x



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = 3  in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a  in
let base =  fs 3 in
List.fold_left f base fs
Error: This expression has type int -> 'a
       but an expression was expected of type ('a -> 'a) list


let pipe fs = 
let f a x = x in
let base =  f (x a) in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = x in
let base =  f ((f a x) a) in
List.fold_left f base fs
Error: Unbound value a


let pipe fs = 
let f a x = x in
let base =  f base in
List.fold_left f base fs
Error: Unbound value base


let pipe fs = 
let f a x = f x in
let base = 3  in
List.fold_left f base fs
Error: Unbound value f


let pipe fs = 
let f a x = fs x in
let base = 3  in
List.fold_left f base fs
Error: This expression has type 'a -> int
       but an expression was expected of type 'a list



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = f  in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = x  in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = x a in
let base = a  in
List.fold_left f base fs
Error: Unbound value a



hw3 pipe

fix:
let pipe fs = 
let f a x = a in
let base = f  in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = f  in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
match fs with 
| [] -> 0
| f::fs' -> 
let f a x = x a in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
match fs with 
| [] -> base
| f::fs' -> 
let f a x = x a in
let base = a in
List.fold_left f base fs
Error: Unbound value base


let pipe fs = 
match fs with 
| [] -> 0
| f::fs' -> 
let f a x = x a in
let base = a in
List.fold_left f base fs
Error: Unbound value a



hw3 pipe

fix:
let sqsum xs = 
let f a x = failwith "to be implemented" in
let base = failwith "to be implemented" in
List.fold_left f base xs

let pipe fs = 
let f a x = f x  in
let base = 3 in
List.fold_left f base fs

bad:
let pipe fs = 
match fs with 
| [] -> 0
| f::fs' -> 
let f a x = x a in
let base = f 0 in
List.fold_left f base fs
Error: This expression has type (int -> 'a) -> 'a
       but an expression was expected of type int


let pipe fs = 
match fs with 
| [] -> 0
| f::fs' -> 
let f a x = x a in
let base = f a in
List.fold_left f base fs
Error: Unbound value a


let pipe fs = 
match fs with 
| [] -> 0
| f::fs' -> 
let f a x = x a in
let base = f x in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
match fs with 
| [] -> 0
| f::fs' -> 
let f a x = x a in
let base = f in
List.fold_left f base fs
Error: This expression has type 'a -> ('a -> 'b) -> 'b
       but an expression was expected of type int


let pipe fs = 
match fs with 
| [] -> 0
| f::fs' -> 
let f a x = x a in
let base = fs' in
List.fold_left f base fs
Error: This expression has type 'a list
       but an expression was expected of type ('a list -> 'a list) list
       The type variable 'a occurs inside 'a list -> 'a list


let pipe fs = 
match fs with 
| [] -> 0
| f::fs' -> 
let f a x = x a in
let base = fs' in
List.fold_left f base fs
Error: This expression has type 'a list
       but an expression was expected of type ('a list -> 'a list) list
       The type variable 'a occurs inside 'a list -> 'a list



hw3 pipe

fix:
let pipe fs =
let f a x = x a in
let base = f in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = x a in
let base = f(x,a) in
List.fold_left f base fs
Error: Unbound value x


let pipe fs =
let f a x = x a in
let base = f a in
List.fold_left f base fs
Error: Unbound value a



hw3 pipe

fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs =
let f a x = fun p -> x (a p) in
let base =  fun b -> x in
List.fold_left f base fs

bad:
let pipe fs =
let f a x = x a in
let base = f (x a) in
List.fold_left f base fs
Error: Unbound value x


let pipe fs =
let f a x = x a in
let base = _ in
List.fold_left f base fs
Error: Syntax error



hw3 stringOfList

fix:
let stringOfList f l = 
List.map sepConcat l

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: This expression has type int -> string
       but an expression was expected of type string


let stringOfList f l = 
List.map (sepConcat f l) l
Error: This expression has type string but an expression was expected of type
         'a -> 'b



hw3 stringOfList

fix:
let stringOfList f l = 
List.map (sepConcat "") l

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: This expression has type int but an expression was expected of type
         string



hw3 stringOfList

fix:
let stringOfList f l = 
List.map (sepConcat (f "")) l

bad:
let stringOfList f l = 
List.map (sepConcat fun y -> f "") l
Error: Syntax error: operator expected.



hw3 stringOfList

fix:
let stringOfList f l = 
List.map ( sepConcat (f l) ) l

bad:
let stringOfList f l = 
List.map (( sepConcat "" ) l) l
Error: This expression has type string but an expression was expected of type
         'a -> 'b


let stringOfList f l = 
List.map f (( sepConcat "" ) l)
Error: This expression has type string but an expression was expected of type
         'a list



hw3 stringOfList

fix:
let stringOfList f l = 
List.map ( sepConcat (f) ) l

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: This expression has type int -> string
       but an expression was expected of type string list list -> string
       Type int is not compatible with type string list list 



hw3 stringOfList

fix:
let stringOfList f l = 
List.map (sepConcat f) l

bad:
let stringOfList f l = 
List.map (sepConcat f) (f l)
Error: This expression has type string
       This is not a function; it cannot be applied.


let stringOfList f l = 
List.map (sepConcat f) (f l)
Error: This expression has type string
       This is not a function; it cannot be applied.



hw3 stringOfList

fix:
let stringOfList f l = 
List.map (sepConcat f) l

bad:
let stringOfList f l = 
List.map (sepConcat ("" l)) l
Error: This expression has type string
       This is not a function; it cannot be applied.


let stringOfList f l = 
List.map (sepConcat "" l) l
Error: This expression has type string but an expression was expected of type
         'a -> 'b


let stringOfList f l = 
List.map (sepConcat f l) l
Error: This expression has type string but an expression was expected of type
         'a -> 'b



hw3 stringOfList

fix:
let stringOfList f l = 
"[" ^ sepConcat ";" (List.map f l) ^ "]"

bad:
let stringOfList f l = 
List.map f (sepConcat f l)
Error: This expression has type 'a -> 'b
       but an expression was expected of type string


let stringOfList f l = 
List.map f (sepConcat l)
Error: This expression has type string list -> string
       but an expression was expected of type 'a list


let stringOfList f l = 
(sepConcat "" l) List.map (f l)
Error: This expression has type string
       This is not a function; it cannot be applied.


let stringOfList f l = 
(sepConcat List.map (f l) l)
Error: This function has type string -> string list -> string
       It is applied to too many arguments; maybe you forgot a `;'.


let stringOfList f l = 
(sepConcat (List.map (f l)) l)
Error: This expression has type 'a list -> 'b list
       but an expression was expected of type string


let stringOfList f l = 
"[" ^ sepConcat ";" ^ List.map(f l) ^ "]"
Error: This expression has type string list -> string
       but an expression was expected of type string


let stringOfList f l = 
"[" ^ sepConcat ";" List.map(f l) ^ "]"
Error: This function has type string -> string list -> string
       It is applied to too many arguments; maybe you forgot a `;'.


let stringOfList f l = 
"[" ^ sepConcat ";" List.map(f l) ^ "]"
Error: This function has type string -> string list -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 clone

fix:
let rec clone x n = match n with 
| 0 -> []
| n -> x@clone x (n-1)

bad:
let rec clone x n = match n with 
| 0 -> []
| _ -> clone x::[] (n-1)
Error: This expression has type int -> 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside int -> 'a list



hw3 clone

fix:
let rec clone x n = 
if n <= 0 then []
else [x]@clone x (n-1)

bad:
let rec clone x n = match n with 
if n <= 0 then []
else [x]@clone x (n-1)
Error: Syntax error



hw3 padZero

fix:
let sqsum xs = 
(* Add 'a' to the square of x *)
let f a x = a + x*x in
(* List of numbers, so base must be 0 *)
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs =
(* Call a function p that returns the function x in fs. Called on the 'a' value *)
let f a x = fun p -> x (a p) in
(* Save base into a function that simply returns the parameter *)
let base =  fun b -> b in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
(* Concatenate the first element with the separator and x *)
let f a x = a ^ sep ^ x in
(* base element be the head *)
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello";]

let stringOfList f l = 
"[" ^ sepConcat "; " (List.map f l) ^ "]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n = 
if n <= 0 then []
else [x]@clone x (n-1)

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let padZero l1 l2 = 
if List.length l1 = List.length l2 then (l1, l2)

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2 then (l1, l2)
Error: This expression has type 'a * 'b
       but an expression was expected of type unit



hw3 padZero

fix:
let sqsum xs = 
(* Add 'a' to the square of x *)
let f a x = a + x*x in
(* List of numbers, so base must be 0 *)
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs =
(* Call a function p that returns the function x in fs. Called on the 'a' value *)
let f a x = fun p -> x (a p) in
(* Save base into a function that simply returns the parameter *)
let base =  fun b -> b in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
(* Concatenate the first element with the separator and x *)
let f a x = a ^ sep ^ x in
(* base element be the head *)
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello";]

let stringOfList f l = 
"[" ^ sepConcat "; " (List.map f l) ^ "]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n = 
if n <= 0 then []
else [x]@clone x (n-1)

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let padZero l1 l2 = 
if List.length l1 = List.length l2 then (l1, l2)

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2 then List.combine (l1, l2)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let padZero l1 l2 = 
if List.length l1 = List.length l2 then List.combine l1 l2
Error: This expression has type ('a * 'b) list
       but an expression was expected of type unit


let padZero l1 l2 = 
if List.length l1 = List.length l2 then l1 l2
Error: This expression has type 'a list
       This is not a function; it cannot be applied.


let padZero l1 l2 = 
if List.length l1 = List.length l2 then (l1, l2)
Error: This expression has type 'a * 'b
       but an expression was expected of type unit



hw3 padZero

fix:
let sqsum xs = 
(* Add 'a' to the square of x *)
let f a x = a + x*x in
(* List of numbers, so base must be 0 *)
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs =
(* Call a function p that returns the function x in fs. Called on the 'a' value *)
let f a x = fun p -> x (a p) in
(* Save base into a function that simply returns the parameter *)
let base =  fun b -> b in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
(* Concatenate the first element with the separator and x *)
let f a x = a ^ sep ^ x in
(* base element be the head *)
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello";]

let stringOfList f l = 
"[" ^ sepConcat "; " (List.map f l) ^ "]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n = 
if n <= 0 then []
else [x]@clone x (n-1)

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let padZero l1 l2 = 
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then ([0]@l1, l2)

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then padZero(0::l1 l2)
Error: This expression has type 'a list
       This is not a function; it cannot be applied.


let padZero l1 l2 = 
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then padZero((0::l1) l2)
Error: This expression has type int list
       This is not a function; it cannot be applied.


let rec padZero l1 l2 = 
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then padZero((0::l1) l2)
Error: This expression has type int list
       This is not a function; it cannot be applied.


let padZero l1 l2 = 
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then 0::l1
Error: This variant expression is expected to have type unit
       The constructor :: does not belong to type unit


let padZero l1 l2 = 
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then (0::l1, l2)
Error: This expression has type 'a * 'b
       but an expression was expected of type unit



hw3 padZero

fix:
let padZero l1 l2 = 
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then (l1, l2)
else (l1, l2)

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then (0::l1, l2)
Error: This expression has type 'a * 'b
       but an expression was expected of type unit


let padZero l1 l2 = 
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then (List.append [0] l1, l2)
Error: This expression has type 'a * 'b
       but an expression was expected of type unit


let padZero l1 l2 = 
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then (l1, l2)
Error: This expression has type 'a * 'b
       but an expression was expected of type unit



hw3 padZero

fix:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then (l1, 0::l2)
else if List.length l1 < List.length l2 then (0::l1, l2)
else (l1, l2)

bad:
let padZero l1 l2 = 
if List.length l1 = List.length l2 then (l1, l2)
else if List.length l1 < List.length l2 then (0::l1, 0::l2)
else (l1::[], l2::[])
Error: This expression has type int list
       but an expression was expected of type int


let padZero l1 l2 = 
if List.length l1 > List.length l2 then (l1, l2::0)
else if List.length l1 < List.length l2 then (0::l1, l2)
else (l1, l2)
Error: This expression has type int but an expression was expected of type
         'a list list



hw3 padZero

fix:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
(* L1 is greater, so append 0's to l2 *)
(l1, List.append (clone 0 l1G) l2) 
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l1 in 
(List.append (clone 0 l2G) l1, l2)
else (l1, l2)

bad:
let padZero l1 l2 = 
if List.length l1 > List.length l2 then clone (l1, 0::l2)
else if List.length l1 < List.length l2 then clone (0::l1, l2)
else (l1, l2)
Error: This expression has type 'a * 'b
       but an expression was expected of type
         int -> (int list * int list) list


let padZero l1 l2 = 
if List.length l1 > List.length l2 then clone (l1, 0::l2) ,
else if List.length l1 < List.length l2 then clone (0::l1, l2)
else (l1, l2)
Error: Syntax error


let padZero l1 l2 = 
if List.length l1 > List.length l2 then List.combine(l1, clone(0::l2) 
else if List.length l1 < List.length l2 then clone (0::l1, l2)
else (l1, l2)
Characters 73-74:
  if List.length l1 > List.length l2 then List.combine(l1, clone(0::l2) 
                                                      ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let padZero l1 l2 = 
if List.length l1 > List.length l2 then List.append(l1, clone(0::l2) 
else if List.length l1 < List.length l2 then List.append (0::l1, l2)
else (l1, l2)
Characters 72-73:
  if List.length l1 > List.length l2 then List.append(l1, clone(0::l2) 
                                                     ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
List.append(l1, clone(0 l2) )
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l2 in 
then List.append (0::l1, l2)
else (l1, l2)
Error: Syntax error


let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
List.append(l1, clone(l1, l2) )
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l2 in 
then List.append (clone (l1 l2G), l2)
else (l1, l2)
Error: Syntax error


let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
List.append(l1, clone(l1, l2) )
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l2 in 
List.append (clone (l1 l2G), l2)
else (l1, l2)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
List.append(l1, clone(0, l1G) )
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l2 in 
List.append (clone (0 l2G), l2)
else (l1, l2)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
List.append(l1, clone(0  l1G) )
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l2 in 
List.append (clone (0 l2G), l2)
else (l1, l2)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
List.append(l1 clone(0  l1G) )
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l2 in 
List.append (clone (0 l2G) l2)
else (l1, l2)
Error: This expression has type 'a list
       This is not a function; it cannot be applied.


let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
List.append(l1, clone(0  l1G) l2 )
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l1 in 
List.append (clone (0 l2G) l1) l2
else (l1, l2)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
List.append(l1, (clone 0  l1G) l2 )
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l1 in 
List.append ((clone 0 l2G) l1, l2)
else (l1, l2)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (n1, n2) = x in
let (carry, rest) = a in 
let total = n1 + n2 + carry in
(total/10, (total mod 10)::rest) in
let base = (0, []) in
let args = List.rev (List.combine(0::l1) ( 0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| [] -> []
| h::t -> h in
match x with
| [] -> [] 
| h2::t2 -> in 
let base = h in
let args = h2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (n1, n2) = x in
let (carry, rest) = a in 
let total = n1 + n2 + carry in
(total/10, (sum mod 10)::rest) in
let base = (0, []) in
let args = List.rev (List.combine(0::l1, 0::l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Characters 206-207:
  let args = List.rev (List.combine(0::l1, 0::l2) in
                      ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (n1, n2) = x in
let (carry, rest) = a in 
let total = n1 + n2 + carry in
(total/10, (sum mod 10)::rest) in
let base = (0, []) in
let args = List.rev (List.combine(0::l1, 0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value sum


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (n1, n2) = x in
let (carry, rest) = a in 
let total = n1 + n2 + carry in
(total/10, (total mod 10)::rest) in
let base = (0, []) in
let args = List.rev (List.combine(0::l1, 0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list



hw3 mulByDigit

fix:
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::((prod / 10)::(mulByDigit i t))
else prod::t

bad:
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::((prod / 10) + (mulByDigit i t))
else prod::t
Error: This expression has type int list
       but an expression was expected of type int


let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::((prod / 10) + ((mulByDigit i t))
else prod::t
Characters 124-125:
  if prod > 10 then (prod mod 10)::((prod / 10) + ((mulByDigit i t))
                                   ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::((prod / 10) + (mulByDigit i t)::t)
else prod::t
Error: This expression has type int list
       but an expression was expected of type int


let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::((prod / 10))
else prod::t
Error: This expression has type int but an expression was expected of type
         int list



hw3 mulByDigit

fix:
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10)::(mulByDigit i t) )
else (prod mod 10)::t

bad:
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::[((prod / 10)::(mulByDigit i t))]
else prod::t
Error: This expression has type 'a list
       but an expression was expected of type int


let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )::t
else prod::t
Error: This expression has type int list
       but an expression was expected of type int


let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )
else prod::t
Error: This expression has type int list
       but an expression was expected of type int


let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t)::[] )
else prod::t
Error: This expression has type int list
       but an expression was expected of type int


let rec mulByDigit i l = 
match List.rev l with
| [] -> 0
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )
else prod::t
Error: This expression has type 'a list
       but an expression was expected of type int


let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )
else prod::t
Error: This expression has type int list
       but an expression was expected of type int


let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )
else (prod mod 10)::t
Error: This expression has type int list
       but an expression was expected of type int



hw3 mulByDigit

fix:
let sqsum xs = 
(* Add 'a' to the square of x *)
let f a x = a + x*x in
(* List of numbers, so base must be 0 *)
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs =
(* Call a function p that returns the function x in fs. Called on the 'a' value *)
let f a x = fun p -> x (a p) in
(* Save base into a function that simply returns the parameter *)
let base =  fun b -> b in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
(* Concatenate the first element with the separator and x *)
let f a x = a ^ sep ^ x in
(* base element be the head *)
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello";]

let stringOfList f l = 
"[" ^ sepConcat "; " (List.map f l) ^ "]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n = 
if n <= 0 then []
else [x]@clone x (n-1)

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let padZero l1 l2 = 
if List.length l1 > List.length l2 then
let l1G = List.length l1 - List.length l2 in 
(* L1 is greater, so append 0's to l2 *)
(l1, List.append (clone 0 l1G) l2) 
else if List.length l1 < List.length l2 then
let l2G = List.length l2 - List.length l1 in 
(List.append (clone 0 l2G) l1, l2)
else (l1, l2)

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

let rec removeZero l = match l with
| [] -> []
| h::t ->
if h = 0 then
removeZero t 
else l

let _ = removeZero [0;0;0;1;0;0;2]

let _ = removeZero [9;9]

let _ = removeZero [0;0;0;0]

let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 

(* Divide two lists into tuples of their digits. i.e.
[7;2;4;6] and [3;9;2;7] -> (7,3) (2,9) (4,2) (6,7 )*)
let (n1, n2) = x in

(* Carry = value after adding them, rest = rest of tuples put in a list *)
let (carry, rest) = a in 

(* Add up the two digits in the pair plus the carry over *)
let total = n1 + n2 + carry in
(* Grab the first digit of the sum and divide by 10 to check whether there is a carry, last digit::rest *)
(total/10, (total mod 10)::rest) in

(* Base - sum is initially 0 and pass empty list to store list of
pairs of the digits of the list*)
let base = (0, []) in

(* Args == list of tuples of list's digits *)
let args = List.rev (List.combine(0::l1) ( 0::l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10)::(mulByDigit i t) )
else (prod mod 10)::t

bad:
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then ((prod mod 10)::( (prod / 10) + (mulByDigit i t) ))::t
else (prod mod 10)::t
Error: This expression has type int list list
       but an expression was expected of type int


let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( (prod / 10) + [(mulByDigit i t)] )
else (prod mod 10)::t
Error: This expression has type 'a list
       but an expression was expected of type int


let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::( [(prod / 10)]::(mulByDigit i t) )
else (prod mod 10)::t
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 mulByDigit

fix:
let rec mulByDigit i l = 
let mult i l = 
let f a x = 
let (carryOver, rest) = a in
let num = carryOver + (x * i) in
let secondDigit = num mod 10 in
let carryOver = num / 10 in
let result = secondDigit::rest in (carryOver, rest) in
let base = (0, []) in
let (carryOver, rest) = List.fold_left f base (List.rev l) in
carryOver::rest in
removeZero(mult i l)

bad:
let rec mulByDigit i l = 
match l with
| [] -> []
| h::t -> let prod = (h * i) in
let lastDigit = prod / 10 in 
let firstDigit = prod mod 10 in
if prod > 10 then lastDigit::[firstDigit + mulByDigit(i t)]
else firstDigit::t
Error: This expression has type int
       This is not a function; it cannot be applied.


let rec mulByDigit i l = 
match l with
| [] -> []
| h::t -> let prod = (h * i) in
let lastDigit = prod / 10 in 
let firstDigit = prod mod 10 in
let ret = mulByDigit ( i t ) in
match ret with 
| [] -> 0
| h2::t2 -> if h2 > 10 then let temp = h2 
else let temp = h2 mod 10 in 
if prod > 10 then lastDigit::[firstDigit + temp]
else firstDigit::t
Error: Syntax error


let rec mulByDigit i l = 
match l with
| [] -> []
| h::t -> let prod = (h * i) in
let lastDigit = prod / 10 in 
let firstDigit = prod mod 10 in
let ret = mulByDigit ( i t ) in
match ret with 
| [] -> 0
| h2::t2 -> if h2 > 10 then let temp = h2 
else temp = h2 mod 10 in 
if prod > 10 then lastDigit::[firstDigit + temp]
else firstDigit::t
Error: Syntax error


let rec mulByDigit i l = 
match l with
| [] -> []
| h::t -> let prod = (h * i) in
let lastDigit = prod / 10 in 
let firstDigit = prod mod 10 in
let ret = mulByDigit ( i t ) in
match ret with 
| [] -> 0
| h2::t2 -> if h2 > 10 then let temp = h2 in 
if prod > 10 then lastDigit::[firstDigit + temp]
else firstDigit::t
Error: This expression has type int
       This is not a function; it cannot be applied.



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in
let base = [] in
let args = List.rev l2 in
List.fold_left f base args

bad:
let bigMul l1 l2 = 
let f a x = List.append ((mulByDigit x l1) (clone 0 (List.length a))::a) in
let base = [] in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list
       This is not a function; it cannot be applied.
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int list
       This is not a function; it cannot be applied.


let bigMul l1 l2 = 
let f a x = ((mulByDigitx l1)@(clone 0 (List.length a)))::a in
let base = [] in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value mulByDigitx
Hint: Did you mean mulByDigit?
Error: Unbound value mulByDigitx
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value mulByDigitx
Hint: Did you mean mulByDigit?


let bigMul l1 l2 = 
let f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in
let base = [] in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list list
       but an expression was expected of type 'a * 'b
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int list list
       but an expression was expected of type 'a * 'b



hw1 sumList

fix:
let rec sumList xs = 
let x :: t = xs in
x + sumList (t)

bad:
let rec sumList xs = 
xs.(0) + hd xs
Error: Unbound value hd


let rec sumList xs = 
if xs.length != 0 then xs.(0) + sumList(hd xs)
Error: Unbound record field length


let rec sumList xs = 
if List.length xs != 0 then xs.(0) + sumList(hd xs)
Error: This expression has type 'a list
       but an expression was expected of type 'b array


let rec sumList xs = 
if List.length xs != 0 then xs.(0) + sumList(List.hd xs)
Error: This expression has type 'a list
       but an expression was expected of type 'b array


let rec sumList xs = 
if List.length xs != 0 then List.nth xs 0 + sumList(List.hd xs)
Error: This expression has type int but an expression was expected of type
         int list


let rec sumList xs = 
if List.length xs != 0 then List.nth xs 0 + sumList(List.tl xs)
Error: This expression has type int but an expression was expected of type
         unit


let rec sumList xs = 
if List.length xs != 0 then List.nth xs 0 + sumList(List.tl xs)
Error: This expression has type int but an expression was expected of type
         unit


let rec sumList xs = 
let rec int q =
q + if List.length xs != 0 then List.nth xs 0 
| sumList(List.tl xs)
Error: Syntax error


let rec sumList xs = 
let rec int q =
q + if List.length xs != 0 then List.nth xs 0 
sumList(List.tl xs)
Error: Syntax error


let rec sumList xs = 
let int q =
q + x :: xs
Error: Syntax error


let rec sumList xs = 
let int q =
q + x :: xs
Error: Syntax error


let rec sumList xs = 
let x :: t = xs in
let int q = q + x + sumList(t)
Error: Syntax error


let rec sumList xs = 
let x :: t = xs in
let int q = q + x + sumList (t)
Error: Syntax error



hw1 sumList

fix:
let rec sumList xs = 
let x :: t = xs in
x + if t = [] then 0 else sumList (t)

bad:
let rec sumList xs = 
let x :: t = xs in
if t != [] then x + sumList (t)
Error: This expression has type int but an expression was expected of type
         unit


let rec sumList xs = 
let x :: t = xs in
if x != [] then x + sumList (t)
Error: This expression has type 'a list
       but an expression was expected of type int


let rec sumList xs = 
let x :: t = xs in
x + if t != [] then sumList (t)
Error: This expression has type unit but an expression was expected of type
         int



hw1 digitsOfInt

fix:
let rec sumList xs = 
let x :: t = xs in
x + if t = [] then 0 else sumList (t)

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

let rec digitsOfInt n = 
n mod 10 :: if n > 0 then digitsOfInt (n / 10)

bad:
let rec digitsOfInt n = 
n mod 10 :: if n <> [] then digitsOfInt (n / 10)
Error: This expression has type 'a list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
let int list digInt = n mod 10 in
if n > 0 then digitsOfInt (n / 10) else []

bad:
let rec digitsOfInt n = 
let int list xs = 
n mod 10 :: if n > 0 then digitsOfInt (n / 10)
Error: Syntax error


let rec digitsOfInt n = 
let digInt =
n mod 10 :: if n > 0 then digitsOfInt (n / 10)
Error: Syntax error


let rec digitsOfInt n = 
let int list digInt =
n mod 10 :: if n > 0 then digitsOfInt (n / 10) else []
Error: Syntax error



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
let int list digInt = n mod 10 in
if n > 0 then digitsOfInt (n / 10)

bad:
let rec digitsOfInt n = 
let int list digInt = n mod 10 in
if n > 0 then digitsOfInt (n / 10) else digInt
Error: Unbound value digInt


let rec digitsOfInt n = 
let int list digInt = n mod 10 in
if n > 0 then digitsOfInt (n / 10) else digInt
Error: Unbound value digInt



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
let list digInt = (n mod 10) in
if n / 10 <> 0 then digitsOfInt (n / 10)

bad:
let rec digitsOfInt n = 
let int list digInt :: n mod 10 in
if n > 0 then digitsOfInt (n / 10)
Error: Syntax error


let rec digitsOfInt n = 
let list digInt :: n mod 10 in
if n > 0 then digitsOfInt (n / 10)
Error: Syntax error


let rec digitsOfInt n = 
let list digInt :: (n mod 10) in
if n > 0 then digitsOfInt (n / 10)
Error: Syntax error


let rec digitsOfInt n = 
let list digInt :: (n mod 10)
if n > 0 then digitsOfInt (n / 10)
Error: Syntax error


let rec digitsOfInt n = 
let list digInt :: (n mod 10) in
if n / 10 <> 0 then digitsOfInt (n / 10)
Error: Syntax error



hw1 digitsOfInt

fix:
let int list digInt = []

let rec digitsOfInt n = 
digInt = n mod 10 :: digitsOfInt( n / 10)

bad:
let rec digitsOfInt n = 
let int list digInt :: (n mod 10) in
if n / 10 <> 0 then digitsOfInt (n / 10)
Error: Syntax error


let rec digitsOfInt n = 
let int list digInt =
n mod 10 :: if n / 10 <> 0 then digitsOfInt (n / 10)
Error: Syntax error


let rec digitsOfInt n = 
let int list digInt = n mod 10 :: digitsOfInt( n / 10)
Error: Syntax error


let rec digitsOfInt n = 
digInt = n mod 10 :: digitsOfInt( n / 10)
Error: Unbound value digInt


let rec digitsOfInt n = 
int list digInt = n mod 10 :: digitsOfInt( n / 10)
Error: Unbound value int



hw1 ???

fix:
let r = [2;3]

let 15 mod 10 :: r

bad:
let r = [2; 3]

15 mod 10 :: r
Error: This expression has type int list
       This is not a function; it cannot be applied.


let r = [2;3]

15 mod 10 :: r
Error: This expression has type int list
       This is not a function; it cannot be applied.



hw1 ???

fix:
let r = [2;3]

bad:
let 15 mod 10 :: r = r
Error: Syntax error


let r = [2;3] 

15 mod 10 :: r
Error: This expression has type int list
       This is not a function; it cannot be applied.



hw1 digitsOfInt

fix:
let rec sumList xs = 
let x :: t = xs in
x + if t = [] then 0 else sumList (t)

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

let r = [2;3]

let rec digitsOfInt n = 
let digInt = [] in
if (n / 10) <> 0 
then digInt :: digitsOfInt ( n / 10) 
else []

bad:
let rec digitsOfInt n = 
let int list digInt = n mod 10 :: digInt 
if (n / 10) <> 0 then digitsOfInt ( n / 10)
Error: Syntax error


let rec digitsOfInt n = 
let int list digInt = n mod 10 :: digInt in
if (n / 10) <> 0 then digInt :: digitsOfInt ( n / 10)
Error: This variant expression is expected to have type unit
       The constructor :: does not belong to type unit


let rec digitsOfInt n = 
let int list digInt = [] in
if (n / 10) <> 0 then digInt :: digitsOfInt ( n / 10)
Error: This variant expression is expected to have type unit
       The constructor :: does not belong to type unit



hw1 digitsOfInt

fix:
let l = []

let rec digitsOfInt n l= 
match l with
| [] -> []
| (n mod 10) :: l -> if (n / 10) <> 0
then digitsOfInt (n / 10) l
else []

bad:
let rec digitsOfInt n = 
let digInt =
if (n / 10) <> 0 
then digInt :: digitsOfInt ( n / 10) 
else []
Error: Syntax error


let rec digitsOfInt n = 
let digInt =
if (n / 10) <> 0 
then n mod 10 :: digitsOfInt ( n / 10) 
else []
Error: Syntax error


let rec digitsOfInt n = 
let digInt = n mod 10
if (n / 10) <> 0 
then n mod 10 :: digitsOfInt ( n / 10) 
else []
Error: Syntax error


let rec digitsOfInt n = 
let digInt =
if (n / 10) <> 0 
then n mod 10 :: digitsOfInt ( n / 10) 
else []
Error: Syntax error



hw1 digitsOfInt

fix:
let rec digitsOfInt n =
match n / 10 with
| 0  -> n mod 10 ::[]
| _  -> n mod 10 :: digitsOfInt( n / 10)

bad:
let digitsOfInt n =
let l = [] in
match n / 10 with
| 0  -> []
| _  -> l :: n mod 10 :: digitsOfInt( n / 10)
Error: This expression has type int but an expression was expected of type
         'a list


let digitsOfInt n =
let l = [] 
match n / 10 with
| 0  -> []
| _  -> l :: n mod 10 :: digitsOfInt( n / 10)
Error: Syntax error


let digitsOfInt n =
match n / 10 with
| 0  -> []
| _  -> l :: n mod 10 :: digitsOfInt( n / 10)
Error: This expression has type int but an expression was expected of type
         'a list


let digitsOfInt n =
match n / 10 with
| 0  -> n mod 10 ::[]
| _  -> l :: n mod 10 :: digitsOfInt( n / 10)
Error: This expression has type 'a list
       but an expression was expected of type int


let digitsOfInt n =
match n / 10 with
| 0  -> n mod 10 ::[]
| _  -> n mod 10 :: digitsOfInt( n / 10)
Error: This expression has type 'a list list
       but an expression was expected of type int list
       Type 'a list is not compatible with type int 



hw1 listReverse

fix:
let rec listReverse l = 
match l with 
| []   -> []
| x::l -> x :: listReverse(l)

bad:
let rec listReverse l = 
match l with 
| []   -> []
| x::l -> listReverse(l) :: x
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec listReverse l = 
match l with 
| []   -> []
| x::l -> x :: listReverse(l) x
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 ???

fix:
let append x y =
match y with
| [] -> []
| h::t -> x :: h

bad:
let fun append x y =
match y with
| [] -> []
| h::t -> x :: h
Error: Syntax error



hw1 ???

fix:
let append x y =
match y with
| [] -> []
| h::t -> h :: x

bad:
let _ = append [1;2] [3;4]
Error: This expression has type int but an expression was expected of type
         int list list



hw1 ???

fix:
let append x y =
match y with
| [] -> []
| h :: [] -> h :: x
| h::t -> h :: x

bad:
let append x y =
match y with
| [] -> []
| _ -> h :: x
Error: Unbound value h



hw1 ???

fix:
let rec append x y =
match y with
| []   -> []
| h::t -> append (h::x) t

bad:
let rec append x y =
match y with
| []   -> []
| h::t -> append h::x t
Error: This expression has type 'a list -> 'b list
       but an expression was expected of type 'b
       The type variable 'b occurs inside 'a list -> 'b list



hw1 listReverse

fix:
let rec append x y =
match y with
| []   -> x
| h::t -> append (h::x) t

let rec listReverse l = 
match l with 
| [] -> []
| h::t -> listReverse(t) :: h

bad:
let rec listReverse l = 
match l with 
| [] -> []
| h::t -> listReverse(t) :: h
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 listReverse

fix:
let rec listReverse l = 
let h::t = l in
match l with 
| []   -> []
| h::t -> listReverse t

bad:
let rec listReverse l = 
match l with 
| [] -> []
| h::t -> listReverse t :: h :: []
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 sumList

fix:
let rec sumList xs =
match xs with
| [] -> 0
| h::t -> h + sumList(t)

bad:
let rec sumList xs = 
match xs with
| [] -> x + 0
| h::t -> x + sumList(t)
Error: Unbound value x


let rec sumList xs =
let x =
match xs with
| [] -> x + 0
| h::t -> x + sumList(t)
Error: Syntax error



hw1 listReverse

fix:
let rec listReverse l = 
match l with
| [] -> []
| h::t -> (listReverse t)

bad:
let rec listReverse l = 
match l with
| [] -> []
| h::t -> (listReverse t) :: h
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec listReverse l = 
if l <> [] then let
match l with 
| []   -> l
| h::t -> (listReverse t) :: h
Error: Syntax error



hw1 listReverse

fix:
let rec listReverse2 l dest = 
match l with
| [] -> []
| h::t -> listReverse2 t (h::dest)

let rec listReverse l = listReverse2 l []

bad:
let rec listReverse l = 
if l <> [] then let
match l with 
| []   -> l
| h::t -> (listReverse t) :: h
Error: Syntax error


let rec listReverse l = 
if l <> [] then 
match l with 
| []   -> l
| h::t -> (listReverse t) :: h
Error: This expression has type 'a list
       but an expression was expected of type unit



hw1 digitalRoot

fix:
let rec digitalRoot n = digitalRoot(sumList(digits(n)))

bad:
let rec digitalRoot n = digitalRoot(sumList(n))
Error: This expression has type int but an expression was expected of type
         int list



hw1 ???

fix:
let _ = digitsToList 5533

bad:
let rec digitsToList n = 
match n / 10 with
| 0  -> n mod 10 ::[]
| _  -> n mod 10 :: digitsToList( n / 10)
Error: Unbound value listReverse



hw1 listReverse

fix:
let listReverse l = listReverse2 l []

bad:
let listReverse l = listReverse2 l []
Error: Unbound value listReverse


let rec listReverse2 l dest = 
Error: Unbound value listReverse2


let rec listReverse2 l dest = 
match l with
| [] -> dest
| h::t -> listReverse2 t (h::dest)
Error: Syntax error



hw1 additivePersistence

fix:
let _ = additivePersistence 9876

bad:
let additivePersistence n = additivePersistence2 n 0
NO ERROR FROM MINIMAL PROGRAM!!!
Error: This function has type int -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 ???

fix:
let rec proceed a b =
match a, b with
| [] , [] -> true
| _::_, [] -> false
| [], _::_ -> false
| ha::ta, hb::tb -> if ha = hb then proceed ta tb else false

bad:
let rec proceed a b =
match a, b with
| [] , [] -> true
| ha::ta, hb::tb -> if ha = hb then proceed ta tb else false
Error: Unbound value proceed
Hint: Did you mean pred?



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then seen else h :: seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen' then seen' else h :: seen' in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: Unbound value seen'
Hint: Did you mean seen?



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile (f ,b)

bad:
let fixpoint (f,b) = wwhile (f b <> b,b)
Error: This expression has type bool but an expression was expected of type
         'a -> 'a * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile (f b ,b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: This expression has type int -> int
       but an expression was expected of type int -> int * bool
       Type int is not compatible with type int * bool 



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ( f, b)

bad:
let fixpoint (f,b) = wwhile (wwhile (f, b),b)
Error: This expression has type 'a -> 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'a * bool


let fixpoint (f,b) = wwhile (wwhile (f , b) , b)
Error: This expression has type 'a -> 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'a * bool


let fixpoint (f,b) = wwhile ( if f b = b then b else f b , b)
Error: This expression has type ('a -> 'a * bool) * 'a
       but an expression was expected of type 'a -> 'a * bool


let fixpoint (f,b) = wwhile ( fixpoint (f , b), b)
Error: This expression has type 'a -> 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'a * bool
Error: Unbound value wwhile
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type 'a -> 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'a * bool


let fixpoint (f,b) = wwhile ( fixpoint , b)
Error: This expression has type ('a -> 'a -> 'a * bool) * 'a -> 'a
       but an expression was expected of type
         ('a -> 'a -> 'a * bool) * 'a ->
         (('a -> 'a -> 'a * bool) * 'a) * bool
       The type variable 'a occurs inside
       (('a -> 'a -> 'a * bool) * 'a) * bool
Error: Unbound value wwhile
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type ('a -> 'a -> 'a * bool) * 'a -> 'a
       but an expression was expected of type
         ('a -> 'a -> 'a * bool) * 'a ->
         (('a -> 'a -> 'a * bool) * 'a) * bool
       The type variable 'a occurs inside
       (('a -> 'a -> 'a * bool) * 'a) * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ( let b' = f b in if b' = b then f b else f b')

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: This expression has type int -> int
       but an expression was expected of type int -> int * bool
       Type int is not compatible with type int * bool 


let fixpoint (f,b) = wwhile ( let b' = f b in if b' = b then f b else f b', b)
Error: This expression has type ('a -> 'a * bool) * 'a
       but an expression was expected of type 'a -> 'a * bool



hw2 fixpoint

fix:
let rec assoc (d,k,l) = 
match l with  
| [] -> d
| h::t -> 
let (p , q) = h in
if k = p then q
else assoc (d, k, t)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then seen else h :: seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) = 
let (b' , c') = f b in
if c' = false then b' else wwhile(f, b')

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) = wwhile (failwith "to be written" , b)

bad:
let fixpoint (f,b) = wwhile ( , b)
Error: Syntax error: operator expected.



hw2 exprToString

fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine(expr) -> "sin(pi*"^exprToString(expr)^")"
| Cosine(expr) -> "cos(pi"^ exprToString(expr)^")"
| Average(expr, expr2) -> "(("^exprToString(expr)^"+"^exprToString(expr2)^"/2)"
| Times(expr, expr2) -> exprToString(expr)^"*"^exprToString(expr2)
| Thresh(expr, expr2, expr3, expr4) -> "("^exprToString(expr)^"<"^exprToString(expr2)^"?"^exprToString(expr3)^":"^exprToString(expr4)^")"

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine(expr) -> "sin(pi*"^exprToString(expr)^")"
| Cosine(expr) -> "cos(pi"^ exprToString(expr)^")"
| Average(expr, expr2) -> "(("^exprToString(expr)^"+"^exprToString(expr2)^"/2)"
| Times(expr, expr2) -> exprToString(expr)^"*"exprToString(expr2)
| Thresh(expr, expr2, expr3, expr4) -> "("^exprToString(expr)^"<"^exprToString(expr2)^"?"^exprToString(expr3)^":"^exprToString(expr4)")"
Error: This expression has type string
       This is not a function; it cannot be applied.


let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine(expr) -> "sin(pi*"^exprToString(expr)^")"
| Cosine(expr) -> "cos(pi"^ exprToString(expr)^")"
| Average(expr, expr2) -> "(("^exprToString(expr)^"+"^exprToString(expr2)^"/2)"
| Times(expr, expr2) -> exprToString(expr)^"*"^exprToString(expr2)
| Thresh(expr, expr2, expr3, expr4) -> "("^exprToString(expr)^"<"^exprToString(expr2)^"?"^exprToString(expr3)^":"^exprToString(expr4)")"
Error: This function has type expr -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw2 eval

fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(eval(e, x, y ))
| Cosine(e)  -> cos(eval(e, x, y))
| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) +. (eval(e2, x ,y) /. 2.0))
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x ,y)
| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) 
then eval(e3, x ,y) else eval(e4, x, y)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(eval(e, x, y ))
| Cosine(e)  -> cos(eval(e, x, y))
| Average(e1, e2) -> ((eval(e1, x , y) ./ 2) + (eval(e2, x ,y) ./ 2))
| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)
| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) 
then eval(e3, x ,y) else eval(e4, x, y)
Error: Syntax error: operator expected.


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(eval(e, x, y ))
| Cosine(e)  -> cos(eval(e, x, y))
| Average(e1, e2) -> ((eval(e1, x , y) /. 2) + (eval(e2, x ,y) /. 2))
| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)
| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) 
then eval(e3, x ,y) else eval(e4, x, y)
Error: This expression has type int but an expression was expected of type
         float


et rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(eval(e, x, y ))
| Cosine(e)  -> cos(eval(e, x, y))
| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) + (eval(e2, x ,y) /. 2.0))
| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)
| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) 
then eval(e3, x ,y) else eval(e4, x, y)
Error: Syntax error


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(eval(e, x, y ))
| Cosine(e)  -> cos(eval(e, x, y))
| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) + (eval(e2, x ,y) /. 2.0))
| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)
| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) 
then eval(e3, x ,y) else eval(e4, x, y)
Error: This expression has type float but an expression was expected of type
         int



hw2 build

fix:
uildX()                       = VarX

let buildY()                       = VarY

let buildSine(e)                   = Sine(e)

let buildCosine(e)                 = Cosine(e)

let buildAverage(e1,e2)            = Average(e1,e2)

let buildTimes(e1,e2)              = Times(e1,e2)

let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)

let pi = 4.0 *. atan 1.0

let rec eval (e,x,y) = match e with

bad:
let sampleExpr =
buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(
buildX()),buildTimes(buildCosine (buildCosine (buildAverage
(buildTimes (buildY(),buildY()),buildCosine (buildX())))),
buildCosine (buildTimes (buildSine (buildCosine
(buildY())),buildAverage (buildSine (buildX()), buildTimes
(buildX(),buildX()))))))),buildY())))
Error: Unbound value buildCosine



hw2 build

fix:
let rec build (rand, depth) = 
if depth = 0 then 
match rand(0, 2) with
| 0 -> buildX()
| 1 -> buildY()
else
match rand(2, 7) with 
| 2 -> buildSine(build(rand, depth - 1))
| 3 -> buildCosine(build(rand, depth - 1))
| 4 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))
| 5 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))
| 6 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))

bad:
let rec build (rand, depth) = 
let f = makeRand(rand) in
if depth = 0 then buildX()
else
match f with 
| 2 -> buildSine(build(rand, depth - 1))
| 3 -> buildCosine(build(rand, depth - 1))
| 4 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))
| 5 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))
| 6 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))
Error: This pattern matches values of type int
       but a pattern was expected which matches values of type
         int * int -> int


let rec build (rand, depth) = 
if depth = 0 then 
match rand(0, 2)
| 0 -> buildX()
| 1 -> buildY()
else
match rand(2, 7) with 
| 2 -> buildSine(build(rand, depth - 1))
| 3 -> buildCosine(build(rand, depth - 1))
| 4 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))
| 5 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))
| 6 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))
Error: Syntax error



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile (f, b)

bad:
let fixpoint (f,b) = let xx = f(b) in (xx, xx = b) in wwhile (f, b)
Error: Unbound value f



hw2 fixpoint

fix:
let rec assoc (d,k,l) = 
match l with  
| [] -> d
| h::t -> 
let (p , q) = h in
if k = p then q
else assoc (d, k, t)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then seen else h :: seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) = 
let (b' , c') = f b in
if c' = false then b' else wwhile(f, b')

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) = 
let b' = f b in
if b = b' then b else f b in 
wwhile (f , b)

bad:
let fixpoint (f,b) = wwhile ( wwhile(f, b), b)
Error: This expression has type 'a -> 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'a * bool


let fixpoint (f,b) = wwhile (if f b = b then b else f b , b)
Error: This expression has type ('a -> 'a * bool) * 'a
       but an expression was expected of type 'a -> 'a * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = 
let (b', c') = f b in
if b = b' then b else wwhile (f , b)

bad:
let fixpoint (f,b) = 
let b' = f b in
if b = b' then b else wwhile (f , b)
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> 'a * bool
       The type variable 'a occurs inside 'a * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = 
let f x = let xx = f b in (xx, xx <> b) in wwhile (f, b)

bad:
let fixpoint (f,b) = 
let b' = f b in
if b = b' then b else wwhile (f , b)
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> 'a * bool
       The type variable 'a occurs inside 'a * bool


let fixpoint (f,b) = 
let b' = f b in
if b = b' then b else f b in wwhile (f , b)
Error: Unbound value f


let fixpoint (f,b) = 
let b' = f b in
if b = b' then b else f b in wwhile (f b, b)
Error: Unbound value f


let fixpoint (f,b) = 
let f b = b' in
if b = b' then b else f b in wwhile (f b, b)
Error: Unbound value b'


let fixpoint (f,b) = 
let f x = let xx = f b in (xx, xx <> b) in wwhile (f b, b)
Error: This expression has type 'a * bool
       but an expression was expected of type 'b -> 'b * bool



hw2 fixpoint

fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let fixpoint (f,b) = 
let f b = let xx = f b in (xx, xx <>  b) in wwhile (f, b)
Error: Unbound value wwhile


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a + x in
let base =  0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = (+) x in
let base = [] in
List.fold_left f base xs
Error: This expression has type 'a list
       but an expression was expected of type int -> int


let sqsum xs = 
let f a x = (+) x in
let base = 0 in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         int -> int



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base =  [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  _ in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base =  f in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  a' in
List.fold_left f base fs
Error: Unbound value a'



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base =  0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  fs in
List.fold_left f base fs
Error: This expression has type 'a but an expression was expected of type
         ('a -> 'a) list
       The type variable 'a occurs inside ('a -> 'a) list



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = f in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  x a in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = x a in
let base =  a in
List.fold_left f base fs
Error: Unbound value a


let pipe fs = 
let f a x = x a in
let base = fs in
List.fold_left f base fs
Error: This expression has type 'a but an expression was expected of type
         ('a -> 'a) list
       The type variable 'a occurs inside ('a -> 'a) list



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = _ in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = (+) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = f g in
List.fold_left f base fs
Error: Unbound value g


let pipe fs = 
let f a x = x a in
let base = fun x in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x a in
let base = fun f in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x a in
let base = f base in
List.fold_left f base fs
Error: Unbound value base



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let rec base = base in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = (base) in
List.fold_left f base fs
Error: Unbound value base


let pipe fs = 
let f a x = x a in
let base = (_) in
List.fold_left f base fs
Error: Syntax error: operator expected.


let pipe fs = 
let f a x = x a in
let base = x a in
List.fold_left f base fs
Error: Unbound value x



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 stringOfList

fix:
let sqsum xs = 
let f a x = a + x in
let base =  0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = fun q ->  x (a q)in
let base = fun x -> x in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base =  h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = sepConcat("" List.map(f l))

bad:
let stringOfList f l = sepConcat("" List.map(f l))
Error: This expression has type string
       This is not a function; it cannot be applied.



hw3 stringOfList

fix:
let stringOfList f l = 
let x = List.map f l  in
sepConcat ";" x

bad:
let stringOfList f l = sepConcat"" List.map(f l)
Error: This function has type string -> string list -> string
       It is applied to too many arguments; maybe you forgot a `;'.


let stringOfList f l = sepConcat "" List.map(f l)
Error: This function has type string -> string list -> string
       It is applied to too many arguments; maybe you forgot a `;'.


let stringOfList f l = let x = List.map(f l) in
sepConcat ";" x
Error: This expression has type 'a list -> 'b list
       but an expression was expected of type string list



hw3 stringOfList

fix:
let stringOfList f l = 
let x = List.map f l  in
sepConcat ";" x

bad:
let stringOfList f l = sepConcat ";" List.map f l
Error: This function has type string -> string list -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 clone

fix:
let rec clone x n = 
if n <= 0 then []
else n :: (clone x (n-1))

bad:
let rec clone x n = 
if n <= 0 then []
else n :: clone x n-1
Error: This expression has type int list
       but an expression was expected of type int


let rec clone x n = 
if n <= 0 then []
else n :: (clone x n-1)
Error: This expression has type int list
       but an expression was expected of type int



hw3 padZero

fix:
let padZero l1 l2 = 
let x1 = List.length(l1) in
let x2 = List.length(l2) in
if x1 < x2 then l1 @ clone 0 (x2-x1)
else l2 @ clone 0 (x1-x2)

bad:
let padZero l1 l2 = 
let x1 = List.length(l1) in
let x2 = List.length(l2) in
if x1 < x2 then x1 @ clone 0 (x2-x1)
else x2 @ clone 0 (x1-x2)
Error: This expression has type int but an expression was expected of type
         'a list



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a +. x**2.0 in
let base =  0.0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a + x**2 in
let base =  0 in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         float


let sqsum xs = 
let f a x = a + x**2.0 in
let base =  0 in
List.fold_left f base xs
Error: This expression has type float but an expression was expected of type
         int


let sqsum xs = 
let f a x = a +. x**2.0 in
let base =  0 in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         float



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a + int_of_float(float_of_int(x)**2.0) in
let base =  0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a + x**2 in
let base =  0 in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         float


let sqsum xs = 
let f a x = a + (pow x 2) in
let base =  0 in
List.fold_left f base xs
Error: Unbound value pow



hw3 ???

fix:
let _ = [(1,2); ]

bad:
); ()]
Error: Syntax error


let _ = [(1,2); ()]
Error: This expression has type unit but an expression was expected of type
         int * int


let _ = [(1,2); (,)]
Error: Syntax error: operator expected.



hw3 stringOfList

fix:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

bad:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[
Error: Syntax error



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (a1, a2) = a in
let h :: _ = a1 in
let tens = x1 + x2 + h / 10 in
let ones = x1 + x2 + h mod 10 in
(tens :: a1, ones :: a2)
in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =
match x with
| h :: t -> a
(*
let (x1, x2) = h in
let ha :: _ = a in
let (a1, a2) = ha in
let tens = x1 + x2 + a1 / 10 in
let ones = x1 + x2 + a1 mod 10 in
(tens, ones) :: a *)
| [] -> a
in
let base = (0 , 0) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type ('a * 'b) list
       but an expression was expected of type 'c list list
       Type 'a * 'b is not compatible with type 'c list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x
(*
match x with
| h :: t -> a

let (x1, x2) = h in
let ha :: _ = a in
let (a1, a2) = ha in
let tens = x1 + x2 + a1 / 10 in
let ones = x1 + x2 + a1 mod 10 in
(tens, ones) :: a 
| [] -> a *)
in
let base = (0 , 0) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let ha :: _ = a in
let (a1, a2) = ha in
let tens = x1 + x2 + a1 / 10 in
let ones = x1 + x2 + a1 mod 10 in
(tens, ones) :: a 
in
let base = (0 , 0) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value x1


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let ha :: _ = a in
let (a1, a2) = ha in
let tens = x1 + x2 + a1 / 10 in
let ones = x1 + x2 + a1 mod 10 in
(tens, ones) :: a 
in
let base = (0 , 0) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int * int
       but an expression was expected of type (int * int) list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let ha :: _ = a in
let (a1, a2) = ha in
let tens = x1 + x2 + a1 / 10 in
let ones = x1 + x2 + a1 mod 10 in
(tens, ones) :: a 
in
let base = [(0 , 0)] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type (int * int) list
       but an expression was expected of type 'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let ha :: _ = a in
let (a1, a2) = ha in
let tens = x1 + x2 + a1 / 10 in
let ones = x1 + x2 + a1 mod 10 in
(tens, ones)
in
let base = (0 , 0) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type (int * 'a) list -> int * int -> int * int
       but an expression was expected of type
         (int * 'a) list -> int * int -> (int * 'a) list
       Type int * int is not compatible with type (int * 'a) list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let ha :: _ = a in
let (a1, a2) = ha in
let tens = x1 + x2 + a1 / 10 in
let ones = x1 + x2 + a1 mod 10 in
(tens, ones) :: a
in
let base = [(0 , 0)] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type (int * int) list
       but an expression was expected of type 'a * 'b



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
match carry with
| h :: t -> 
let tens = x1 + x2 + h / 10 in
let ones = x1 + x2 + h mod 10 in
(tens :: carry, ones :: res)
| [] ->
let tens = x1 + x2 / 10 in
let ones = x1 + x2 mod 10 in
(tens :: carry, ones :: res)
in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
match carry with
| h :: t -> 
let tens = x1 + x2 + h / 10 in
let ones = x1 + x2 + h mod 10 in
(tens :: carry, ones :: res)
| [] ->
let tens = x1 + x2 / 10 in
let ones = x1 + x2 mod 10 in
(carry :: a1, ones :: res)
in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list
       but an expression was expected of type int



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
if carry <> [] then
let ch :: _ = carry in
let tens = (x1 + x2 + ch) / 10 in
let ones = (x1 + x2 + ch) mod 10 in
([tens] , tens :: ones :: res)
else
let tens = (x1 + x2) / 10 in
let ones = (x1 + x2) mod 10 in
([tens], tens :: ones :: res)

in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
match x2 with
| h :: t ->
let (carry, res) = a in
let tens = (x1 + x2 + h) / 10 in
let ones = (x1 + x2 + h) mod 10 in
(tens :: carry, ones :: res)
| [] ->
let (carry, res) = a in
let tens = (x1 + x2 + h) / 10 in
let ones = (x1 + x2 + h) mod 10 in
(tens :: ones :: res)

in
let base = ([0], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type int


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
match x with
| h :: t ->
let (carry, res) = a in
let tens = (x1 + x2 + h) / 10 in
let ones = (x1 + x2 + h) mod 10 in
(tens :: carry, ones :: res)
| [] ->
let (carry, res) = a in
let tens = (x1 + x2 + h) / 10 in
let ones = (x1 + x2 + h) mod 10 in
(tens :: ones :: res)

in
let base = ([0], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This pattern matches values of type 'a list
       but a pattern was expected which matches values of type 'b * 'c


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match x with
| h :: t -> 
let (x1, x2) = x in
let (carry, res) = a in
let tens = x1 + x2 + a1 / 10 in
let ones = x1 + x2 + a1 mod 10 in
if t = [] then (0 ,tens :: ones :: res)
else (tens :: carry, ones :: res)
| [] -> a


in
let base = ([0], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type 'b * 'c


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
let tens = x1 + x2 + carry / 10 in
let ones = x1 + x2 + carry mod 10 in
(tens :: ones :: res)
in
let base = ([0], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int * int list -> int * int -> int list
       but an expression was expected of type
         int * int list -> int * int -> int * int list
       Type int list is not compatible with type int * int list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
let tens = x1 + x2 + carry / 10 in
let ones = x1 + x2 + carry mod 10 in
(tens ,tens :: ones :: res)
in
let base = ([0], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list * 'a list
       but an expression was expected of type int * int list
       Type int list is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
let tens = x1 + x2 + carry / 10 in
let ones = x1 + x2 + carry mod 10 in
(tens , tens :: ones :: res)
in
let base = ([0], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list * 'a list
       but an expression was expected of type int * int list
       Type int list is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
let tens = x1 + x2 + carry / 10 in
let ones = x1 + x2 + carry mod 10 in
(tens , tens :: ones :: res)
in
let base = ([0], [0]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list * int list
       but an expression was expected of type int * int list
       Type int list is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
let tens = x1 + x2 + carry / 10 in
let ones = x1 + x2 + carry mod 10 in
([tens] , tens :: ones :: res)
in
let base = ([0], [0]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type
         int * int list -> int * int -> int list * int list
       but an expression was expected of type
         int * int list -> int * int -> int * int list
       Type int list is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
if carry <> [] then
let tens = (x1 + x2 + carry) / 10 in
let ones = (x1 + x2 + carry) mod 10 in
([tens] , tens :: ones :: res)
else
let tens = (x1 + x2) / 10 in
let ones = (x1 + x2) mod 10 in
([tens], tens :: ones :: res)

in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
if res <> [] then
let lastTens :: rest = res in
if carry <> [] then
let ch :: _ = carry in
let tens = (x1 + x2 + ch) / 10 in
let ones = (x1 + x2 + ch) mod 10 in
([tens] , tens :: ones :: rest)
else
let tens = (x1 + x2) / 10 in
let ones = (x1 + x2) mod 10 in
([tens], tens :: ones :: rest)

else 
if carry <> [] then
let ch :: _ = carry in
let tens = (x1 + x2 + ch) / 10 in
let ones = (x1 + x2 + ch) mod 10 in
([tens] , tens :: ones :: res)
else
let tens = (x1 + x2) / 10 in
let ones = (x1 + x2) mod 10 in
([tens], tens :: ones :: res)

in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
if res <> [] then
let lastTens :: rest = res in
else let rest = res in
if carry <> [] then
let ch :: _ = carry in
let tens = (x1 + x2 + ch) / 10 in
let ones = (x1 + x2 + ch) mod 10 in
([tens] , tens :: ones :: rest)
else
let tens = (x1 + x2) / 10 in
let ones = (x1 + x2) mod 10 in
([tens], tens :: ones :: rest)

in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error



hw3 mulByDigit

fix:
let rec mulByDigit i l = 
if i <> 0 then mulByDigit (i-1) (bigAdd l l)
else l

bad:
let rec mulByDigit i l = 
if i <> 0 then mulByDigit (i-1) bigAdd l l
else l
Error: This expression has type 'a but an expression was expected of type
         (int list -> int list -> int list) ->
         (int list -> int list -> int list) -> 'a
       The type variable 'a occurs inside
       (int list -> int list -> int list) ->
       (int list -> int list -> int list) -> 'a



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
match res with
| h :: t -> 
(match carry with
| h1 :: t1 ->
let tens = (x1 + x2 + h1) / 10 in
let ones = (x1 + x2 + h1) mod 10 in
([tens], tens :: ones :: t)
| [] ->
let tens = (x1 + x2) / 10 in
let ones = (x1 + x2) mod 10 in
([tens], tens :: ones :: t)
)
| [] -> 
(match carry with
| h1 :: t1 ->
let tens = (x1 + x2 + h1) / 10 in
let ones = (x1 + x2 + h1) mod 10 in
([tens], tens :: ones :: res)
| [] ->
let tens = (x1 + x2) / 10 in
let ones = (x1 + x2) mod 10 in
([tens], tens :: ones :: res)
)
in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (x1, x2) = x in
let (carry, res) = a in
match res with
| h :: t -> 
(match carry with
| h1 :: t1 ->
let tens = (x1 + x2 + h1) / 10 in
let ones = (x1 + x2 + h1) mod 10 in
([tens], tens :: ones :: t)
| [] ->
let tens = (x1 + x2) / 10 in
let ones = (x1 + x2) mod 10 in
([tens], tens :: ones :: t)
)
| [] -> 
(match carry with
| h1 :: t1 ->
let tens = (x1 + x2 + h1) / 10 in
let ones = (x1 + x2 + h1) mod 10 in
([tens], tens :: ones :: res)
| [] ->
let tens = (x1 + x2 + h1) / 10 in
let ones = (x1 + x2 + h1) mod 10 in
([tens], tens :: ones :: res)
)
in
let base = ([], []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value h1



hw3 mulByDigit

fix:
let rec mulByDigit i l = helper [0] i l

let _ = mulByDigit 9 [9;9;9;9]

bad:
let rec mulByDigit i l = helper 0 i l
Error: This expression has type int but an expression was expected of type
         int list



hw2 fixpoint

fix:
let fixpoint (f,b) = 
let h x = (f x, if f x = x then false else true) in
wwhile (h ,b)

bad:
let fixpoint (f,b) = 
let h x = (f x, if f x = x then false else true)
wwhile (h ,b)
Error: Syntax error



hw2 exprToString

fix:
let rec exprToString e = 
match e with
| VarX -> "x"
| VarY -> "y"
| Sine a -> "sin" ^ exprToString a
| Cosine a -> "cos" ^ exprToString a
| Average (a,b) -> exprToString a ^ "/" ^ exprToString b
| Times (a,b) -> exprToString a ^ "*" ^ exprToString b
| Thresh (a,b,c,d) -> exprToString a ^ "<" ^ exprToString b ^ "?" ^ exprToString c ^ ":" ^ exprToString d

bad:
let rec exprToString e = 
string x = e
Error: Unbound value string
Hint: Did you mean stdin?


let rec exprToString e = 
String x = e
Error: Unbound constructor String


let rec exprToString e = 
match e with
| VarX -> x
| VarY -> y
| Sine a -> "sin" ^ exprToString a
| Cosine a -> "cos" ^ exprToString a
| Average (a,b) -> exprToString a ^ "/" ^ exprToString b
| Times (a,b) -> exprToString a ^ "*" ^ exprToString b
| Thresh (a,b,c,d) -> exprToString a ^ "<" ^ exprToString b ^ "?" ^ exprToString c ^ ":" ^ exprToString d
Error: Unbound value x



hw2 eval

fix:
let rec eval (e,x,y) = 
match e with
|VarX -> x
|VarY -> y
|Sine a -> sin (pi *. eval(a,x,y))
|Cosine a -> cos (pi *. eval(a,x,y))
|Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.
|Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
|Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)

bad:
let rec eval (e,x,y) = 
match e with
|VarX -> x
|VarY -> y
|Sine a -> sin (pi *. eval(a,x,y))
|Cosine a -> cos (pi *. eval(a,x,y))
|Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2
|Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
|Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)
Error: This expression has type int but an expression was expected of type
         float



hw2 build

fix:
let rec build (rand, depth) = 
if depth = 0 then 
let result = rand 0 1 in
if result = 0 then 
buildX() else
buildY()
else
let result = rand 0 6 in
match result with
|0 -> buildX()
|1 -> buildY()
|2 -> buildSine(build(rand,depth-1))
|3 -> buildCosine(build(rand,depth-1))
|4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))
|5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
|6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
|_ -> buildX()

bad:
let rec build (rand, depth) = 
if depth = 0 then 
let result = rand 0 1 in
if result = 0 then 
buildX() else
buildY()
else
let result = rand 0 6 in
match result with
|0 -> buildX()
|1 -> buildY()
|2 -> buildSine(build(rand,depth-1))
|3 -> buildCosine(build(rand,depth-1))
|4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))
|5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
|6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
|_ -> build()
Error: This expression has type unit but an expression was expected of type
         (int -> int -> int) * int



hw2 eval

fix:
let rec eval (e,x,y) = 
match e with
|VarX -> x
|VarY -> y
|Sine a -> sin (pi *. eval(a,x,y))
|Cosine a -> cos (pi *. eval(a,x,y))
|Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.
|Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
|Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)
|Inverse a -> let result  = eval(a,x,y) in
if result = 0. then 0.
else
1. /. result
|Max (a,b) -> let aResult = eval(a,x,y) in
let bResult = eval(b,x,y) in
if aResult > bResult then aResult
else bResult
|Range (a,b,c) -> let aResult = eval(a,x,y) in
let bResult = eval(b,x,y) in
let cResult = eval(c,x,y) in
if aResult < bResult then bResult else
if aResult < cResult then cResult else
aResult

bad:
let rec eval (e,x,y) = 
match e with
|VarX -> x
|VarY -> y
|Sine a -> sin (pi *. eval(a,x,y))
|Cosine a -> cos (pi *. eval(a,x,y))
|Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.
|Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
|Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)
|Inverse a -> let result  = eval(a,x,y) in
if result = 0. then 0.
else
1 /. result
|Max (a,b) -> let aResult = eval(a,x,y) in
let bResult = eval(b,x,y) in
if aResult > bResult then aResult
else bResult
|Range (a,b,c) -> let aResult = eval(a,x,y) in
let bResult = eval(b,x,y) in
let cResult = eval(c,x,y) in
if aResult < bResult then bResult else
if aResult < cResult then cResult else
aResult
Error: This expression has type int but an expression was expected of type
         float



hw2 ???

fix:
let _ = doRandomGray (12,12,12)

bad:
let _ = doRandomGray 12
Error: This expression has type int but an expression was expected of type
         int * int * int
Error: Unbound constructor VarX
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int but an expression was expected of type
         int * int * int



hw2 ???

fix:
let _ = doRandomGray (8,10,10)

let _ = doRandomGray (10,132,14123)

let _ = doRandomColor (12,123412,90)

let _ = doRandomColor (20,21,22)

let _ = doRandomColor (11,1234,4312)

bad:
let _ = doRandomGray 8,10,10
Error: This expression has type int but an expression was expected of type
         int * int * int
Error: Unbound constructor VarX
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int but an expression was expected of type
         int * int * int


let _ = doRandomGray 10,132,14123
Error: This expression has type int but an expression was expected of type
         int * int * int
Error: Unbound constructor VarX
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int but an expression was expected of type
         int * int * int


let _ = doRandomColor 12,123412,90
Error: This expression has type int but an expression was expected of type
         int * int * int
Error: Unbound constructor VarX
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int but an expression was expected of type
         int * int * int


let _ = doRandomColor 20,21,22
Error: This expression has type int but an expression was expected of type
         int * int * int
Error: Unbound constructor VarX
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int but an expression was expected of type
         int * int * int


let _ = doRandomColor 11,1234,4312
Error: This expression has type int but an expression was expected of type
         int * int * int
Error: Unbound constructor VarX
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int but an expression was expected of type
         int * int * int



hw3 padZero

fix:
let padZero l1 l2 = 
let num1 = List.length l2 - List.length l1 in
let num2 = List.length l1 - List.length l2 in
(clone 0 num1 @l1,clone 0 num2 @ l2)

bad:
let padZero l1 l2 = 
let num1 = List.length l2 - List.length l1 in
let num2 = List.length l1 - list.length l2 in
(clone 0 num1 @l1,clone 0 num2 @ l2)
Error: Unbound value list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
|(z,y) -> let sum = z + y in
if sum > 10 then let result = ((sum mod 10)::a) in
1::result else
sum::a in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
|(z,y) -> let sum = z + y in
if sum > 10 then let result = a @ sum mod 10 in
result @ 1 else
a @ result in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
|(z,y) -> let sum = z + y in
if sum > 10 then let result = a @ (sum mod 10) in
result @ 1 else
a @ result in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
|(z,y) -> let sum = z + y in
if sum > 10 then let result = (a @ (sum mod 10)) in
result @ 1 else
a @ result in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
|(z,y) -> let sum = z + y in
if sum > 10 then let result = ((sum mod 10)::a) in
1::result else
sum::a in
let base = [] in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list
       but an expression was expected of type 'a * 'b



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let rec intlist x =
if x < 10 then [x] 
else (intlist (x / 10)) @ [x mod 10] in
match x with
|(z,y) -> (match a with
|[] -> let sum = z + y in
intlist sum
|h::t -> let sum = h + z + y in
(intlist sum) @ t) in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let rec intlist x =
if x < 10 then x 
else (intlist (x / 10))::[x mod 10] in
match x with
|(z,y) -> (match a with
|h -> let sum = h + z + y in
intlist sum
|h::t -> let sum = h + z + y in
(intlist sum)::t) in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type int


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let rec intlist x =
if x < 10 then [x] 
else (intlist (x / 10))::[x mod 10] in
match x with
|(z,y) -> (match a with
|h -> let sum = h + z + y in
intlist sum
|h::t -> let sum = h + z + y in
(intlist sum)::t) in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list
       but an expression was expected of type int


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let rec intlist x =
if x < 10 then [x] 
else (intlist (x / 10)) @ [x mod 10] in
match x with
|(z,y) -> (match a with
|h -> let sum = h + z + y in
intlist sum
|h::t -> let sum = h + z + y in
(intlist sum) @ t) in
let base = [] in
let args = List.combine l1 l2 in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 ???

fix:
let rec intlist x =
if x < 10 then [x] 
else (intlist (x / 10)) @ [x mod 10]

)

intlist 10

intlist 22

intlist 5

intlist 12345

bad:
let rec intlist x =
if x < 10 then [x] 
else (intlist (x / 10)) @ [x mod 10] 

intlist 10
Error: This expression has type int list
       This is not a function; it cannot be applied.


intlist 22
Error: Unbound value intlist


intlist 5
Error: Unbound value intlist


intlist 12345
Error: Unbound value intlist


let rec intlist x =
if x < 10 then [x] 
else (intlist (x / 10)) @ [x mod 10] 

intlist 10
Error: This expression has type int list
       This is not a function; it cannot be applied.


intlist 22
Error: Unbound value intlist


intlist 5
Error: Unbound value intlist


intlist 12345
Error: Unbound value intlist



hw3 ???

fix:
let f a x = 
let rec intlist l =
if l < 10 then [l] 
else (intlist (l / 10)) @ [l mod 10] in
match x with
|(z,y) -> (match a with
|[] -> let sum = z + y in
intlist sum
|h::t -> let sum = h + z + y in
(intlist sum) @ t)

let _ = f [] (9;2)

bad:
let _ = f [] (9;2)
Error: This expression has type int but an expression was expected of type
         int * int



hw3 ???

fix:
let _ = f [0] (9,2)

bad:
let _ = f [] (9;2)
Error: This expression has type int but an expression was expected of type
         int * int


let _ = f ([] (9;2))
Error: The constructor [] expects 0 argument(s),
       but is applied here to 1 argument(s)


let _ = f [0] (9;2)
Error: This expression has type int but an expression was expected of type
         int * int


let _ = f [0] (9;2)
Error: This expression has type int but an expression was expected of type
         int * int



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let rec intlist x =
if x < 10 then [x] 
else (intlist (x / 10)) @ [x mod 10] in
match x with
|(z,y) -> (match a with
|[] -> let sum = z + y in
intlist sum
|h::t -> let sum = h + z + y in
result = (intlist sum) @ t in
if sum < 10 then 0::result else result

) in 

let base = [0] in
let args = List.rev (List.combine l1 l2) in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let rec intlist x =
if x < 10 then [x] 
else (intlist (x / 10)) @ [x mod 10] in
match x with
|(z,y) -> (match a with
|[] -> let sum = z + y in
intlist sum
|h::t -> let sum = h + z + y in
result = (intlist sum) @ t) in
if sum < 10 then 0::result else result in 

let base = [0] in
let args = List.rev (List.combine l1 l2) in
let res = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value result



hw3 mulByDigit

fix:
let rec mulByDigit i l =
let rec intlist x =
if x < 10 then [x] 
else (intlist (x / 10)) @ [x mod 10] in

match l with 
|[] -> 0
|h::t -> let zeroList = (match t with 
|[] -> []
|h'::t' -> let (_,zeroList') = padZero(t',[]) in zeroList') in
let mult = intlist h*i in
let res = mult @ zeroList in
bigAdd res (mulByDigit t)

let _ = mulByDigit 9 [9;9;9;9]

bad:
let rec mulByDigit i l =
let rec intlist x =
if x < 10 then [x] 
else (intlist (x / 10)) @ [x mod 10] in

match l with 
|[] -> 0
|h::t -> (match t with 
|[] -> let zeroList = []
|h'::t' -> let (_,zeroList) = padZero(t',[])) in
let mult = intlist h*i in
let res = mult @ zeroList in
bigAdd res (mulByDigit t)
Error: Syntax error: operator expected.



hw3 mulByDigit

fix:
let rec mulByDigit i l =
let rec intlist x =
if x < 10 then [x] 
else (intlist (x / 10)) @ [x mod 10] in

match l with 
|[] -> 0
|h::t -> let zeroList = (match t with 
|[] -> []
|h'::t' -> (match padZero(t' [0]) with 
|(a,b) -> b)) in
let mult = intlist h*i in
let res = mult @ zeroList in
bigAdd res (mulByDigit t)

let _ = mulByDigit 9 [9;9;9;9]

bad:
let rec mulByDigit i l =
let rec intlist x =
if x < 10 then [x] 
else (intlist (x / 10)) @ [x mod 10] in

match l with 
|[] -> 0
|h::t -> let zeroList = (match t with 
|[] -> []
|h'::t' -> (match padZero((t',[0])) with 
|(a,b) -> b)) in
let mult = intlist h*i in
let res = mult @ zeroList in
bigAdd res (mulByDigit t)
Error: This expression has type 'a * 'b
       but an expression was expected of type int list
Error: Unbound value padZero
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type 'a * 'b
       but an expression was expected of type int list



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
match n > 0 with
| true  -> digOfIntHelper n::[n mod 10] 
| false -> []

bad:
let rec digitsOfInt n = 
match n > 0 with
| true  -> digOfIntHelper::[n mod 10] 
| false -> []
Error: This expression has type int but an expression was expected of type
         int -> int


let rec digitsOfInt n = 
match n > 0 with
| true  -> digOfIntHelper::[n % 10] 
| false -> []
Error: Unbound value %



hw1 digitsOfInt

fix:
let rec sumList xs = 
match xs with
| h::t  -> h + sumList t
| []    -> 0

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

let rec digOfIntHelper h = 
match h > 0 with
| true  -> 1
| false -> 0

let rec digitsOfInt n = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt n
| true  -> digitsOfInt n mod 10

bad:
let rec digitsOfInt n = 
match n with
| 0    -> []
| [0]   -> []
| 1     -> []
| true  -> digOfIntHelper n::[]::[n mod 10] 
| false -> []
Error: This pattern matches values of type 'a list
       but a pattern was expected which matches values of type int


let rec digitsOfInt n = 
match n > 0 with
| true  -> digOfIntHelper n::[]::[n mod 10] 
| false -> []
Error: This expression has type 'a list
       but an expression was expected of type int


let rec digitsOfInt n = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt n
| true  -> digitsOfInt n mod 10
Error: This expression has type int list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: []
| true  -> (n / 10) :: digitsOfInt (n mod 10)

bad:
let rec digitsOfInt n = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: []
| true  -> digitsOfInt (n / 10) :: digitsOfInt (n mod 10)
Error: This expression has type int list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: []
| true  -> n / 10 :: digitsOfInt (n / 10)

bad:
let rec digitsOfInt n = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: []
| true  -> digitsOfInt (n / 10) ::  (n mod 10)
Error: This expression has type int list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> 1 :: 1

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

bad:
let rec digitsOfInt n = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> 1
Error: This expression has type int but an expression was expected of type
         int list



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> n mod 10 :: digitsOfInt ( n / 10 )

bad:
let rec digitsOfInt n = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> 1 :: 2
Error: This expression has type int but an expression was expected of type
         int list



hw1 ???

fix:
let rec reverse l = 
match l with
| h::t  -> reverse t
| [a,b] -> [b,a]

bad:
let rec reverse l = 
match l with
| h::t -> reverse t :: [h]
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 ???

fix:
let rec reverse l = 
match l with
| h::t  -> reverse t
| [a,b] -> [b,a]
| [a]   -> [a]
| []    -> []

bad:
let rec reverse l = 
match l with
| h::t  -> reverse t
| [a,b] -> [b,a]
| _     -> _
Error: Syntax error



hw1 ???

fix:
let rec reverse l = 
match l with
| h::t  -> reverse t
| [a]   -> [a] 
| []    -> []

bad:
let rec reverse l = 
match l with
| h::t  -> reverse t
| [a]   -> [a] :: reverse t
| []    -> []
Error: Unbound value t



hw1 listReverse

fix:
let rec listReverse l =
let rec reverseHelper revd = 
match revd with
| []    -> []
| h::t  -> reverseHelper t h::revd 
in
reverseHelper [] l

;;

bad:
let rec listReverse l =
let rec reverseHelper revd = 
match revd with
| []    -> []
| h::t  -> reverseHelper t h::revd 
in
reverseHelper [] l
Error: This function has type 'a list -> 'b list
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 listReverse

fix:
let rec sumList xs = 
match xs with
| h::t  -> h + sumList t
| []    -> 0

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

let rec listReverse l =
let rec reverseHelper revd = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::revd )
in
listReverse [] l

bad:
let listReverse l =
let rec reverseHelper revd = 
match revd with
| []    -> []
| h::t  -> reverseHelper t h::revd 
in
reverseHelper [] l
Error: This function has type 'a list -> 'b list
       It is applied to too many arguments; maybe you forgot a `;'.


let listReverse l =
let rec reverseHelper revd = 
match revd with
| []    -> []
| h::t  -> reverseHelper t (h::revd )
in
reverseHelper [] l
Error: This function has type 'a list -> 'b list
       It is applied to too many arguments; maybe you forgot a `;'.


let listReverse l =
let rec reverseHelper revd = 
match revd with
| []    -> []
| h::t  -> listReverse t (h::revd )
in
reverseHelper [] l
Error: This function has type 'a list -> 'b list
       It is applied to too many arguments; maybe you forgot a `;'.


let rec listReverse l =
let rec reverseHelper revd = 
match revd with
| []    -> []
| h::t  -> listReverse t (h::revd )
in
reverseHelper [] l
Error: This function has type 'a list -> 'b list
       It is applied to too many arguments; maybe you forgot a `;'.


let rec listReverse l =
let rec reverseHelper revd = 
match revd with
| []    -> []
| h::t  -> listReverse t (h::revd )
in
listReverse[] l
Error: This expression has type 'a list
       but an expression was expected of type 'b list -> 'a list


let rec listReverse l =
let rec reverseHelper revd = 
match revd with
| []    -> []
| h::t  -> listReverse t (h::revd )
in
listReverse [] l
Error: This expression has type 'a list
       but an expression was expected of type 'b list -> 'a list


let rec listReverse l =
let rec reverseHelper revd = 
match l with
| []    -> []
| h::t  -> listReverse t (h::revd )
in
listReverse l []
Error: This expression has type 'a list
       but an expression was expected of type 'b list -> 'a list


let rec listReverse l =
let rec reverseHelper revd = 
match l with
| []    -> []
| h::t  -> listReverse t (h::revd )
in
listReverse [] l
Error: This expression has type 'a list
       but an expression was expected of type 'b list -> 'a list


let rec listReverse l =
let rec reverseHelper revd = 
match l with
| []    -> []
| h::t  -> listReverse t (h::revd )
in
reverseHelper []
Error: This expression has type 'a list
       but an expression was expected of type 'b list -> 'a list


let rec listReverse l =
let rec reverseHelper revd = 
match l with
| []    -> []
| h::t  -> listReverse t (h::revd )
in
reverseHelper l
Error: This expression has type 'a list
       but an expression was expected of type 'b list -> 'a list


let rec listReverse l =
let rec reverseHelper revd = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::revd )
in
in

listReverse l []
Error: Syntax error


let rec listReverse l =
let rec reverseHelper revd = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::revd )
in
listReverse l []
Error: This expression has type 'a list
       but an expression was expected of type 'b list -> 'a list


let rec listReverse l =
let rec reverseHelper revd = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::revd )
in
listReverse [] l
Error: This expression has type 'a list
       but an expression was expected of type 'b list -> 'a list



hw1 listReverse

fix:
let rec listReverse l =
let reverseHelper l r = 
match l with
| []    -> l
| h::t  -> listReverse t ( h::r ) 
in
reverseHelper []

bad:
let rec listReverse l =
let rec reverseHelper revd = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::revd )
in
reverseHelper [] l
Error: This function has type 'a list -> 'b list
       It is applied to too many arguments; maybe you forgot a `;'.


let rec listReverse l =
let rec reverseHelper r = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::r )
in
listReverse l []
Error: This expression has type 'a list
       but an expression was expected of type 'b list -> 'a list


let rec listReverse l =
let reverseHelper r = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::r )
in
listReverse l []
Error: This expression has type 'a list
       but an expression was expected of type 'b list -> 'a list


let rec listReverse l =
let reverseHelper r = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::r )
Error: Syntax error


let rec listReverse l =
let reverseHelper r = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::r )
Error: Syntax error


let rec listReverse l =
let reverseHelper r = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::r ) 
in
listReverse l []
Error: This expression has type 'a list
       but an expression was expected of type 'b list -> 'a list


let rec listReverse l =
let reverseHelper r = 
match l with
| []    -> []
| h::t  -> listReverse t ( h::r ) 
in
listReverse [] []
Error: This expression has type 'a list
       but an expression was expected of type 'b list -> 'a list


let rec listReverse l =
let reverseHelper r = 
match l with
| []    -> l
| h::t  -> listReverse t ( h::r ) 
in
listReverse [] []
Error: This expression has type 'a list
       but an expression was expected of type 'a list -> 'a list


let rec listReverse l =
let reverseHelper r = 
match l with
| []    -> l
| h::t  -> listReverse t ( h::r ) 
in
reverseHelper l []
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.


let rec listReverse l =
let reverseHelper r = 
match l with
| []    -> l
| h::t  -> listReverse t ( h::r ) 
in
reverseHelper []
Error: This expression has type 'a list
       but an expression was expected of type 'a list -> 'a list


let rec listReverse l =
let reverseHelper r = 
match l with
| []    -> l
| h::t  -> listReverse t ( h::r ) 
in
r
Error: Unbound value r


let rec listReverse l =
let reverseHelper r = 
match l with
| []    -> l
| h::t  -> listReverse t ( h::r ) 
in


let _ = listReverse [1; 2; 3; 4]
Error: Syntax error



hw1 listReverse

fix:
let rec listReverse l =
let rec reverseHelper l r = 
match l with
| []    -> l
| h::t  -> reverseHelper t ( h::r ) 
in
reverseHelper []

bad:
let rec listReverse l =
let reverseHelper l r = 
match l with
| []    -> l
| h::t  -> reverseHelper t ( h::r ) 
in
reverseHelper []
Error: Unbound value reverseHelper



hw1 listReverse

fix:
let rec digOfInt = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> n mod 10 :: digitsOfInt ( n / 10 )

let rec digitsOfInt n = listReverse (digOfInt n)

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

bad:
let rec digitsOfInt n = 
let digOfInt n = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> n mod 10 :: digitsOfInt ( n / 10 ) 
in
listReverse n
Error: This expression has type int but an expression was expected of type
         'a list


let rec digitsOfInt n = 
let digOfInt n r = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> n mod 10 :: digitsOfInt ( n / 10 ) 
in
listReverse n r
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.


let rec digitsOfInt n = 
let digOfInt n r = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> n mod 10 :: digitsOfInt ( n / 10 ) 
in
listReverse n r
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.


let rec digitsOfInt n = 
let digOfInt n r = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> n mod 10 :: digitsOfInt ( n / 10 ) 
in
listReverse n
Error: This expression has type int but an expression was expected of type
         'a list


let rec digitsOfInt n = 
let digOfInt n = 
match n > 0 with
| false -> []
| true  -> match n > 9 with
| false -> n :: digitsOfInt ( n / 10 )
| true  -> n mod 10 :: digitsOfInt ( n / 10 ) 
in
listReverse n
Error: This expression has type int but an expression was expected of type
         'a list



hw1 digitsOfInt

fix:
let rec sumList xs = 
match xs with
| h::t  -> h + sumList t
| []    -> 0

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

let digitsOfInt n =  
let rec digOfIntHelper n l = 
if (n > 0)
then (
if (n > 9)
then (
digOfIntHelper (n / 10) ((n mod 10)::l) )
else (
n :: l )
else ( 
[] )
in
digOfIntHelper n []

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

bad:
let digitsOfInt n =  
let rec digOfIntHelper n l = 
if n > 0 
then (
match n > 9 with
| false -> n :: l
| true  -> digOfIntHelper (n / 10) ((n mod 10)::l))
else ( 
[] )
in
digOfIntHelper n []
Error: Syntax error: operator expected.



hw1 palindrome

fix:
let rec palindrome w = 
match w with
| []    -> 
(match listReverse(w) with
| []  -> true
| _   -> false)
| h::t  ->
(match listReverse(w) with
| []      -> true
| h2::t2  -> if (h2 = h)
then (
palindrome t )
else (
false ) )

let _ = palindrome "malayalam"

let _ = palindrome "myxomatosis"

bad:
let palindrome w = 
match w with
| []    -> 
(match listReverse(w) with
| []  -> true
| _   -> false)
| h::t  ->
(match listReverse(w) with
| []      -> true
| h2::t2  -> if (h2 = h)
then (
palindrome t )
else (
false ) )
Error: Unbound value h1


let rec palindrome w = 
match w with
| []    -> 
(match listReverse(w) with
| []  -> true
| _   -> false)
| h::t  ->
(match listReverse(w) with
| []      -> true
| h2::t2  -> if (h2 = h)
then (
palindrome t )
else (
false ) )
Error: Unbound value palindrome



hw1 palindrome

fix:
let rec palind w = 
match w with
| []    -> 
(match listReverse(w) with
| []  -> true
| _   -> false)
| h::t  ->
(match listReverse(w) with
| []      -> true
| h2::t2  -> if (h2 = h)
then (
palind t )
else (
false ) )

let palindrome w = palind (explode w)

bad:
let palindrome w = palind (explode w)
Error: This expression has type string but an expression was expected of type
         'a list


let rec palind w = 
match w with
| []    -> 
(match listReverse(w) with
| []  -> true
| _   -> false)
| h::t  ->
(match listReverse(w) with
| []      -> true
| h2::t2  -> if (h2 = h)
then (
palind t )
else (
false ) )
Error: Unbound value palind



hw1 listReverse

fix:
let listReverse l = lReverse (l, [])

let rec lReverse (l, rl) = 
match l with
| []    -> rl
| h::t  -> lReverse (t, h::rl)

let _ = listReverse [1; 2; 3; 4]

let _ = listReverse ["a"; "b"; "c"; "d"]

bad:
let listReverse l =
let rec reverseHelper l rl = 
match l with
| []    -> rl
| h::t  -> reverseHelper t ( h::rl ) 
in
reverseHelper l []
Error: Unbound value reverseHelper



hw2 assoc

fix:
let rec assoc (d,k,l) = match l with
| []        -> d
| (n,v)::t  -> if k = n 
then v
else assoc (d,k,t)

bad:
let rec assoc (d,k,l) = match (d,k,l with
| []        -> d
| (n,v)::t  -> if k = n 
then v
else assoc (d,k,t)
Characters 30-31:
  let rec assoc (d,k,l) = match (d,k,l with
                                ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let fixpoint (f,b) = let (b', c) =  (f(b), f(b)<>b)
in
wwhile ((b', c) ,b)
Error: Unbound value fixpoint


let fixpoint (f,b) = wwhile (f ,b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let fixpoint (f,b) = wwhile ( (b, b<>f(b)) ,b)
Error: This expression has type int -> int
       but an expression was expected of type int -> int * bool
       Type int is not compatible with type int * bool 


let fixpoint (f,b) = let b' = f(b) 
in
(b', f(b)<>b)
in
wwhile ( f ,b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = let b' = f(b) 
in
(b', f(b)<>b)
in
wwhile ( f ,b)
Error: Unbound value f


let fixpoint (f,b) = let b' = f(b) 
in
(b', f(b)<>b)
in
wwhile ( f ,b)
Error: Unbound value f


let fixpoint (f,b) = let f b = let b' = f(b) 
in
(b', f(b)<>b)
in
wwhile (f ,b)
Error: Unbound value f



hw2 exprToString

fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

let _ = exprToString sampleExpr1

bad:
let rec exprToString e = 
VarX		      -> "x"
| VarY			-> "y"
| Sine(x)		-> "sin(pi*" ^ (exprToString x) ^ ")"
| Cosine(x)		-> "cos(pi*" ^ (exprToString x) ^ ")"
| Average(x1,x2)	-> "((" ^ (exprToString x1) ^ "+" ^ (exprToString x2) ^ ")/2)"
| Times(x1,x2)		-> (exprToString x1) ^ "*" ^ (exprToString x2)
| Thresh(x1,x2,x3,x4)	-> "(" ^ (exprToString x1) ^ "<" ^ (exprToString x2) 
^ "?" ^ (exprToString x3) ^ ":" ^ (exprToString x4)
Error: Unbound value exprToString


let rec exprToString e = 
VarX _ 		      -> "x"
| VarY _		-> "y"
| Sine(x)		-> "sin(pi*" ^ (exprToString x) ^ ")"
| Cosine(x)		-> "cos(pi*" ^ (exprToString x) ^ ")"
| Average(x1,x2)	-> "((" ^ (exprToString x1) ^ "+" ^ (exprToString x2) ^ ")/2)"
| Times(x1,x2)		-> (exprToString x1) ^ "*" ^ (exprToString x2)
| Thresh(x1,x2,x3,x4)	-> "(" ^ (exprToString x1) ^ "<" ^ (exprToString x2) 
^ "?" ^ (exprToString x3) ^ ":" ^ (exprToString x4)
Error: Syntax error


let rec exprToString e = match e with
VarX   		      -> "x"
| VarY  		-> "y"
| Sine(x)		-> "sin(pi*" ^ (exprToString x) ^ ")"
| Cosine(x)		-> "cos(pi*" ^ (exprToString x) ^ ")"
| Average(x1,x2)	-> "((" ^ (exprToString x1) ^ "+" ^ (exprToString x2) ^ ")/2)"
| Times(x1,x2)		-> (exprToString x1) ^ "*" ^ (exprToString x2)
| Thresh(x1,x2,x3,x4)	-> "(" ^ (exprToString x1) ^ "<" ^ (exprToString x2) 
^ "?" ^ (exprToString x3) ^ ":" ^ (exprToString x4)
Error: Syntax error



hw2 eval

fix:
let rec eval (e,x,y) = match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.

) 


bad:
let rec eval (e,x,y) = match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x)		-> sin (eval (pi *. x) )
| Cosine(x)		-> cos (pi *. (eval x) )
| Average(x1,x2)	-> ( (eval x1) +. (eval x2) ) /. 2.
Error: Syntax error


) 

Error: This expression has type expr but an expression was expected of type
         float


let rec eval (e,x,y) = match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y ) ) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y ) ) )
| Average(x1,x2)	-> ( (eval x1) +. (eval x2) ) /. 2.
Error: Syntax error


) 

Error: This expression has type expr but an expression was expected of type
         expr * float * float



hw2 eval

fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr,0.5,0.2)

bad:
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> "(" ^ (exprToString x1) ^ "<" ^ (exprToString x2) 
^ "?" ^ (exprToString x3) ^ ":" ^ (exprToString x4) ^ ")"
Error: Syntax error


let rec eval (e,x,y) = match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> "(" ^ (exprToString x1) ^ "<" ^ (exprToString x2) 
^ "?" ^ (exprToString x3) ^ ":" ^ (exprToString x4) ^ ")"
Error: Syntax error


let rec eval (e,x,y) = match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> (eval (x1,x,y )) < (eval (x2,x,y )) 
? (eval (x3,x,y )) : (eval (x4,x,y ))
Error: This expression has type string but an expression was expected of type
         float


let rec eval (e,x,y) = match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> (eval (x1,x,y )) < (eval (x2,x,y )) ? (eval (x3,x,y )) : (eval (x4,x,y ))
Error: Syntax error


let rec eval (e,x,y) = match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> ((eval (x1,x,y )) < (eval (x2,x,y )) 
? (eval (x3,x,y )) : (eval (x4,x,y )))
Error: Syntax error


let rec eval (e,x,y) = match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> (eval (x1,x,y )) <. (eval (x2,x,y )) 
? (eval (x3,x,y )) : (eval (x4,x,y ))
Error: Syntax error: operator expected.


let rec eval (e,x,y) = match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> (eval (x1,x,y )) < (eval (x2,x,y )) 
? eval (x3,x,y ) : (eval (x4,x,y ))
Error: Syntax error


let rec eval (e,x,y) = match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> (eval (x1,x,y )) < (eval (x2,x,y )) 
? eval (x3,x,y ) : eval (x4,x,y )
Error: Syntax error


let rec eval (e,x,y) = match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> (eval (x1,x,y )) < (eval (x2,x,y )) 
? eval (x3,x,y ) : eval (x4,x,y )
Error: Syntax error


let rec eval (e,x,y) = match e with
VarX   		      -> x
| VarY  		-> y 
| Sine(x1)		-> sin (pi *. (eval (x1,x,y )) )
| Cosine(x1)		-> cos (pi *. (eval (x1,x,y )) )
| Average(x1,x2)	-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.
| Times(x1,x2)		-> (eval (x1,x,y )) *. (eval (x2,x,y ))
| Thresh(x1,x2,x3,x4)	-> if (eval (x1,x,y )) < (eval (x2,x,y )) 
then eval (x3,x,y ) 
else eval (x4,x,y )
Error: Syntax error



hw2 build

fix:
let rec build (rand, depth) = match depth with
| 0   -> ( match (rand 1 3 ) with
| 1 -> buildX()
| 2 -> buildY() 
)
| _   -> ( match (rand 1 5 ) with
| 1 -> buildSine(build(rand,depth-1))
| 2 -> buildCosine(build(rand,depth-1))
| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),
build(rand,depth-1),build(rand,depth-1))
)

bad:
let rec build (rand, depth) = match depth with
| 0   -> ( match (rand 1 3 ) with
| 1 -> buildX()
| 2 -> buildY() 
)
| _   -> ( match (rand 1 4 ) with
| 1 -> buildThresh(build(rand,depth-1),build(rand,depth-1),
build(rand,depth-1),build(rand,depth-1))
| 2 -> buildSine(build(rand,depth-1))
| 3 -> buildCos(build(rand,depth-1))
| 4 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
)
Error: Unbound value buildSin
Hint: Did you mean buildSine?
Error: Unbound value buildSin
Hint: Did you mean build, buildY or buildX?
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value buildSin
Hint: Did you mean buildSine?


let rec build (rand, depth) = match depth with
| 0   -> ( match (rand 1 3 ) with
| 1 -> buildX()
| 2 -> buildY() 
)
| _   -> ( match (rand 1 4 ) with
| 1 -> buildThresh(build(rand,depth-1),build(rand,depth-1),
build(rand,depth-1),build(rand,depth-1))
| 2 -> buildSine(build(rand,depth-1))
| 3 -> buildCosine(build(rand,depth-1))
| 4 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
)
Error: Unbound value buildCos
Hint: Did you mean build, buildCosine, buildY or buildX?
Error: Unbound value buildCos
Hint: Did you mean build, buildX or buildY?
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value buildCos
Hint: Did you mean build, buildCosine, buildY or buildX?



hw2 build

fix:
let rec build (rand, depth) = match depth with
| 0   -> ( match (rand (1,3) ) with
| 1 -> buildX()
| _ -> buildY() 
)
| _   -> ( match (rand (1,5) ) with
| 1 -> buildSine(build (rand,depth-1) )
| 2 -> buildCosine(build(rand,depth-1))
| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),
build(rand,depth-1),build(rand,depth-1))
)

bad:
let rec build (rand, depth) = match depth with
| 0   -> ( match (rand 1 3 ) with
| 1 -> buildX()
| _ -> buildY() 
)
| _   -> ( match (rand 1 5 ) with
| 1 -> buildSine(build (rand,depth-1) )
| 2 -> buildCosine(build(rand,depth-1))
| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),
build(rand,depth-1),build(rand,depth-1))
)
Error: Syntax error



hw2 ???

fix:
let c2 = (11,3131,73)

let c3 = (12,31331,73373)

bad:
let c3 = (12,31331,73373) 


doRandomColor (g1())
Error: This expression has type int * int * int
       This is not a function; it cannot be applied.


let c2 = (11,3131,73) 



doRandomColor (g1())
Error: This expression has type int * int * int
       This is not a function; it cannot be applied.



hw2 ???

fix:
let _ () = doRandomColor (c1 )

bad:
let _ = doRandomColor (c1 ())
Error: This expression has type int * int * int
       This is not a function; it cannot be applied.
Error: Unbound constructor VarX
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int * int * int
       This is not a function; it cannot be applied.


let _ = doRandomColor (c1 )
Error: This expression has type int * int * int
       This is not a function; it cannot be applied.
Error: Unbound constructor VarX
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int * int * int
       This is not a function; it cannot be applied.



hw2 ???

fix:
let _ = doRandomColor (c2 )

bad:
let _ = doRandomColor (c1 )
Error: Syntax error



hw2 exprToString

fix:
let rec exprToString e = match e with
VarX   		      -> "x"
| VarY  		-> "y"
| Sine(x)		-> "sin(pi*" ^ (exprToString x) ^ ")"
| Cosine(x)		-> "cos(pi*" ^ (exprToString x) ^ ")"
| Average(x1,x2)	-> "((" ^ (exprToString x1) ^ "+" ^ (exprToString x2) ^ ")/2)"
| Times(x1,x2)		-> (exprToString x1) ^ "*" ^ (exprToString x2)
| Thresh(x1,x2,x3,x4)	-> "(" ^ (exprToString x1) ^ "<" ^ (exprToString x2) 
^ "?" ^ (exprToString x3) ^ ":" ^ (exprToString x4) ^ ")"
| CosE(x1,x2,x3)	-> "cos(pi*" ^ (exprToString x1) ^ "*" ^ (exprToString x2) ^ ")e^(-pi*" 
^ (exprToString x3) ^ "^2)"

bad:
let rec exprToString e = match e with
VarX   		      -> "x"
| VarY  		-> "y"
| Sine(x)		-> "sin(pi*" ^ (exprToString x) ^ ")"
| Cosine(x)		-> "cos(pi*" ^ (exprToString x) ^ ")"
| Average(x1,x2)	-> "((" ^ (exprToString x1) ^ "+" ^ (exprToString x2) ^ ")/2)"
| Times(x1,x2)		-> (exprToString x1) ^ "*" ^ (exprToString x2)
| Thresh(x1,x2,x3,x4)	-> "(" ^ (exprToString x1) ^ "<" ^ (exprToString x2) 
^ "?" ^ (exprToString x3) ^ ":" ^ (exprToString x4) ^ ")"
| CosE(x1,x2,x3)	-> "cos(pi*" ^ (exprToString x1) ^ "*" ^ (exprToString x1) ^ ")e^(-pi*" 
^ (exprToString x1) ^ "^2)"
Error: This expression has type expr but an expression was expected of type
         float



hw2 build

fix:
let rec build (rand, depth) = match depth with
| 0 -> ( match (rand (1,3) ) with
| 1 -> buildX()
| _ -> buildY()
)
| _ -> ( match (rand (5,8) ) with
| 1 -> buildSine( build (rand, depth-1) )
| 2 -> buildCosine(  build (rand, depth-1) )
| 3 -> buildTimes( build (rand, depth-1), build (rand, depth-1) )
| 4 -> buildAverage(  build (rand, depth-1), build (rand, depth-1) )
| 5 -> buildSine( build (rand, depth-1) )
| 6 -> buildCosine(  build (rand, depth-1) )
| 7 -> buildCosE(build (rand, depth-1), build (rand, depth-1), build (rand, depth-1) )
)

let g1 = (12,1441,5311)

let g2 = (12,1627,3507)

let g3 = (12,1219,5301)

let c1 = (12,33,3703)

let c2 = (12,31,7113)

let c3 = (12,3351,7373)

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

let emitColor (f1,f2,f3,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_c_"^name) in
let chan = open_out (fname^".ppm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P6 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z1 = f1 (x,y) in
let z2 = f2 (x,y) in
let z3 = f3 (x,y) in

(* Convert the result to a grayscale value *)
let iz1 = toIntensity(z1) in
let iz2 = toIntensity(z2) in
let iz3 = toIntensity(z3) in

(* Emit one byte per color for this pixel *)
output_char chan (char_of_int iz1);
output_char chan (char_of_int iz2);
output_char chan (char_of_int iz3);
)) in  
close_out chan;
ignore(Sys.command ("convert "^fname^".ppm  "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".ppm"))

let doRandomColor (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand (seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e1 = build (g, depth) in
let e2 = build (g, depth) in
let e3 = build (g, depth) in

let _ = Format.printf "red   = %s \n" (exprToString e1) in
let _ = Format.printf "green = %s \n" (exprToString e2) in
let _ = Format.printf "blue  = %s \n" (exprToString e3) in

let f1 = eval_fn e1 in
let f2 = eval_fn e2 in
let f3 = eval_fn e3 in

(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitColor (f1,f2,f3,n,name)

let _ = doRandomColor (c1 )

let _ = doRandomColor (c2 )

let _ = doRandomColor (c3 )

let _ = doRandomGray (g1 )

let _ = doRandomGray (g2 )

let _ = doRandomGray (g3 )

bad:
let rec build (rand, depth) = match depth with
| 0 -> ( match (rand (1,3) ) with
| 1 -> buildX()
| _ -> buildY()
)
| _ -> ( match (rand (5,8) ) with
| 1 -> buildSine( build (rand, depth-1) )
| 2 -> buildCosine(  build (rand, depth-1) )
| 3 -> buildTimes( build (rand, depth-1), build (rand, depth-1) )
| 4 -> buildAverage(  build (rand, depth-1), build (rand, depth-1) )
| 5 -> buildSine( build (rand, depth-1) )
| 6 -> buildCosine(  build (rand, depth-1) )
| 7 -> buildCosE(build (rand, depth-1), build (rand, depth-1), build (rand, depth-1) )
)
Error: Unbound value doRandomGray



hw3 sqsum

fix:
let sqsum xs = 
let f a x = x * x + a in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

bad:
let sqsum xs = 
let f a x = a * a + in
let base = 0 in
List.fold_left f base xs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = f in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = a in
List.fold_left f base fs
Error: Unbound value a


let pipe fs = 
let f a x = x a in
let base = x in
List.fold_left f base fs
Error: Unbound value x



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = f in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = base in
List.fold_left f base fs
Error: Unbound value base


let pipe fs = 
let f a x = x a in
let base = + in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = x a in
let base = _ in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = f in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This function has type (unit -> unit) list -> unit
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = (+) in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> ('a -> 'b) -> 'b
       but an expression was expected of type int


let pipe fs = 
let f a x = x a in
let base = (_) in
List.fold_left f base fs
Error: Syntax error: operator expected.


let pipe fs = 
let f a x = x a in
let base =  in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x (a) in
let base = () in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int -> int -> int
       but an expression was expected of type int


let pipe fs = 
let f a x = a x in
let base = a in
List.fold_left f base fs
Error: Unbound value a


let pipe fs = 
let f a x = a x in
let base = x in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = a x in
let base = f in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = x (a) in
let base = f in
List.fold_left f base fs

let _ = pipe [] 3

bad:
let _ = pipe [] 3
Error: This function has type (unit -> unit) list -> unit
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This function has type (unit -> unit) list -> unit
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe fs = 
let f a x = x (a) in
let base = (+) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x (a) in
let base = + in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x (a ) in
let base = fun x->x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x (a) in
let base = 0(+) in
List.fold_left f base fs
Error: This expression has type int
       This is not a function; it cannot be applied.


let pipe fs = 
let f a x = x (a) in
let base = 0(+) in
List.fold_left f base fs
Error: This expression has type int
       This is not a function; it cannot be applied.


let pipe fs = 
let f a x = x (a p) in
let base = p in
List.fold_left f base fs
Error: Unbound value p


let pipe fs p = 
let f a x = x (a p) in
let base = p in
List.fold_left f base fs
Error: This expression has type 'a but an expression was expected of type
         'a -> 'b
       The type variable 'a occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = fun p -> x (a p) in
let base = fun x->x in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h ^ sepConcat sep t  in
let base = h in
let l =  t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h ^ sep  in
let base = h in
let l =  sepConcat sep t in
List.fold_left f base l
Error: This expression has type string but an expression was expected of type
         'a list



hw3 stringOfList

fix:
let stringOfList f l = "[" ^ (sepConcat "; " (List.map f l) ) ^ "]"

bad:
let stringOfList f l = "[" ^ sepConcat "; " List.map f l ^ "]"
Error: This function has type string -> string list -> string
       It is applied to too many arguments; maybe you forgot a `;'.


let stringOfList f l = "[" ^ (sepConcat "; " List.map f l) ^ "]"
Error: This function has type string -> string list -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 clone

fix:
let rec clone x n = 
match n with 
| 0 -> []
| _ -> x :: (clone x (n-1) )

bad:
let rec clone x n = 
let helper = 
match n with
| 0 -> []
| _ -> x :: clone x n-1
Error: Syntax error


let rec clone x n = 
let helper = 
match n with
| 0 -> []
| _ -> x :: clone x n-1
in 
helper n
Error: This expression has type int but an expression was expected of type
         'a list


let rec clone x n = 
let helper = 
match n with
| 0 -> []
| _ -> x :: clone x (n-1)
in 
helper n
Error: This expression has type 'a list
       This is not a function; it cannot be applied.


let rec clone x n = 
let helper = 
match n with
| 0 -> []
| _ -> x :: helper n-1
in 
helper n
Error: Unbound value helper


let rec clone x n = 
let rec helper = 
match n with
| 0 -> []
| _ -> x :: helper n-1
in 
helper n
Error: This expression has type 'a list
       This is not a function; it cannot be applied.


let rec clone x n = 
let rec helper = 
match n with
| 0 -> []
| _ -> x :: (helper n-1)
in 
helper n
Error: This expression has type 'a list
       This is not a function; it cannot be applied.


let rec clone x n = 
let rec helper = 
match n with
| 0 -> []
| _ -> helper n-1
in 
helper n
Error: This expression has type 'a list
       This is not a function; it cannot be applied.


let rec clone x n = 
let rec helper n = 
match n with
| 0 -> []
| _ -> helper n-1
in 
helper n
Error: This expression has type 'a list
       but an expression was expected of type int


let rec clone x n = 
match n with 
| 0 -> []
| _ -> x :: (clone x n-1)
Error: This expression has type 'a list
       but an expression was expected of type int



hw1 ???

fix:
type test = unit -> string

let key        = ""

let prefix130  = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)); ErrorCode "exception")

let scoreMsg () = 
Printf.sprintf "Results: Score/Max = %d / %d \n" !score !max

bad:
type test = unit -> strin
Error: Unbound type constructor strin
Hint: Did you mean string?



hw1 sumList

fix:
let rec sumList xs = match xs with
[] -> 0 
| h::t -> h + sumList t

bad:
let rec sumList xs = match sumList with
| h::t -> h + sumList t
Error: This pattern matches values of type 'a list
       but a pattern was expected which matches values of type 'b -> 'c


let rec sumList xs = match sumList with
[] -> 0 
| h::t -> h + sumList t
Error: This pattern matches values of type 'a list
       but a pattern was expected which matches values of type 'b -> 'c


let rec sumList xs = match sumList with
[] -> 0 
| h::t -> h + sumList t
Error: This pattern matches values of type 'a list
       but a pattern was expected which matches values of type 'b -> 'c



hw1 digitsOfInt

fix:
let _ = digitsOfInt (-2)

bad:
let _ = digitsOfInt -2
Error: This expression has type int -> int list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let rec digitsOfInt n =
if n < 0 then []
else
let rec loop n acc =
if n = 0 then acc
else loop (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> loop n []

bad:
let rec digitsOfInt n = 
if n < 0 then []
Error: This variant expression is expected to have type unit
       The constructor [] does not belong to type unit


let rec digitsOfInt n = 
if n < 0 -> []
Error: Syntax error


let rec digitsOfInt n = 
if n < 0 then -> []
Error: Syntax error


let rec digitsOfInt n = 
when n < 0 -> []
Error: Syntax error


let rec digitsOfInt n =
if n < 0 then []
Error: This variant expression is expected to have type unit
       The constructor [] does not belong to type unit



hw1 ???

fix:
let _ = digits (-31243)

bad:
let _ = digits -31243
Error: This expression has type int -> int list
       but an expression was expected of type int



hw1 additivePersistence

fix:
let additivePersistence n = 
digits n

bad:
let additivePersistence n = 
let digits n = x in
sumList x
Error: Unbound value x


let additivePersistence n = 
digits n
sumList n
Error: This function has type int -> int list
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 additivePersistence

fix:
let additivePersistence n = 
sumList (digits n)

bad:
let additivePersistence n = 
digits n = n
Error: This expression has type int but an expression was expected of type
         int list



hw1 digitalRoot

fix:
let rec digitalRoot n = 
if sumList (digits n) > 9
then digitalRoot (sumList (digits n))
else sumList (digits n)

bad:
let digitalRoot n = 
let x = sumList (digits n) in
if x > 9
then digitalRoot x
else sumList x
Error: This expression has type int but an expression was expected of type
         int list
Error: Unbound value sumList
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int but an expression was expected of type
         int list


let rec digitalRoot n = 
let x = sumList (digits n) in
if x > 9
then digitalRoot x
else sumList x
Error: This expression has type int but an expression was expected of type
         int list



hw1 listReverse

fix:
let listReverse l = 
let rec aux acc = function
| [] -> acc
| h::t -> aux (h::acc) t in
aux [] l

bad:
let listReverse l = 
let rec aux acc = function
| [] -> acc
| h::t -> aux (h::acc) t in
aux [] list
Error: Unbound value list



hw1 digitalRoot

fix:
let additivePersistence n = 
let rec helper n count =
let rec digitalRoot n =
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else count
in digitalRoot n
in helper n 0

bad:
let additivePersistence n = 
let rec helper n count = function
digitalRoot n
Error: Syntax error


let additivePersistence n = 
let rec helper n count = 
digitalRoot n
Error: Syntax error


let additivePersistence n = 
let rec helper n count = 
let rec digitalRoot n =
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else sumList (digits n)
Error: Syntax error


let additivePersistence n = 
let rec helper n count = 
let rec digitalRoot n =
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else sumList (digits n)
in helper n 0
Error: Syntax error


let additivePersistence n = 
let rec helper n count = 
let rec digitalRoot n =
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else sumList (digits n)
in helper n 0
Error: Syntax error


let additivePersistence n = 
let rec helper n count = 
let rec digitalRoot n =
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else sumList (digits n)
in helper n 0
Error: Syntax error


let additivePersistence n = 
let rec helper n count = 
let rec digitalRoot n =
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else count
in helper n 0
Error: Syntax error


let additivePersistence n = 
let rec helper n count = 
digitalRoot n =
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else count
in helper n 0
Error: This expression has type bool but an expression was expected of type
         int
Error: Unbound value sumList
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type bool but an expression was expected of type
         int


let additivePersistence n = 
let rec helper n count = function
digitalRoot n =
if sumList (digits n) > 9
then helper (sumList (digits n)) (count+1)
else count
in helper n 0
Error: Syntax error



hw1 listReverse

fix:
let listReverse l = 
let rec helper xs = function
| [] -> []
| hd::tl -> helper (hd::xs) tl
in helper [] l

bad:
let listReverse l = 
let rec helper xs = match xs with
| [] -> []
| hd::tl -> helper (hd::xs) tl
in helper [] l
Error: This function has type 'a list -> 'b list
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 listReverse

fix:
let listReverse l = 
let rec helper xs = function
| [] -> xs
| hd::tl -> helper (hd::xs) tl
in helper [] l

bad:
let listReverse l = 
let rec helper xs = function
| [] -> xs
| hd::tl -> helper (hd::xs) 
in helper [] l
Error: This expression has type 'a list -> 'a list
       but an expression was expected of type 'a list



hw1 listReverse

fix:
let listReverse l = 
let rec helper xs l  = match l with
| [] -> []
| hd::tl -> helper (hd::xs) l
in helper [] l

bad:
let listReverse l = 
let rec helper xs n  = function
| [] -> xs
| hd::tl -> helper (hd::xs) tl
in helper [] l
Error: This expression has type 'a list -> 'a list
       but an expression was expected of type 'a list


let listReverse l = 
let rec helper xs l  = match n with
| [] -> []
| hd::tl -> helper (hd::xs) l
in helper [] l
Error: Unbound value n



hw1 listReverse

fix:
let rec reverse res list = match list with
| [] -> []
| hd::tl -> reverse (hd::res) list

let listReverse l = reverse [] list

bad:
let rec reverse res list = match list with
| [] -> []
| hd:tl -> reverse (hd::res) list
Error: This expression has type 'a list -> 'b list
       but an expression was expected of type 'b list


let listReverse l = reverse [] list
Error: Syntax error



hw1 listReverse

fix:
let rec helper xs list  = match list with
| [] -> []
| hd::tl -> helper (hd::xs) 
in helper [] l

let _ = listReverse [1; 2; 3; 4]

bad:
let listReverse l = reverse [] l
Error: Unbound value list



hw1 digitsOfInt

fix:
let rec mylength xs = match xs with
| [] -> 0
| hd::tl -> 1 + mylength tl

let digitsOfInt n =
let rec digits n x list =
if n < 10 then n :: list
else digits (n/10 + n mod 10) (mylength n/10 + n mod 10) list
in digits n (mylength n) []

bad:
let digitsOfInt n =
let rec digits n x list =
if n < 10 then n :: list
else digits (n/10 + n mod 10) (mylength n/10 + n mod 10) list
in digits n (mylength n) []
Characters 37-38:
  let rec digits n (mylength n) list =
                   ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw1 ???

fix:
let num_of_digits xs =
let y = log10 (float_of_int xs)
in y + 1

bad:
let num_of_digits xs =
(log 10 (xs)) + 1
Error: This function has type float -> float
       It is applied to too many arguments; maybe you forgot a `;'.


let num_of_digits xs =
log10 xs + 1
Error: This function has type float -> float
       It is applied to too many arguments; maybe you forgot a `;'.


let num_of_digits xs =
log10 float_of_int xs + 1
Error: This expression has type float but an expression was expected of type
         int


let num_of_digits xs =
log10 (float_of_int xs) + 1
Error: This function has type float -> float
       It is applied to too many arguments; maybe you forgot a `;'.


let num_of_digits xs =
log10 (int_of_float xs) + 1
Error: This expression has type float but an expression was expected of type
         int


let num_of_digits xs =
log10 (int_of_float xs)
Error: This expression has type int but an expression was expected of type
         float


let num_of_digits xs =
log10 (float_of_int xs)
Error: This expression has type int but an expression was expected of type
         float



hw1 ???

fix:
num_of_digits 10

bad:
let num_of_digits xs =
let y = log10 (float_of_int xs)
in (int_of_float y) + 1
Error: This expression has type float but an expression was expected of type
         int



hw1 digitsOfInt

fix:
let _ = digitsOfInt 3124

bad:
let digitsOfInt n =
let rec digits x l =
let numdig = num_of_digits x in
if numdig > 1
then x/(10** numdig -1) mod 10 :: l
else numdig :: 1
in digits n []
Error: This expression has type int but an expression was expected of type
         float


let digitsOfInt n =
let rec digits x l =
let numdig = num_of_digits x in
if numdig > 1
then x/(int_of_float 10 ** numdig -1) mod 10 :: l
else numdig :: 1
in digits n []
Error: This expression has type int but an expression was expected of type
         float


let digitsOfInt n =
let rec digits x l =
let numdig = num_of_digits x in
if numdig > 1
then x/(float_of_int 10 ** numdig -1) mod 10 :: l
else numdig :: 1
in digits n []
Error: This expression has type int but an expression was expected of type
         float


let digitsOfInt n =
let rec digits x l =
let numdig = num_of_digits x in
if numdig > 1
then x/(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: l
else numdig :: 1
in digits n []
Error: This expression has type int but an expression was expected of type
         float


let digitsOfInt n =
let rec digits x l =
let numdig = num_of_digits x in
if numdig > 1
then x/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: l
else numdig :: 1
in digits n []
Error: This expression has type float but an expression was expected of type
         int


let digitsOfInt n =
let rec digits x l =
let numdig = num_of_digits x in
if numdig > 1
then x/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: l
else numdig :: l
in digits n []
Error: This expression has type int but an expression was expected of type
         int list



hw1 digitsOfInt

fix:
let _ = digitsOfInt 3124

bad:
let digitsOfInt n =
let rec digits x l =
let numdig = num_of_digits x in
if numdig > 1
then x/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: 
(digits (x/10) l)
else numdig :: l
in digits n []
Error: This expression has type 'a -> int list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let _ = digitsOfInt 3124

bad:
let digitsOfInt n =
if n < 10 then n :: []
else
(digitsOfInt n/10) :: [n/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10]
Error: Syntax error


let digitsOfInt n =
if n < 10 then n :: []
else
(digitsOfInt (n/10)) :: [n/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10]
Error: This expression has type int list
       but an expression was expected of type int


let digitsOfInt n =
if n < 10 then n :: []
else
(digitsOfInt (n/10)) @ [n/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10]
Error: This expression has type int list
       but an expression was expected of type int


let digitsOfInt n =
if n < 10 then n :: []
else
(digitsOfInt (n/10)) @ [n/int_of_float(float_of_int 10 ** float_of_int (num_of_digits x -1)) mod 10]
Error: Unbound value numdig


let digitsOfInt n =
if n < 10 then n :: []
else
(digitsOfInt (n/10)) @ [n/int_of_float(float_of_int 10 ** float_of_int (num_of_digits n -1)) mod 10]
Error: Unbound value x
Error: Unbound value num_of_digits
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value x



hw1 digitsOfInt

fix:
let _ = digitsOfInt 122

bad:
let digitsOfInt n =
if n < 10 then n :: []
else (digitsOfInt (n/10))
match n with
| hd::tl -> hd
:: [n mod 10]
Error: This expression has type int list
       but an expression was expected of type int
Error: Unbound value num_of_digits
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int list
       but an expression was expected of type int


let digitsOfInt n =
if n < 10 then n :: []
else match n with
| hd::tl -> hd
(digitsOfInt (n/10)) :: [n mod 10]
Error: Syntax error


let digitsOfInt n =
if n < 10 then n :: []
else match n with
| (digitsOfInt (n/10)) :: [n mod 10]
Error: This pattern matches values of type 'a list
       but a pattern was expected which matches values of type int
Error: Unbound value num_of_digits
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This pattern matches values of type 'a list
       but a pattern was expected which matches values of type int


let digitsOfInt n =
if n < 10 then n :: []
else
(digitsOfInt (n/10)) :: [n mod 10]
Characters 63-64:
  | (digitsOfInt (n/10)) :: [n mod 10];;
    ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let digitsOfInt n =
let rec recurse x l =
if x < 10 then x :: l
else
recurse (x/10) [n mod 10]
in recurse n []
Error: This expression has type int list
       but an expression was expected of type int
Error: Unbound value num_of_digits
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int list
       but an expression was expected of type int



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let listReverse l = 
let rec recurse x xs = match x with
| [] -> []
| hd::tl -> recurse tl (hd::xs)
in recurse l []
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw2 removeDuplicates

fix:
let _ = removeDuplicates [1]

bad:
let _ = removeDuplicates [1];

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]
Error: Syntax error



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = 
if (List.mem h seen)
then (h :: seen)
else seen
in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = 
if (List.mem h seen)
then seen
in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This expression has type 'a list
       but an expression was expected of type unit



hw2 build

fix:
let buildX()                       = VarX

let buildY()                       = VarY

let buildSine(e)                   = Sine(e)

let buildCosine(e)                 = Cosine(e)

let buildAverage(e1,e2)            = Average(e1,e2)

let buildTimes(e1,e2)              = Times(e1,e2)

let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)

let rec exprToString e = match e with
| Thresh (a,b,c,d) -> exprToString buildThresh(a,b,c,d)
| Times (a,b) -> exprToString buildTimes(a,b)
| Average (a,b) -> exprToString buildAverage(a,b)
| Cosine (a) -> exprToString buildCosine(a)
| Sine (a) -> exprToString buildSine(a)
| VarY -> exprToString buildY
| VarX -> exprToString buildX

bad:
let rec exprToString e = match e with
| Thresh (a,b,c,d) -> exprToString buildThresh(a,b,c,d)
| Times (a,b) -> exprToString buildTimes(a,b)
| Average (a,b) -> exprToString buildAverage(a,b)
| Cosine (a) -> exprToString buildCosine(a)
| Sine (a) -> exprToString buildSine(a)
| VarY -> exprToString buildY
| VarX -> exprToString buildX
| None -> 0
Error: This variant pattern is expected to have type expr
       The constructor None does not belong to type expr


let rec exprToString e = match e with
| Thresh (a,b,c,d) -> exprToString buildThresh(a,b,c,d)
| Times (a,b) -> exprToString buildTimes(a,b)
| Average (a,b) -> exprToString buildAverage(a,b)
| Cosine (a) -> exprToString buildCosine(a)
| Sine (a) -> exprToString buildSine(a)
| VarY -> exprToString buildY
| VarX -> exprToString buildX
Error: This expression has type expr * expr * expr * expr -> expr
       but an expression was expected of type expr



hw2 build

fix:
let rec exprToString e = match e with
| Thresh (a,b,c,d) -> let e' = buildThresh(a,b,c,d) in exprToString e'
| Times (a,b) -> let e' = buildTimes(a,b) in exprToString e'
| Average (a,b) -> let e' = buildAverage(a,b) in exprToString e'
| Cosine (a) -> let e' = buildCosine(a) in exprToString e'
| Sine (a) -> let e' = buildSine(a) in exprToString e'
| VarY -> exprToString VarX
| VarX -> exprToString VarY

bad:
let rec exprToString e = match e with
| Thresh (a,b,c,d) -> exprToString Thresh a,b,c,d
| Times (a,b) -> exprToString buildTimes(a,b)
| Average (a,b) -> exprToString buildAverage(a,b)
| Cosine (a) -> exprToString buildCosine(a)
| Sine (a) -> exprToString buildSine(a)
| VarY -> exprToString buildY
| VarX -> exprToString buildX
Error: This function has type expr -> 'a * 'b * 'c * 'd
       It is applied to too many arguments; maybe you forgot a `;'.


let rec exprToString e = match e with
| Thresh (a,b,c,d) -> exprToString Thresh (a,b,c,d)
| Times (a,b) -> exprToString buildTimes(a,b)
| Average (a,b) -> exprToString buildAverage(a,b)
| Cosine (a) -> exprToString buildCosine(a)
| Sine (a) -> exprToString buildSine(a)
| VarY -> exprToString buildY
| VarX -> exprToString buildX
Error: The constructor Thresh expects 4 argument(s),
       but is applied here to 0 argument(s)


let rec exprToString e = match e with
| Thresh (a,b,c,d) -> exprToString Thresh(a *b*c*d)
| Times (a,b) -> exprToString buildTimes(a,b)
| Average (a,b) -> exprToString buildAverage(a,b)
| Cosine (a) -> exprToString buildCosine(a)
| Sine (a) -> exprToString buildSine(a)
| VarY -> exprToString buildY
| VarX -> exprToString buildX
Error: The constructor Thresh expects 4 argument(s),
       but is applied here to 0 argument(s)


let rec exprToString e = match e with
| Thresh (a,b,c,d) -> exprToString buildThresh(a,b,c,d)
| Times (a,b) -> exprToString buildTimes(a,b)
| Average (a,b) -> exprToString buildAverage(a,b)
| Cosine (a) -> exprToString buildCosine(a)
| Sine (a) -> exprToString buildSine(a)
| VarY -> exprToString buildY
| VarX -> exprToString buildX
Error: This expression has type expr * expr * expr * expr -> expr
       but an expression was expected of type expr


let rec exprToString e = match e with
| Thresh (a,b,c,d) -> let a = buildThresh(a,b,c,d) in exprToString a
| Times (a,b) -> exprToString buildTimes(a,b)
| Average (a,b) -> exprToString buildAverage(a,b)
| Cosine (a) -> exprToString buildCosine(a)
| Sine (a) -> exprToString buildSine(a)
| VarY -> exprToString buildY
| VarX -> exprToString buildX
Error: This expression has type expr * expr -> expr
       but an expression was expected of type expr


let rec exprToString e = match e with
| Thresh (a,b,c,d) -> let e' = buildThresh(a,b,c,d) in exprToString e'
| Times (a,b) -> let e' = buildTimes(a,b) in exprToString e'
| Average (a,b) -> let e' = buildAverage(a,b) in exprToString e'
| Cosine (a) -> let e' = buildCosine(a) in exprToString e'
| Sine (a) -> let e' = buildSine(a) in exprToString e'
| VarY -> exprToString buildY
| VarX -> exprToString buildX
Error: This expression has type unit -> expr
       but an expression was expected of type expr



hw2 exprToString

fix:
let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

let _ = exprToString sampleExpr1

bad:
let rec exprToString e = match e with
| Thresh (a,b,c,d) -> "(" ^ exprToString a ^ "<" ^ exprToString b ^ "?" ^ exprToString c ^ ":" ^ exprToString d ^ ")"
| Times (a,b) -> exprToString a ^ "*" ^ exprToString b
| Average (a,b) -> "((" ^ exprToString a ^ "+" ^ exprToString b ^ ")/20"
| Cosine (a) -> "cos(pi*" ^ exprToString a ^ ")"
| Sine (a) -> "sin(pi*" ^ exprToString a ^ ")"
| VarY -> "x"
| VarX -> "y"
Error: This expression has type string
       This is not a function; it cannot be applied.



hw2 eval

fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, t))/2
| Cosine (a) -> cos ( pi * eval (a,x,y) )
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY -> x
| VarX -> y
Error: Syntax error


let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2
| Cosine (a) -> cos ( pi * eval (a,x,y) )
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY -> x
| VarX -> y
Error: Unbound value t


let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2
| Cosine (a) -> cos ( pi * eval (a,x,y) )
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY -> float_of_int x
| VarX -> float_of_int y
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2
| Cosine (a) -> cos ( pi * float_of_int eval (a,x,y) )
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2
| Cosine (a) -> cos ( pi * float_of_int (eval (a,x,y)) )
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2
| Cosine (a) -> int_of_float cos ( pi * float_of_int (eval (a,x,y)) )
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2
| Cosine (a) -> int_of_float cos( pi * float_of_int (eval (a,x,y)))
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y
Error: This function has type float -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2
| Cosine (a) ->  cos( pi * float_of_int (eval (a,x,y)))
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y
Error: This function has type float -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2
| Cosine (a) -> cos( pi * pi)
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) * eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2
| Cosine (a) -> cos( pi )
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> eval (a,x,y) ( *.) eval (b,x,y)
| Average (a,b) -> (eval (a,x,y) ( *.) eval (b, x, y))/2
| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> (eval (a,x,y)) ( *.) (eval (b,x,y))
| Average (a,b) -> (eval (a,x,y) ( *.) eval (b, x, y))/2
| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y
Error: This expression has type
         expr * 'a * 'b -> (float -> float -> float) -> 'c -> 'd -> 'e
       but an expression was expected of type 'c
       The type variable 'c occurs inside
       expr * 'a * 'b -> (float -> float -> float) -> 'c -> 'd -> 'e


let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))
| Average (a,b) -> (eval (a,x,y) ( *.) eval (b, x, y))/2
| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y
Error: This expression has type (float -> float -> float) -> 'a -> 'b
       but an expression was expected of type 'a
       The type variable 'a occurs inside
       (float -> float -> float) -> 'a -> 'b


let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))
| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y))/2
| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y
Error: This function has type expr * 'a * 'b -> float
       It is applied to too many arguments; maybe you forgot a `;'.


let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))
| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0
| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))
| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0
| Cosine (a) -> cos( pi * (eval (a,x,y)))
| Sine (a) -> sin (pi * eval (a,x,y) )
| VarY ->  x
| VarX ->  y
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| Thresh (a,b,c,d) -> eval (a,x,y)
| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))
| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0
| Cosine (a) -> cos( pi ** (eval (a,x,y)))
| Sine (a) -> sin (pi ** eval (a,x,y) )
| VarY ->  x
| VarX ->  y
Error: This expression has type float but an expression was expected of type
         int



hw2 eval

fix:
let _ = eval (Average(VarX,VarY), 0.5, 0.0)

bad:
let _ = eval (Sine(0.0))
Error: This expression has type expr but an expression was expected of type
         expr * float * float


let _ = eval (Sine(VarX ** VarY), 0.0, 0.0)
Error: This expression has type expr but an expression was expected of type
         expr * float * float


let _ = eval (Average(VarX,VarY)), 0.0, 0.0
Error: This expression has type expr but an expression was expected of type
         float


let _ = eval (Average(VarX,VarY), 0.0, 0.0)
Error: This expression has type expr but an expression was expected of type
         expr * float * float



hw2 eval

fix:
let _ = eval (Times(VarX,VarY), 3.0, 2.0)

bad:
let _ = eval (Times(VarX,VarY), 1.0, 2.0)
Error: This variant expression is expected to have type expr
       The constructor Time does not belong to type expr
Hint: Did you mean Times?



hw2 wwhile

fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let rec wwhile (f,b) = 
let f b -> (b',c')
if f b = (b',c')
then wwhile(f,b)
else wwhile(f,b)
Error: Unbound value b'


let rec wwhile (f,b) = 
let x = f b
Error: Syntax error


let rec wwhile (f,b) = 
let (b',c') = f b in
Error: Syntax error


let rec wwhile (f,b) = 
let (b',c') = f b in
if c'
then wwhile (f, b')
else b'
Error: Syntax error



hw2 ???

fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1
Error: Unbound value fixpoint



hw2 ???

fix:
let rand = makeRand(10,39) in rand(1,4)

bad:
let rand = makeRand(10,39) in 
let _ =  rand(1,4)
Error: Syntax error


let rand = makeRand(10,39) in rand(1,4)
Error: Syntax error



hw2 build

fix:
let g1 () = failwith "to be implemented"

let g2 () = failwith "to be implemented"

let g3 () = failwith "to be implemented"

let c1 () = failwith "to be implemented"

let c2 () = failwith "to be implemented"

let c3 () = failwith "to be implemented"

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

let _ = doRandomGray (10,10,34)

bad:
let rec build (rand, depth) = 
if depth = 0
then let x = rand(0,1) in match x with
| 0 -> buildX()
| 1 -> buildY()
else
let x = rand(5,10) in match x with
| 5 -> buildSine( build (rand, depth - 1) )
| 6 -> buildCosine( build (rand, depth - 1) )
| 7 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 9 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )
Error: Unbound value doRandomGray



hw2 build

fix:
let rec build (rand, depth) = 
if depth = 0
then let x = rand(1,10) in match x with
| 1 | 3 | 5 | 7 | 9 -> buildY()
| 2 | 4 | 6 | 8 | 10 -> buildX()
else
let x = rand(5,9) in match x with
| 6 -> buildSine( build (rand, depth - 1) )
| 7 -> buildCosine( build (rand, depth - 1) )
| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )

let g1 () = failwith "to be implemented"

let g2 () = failwith "to be implemented"

let g3 () = failwith "to be implemented"

let c1 () = failwith "to be implemented"

let c2 () = failwith "to be implemented"

let c3 () = failwith "to be implemented"

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

let _ = doRandomGray (10,10,34)

let _ = doRandomColor (5,2,10)

bad:
let rec build (rand, depth) = 
if depth = 0
then let x = rand(1,3) in match x with
| 1 -> buildX()
| 2 -> buildY()
else
let x = rand(5,9) in match x with
| 6 -> buildSine( build (rand, depth - 1) )
| 7 -> buildCosine( build (rand, depth - 1) )
| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )
Error: Unbound value doRandomColor


let rec build (rand, depth) = 
if depth = 0
then let x = rand(1,3) in match x with
| 0 -> buildY()
| 1 -> buildX()
| 2 -> buildY()
| 3 -> buildX()
else
let x = rand(5,9) in match x with
| 6 -> buildSine( build (rand, depth - 1) )
| 7 -> buildCosine( build (rand, depth - 1) )
| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )
Error: Unbound value buildX
Hint: Did you mean build?


let rec build (rand, depth) = 
if depth = 0
then let x = rand(1,10) in match x with
| 1 | 2 | 3 -> buildY()
| 1 -> buildX()
else
let x = rand(5,9) in match x with
| 6 -> buildSine( build (rand, depth - 1) )
| 7 -> buildCosine( build (rand, depth - 1) )
| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )
Error: Unbound value buildY
Hint: Did you mean build?


let rec build (rand, depth) = 
if depth = 0
then let x = rand(1,10) in match x with
| 1 | 3 | 5 | 7 | 9 -> buildY()
| 2 | 4 | 6 | 8 | 10 -> buildX()
else
let x = rand(5,9) in match x with
| 6 -> buildSine( build (rand, depth - 1) )
| 7 -> buildCosine( build (rand, depth - 1) )
| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )
Error: Unbound value buildY
Hint: Did you mean build?


let rec build (rand, depth) = 
if depth = 0
then let x = rand(1,10) in match x with
| 1 | 3 | 5 | 7 | 9 -> buildY()
| 2 | 4 | 6 | 8 | 10 | 0 -> buildX()
else
let x = rand(5,9) in match x with
| 6 -> buildSine( build (rand, depth - 1) )
| 7 -> buildCosine( build (rand, depth - 1) )
| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )
Error: Unbound value buildY
Hint: Did you mean build?



hw2 build

fix:
let g1 () = failwith "to be implemented"

let g2 () = failwith "to be implemented"

let g3 () = failwith "to be implemented"

let c1 () = failwith "to be implemented"

let c2 () = failwith "to be implemented"

let c3 () = failwith "to be implemented"

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

let _ = doRandomGray (10,10,34)

let _ = doRandomColor (8,2,10)

bad:
let rec build (rand, depth) = 
if depth = 0
then let x = rand(1,10) in match x with
| 1 | 3 | 5 | 7 | 9 -> buildY()
| 2 | 4 | 6 | 8 | 10 -> buildX()
else
let x = rand(1,10) in match x with
| 6 | 1 -> buildSine( build (rand, depth - 1) )
| 7 | 2 -> buildCosine( build (rand, depth - 1) )
| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )
Error: Unbound value doRandomColor



hw2 build

fix:
let g1 () = failwith "to be implemented"

let g2 () = failwith "to be implemented"

let g3 () = failwith "to be implemented"

let c1 () = failwith "to be implemented"

let c2 () = failwith "to be implemented"

let c3 () = failwith "to be implemented"

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

let _ = doRandomGray (8,10,34)

bad:
let rec build (rand, depth) = 
if depth = 0
then let x = rand(1,10) in match x with
| 1 .. 5 -> buildY()
| 6 .. 10 -> buildX()
else
let x = rand(1,10) in match x with
| 6 | 1 -> buildSine( build (rand, depth - 1) )
| 7 | 2 -> buildCosine( build (rand, depth - 1) )
| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )
Error: Unbound value doRandomColor


let rec build (rand, depth) = 
if depth = 0
then let x = rand(1,10) in 
if x < 5 then buildY()
else buildX()
else
let x = rand(1,10) in match x with
| 6 | 1 -> buildSine( build (rand, depth - 1) )
| 7 | 2 -> buildCosine( build (rand, depth - 1) )
| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )
Error: Only character intervals are supported in patterns.



hw2 build

fix:
let emitColor (f1,f2,f3,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_c_"^name) in
let chan = open_out (fname^".ppm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P6 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z1 = f1 (x,y) in
let z2 = f2 (x,y) in
let z3 = f3 (x,y) in

(* Convert the result to a grayscale value *)
let iz1 = toIntensity(z1) in
let iz2 = toIntensity(z2) in
let iz3 = toIntensity(z3) in

(* Emit one byte per color for this pixel *)
output_char chan (char_of_int iz1);
output_char chan (char_of_int iz2);
output_char chan (char_of_int iz3);
)) in  
close_out chan;
ignore(Sys.command ("convert "^fname^".ppm  "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".ppm"))

let doRandomColor (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand (seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e1 = build (g, depth) in
let e2 = build (g, depth) in
let e3 = build (g, depth) in

let _ = Format.printf "red   = %s \n" (exprToString e1) in
let _ = Format.printf "green = %s \n" (exprToString e2) in
let _ = Format.printf "blue  = %s \n" (exprToString e3) in

let f1 = eval_fn e1 in
let f2 = eval_fn e2 in
let f3 = eval_fn e3 in

(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitColor (f1,f2,f3,n,name)

let _ = doRandomColor (3,19,25)

bad:
let _ = 
let g = makeRand (19,25) in
let e1 = build (g, 3) in Format.printf "red   = %s \n" (exprToString e1)
Error: Unbound value doRandomColor



hw2 build

fix:
let rec build (rand, depth) = 
if depth = 0
then let x = rand(1,10) in match x with
| 1 | 3 | 5 | 7 | 9 -> buildY()
| 2 | 4 | 6 | 8 | 10 -> buildX()
else
let x = rand(1,10) in match x with
| 6 | 1 -> buildSine( build (rand, depth - 1) )
| 7 | 2 -> buildCosine( build (rand, depth - 1) )
| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )

let g1 () = failwith "to be implemented"

let g2 () = failwith "to be implemented"

let g3 () = failwith "to be implemented"

let c1 () = failwith "to be implemented"

let c2 () = failwith "to be implemented"

let c3 () = failwith "to be implemented"

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

let _ = doRandomGray (8,3,34)

let emitColor (f1,f2,f3,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_c_"^name) in
let chan = open_out (fname^".ppm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P6 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z1 = f1 (x,y) in
let z2 = f2 (x,y) in
let z3 = f3 (x,y) in

(* Convert the result to a grayscale value *)
let iz1 = toIntensity(z1) in
let iz2 = toIntensity(z2) in
let iz3 = toIntensity(z3) in

(* Emit one byte per color for this pixel *)
output_char chan (char_of_int iz1);
output_char chan (char_of_int iz2);
output_char chan (char_of_int iz3);
)) in  
close_out chan;
ignore(Sys.command ("convert "^fname^".ppm  "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".ppm"))

let doRandomColor (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand (seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e1 = build (g, depth) in
let e2 = build (g, depth) in
let e3 = build (g, depth) in

let _ = Format.printf "red   = %s \n" (exprToString e1) in
let _ = Format.printf "green = %s \n" (exprToString e2) in
let _ = Format.printf "blue  = %s \n" (exprToString e3) in

let f1 = eval_fn e1 in
let f2 = eval_fn e2 in
let f3 = eval_fn e3 in

(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitColor (f1,f2,f3,n,name)

let _ = doRandomColor (8,5,25)

bad:
let rec build (rand, depth) = 
if depth = 0
then let x = rand(1,10) in 
if x < 5 then buildY()
else buildX()
else
let x = rand(1,10) in match x with
| 6 | 1 -> buildSine( build (rand, depth - 1) )
| 7 | 2 -> buildCosine( build (rand, depth - 1) )
| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )
| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )
| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )
Error: Unbound value doRandomColor



hw2 assoc

fix:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

bad:
let rec assoc (d,k,l) = 
let rec helper (a,b,c) = match c with
| [] -> a
| (n,v)::t -> 
if n = b then v
else helper (a,b,t)
in helper (d,k,l)
Error: This expression has type ('a * 'b) list
       but an expression was expected of type 'a
       The type variable 'a occurs inside ('a * 'b) list



hw2 assoc

fix:
let _ = assoc (0, "hi", [("hi",3)])

bad:
let _ = assoc (0, "hi", [])
Error: Unbound value assox
Hint: Did you mean assoc?
Error: Unbound value assox
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value assox
Hint: Did you mean assoc?



hw2 assoc

fix:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

bad:
let rec assoc (d,k,l) = match l with
| [] -> d
| (n,v)::t -> 
if n = k then v
else assoc (d,k,t)
Error: Unbound value a



hw2 ???

fix:
let _ = doRandomGray (9, 2, 17)

bad:
let _ = doRandomGray (9, 1, 17)
Error: Syntax error



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a*a + x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a*a + x in
let base = [] in
List.fold_left f base xs
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a*a + x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = a**2 + x in
let base = 0 in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         float


let sqsum xs = 
let f a x = a^2 + x in
let base = 0 in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         string


let sqsum xs = 
let f a x = a^^2 + x in
let base = 0 in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         ('a, 'b, 'c, 'd, 'e, 'f) format6 =
           ('a, 'b, 'c, 'd, 'e, 'f) CamlinternalFormatBasics.format6



hw3 pipe

fix:
let pipe fs = 
let f a x = match x with
| x::xs' -> x a
in
let base = (fun _ x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = match x with
| [] -> (fun b -> b)
in
let base = 0 in
List.fold_left f base fs
Error: This expression has type int but an expression was expected of type
         'a -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x = match x with
| x::xs' -> ( fun z d -> x d)
in
let base = (fun _ y -> y) in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression should not be a function, the expected type is
(('a -> 'b -> 'b) -> 'a -> 'b -> 'b) list



hw3 pipe

fix:
let pipe fs = 
let f a x = (fun b a -> a x)in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         int -> int



hw3 pipe

fix:
let pipe fs = 
let f a x = (fun y -> a x)in
let base = (fun y -> y) in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This expression has type int but an expression was expected of type
         ('a -> 'b) -> 'b


let pipe fs = 
let f a x = (fun b c -> a x)in
let base = (fun y -> y) in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'a -> 'c -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'c -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = (fun y -> a x) in
let base = (fun y -> y) in
List.fold_left f base fs

let _ = fun y -> a x

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         int -> int



hw3 pipe

fix:
let pipe fs = 
let f a x = ( fun c -> x ) in
let base = (fun b -> b) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = (fun y -> y) in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = ( fun c -> y ) in
let base = (fun b -> b) in
List.fold_left f base fs
Error: Unbound value y


let (o) f g = fun x -> f (g x)
Error: Syntax error


let foo   = (fun x -> x + 1) o (fun y -> 2 * y)
Error: This function has type int -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let ans  = foo 10
Error: Unbound value foo



hw3 pipe

fix:
let pipe fs = 
let f a x = ( fun y -> a (x y) ) in
let base = (fun b -> b) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = ( fun c -> f a x ) in
let base = (fun b -> b) in
List.fold_left f base fs
Error: Unbound value f


let pipe fs = 
let f a x = ( fun c -> f (a x) ) in
let base = (fun b -> b) in
List.fold_left f base fs
Error: Unbound value f


let pipe fs = 
let f a x = ( fun c -> fun d -> (a x) ) in
let base = (fun b -> b) in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'a -> 'c -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'c -> 'b


let pipe fs = 
let f a x = ( fun x -> f (g x) ) in
let base = (fun b -> b) in
List.fold_left f base fs
Error: Unbound value f



hw3 pipe

fix:
let pipe fs = 
let f a x = ( fun y -> a (x y) ) in
let base = (fun b -> b) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = ( fun y -> a (y x) ) in
let base = (fun b -> b) in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'c -> ('c -> 'a) -> 'b
       but an expression was expected of type ('a -> 'b) -> 'c -> 'a -> 'b
       The type variable 'a occurs inside 'c -> 'a



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ x in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = (fun acc x -> x ^ cc) in
let base = "" in
let l = t in
List.fold_left f base l
Error: Unbound value cc


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = (fun acc x -> x ^ acc) in
let base = "" in
let l = t in
List.fold_left f base l
Error: This expression has type string but an expression was expected of type
         string -> string -> string


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = (fun acc x -> x ^ acc) in
let base = h in
let l = t in
List.fold_left f base l
Error: This expression has type string -> string -> string
       but an expression was expected of type string


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = (fun acc x -> x ^ acc) in
let base = "" in
let l = t in
List.fold_left f base l
Error: This expression has type string but an expression was expected of type
         string -> string -> string



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = "" ^ h ^ "" in
let l = t in
List.fold_left f base l

bad:
let _ = sepConcat ", " ["foo";"bar";"baz"]
Error: This expression has type string but an expression was expected of type
         string list



hw3 stringOfList

fix:
let stringOfList f l = 
"[" ^ sepConcat ";" (List.map f l) ^ "]"

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: This expression has type int but an expression was expected of type
         string list


let stringOfList f l = 
List.map f (sepConcat ";") l
Error: This function has type ('a -> 'b) -> 'a list -> 'b list
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 clone

fix:
let rec clone x n = match n with
| 0 -> []
| _ -> clone x (n-1) @ [x]

bad:
let rec clone x n = match n with
| 0 -> []
| _ -> clone x (n-1) :: [h]
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec clone x n = match n with
| 0 -> []
| _ -> clone x (n-1) :: [x]
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec clone x n = match n with
| 0 -> []
| 1 -> clone x (n-1) :: [x]
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw3 removeZero

fix:
let rec removeZero l = match l with
| [] -> l
| h::t ->
if h = 0 
then removeZero t
else l

bad:
let rec removeZero l = match l with
| [] -> l
| h::t -> if h = 0 then removeZero t
Error: This expression has type int list
       but an expression was expected of type unit


let rec removeZero l = match l with
| [] -> []
| h::t -> if h = 0 then removeZero t
Error: This expression has type 'a list
       but an expression was expected of type unit



hw3 bigAdd

fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = ( fun y -> x (a y) ) in
let base = (fun b -> b) in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base =  h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = 
"[" ^ sepConcat "; " (List.map f l) ^ "]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n = match n with
| 0 -> []
| a -> if a < 0 then [] else clone x (n-1) @ [x]

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let padZero l1 l2 = 
if (List.length l1 > List.length l2)
then (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2)
else (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

let _ = padZero [1;0;0;2] [0;0;9;9]

let _ = padZero [9;1] [1;2]

let _ = padZero [1;1] [1]

let rec removeZero l = match l with
| [] -> l
| h::t ->
if h = 0 
then removeZero t
else l

let _ = removeZero [0;0;0;1;0;0;2]

let _ = removeZero [9;9]

let _ = removeZero [0;0;0;0]

let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match x with
| (h1,h2)::t -> [t]
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let a = h::t in 
match x with
| (x1,x2) -> if x1 + x2 + h > 9 then 1 :: (h = x1 + x2 + h mod 10)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value h


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match a, x with
| h::t, (x1,x2) -> if x1 + x2 + h > 9 then 1 :: (h = x1 + x2 + h mod 10)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This variant expression is expected to have type unit
       The constructor :: does not belong to type unit


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match a, x with
| h::t, (x1,x2) -> if x1 + x2 + h > 9 then 1 :: (x1 + x2 + h mod 10)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This variant expression is expected to have type unit
       The constructor :: does not belong to type unit


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match a, x with
| h::t, (x1,x2) -> if x1 + x2 + h > 9 then (1 :: (x1 + x2 + h mod 10))
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This variant expression is expected to have type unit
       The constructor :: does not belong to type unit


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match a, x with
| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 1 :: (x1 + x2 + h mod 10)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This variant expression is expected to have type unit
       The constructor :: does not belong to type unit


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match a, x with
| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9(*1 :: (x1 + x2 + h mod 10) *)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         unit


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match a, x with
| h::t -> a * x
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match a, x with
| h::t, (x,y) -> a * x
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error



hw3 bigAdd

fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = ( fun y -> x (a y) ) in
let base = (fun b -> b) in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base =  h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = 
"[" ^ sepConcat "; " (List.map f l) ^ "]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n = match n with
| 0 -> []
| a -> if a < 0 then [] else clone x (n-1) @ [x]

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let padZero l1 l2 = 
if (List.length l1 > List.length l2)
then (l1, List.append (clone 0 (List.length l1 - List.length l2)) l2)
else (List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

let _ = padZero [1;0;0;2] [0;0;9;9]

let _ = padZero [9;1] [1;2]

let _ = padZero [1;1] [1]

let rec removeZero l = match l with
| [] -> l
| h::t ->
if h = 0 
then removeZero t
else l

let _ = removeZero [0;0;0;1;0;0;2]

let _ = removeZero [9;9]

let _ = removeZero [0;0;0;0]

let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match x with
| (h1,h2)::t -> [h1]
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match x with
| (h1,h2)::t -> [h1]
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error



hw3 bigAdd

fix:
let bigAdd l1 l2 =
let add (l1, l2) =
let f a x =
let carry =
match a with
| (x,y) -> x in
match x with
| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in
let digit = (carry + addend_a + addend_b) mod 10 in
match a with
| (x,y) -> (new_carry, digit::y) in
let base = (0,[]) in
let args = List.rev(List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match x with
| (h1,h2)::t -> 9
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match x with
| (h1,h2)::t -> [h1]
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match x with
| h1::t -> [h1]
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match x with
| h1::t -> []
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match x with
| h1 -> []
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match x with
| h1::t -> []
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match x with
| h::t -> []
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match x with
| (h1,h2)::t -> []
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match x with
| h::t -> []
(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
match x with
| h::t -> []
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type ('a * 'b) list
       but an expression was expected of type 'c list list
       Type 'a * 'b is not compatible with type 'c list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| h -> []
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list
       but an expression was expected of type 'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1,h1) -> []
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Variable h1 is bound several times in this matching


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1,h2) -> []
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list
       but an expression was expected of type 'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1,h2) -> (h2,h1)
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list
       but an expression was expected of type 'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1,h2) -> [h2]
in
let base =  [0] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int list
       but an expression was expected of type 'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (h1,h2) -> [h2]
in
let base =  [] in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type 'b * 'c



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g)-> f
in
let newc = match x with
| (f,g) -> if (f + g + carry) > 9 then 1 else 0 
in
let digit = match x with
| (f,g)->  f + g + carry mod 10
in 
match a with
| (o,p) -> (newc, digit::p)
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g)-> f
in
let digit = match x with
| (f,g)::t -> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)::t) else (0, (f+g+carry mod 10)::t)
in digit
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type (int * int) list
       but an expression was expected of type int list
       Type int * int is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g)-> f
in
let digit = match x with
| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)::t) else (0, (f+g+carry mod 10)::t)
in digit
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value t


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g)-> f
in
let digit = match x with
| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)) else (0, (f+g+carry mod 10))
in digit
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int * 'a list
       but an expression was expected of type int * int
       Type 'a list is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,[g])-> f
in
let digit = match x with
| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)) else (0, (f+g+carry mod 10))
in digit
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int * 'a list -> int * int -> int * int
       but an expression was expected of type
         int * 'a list -> int * int -> int * 'a list
       Type int is not compatible with type 'a list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g)-> f
in
let digit = match x with
| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)) else (0, (f+g+carry mod 10))
in digit
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int * 'a list
       but an expression was expected of type int * int
       Type 'a list is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g)-> f
in
let newc = match x with
| (f,g) -> if (f + g + carry) > 9 then 1 else 0 
in
let digit = match x with
| (f,g)->  f + g + carry mod 10
in 
match a with
| (o,p) -> (newcarry, digit::p)
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value newcarry
Hint: Did you mean carry?



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g)-> f
in
let newc = match x with
| (f,g) -> if (f + g + carry) > 9 then 1 else 0 
in
let digit = match x with
| (f,g)->  (f + g + carry) mod 10
in 
match a with
| (o,p) -> (newc, digit::p)
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g)-> f
in
let newc = match x with
| (f,g) -> if (f + g + carry) > 9 then 1 else 0 
in
let digit = match x with
| (f,g)->  (f + g + carry) mod 10
| []   -> carry
in 
match a with
| (o,p) -> (newc, digit::p)
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This pattern matches values of type 'a list
       but a pattern was expected which matches values of type int * int



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g) -> f
| (f',g'::h)-> g'
in
let newc = match x with
| (f,g) -> if (f + g + carry) > 9 then 1 else 0 
in
let digit = match x with
| (f,g)->  (f + g + carry) mod 10
in 
match a with
| (o,p) -> (newc, digit::p)
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let carry = match a with
| (f,g) ->
| (f',g'::h)-> g
in
let newc = match x with
| (f,g) -> if (f + g + carry) > 9 then 1 else 0 
in
let digit = match x with
| (f,g)->  (f + g + carry) mod 10
in 
match a with
| (o,p) -> (newc, digit::p)
in
let base = (0,[]) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error



hw3 mulByDigit

fix:
let rec mulByDigit i l = 
if i = 0 then l
else
let a = i :: [] in
bigAdd (mulByDigit (i-1) l) (mulByDigit (i-1) l)

bad:
let rec mulByDigit i l = 
if i = 0 then l
else
let a = i :: [] in
bigAdd (mulByDigit i-1 l) (mulByDigit i-1 l)
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = match a with
| (_,y) -> (0, bigAdd y x) in
let base = (0,[]) in
let args = 
let rec constructargs acc a b = match b with
| [] -> acc
| h::t -> constructargs ((mulByDigit h b) :: acc) a t
in
constructargs [] l1 (List.rev l2)
in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = failwith "to be implemented" in
let base = [] in
let args = match x with in
let (_, res) = List.fold_left f base args in
res
Error: Syntax error


let bigMul l1 l2 = 
let f a x = failwith "to be implemented" in
let base = [] in
let args = match l2 with
in
let (_, res) = List.fold_left f base args in
res
Error: Syntax error


let bigMul l1 l2 = 
let f a x = bigAdd a x in
let base = [] in
let args = 
let rec constructargs acc a b = match b with
| [] -> acc
| h::t -> constructargs ((mulByDigit h b) :: acc) a t
in
constructargs [] l1 (List.rev l2)
in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list
       but an expression was expected of type 'a * 'b


let bigMul l1 l2 = 
let f a x = match a with
| (_,y) -> (0, bigAdd a x) in
let base = (0,[]) in
let args = 
let rec constructargs acc a b = match b with
| [] -> acc
| h::t -> constructargs ((mulByDigit h b) :: acc) a t
in
constructargs [] l1 (List.rev l2)
in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a * 'b
       but an expression was expected of type int list



hw3 mulByDigit

fix:
let unzeroed = 
let rec constructargs acc a b = match b with
| [] -> acc
| h::t -> constructargs ((mulByDigit h a) :: acc) a t
in
constructargs [] [1;2;3] (List.rev [4;5;6])
in 
let rec addZeroes num somelist = match num with
| 0 -> somelist 
| _ -> addZeroes (num-1) (List.append somelist [0])
in
let rec addZeroesWhole acc a = match a with
| [] -> acc
| h::t -> addZeroesWhole ( (addZeroes (List.length t) h) :: acc ) t
in
addZeroesWhole [] unzeroed

bad:
let unzeroed = 
let rec constructargs acc a b = match b with
| [] -> acc
| h::t -> constructargs ((mulByDigit h a) :: acc) a t
in
constructargs [] [1;2;3] (List.rev [4;5;6])
in 
let rec addZeroes num somelist = match num with
| 0 -> somelist 
| _ -> addZeroes (num-1) (List.append somelist 0)
in
let rec addZeroesWhole acc a = match a with
| [] -> acc
| h::t -> addZeroesWhole ( (addZeroes (List.length t) h) :: acc ) t
in
addZeroesWhole [] unzeroed
Error: This expression has type int but an expression was expected of type
         'a list



hw3 mulByDigit

fix:
let rec mulByDigit i l = 
if i <= 0 then [0] else
if i = 1 then l
else
bigAdd (mulByDigit (i-1) l)  l

bad:
let rec mulByDigit i l = 
if i <= 0 then 0 else
if i = 1 then l
else
bigAdd (mulByDigit (i-1) l)  l
Error: This expression has type int but an expression was expected of type
         int list



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n < 0 then []
else let x = n/10 and y = n mod 10
in digitsOfInt x @ y

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

bad:
let rec digitsOfInt n = 
let x = n/10 
and y = n mod 10
and if y = 0 && x = 0 then []::resultList
else y::resultList -> digitsOfInt x
Error: Syntax error


let rec digitsOfInt n = 
let x = n/10 
and y = n mod 10 in
if y = 0 && x = 0 then []::resultList
else y::resultList -> digitsOfInt x
Error: Syntax error


let rec digitsOfInt n = 
let x = n/10 
and y = n mod 10 in
if y = 0 && x = 0 then []::resultList
else y::resultList -> y :: digitsOfInt x
Error: Syntax error



hw1 digitsOfInt

fix:
let _ = digitsOfInt (-300)

bad:
let _ = digitsOfInt (digits -300)
Error: This expression has type int -> int list
       but an expression was expected of type int
Error: Unbound value digitsOfInt
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int -> int list
       but an expression was expected of type int


let _ = digitsOfInt (digits (-300))
Error: This expression has type int list
       but an expression was expected of type int
Error: Unbound value digitsOfInt
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let x = sumList (digitsOfInt 10)

bad:
let x = sumList digitsOfInt 10
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let x = sumList digitsOfInt 10
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 listReverse

fix:
let rec listReverse l = 
match l with
| [] -> 0
| x :: l' -> listReverse l'

bad:
let rec listReverse l = 
| [] -> 0
| x :: l' -> listReverse l' @ [x]
Error: Syntax error


let rec listReverse l = 
match l with
| [] -> 0
| x :: l' -> listReverse l' @ [x]
Error: This expression has type int but an expression was expected of type
         'a list


let rec listReverse l = 
match l with
| [] -> 0
| x :: l' -> listReverse [l'] @ [x]
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec listReverse l = 
match l with
| [] -> 0
| x :: l' -> listReverse [l'] @ [x]
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 listReverse

fix:
let rec listReverse l = 
match l with
| [] -> []
| head::tail -> listReverse tail @ head

bad:
let rec listReverse l = 
match l with
| [] -> 0
| x :: l' -> listReverse l'::x
Error: This expression has type 'a list
       but an expression was expected of type int


let rec listReverse l = 
match l with
| [] -> 0
| x :: l' -> listReverse l'::[x]
Error: This expression has type 'a list
       but an expression was expected of type int


let rec listReverse l = 
match l with
| [] -> 0
| x :: l' -> 

(* uncomment and run AFTER you have implemented listReverse

let _ = listReverse [1; 2; 3; 4]
let _ = listReverse ["a"; "b"; "c"; "d"]

*)

(* explode : string -> char list 
* (explode s) is the list of characters in the string s in the order in 
*   which they appear
* e.g.  (explode "Hello") is ['H';'e';'l';'l';'o']
*)
let explode s = 
let rec go i = 
if i >= String.length s 
then [] 
else (s.[i]) :: (go (i+1)) 
in
go 0
Error: Syntax error


let rec listReverse l = 
match l with
| [] -> 0
| x :: xl -> listReverse x :: []
Error: This expression has type 'a list
       but an expression was expected of type int


let rec listReverse l = 
match l with
| [] -> 0
| x :: xl -> listReverse xl :: []
Error: This expression has type 'a list
       but an expression was expected of type int


let rec listReverse l = 
match l with
| [] -> 0
| head::tail -> tail
Error: This expression has type 'a list
       but an expression was expected of type int


let rec listReverse l = 
match l with
| [] -> 0
| head :: tail -> tail
Error: This expression has type 'a list
       but an expression was expected of type int



hw1 palindrome

fix:
let palindrome w = 
(listReverse (explode w))

bad:
let palindrome w = 
if listReverse explode w = w then true
else false
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.


let palindrome w = 
if (listReverse (explode w)) = w then true
else false
Error: This expression has type string but an expression was expected of type
         char list



hw1 palindrome

fix:
let palindrome w = 
if (listReverse (explode w)) = explode w then true
else false

bad:
let palindrome w = 
if (listReverse (explode w)) = w then 1
else 0
Error: This expression has type string but an expression was expected of type
         char list



hw1 ???

fix:
List.hd x

bad:
x.hd
Error: Unbound record field hd



hw1 ???

fix:
List.rev x

bad:
List.revs x
Error: Unbound value List.revs
Hint: Did you mean rev?



hw1 ???

fix:
let x = [1;2;3]

bad:
(x 3)
Error: This expression has type int list
       This is not a function; it cannot be applied.


(x 3)::[1;2;3]
Error: This expression has type int list
       This is not a function; it cannot be applied.



hw1 listReverse

fix:
let rec listReverse l = 
match l with
| [] -> []
| [x] -> [x]
| head::tail::third -> head::[tail]

bad:
let rec listReverse l = 
match l with
| [] -> []
| [x] -> [x]
| head::tail::t::s -> s::t::tail::head
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec listReverse l = 
match l with
| [] -> []
| [x] -> [x]
| head::tail::t::s -> s::t::tail::head
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec listReverse l = 
match l with
| [] -> []
| [x] -> [x]
| head::tail::t::s = l -> s::t::tail::head
Error: Syntax error


let rec listReverse l = 
match l with
| [] -> []
| [x] -> [x]
| head::tail::t::s::l -> s::t::tail::head
Error: This expression has type 'a but an expression was expected of type
         'a list
       The type variable 'a occurs inside 'a list


let rec listReverse l = 
match l with
| [] -> []
| [x] -> [x]
| head::tail::third -> head::tail
Error: This expression has type 'a but an expression was expected of type
         'a list
       The type variable 'a occurs inside 'a list



hw1 listReverse

fix:
let rec listReverse l = 
match l with
| [] -> []
| [x] -> [x]
| head::tail::third::fourth::fifth -> fourth::third::tail::[head]

bad:
let rec listReverse l = 
match l with
| [] -> []
| [x] -> [x]
| head::tail::third::fourth -> fourth::third::tail::[head]
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 listReverse

fix:
let rec listReverse l = 
match l with
| [] -> []
| [x] -> [x]
| head::tail -> head::listReverse tail

bad:
let rec listReverse l = 
match l with
| [] -> []
| [x] -> [x]
| head::tail -> head::listReverse tail::tail
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 ???

fix:
1::2::3::[4]

bad:
1::2::3::4
Error: This expression has type int but an expression was expected of type
         int list



hw1 ???

fix:
let rec getLast l =
match l with
| [x] -> x
| head::tail -> getLast tail

bad:
let rec getLast l =
| [] -> _
| [x] -> x
| head::tail -> getLast tail
Error: Syntax error


let rec getLast l =
| [x] -> x
| head::tail -> getLast tail
Error: Syntax error



hw1 ???

fix:
let rec getLast l =
match l with
| [] -> []
| [x] -> x
| head::tail -> getLast tail

bad:
let rec getLast l =
match l with
| [] -> _
| [x] -> x
| head::tail -> getLast tail
Error: Syntax error



hw1 ???

fix:
let x = [1;2;3]

getLast x

bad:
getLast [1;2;3]
Error: This expression has type int but an expression was expected of type
         'a list



hw1 ???

fix:
let rec reverseInt x y =
if x != 0 then reverseInt (x/10) (y*10+10 mod 10)
else y

bad:
let rec reverseInt x y =
(x != 0)? reverseInt(x/10, y*10+x mod 10) : y
Error: Syntax error


let rec reverseInt x y =
(x != 0)? reverseInt(x/10, y*10+x mod 10):y
Error: Syntax error


let rec reverseInt x y =
(x != 0)? reverseInt(x/10, y*10+x mod 10):y
Error: Syntax error


let rec reverseInt x y =
(x != 0)? reverseInt x/10 y*10+x mod 10 :y
Error: Syntax error


let rec reverseInt x y =
(x != 0)? reverseInt (x/10) (y*10+x mod 10) :y
Error: Syntax error



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n < 0 then []
else 
let x = reverseInt n 0/10 
and y = reverseInt n 0 mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x

bad:
let rec digitsOfInt n = 
if n < 0 then []
else 
let m = n
Error: Syntax error


let x = m/10 
and y = m mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x
Error: Unbound value m


let rec digitsOfInt n = 
if n < 0 then []
else 
let m = n 
and x = m/10 
and y = m mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x
Error: Unbound value m


let rec digitsOfInt n = 
if n < 0 then []
else 
let m = n 
and x = m/10 
and y = m mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x
Error: Unbound value m


let rec digitsOfInt n = 
if n < 0 then []
else 
let m = n 
and x = m/10 
and y = m mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x
Error: Unbound value m


let rec digitsOfInt n = 
if n < 0 then []
else 
let m = reverseInt n
and x = m/10 
and y = m mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x
Error: Unbound value m


let rec digitsOfInt n = 
if n < 0 then []
else 
let m = reverseInt n
in let x = m/10 
and y = m mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x
Error: This expression has type int -> int
       but an expression was expected of type int


let rec digitsOfInt n = 
if n < 0 then []
else 
let x = reverseInt n/10 
and y = reverseInt n mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x
Error: This expression has type int -> int
       but an expression was expected of type int


let rec digitsOfInt n = 
if n < 0 then []
else 
let x = reverseInt n 0/10 
and y = reverseInt n mod 10 in 
if x = 0 && y = 0 then []
else y::digitsOfInt x
Error: This expression has type int -> int
       but an expression was expected of type int



hw1 ???

fix:
let reverseInt x y=
while x > 0 do
let k = x mod 10
and y = y*10
and x = x/10 in x done

bad:
let reverseInt x y=
while x > 0 do
let k = x mod 10
and y = y*10 + k
and x = x/10 in
x
Error: Syntax error


let reverseInt x y=
while x > 0 do
let k = x mod 10
and y = y*10 + k
and x = x/10
Error: Syntax error


let reverseInt x y=
while x > 0 do
let k = x mod 10
and y = y*10 + k
and x = x/10
Error: Syntax error


let reverseInt x y=
while x > 0 do
let k = x mod 10
and y = y*10 + k
and x = x/10
Error: Syntax error


let reverseInt x y=
while x > 0 do
let k = x mod 10
and y = y*10 + k
and x = x/10
Error: Syntax error


let reverseInt x y=
while x > 0 do
let k = x mod 10
and y = y*10 + k
and x = x/10
Error: Syntax error


let reverseInt x y=
while x > 0 do
let k = x mod 10
and y = y*10 + k
and j = x/10
Error: Syntax error


let reverseInt x y=
while x > 0 do
let k = x mod 10
and y = y*10 + k
Error: Syntax error


let reverseInt x y=
while x > 0 do
let k = x mod 10
and y = y*10 + k
Error: Syntax error


let reverseInt x y=
while x > 0 do
let k = x mod 10
and y = y*10 + k
and x = x/10 in x
Error: Syntax error


let reverseInt x y=
while x > 0 do
let k = x mod 10
and y = y*10 + k
and x = x/10 in x done
Error: Unbound value k



hw1 ???

fix:
let reverseInt x y=
while x > 0 do
let y = y*10 + x mod 10  
and x = x/10 in x done

bad:
let reverseInt x y=
while x > 0 do
let k = x mod 10
and y = y*10 + k
and x = x/10 in x done
Error: Unbound value k



hw1 ???

fix:
string_of_list x

bad:
_of_st
Error: Syntax error


int_of_string x;
Error: Unbound value _of_st



hw1 ???

fix:
let x = 13

string_of_int x

bad:
string_of_List x
Error: Unbound value string_of_list
Hint: Did you mean string_of_int?


string_of_int x
Error: Unbound value string_of_List
Hint: Did you mean string_of_int?


lsit_of_string x
Error: This expression has type string but an expression was expected of type
         int


int_of_string x
Error: Unbound value lsit_of_string
Hint: Did you mean float_of_string or int_of_string?



hw1 digitsOfInt

fix:
let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

let _ = digitsOfInt (-42313)

bad:
let rec digitsOfInt n = 
if n < 0 then []
else 
let x = reverse (string_of_int n) 
and y= x /10 
and z = x mod 10 in 
if y = 0 && z = 0 then []
else z::digitsOfInt y
Error: This expression has type string but an expression was expected of type
         int
Error: Unbound value x
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type string but an expression was expected of type
         int


let rec digitsOfInt n = 
if n < 0 then []
else 
let x = reverse (string_of_int n) 
and y= x /10 
and z = x mod 10 in 
if y = 0 && z = 0 then []
else z::digitsOfInt y
Error: This expression has type string but an expression was expected of type
         int
Error: Unbound value x
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type string but an expression was expected of type
         int


let rec digitsOfInt n = 
if n < 0 then []
else 
let x = reverse (string_of_int n) 
and y= x /10 
and z = x mod 10 in 
if y = 0 && z = 0 then []
else z::digitsOfInt y
Error: This expression has type string but an expression was expected of type
         int
Error: Unbound value x
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type string but an expression was expected of type
         int


let rec digitsOfInt n = 
if n < 0 then []
else 
let x = reverse (string_of_int n) 
and y= x /10 
and z = x mod 10 in 
if y = 0 && z = 0 then []
else z::digitsOfInt y
Error: This expression has type string but an expression was expected of type
         int
Error: Unbound value x
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type string but an expression was expected of type
         int


let rec digitsOfInt n = 
if n < 0 then []
else 
let x = int_of_string reverse (string_of_int n) 
and y= x /10 
and z = x mod 10 in 
if y = 0 && z = 0 then []
else z::digitsOfInt y
Error: This expression has type string but an expression was expected of type
         int
Error: Unbound value x
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type string but an expression was expected of type
         int


let rec digitsOfInt n = 
if n < 0 then []
else 
let s = reverse (string_of_int n) 
and n2 = int_of_string s  
and z = x mod 10 in 
if y = 0 && z = 0 then []
else z::digitsOfInt y
Error: This function has type string -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let rec digitsOfInt n = 
if n < 0 then []
else 
let s = reverse (string_of_int n) in
let n2 = int_of_string s  
and z = x mod 10 in 
if y = 0 && z = 0 then []
else z::digitsOfInt y
Error: Unbound value s


let rec digitsOfInt n = 
if n < 0 then []
else 
let s = reverse (string_of_int n) in
let n2 = int_of_string s  in
let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x
Error: This expression has type string but an expression was expected of type
         int



hw1 digitsOfInt

fix:
let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

let _ = digitsOfInt (-42313)

bad:
let rec digitsOfInt n = 
if n < 0 then []
else if z = 0 and let n2 = reverse n in z = z+1
Error: Unbound value n2


let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x
Error: Syntax error


let rec digitsOfInt n = 
if n < 0 then []
else if z = 0
Error: Unbound value n2


let n2 = reverse n in z = z+1
Error: Syntax error


let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x
Error: Unbound value n


let rec digitsOfInt n = 
if n < 0 then []
else if z = 0 then let n2 = reverse n in z = z+1
Error: Unbound value n2


let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x
Error: This expression has type int but an expression was expected of type
         bytes = string


let rec digitsOfInt n = 
if n < 0 then []
else if z = 0 then let n2 = reverse (string_of_int n) in z = z+1
Error: Unbound value n2


let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x
Error: This expression has type bool but an expression was expected of type
         unit


let rec digitsOfInt n = 
if n < 0 then []
else if z = 0 then let n2 = reverse (string_of_int n) in z+1
Error: Unbound value n2


let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x
Error: This expression has type int but an expression was expected of type
         unit


let rec digitsOfInt n = 
if n < 0 then []
else if z = 0 then let n2 = reverse (string_of_int n)
Error: Unbound value n2


let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x
Error: Syntax error


let rec digitsOfInt n = 
if n < 0 then []
else if z = 0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitOfInt n2
Error: Unbound value n2


let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x
Error: Unbound value digitOfInt
Hint: Did you mean digitsOfInt?


let rec digitsOfInt n = 
if n < 0 then []
else if z = 0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitsOfInt n2
Error: Unbound value n2


let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x
Error: This expression has type 'a list
       but an expression was expected of type unit


let rec digitsOfInt n = 
if n < 0 then []
else if z = 0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitsOfInt n2;
let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x
Error: Unbound value n2


let rec digitsOfInt n = 
if n < 0 then []
else if z = 0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitsOfInt n2;
else 
let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x
Error: This variant expression is expected to have type unit
       The constructor [] does not belong to type unit


let rec digitsOfInt n = 
if n < 0 then []
else if z = 0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitsOfInt n2;
else 
let x = n/10 
and y = n mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x
Error: Unbound value n2



hw1 digitsOfInt

fix:
let rec digitsOfInt n =
let s = string_of_int n in
let s2 = String.length s in
for i=0 to (s2-1)/2 do
let c = s.[i] in
s.[i] <- s.[n-i-1];
s.[n-i-1] <- c;
done;
int_of_string s

let rec reverse s = 
else let x = s2/10 
and y = s2 mod 10 in
if x = 0 & y = 0 then []
else y::reverse x

bad:
let rec digitsOfInt n =
let s = string_of_int n in
let s2 = String.length s in
for i=0 to (s2-1)/2 do
let c = s2.[i] in
s2.[i] <- s2.[n-i-1];
s2.[n-i-1] <- c;
done;
int_of_string s2
Error: Syntax error


let rec digitsOfInt n =
let s = string_of_int n in
let s2 = String.length s in
for i=0 to (s2-1)/2 do
let c = s2.[i] in
s2.[i] <- s2.[n-i-1];
s2.[n-i-1] <- c;
done;
int_of_string s2
Error: This expression has type int but an expression was expected of type
         string


let rec digitsOfInt n =
let s = string_of_int n in
let s2 = String.length s in
for i=0 to (s2-1)/2 do
let c = s2.[i] in
s2.[i] <- s2.[n-i-1];
s2.[n-i-1] <- c;
done;
int_of_string s2
Error: This expression has type int but an expression was expected of type
         string


let rec reverse s2 = 
else let x = s2/10 
and y = s2 mod 10 in
if x = 0 & y = 0 then []
else y::reverse x
Error: This expression has type int but an expression was expected of type
         string


let rec digitsOfInt n =
let s = string_of_int n in
let s2 = String.length s in
for i=0 to (s2-1)/2 do
let c = s2.[i] in
s2.[i] <- s2.[n-i-1];
s2.[n-i-1] <- c;
done;
int_of_string s2
Error: Syntax error


let rec reverse s2 = 
else let x = s2/10 
and y = s2 mod 10 in
if x = 0 & y = 0 then []
else y::reverse x
Error: This expression has type int but an expression was expected of type
         string



hw1 ???

fix:
let x = "1234"
reverse x

bad:
let rec reverse s =
let s2 = String.length s in
for i=0 to (s2-1)/2 do
let c = s.[i] in
s.[i] <- s.[s2-i-1];
s.[n-i-1] <- c;
done;
int_of_string s
Error: Unbound value n


let rec reverse s =
let s2 = String.length s in
for i=0 to (s2-1)/2 do
let c = s.[i] in
s.[i] <- s.[s2-i-1];
s.[s2-i-1] <- c;
done;
int_of_string s
Error: Unbound value n



hw1 digitsOfInt

fix:
let z = 0

let rec digitsOfInt n = 
if n < 0 then []
else if z = 0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitsOfInt n2;
else 
let x = n/10 
and y = n mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x

bad:
let z = 0;

let rec digitsOfInt n = 
if n < 0 then []
else if z = 0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitsOfInt n2;
else 
let x = n/10 
and y = n mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x
Error: Unbound value z



hw1 digitsOfInt

fix:
let rec digitsOfInt n z= 
if n < 0 then []
else if z=0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitsOfInt n2;
else 
let x = n/10 
and y = n mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x

let _ = digitsOfInt 3124

bad:
let _ = digitsOfInt 3124
Error: Unbound value reverse


let _ = digitsOfInt 352663
Error: Unbound value digitsOfInt


let _ = digitsOfInt (-42313)
Error: Unbound value digitsOfInt



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n < 0 then []
else
let x = n/10 
and y = n mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x

let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n z= 
if n < 0 then []
else if z=0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitsOfInt n2;
else 
let x = n/10 
and y = n mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x
Error: Unbound value digitsOfInt


let rec digitsOfInt n z= 
if n < 0 then []
else if z=0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitsOfInt n2 0;
else 
let x = n/10 
and y = n mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x
Error: Unbound value reverse


let rec digitsOfInt n z= 
if n < 0 then []
else if z=0 then 
let n2 = reverse (string_of_int n)
and z = 1 in 
digitsOfInt n2 0;
else 
let x = n/10 
and y = n mod 10 in
if x = 0 && y = 0 then []
else y::digitsOfInt x 0
Error: Unbound value reverse


let _ = digitsOfInt 3124
Error: Unbound value reverse


let _ = digitsOfInt 352663
Error: Unbound value digitsOfInt


let _ = digitsOfInt (-42313)
Error: Unbound value digitsOfInt


let _ = digitsOfInt (-42313)
Error: Unbound value digitsOfInt



hw1 digitsOfInt

fix:
let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n = 
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n)
and rest = n. - 1.*(10.**s.) in
if x = 0 && y = 0 then []
else y::digitsOfInt x
Error: This expression has type int but an expression was expected of type
         float


let rec digitsOfInt n = 
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n)
and rest = float_of_int n - 1.*(10.** float_of_int s) in
if x = 0 && y = 0 then []
else y::digitsOfInt x
Error: Syntax error


let rec digitsOfInt n = 
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n)
and rest = (float_of_int n) - 1.*(10.** float_of_int s) in
if x = 0 && y = 0 then []
else y::digitsOfInt x
Error: This expression has type float but an expression was expected of type
         int


let rec digitsOfInt n = 
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n)
and rest = n - 1* int_of_float (10 ** float_of_int s) in
if x = 0 && y = 0 then []
else y::digitsOfInt x
Error: This expression has type float but an expression was expected of type
         int


let rec digitsOfInt n = 
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n)
and rest = n - 1* int_of_float (10. ** float_of_int s) in
if x = 0 && y = 0 then []
else y::digitsOfInt x
Error: This expression has type int but an expression was expected of type
         float


let rec digitsOfInt n = 
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n) in
let rest = n - 1* int_of_float (10. ** float_of_int s) in
if x = 0 && y = 0 then []
else y::digitsOfInt x
Error: Unbound value s


let rec digitsOfInt n = 
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n) in
let rest = n - 1* int_of_float (10. ** float_of_int s) in
head::digitsOfInt rest
Error: Unbound value y



hw1 digitsOfInt

fix:
let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

let _ = digitsOfInt (-42313)

bad:
let rec digitsOfInt n = 
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n) in
let rest = head - 1* int_of_float (10. ** float_of_int s) in
head::digitsOfInt rest
Error: Syntax error



hw1 digitsOfInt

fix:
let rec rev s =
let n = String.length s in
for i=0 to (n - 1) / 2 do
let c = s.[i] in
s.[i] <- s.[n-i-1];
s.[n-i-1] <- c;
done;
int_of_string s

let digitsOfInt n =
if n < 0 then []
else let n2 = rev (string_of_int) in
let rec reverse n2 = 
let x = n2/10 
and y = n2 mod 10 in
if x = 0 && y = 0 then []
else y::reverse x

bad:
let rec digitsOfInt n = 
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n) in
let rest = head - 1* int_of_float (10. ** float_of_int s);
head::digitsOfInt rest
Error: Syntax error


let rec digitsOfInt n = 
if n < 0 then []
else if n < 10 then [n]
else 
let head = getFirst n
and s = String.length (string_of_int n) in
let rest = head - 1* int_of_float (10. ** float_of_int s) in
head::digitsOfInt rest
Error: Syntax error



hw2 fixpoint

fix:
let rec assoc (d,k,l) = 
match l with
| [] -> d
| (a,i)::t -> 
if a = k then i 
else 
assoc (d,k,t)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = 
if List.mem h seen then seen
else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) = 
let (number,boolean) = f b in
if boolean then wwhile(f,number)
else number

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) = wwhile (f,b)

bad:
let fixpoint (f,b) = wwhile (f,b)
Error: This expression has type int -> int
       but an expression was expected of type int -> int -> int * bool
       Type int is not compatible with type int -> int * bool 



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile (f b,b)
Error: This expression has type int -> int
       but an expression was expected of type int -> int * bool
       Type int is not compatible with type int * bool 



hw2 exprToString

fix:
let rec exprToString e = 
match e with
| VarX -> "x"
| VarY -> "y"
| Sine e1 -> "sine(pi*" ^ exprToString e1 ^ ")"

let s = Sine VarX

bad:
let rec exprToString e = 
match e with
| VarX -> "x"
| VarY -> "y"
| Sine -> "sine(pi*" ^ exprToString e ^ ")"
Error: The constructor Sine expects 1 argument(s),
       but is applied here to 0 argument(s)


let rec exprToString e = 
match e with
| VarX -> "x"
| VarY -> "y"
| Sine e1 -> "sine(pi*" ^ exprToString e1 ^ ")"
Error: The constructor Sine expects 1 argument(s),
       but is applied here to 0 argument(s)



hw2 exprToString

fix:
let rec exprToString e = 
match e with
| VarX -> "x"
| VarY -> "y"
| Sine e1 -> "sin(pi*" ^ exprToString e1 ^ ")"
| Cosine e2 -> "cos(pi*" ^ exprToString e2 ^ ")"
| Average (e3,e4) -> "((" ^ exprToString e3 ^ "+" ^ exprToString e4 ^ ")/2)"
| Times (e5,e6) -> exprToString e5 ^ "*" ^ exprToString e6
| Thresh (e7,e8,e9,e10) -> "(" ^ exprToString e7 ^ "<" ^ exprToString e8 ^ "?" ^ exprToString e9 ^ ":" ^ exprToString e10 ^ ")"

bad:
let rec exprToString e = 
match e with
| VarX -> "x"
| VarY -> "y"
| Sine e1 -> "sin(pi*" ^ exprToString e1 ^ ")"
| Cosine e2 -> "cos(pi*" ^ exprToString e2 ^ ")"
| Average (e3,e4) -> "((" ^ exprToString e3 ^ "+" ^ exprToString e4 ^ ")/2)"
Error: This expression has type string
       This is not a function; it cannot be applied.



hw2 eval

fix:
let _ = eval (Sine(Varx),1,1)

bad:
let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
Error: This expression has type float but an expression was expected of type
         int



hw2 eval

fix:
let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/2

bad:
let _ = eval (Sine(VarX),1,1)
Error: This variant expression is expected to have type expr
       The constructor Varx does not belong to type expr
Hint: Did you mean VarX or VarY?


let _ = eval (Sine(VarX),1.0,1.0)
Error: This expression has type int but an expression was expected of type
         float



hw2 eval

fix:
let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.
| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)

bad:
let rec eval (e,x,y) = 
match e with
| VarX -> float_of_int x
| VarY -> float_of_int y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> float_of_int (eval(e1,x,y) + eval(e2,x,y))/2
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) + eval(e2,x,y))/.2
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) + eval(e2,x,y))/.2
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2
Error: This expression has type int but an expression was expected of type
         float


let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.
Error: This expression has type int but an expression was expected of type
         float



hw2 fixpoint

fix:
let rec assoc (d,k,l) = 
match l with
| [] -> d
| (a,i)::t -> 
if a = k then i 
else 
assoc (d,k,t)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = 
if List.mem h seen then seen
else h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) = 
let (number,boolean) = f b in
if boolean then wwhile(f,number)
else number

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) = wwhile (fun y b ->  (f b, f b = b),b)

bad:
let fixpoint (f,b) = wwhile (fun y b -> (f b, true),b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a


let fixpoint (f,b) = wwhile ((fun y b -> (f b, true)),b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a



hw2 fixpoint

fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) = wwhile (let y x =
let xx = f x in
(xx, xx != x) in y, b)

bad:
let fixpoint (f,b) = wwhile ((f b, f b = b),b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a


let fixpoint (f,b) = wwhile (fun y = (f b, f b = b),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile (fun y -> (f b, f b = b),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile (fun y -> (f b, f b != b),b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a


let fixpoint (f,b) = wwhile (fun y b-> (f b, f b != b),b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a


let fixpoint (f,b) = wwhile (fun y -> 
let x = f b in
if x = b then (x, true)
,b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a


let fixpoint (f,b) = wwhile (fun y b-> 
let x = f b in
if x = b then (x, true)
else y x 
,b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a


let fixpoint (f,b) = wwhile (let y x = 
let z = f x in
if z = b then (x, true)
else y z,b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a


let fixpoint (f,b) = wwhile (let y x = 
let z = f x in
if z = b then (x, true)
else y z
,b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile (let y x = 
let z = f x in
if z = b then (x, true)
else y z
,b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile (fun y x -> 
let z = f x in
if z = b then (x, true)
else y z
,b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile (fun y x -> 
let z = f x in
if z = b then (x, true)
else y z in wwhile(y, x)
,b
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a


)
Characters 28-29:
  let fixpoint (f,b) = wwhile (fun y x -> 
                              ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let fixpoint (f,b) = wwhile (fun y x -> 
let z = f x in
if z = b then (x, true)
else y z in wwhile(y, b)
,b
Error: Syntax error


)
Characters 28-29:
  let fixpoint (f,b) = wwhile (fun y x -> 
                              ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let fixpoint (f,b) = wwhile ((fun y x -> 
let z = f x in
if z = b then (x, true)
else y z in wwhile(y, b)
Error: Syntax error


)
,b
Characters 29-30:
  let fixpoint (f,b) = wwhile ((fun y x -> 
                               ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


)
Error: Syntax error


let fixpoint (f,b) = wwhile (let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2),b)
Error: Syntax error


let fixpoint (f,b) = wwhile (let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2),b)
Error: This expression has type int but an expression was expected of type
         'a -> 'a * bool


let fixpoint (f,b) = wwhile (let f x = let xx = x*x*x in (xx, xx < 100),b)
Error: This expression has type int but an expression was expected of type
         'a -> 'a * bool


let fixpoint (f,b) = wwhile (let y x = let xx = x*x*x in (xx, xx < 100),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ((let y x = let xx = x*x*x in (xx, xx < 100)), b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile (fun y x-> (f x, f x != b), b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ((fun y x-> (f x, f x != b)), b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a


let fixpoint (f,b) = wwhile (fun y -> (f b, f b != b), b)
Error: This function expects too many arguments, it should have type
'a -> 'a * bool


let fixpoint (f,b) = wwhile (fun y -> ((f b), (f b) != b), b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a


let fixpoint (f,b) = wwhile (fun y b-> (f b, f b != b), b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a


let fixpoint (f,b) = wwhile (let y b =
let xx = f b in
(xx, xx != b), b)
Error: This expression should not be a function, the expected type is
('a -> 'a * bool) * 'a


let fixpoint (f,b) = wwhile (let y b1 =
let xx = f b1 in
(xx, xx != b), b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile (let y b1 =
let xx = f b1 in
(xx, xx != b1), b)
Error: Syntax error: operator expected.



hw2 build

fix:
let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))

let rec build (rand, depth) = failwith "to be implemented"

bad:
let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))


(******************* Functions you need to write **********)

(* build: (int*int->int) * int -> Expr 
Build an expression tree.  The second argument is the depth, 
the first is a random function.  A call to rand(2,5) will give
you a random number in the range [2,5].

Your code should call buildX, buildSine, etc. to construct
the expression.
*)

makeRand(1,2)
Error: Unbound value rand
Hint: Did you mean land?


let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))


(******************* Functions you need to write **********)

(* build: (int*int->int) * int -> Expr 
Build an expression tree.  The second argument is the depth, 
the first is a random function.  A call to rand(2,5) will give
you a random number in the range [2,5].

Your code should call buildX, buildSine, etc. to construct
the expression.
*)



makeRand(1,2)
Error: This function has type expr * expr * expr * expr -> expr
       It is applied to too many arguments; maybe you forgot a `;'.



hw2 build

fix:
let rec build (rand, depth) = 
let rand = makeRand (1,7) in
let x = rand(1,7) in x

bad:
let rec build (rand, depth) = 
let rand = makeRand (1,7) in
let x = rand(1,7)
Error: Syntax error


let rec build (rand, depth) = 
let rand = makeRand (1,7) in
let x = rand(1,7) in rand
Error: Syntax error



hw2 build

fix:
let rand = makeRand(1,7)

let rec build (rand, depth) = 
let x = rand

bad:
let rec build (rand, depth) = 
let rand = makeRand (1,7) in
let x = rand(1,7) in x
Error: Unbound value rand
Hint: Did you mean land?



hw2 build

fix:
let rec build (rand, depth) = 
let x = rand(0,6) in 
match x with 
| 0 -> buildX()
| 1 -> buildY()
| 2 -> if depth = 0 then build(rand,depth) 
else buildSine(build(rand,depth-1))
| 3 -> if depth = 0 then build(rand,depth)
else buildAverage(build(rand,depth-1),build(rand,depth-1))

bad:
let rec build (rand, depth) = 
let x = rand(1,7) in 
match x with 
| 1 -> buildX()
| 2 -> buildY()
| 3 -> if depth = 0 then build(rand,depth) 
else buildSine(build(rand,depth-1))
| 4 -> if depth = 0 then build(rand,depth)
else buildAverage(build(rand,depth-1),build(rand,depth-1))
Error: Unbound value buildAverge
Hint: Did you mean buildAverage?
Error: Unbound value buildAverge
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value buildAverge
Hint: Did you mean buildAverage?



hw2 eval

fix:
let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.
| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh(e1,e2,e3,e4) -> 
if eval(e1,x,y) < eval(e2,x,y) then 
eval(e3,x,y)
else eval(e4,x,y)
| Power(e1,e2) -> eval(e1,x,y) ** eval(e2,x,y)
| AddThree(e1,e2,e3) -> eval(e1,x,y) +. eval(e2,x,y) +. eval(e3,x,y)

bad:
let rec eval (e,x,y) = 
match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(pi*.eval(e,x,y))
| Cosine(e) -> cos(pi*.eval(e,x,y))
| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.
| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh(e1,e2,e3,e4) -> 
if eval(e1,x,y) < eval(e2,x,y) then 
eval(e3,x,y)
else eval(e4,x,y)
| Power(e1,e2) -> eval(e1,x,y) ** eval(e2,x,y)
Error: Unbound value **.
Hint: Did you mean *. or **?



hw2 eval

fix:
let _ = eval (AddThree(VarX,VarY,VarX),1.,5.)

bad:
let _ = eval (AddThree(VarX,VarY,VarX),1.,2.,3.)
Error: This expression has type int but an expression was expected of type
         float


let _ = eval (AddThree(VarX,VarY,VarX),1.,2.)
Error: This expression has type 'a * 'b * 'c * 'd
       but an expression was expected of type expr * float * float



hw2 build

fix:
let g1 () = 20,8,9

let g2 () = 20,10,11

let g3 () = 20,9,12

let c1 () = 12,1,100

let c2 () = 12,2,50

let c3 () = 12,3,8

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let emitColor (f1,f2,f3,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_c_"^name) in
let chan = open_out (fname^".ppm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P6 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z1 = f1 (x,y) in
let z2 = f2 (x,y) in
let z3 = f3 (x,y) in

(* Convert the result to a grayscale value *)
let iz1 = toIntensity(z1) in
let iz2 = toIntensity(z2) in
let iz3 = toIntensity(z3) in

(* Emit one byte per color for this pixel *)
output_char chan (char_of_int iz1);
output_char chan (char_of_int iz2);
output_char chan (char_of_int iz3);
)) in  
close_out chan;
ignore(Sys.command ("convert "^fname^".ppm  "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".ppm"))

let doRandomColor (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand (seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e1 = build (g, depth) in
let e2 = build (g, depth) in
let e3 = build (g, depth) in

let _ = Format.printf "red   = %s \n" (exprToString e1) in
let _ = Format.printf "green = %s \n" (exprToString e2) in
let _ = Format.printf "blue  = %s \n" (exprToString e3) in

let f1 = eval_fn e1 in
let f2 = eval_fn e2 in
let f3 = eval_fn e3 in

(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitColor (f1,f2,f3,n,name)

type test = unit -> string

let key = ""

let prefix130 = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)); ErrorCode "exception")

let explode s = 
let rec _exp i = 
if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in
_exp 0

let implode cs = 
String.concat "" (List.map (String.make 1) cs)

let drop_paren s = 
implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))

let eq_real p (r1,r2) = 
(r1 -. r2) < p || (r2 -. r1) < p

let scoreMsg () = 
Format.sprintf "Results: Score/Max = %d / %d \n" !score !max

bad:
let _ = eval (Power(VarX,VarY),3.,2.)
Error: Unbound value eval


let _ = eval (AddThree(VarX,VarY,VarX),2.,5.)
Error: Unbound value eval


let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv
Error: Unbound value eval


let sampleExpr =
buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(
buildX()),buildTimes(buildCosine (buildCosine (buildAverage
(buildTimes (buildY(),buildY()),buildCosine (buildX())))),
buildCosine (buildTimes (buildSine (buildCosine
(buildY())),buildAverage (buildSine (buildX()), buildTimes
(buildX(),buildX()))))))),buildY())))
Error: Unbound value eval


let _ = eval (sampleExpr,0.5,0.2)
Error: Unbound value buildCosine


let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))
Error: Unbound value eval


let rec build (rand, depth) = 
let x = rand(0,7) in 
match x with 
| 0 -> buildX()
| 1 -> buildY()
| 2 -> if depth = 0 then build(rand,depth) 
else buildSine(build(rand,depth-1))
| 3 -> if depth = 0 then build(rand,depth)
else buildAverage(build(rand,depth-1),build(rand,depth-1))
| 4 -> if depth = 0 then build(rand,depth)
else buildTimes(build(rand,depth-1),build(rand,depth-1))
| 5 -> if depth = 0 then build(rand,depth)
else buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
| 6 -> if depth = 0 then build(rand,depth)
else buildPower(build(rand,depth-1),build(rand,depth-1))
| 7 -> if depth = 0 then build(rand,depth)
else buildAddThree(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
| _ -> buildX()
Error: Unbound value buildThresh



hw3 pipe

fix:
(* UNCOMMENT AFTE

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x);

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

bad:


let pipe fs = 
let f a x = x a in
let b
Error: Syntax error




let pipe fs = 
let f a x = x a in
let b
Error: Syntax error




let pipe fs = 
let f a x = x a in
let b
Error: Syntax error




let pipe fs = 
let f a x = x a in
let b
Error: Syntax error




let pipe fs y = 
let f a x = x a in
let b
Error: Syntax error




let pipe fs  = function 
let f a x = x a in
let b
Error: Syntax error




let pipe fs  y=  
let f a x = x a in
let b
Error: Syntax error



hw3 sepConcat

fix:
(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*


let _ = sepConcat ", " [


let _ = sepConcat ", " ["foo";"bar";"baz"

let _ = sepConcat ", " ["foo";"

bad:


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ x in
let base = "" in
let l 
Error: Syntax error




let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ "x" in
let base = "" in
let l 
Error: Syntax error




let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = "" in
let l 
Error: Syntax error



hw3 sepConcat

fix:
(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*


let _ = sepConcat ", " [


let _ = sepConcat ", " ["foo";"bar";"baz"

let _ = sepConcat ", " ["foo";"

bad:


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h ^ sep ^ x in
let base = "" in
let l 
Error: Syntax error



hw3 sepConcat

fix:
(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*


let _ = sepConcat ", " [


let _ = sepConcat ", " ["foo";"bar";"baz"

let _ = sepConcat ", " ["foo";"

bad:


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = "h" in
let l
Error: Syntax error



hw3 sepConcat

fix:
(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*


let _ = sepConcat ", " [


let _ = sepConcat ", " ["foo";"bar";"baz"

let _ = sepConcat ", " ["foo";"

bad:


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = h in
let l =
Error: Syntax error



hw3 pipe

fix:


let pipe fs =  
let f a x = x a in
let b

(* UNCOMMENT AFTE

let _ = pipe [] 3

bad:


let pipe fs y=  
let f a x = x a in
let b
Error: Syntax error



hw3 pipe

fix:
(* UNCOMMENT AFTE

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x);

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

bad:


let _ = pipe [(fun x -> x+x);
Error: Unbound value pipe


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: Syntax error




let _ = pipe [(fun x -> x+x);
Error: Unbound value pipe


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: Syntax error


let pipe fs =  
let f a x = x a in
let b
Error: Unbound value pipe




let pipe fs =  
let f a x = x base in
le
Error: Syntax error




let pipe fs =  
let f a x = x' (x a)  in
Error: Unbound value base




let pipe fs =  
let f a x = fun (x a)  i
Error: Syntax error




let pipe fs =  
let f a x = fun x' ->  x
Characters 35-36:
  let f a x = fun (x a)  i;;
                  ^
Syntax error: ')' expected, the highlighted '(' might be unmatched




let pipe fs y=  
let f a x = x a  in
let 
Error: Syntax error



hw3 sqsum

fix:
;;

let sqsum xs = 
let f a x = x * x + a in

bad:
let sqsum xs = 
let f a x = x * x + a in
Characters 25-26:
  (r1 -. r2;;
  ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw3 sqsum

fix:
;;

let sqsum xs = 
let f a x = x * x + a in

bad:
let sqsum xs = 
let f a x = x * x + a in
Error: Syntax error



hw3 sqsum

fix:
let sqsum xs = 
let f a x = (x * x + a)

let base = 0 
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;

bad:
let sqsum xs = 
let f a x = (x * x + a) 
Error: Syntax error



hw3 sqsum

fix:


let sqsum xs = 
let f a x = x * x + a in


(* UNCOMMENT AF

(* UNCOMMENT AFTER IMPL

let _ = sqsum []
let _ = sqsum [1;2;3;

bad:
let sqsum xs = 
let f a x = x * x + a in
Error: Syntax error



hw3 mulByDigit

fix:
let _ = mulByDigit 9 [9;9;9;9]

bad:
let rec mulByDigit i l = 
if i = 0 then []
else if i = 1 then l
else bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)
Error: This expression has type int list -> int list
       but an expression was expected of type int



hw3 bigMul

fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = match a with
| (list1, res) -> (list1, mulByDigit (x*10 * List.length res) list1) in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int
       This is not a function; it cannot be applied.
Error: Unbound value bigAdd
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int
       This is not a function; it cannot be applied.



hw3 bigMul

fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = match a with
| (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x) *. 10. ** (float_of_int List.length res)) list1) in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Characters 63-64:
  | (list1, res) -> (list1, mulByDigit ((int_of_float (float_of_int x *. 10. ** float_of_int List.length res)) list1) in
                    ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let bigMul l1 l2 = 
let f a x = match a with
| (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x) *. 10. ** (float_of_int (List.length res))) list1) in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int but an expression was expected of type
         float
Error: Unbound value bigAdd
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int but an expression was expected of type
         float


let bigMul l1 l2 = 
let f a x = match a with
| (list1, res) -> (list1, mulByDigit (int_of_float ((float_of_int x) *. 10. ** (float_of_int (List.length res)))) list1) in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int but an expression was expected of type
         float
Error: Unbound value bigAdd
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int but an expression was expected of type
         float



hw3 bigMul

fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = match a with
| (list1, res) -> (list1, bigAdd res (mulByDigit (x*List.lengh res) list1)) in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list -> int list
       but an expression was expected of type int
Error: Unbound value bigAdd
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int list -> int list
       but an expression was expected of type int


let bigMul l1 l2 = 
let f a x = match a with
| (list1, res) -> (list1, bigAdd res (mulByDigit (x*List.length res) list1)) in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value List.lengh
Hint: Did you mean length?
Error: Unbound value bigAdd
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value List.lengh
Hint: Did you mean length?



hw3 bigMul

fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = match a with
| (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**List.length res))) list1)) in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list -> int list
       but an expression was expected of type int
Error: Unbound value bigAdd
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int list -> int list
       but an expression was expected of type int


let bigMul l1 l2 = 
let f a x = match a with
| (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**float_of_int List.length res))) list1)) in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int but an expression was expected of type
         float
Error: Unbound value bigAdd
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int but an expression was expected of type
         float


let bigMul l1 l2 = 
let f a x = match a with
| (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**float_of_int (List.length res)))) list1)) in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This function has type int -> float
       It is applied to too many arguments; maybe you forgot a `;'.
Error: Unbound value bigAdd
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This function has type int -> float
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 sumList

fix:
let rec sumList xs =
match xs with
[] -> 0 | h::t -> h + sumList t

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

bad:
let rec sumList xs =
match xs with
[] -> 0 | h::t -> h + sumList
Error: This expression has type int list -> int
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let rec sumList xs =
match xs with
[] -> 0 
| h::t -> h + sumList t

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

let rec digitsOfInt n =
match n with
0  -> [] 
| _  -> digitsOfInt n/10 @  [n%10]

bad:
let rec digitsOfInt n =
match n with
n/10 == 0 -> [n] | digitsOfInt n/10 -> n%10 :: []
Error: Syntax error


let rec digitsOfInt n =
match n with
0 -> [] | digitsOfInt n/10 -> n%10 :: []
Error: Syntax error


let rec digitsOfInt n =
match n with
0 -> [] | digitsOfInt (n/10) -> n%10 :: []
Error: Syntax error


let rec digitsOfInt n =
match n with
0 -> [] | digitsOfInt n -> n%10 :: []
Error: Syntax error


let rec digitsOfInt n =
match n with
0 -> [] | n -> digitsOfInt n/10 n%10 :: []
Error: Unbound value %


let rec digitsOfInt n =
match n with
0 -> [] | n -> digitsOfInt n/10 :: []
Error: This expression has type 'a list
       but an expression was expected of type int


let rec digitsOfInt n =
match n with
0 -> [] | n -> digitsOfInt n :: []
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec digitsOfInt n =
match n with
0 -> [] | n -> [digitsOfInt n/10]
Error: This expression has type 'a list
       but an expression was expected of type int


let rec digitsOfInt n =
match n with
0 -> [] | n/10 -> [digitsOfInt n]
Error: Syntax error


let rec digitsOfInt n =
match n with
0 -> [] | (n/10) -> [digitsOfInt n]
Characters 47-48:
  0 -> [] | (n/10) -> [digitsOfInt n];;
            ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw1 digitsOfInt

fix:
let rec digitsOfInt n =
match n with
0  -> [] 
| _  -> digitsOfInt (n/10) @  [n mod 10]

bad:
let rec digitsOfInt n =
match n with
0  -> [] 
| _  -> digitsOfInt (n/10) @  [n%10]
Error: Unbound value %



hw1 digitsOfInt

fix:
let rec digitsOfInt n =
_ -> digitsOfInt (n/10) @  [n mod 10]

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

let _ = digitsOfInt 0

let _ = digitsOfInt 1

bad:
let rec digitsOfInt n =
n -> digitsOfInt (n/10) @  [n mod 10]
Error: Syntax error



hw1 ???

fix:
let catNum x =
match x with
[] -> x::[]
| h::t -> x::[]

bad:
let catNum x
_ -> x::(h::t)
Error: Syntax error


let catNum x
match x with
[] -> x::[]
| h::t -> x::(h::t)
Error: Syntax error


let catNum x =
match x with
[] -> x::[]
| h::t -> x::(h::t)
Error: This expression has type 'a but an expression was expected of type
         'a list
       The type variable 'a occurs inside 'a list


let catNum x =
match x with
[] -> x::[]
| h::t -> x::h::t
Error: This expression has type 'a but an expression was expected of type
         'a list
       The type variable 'a occurs inside 'a list


let catNum x =
match x with
[] -> x::[]
| h::t -> x::h
Error: This expression has type 'a but an expression was expected of type
         'a list list
       The type variable 'a occurs inside 'a list list


let catNum x =
match x with
[] -> x::[]
| h::t -> x::catNum
Error: Unbound value catNum


let catNum x =
match x with
[] -> x::[]
| h::t -> x::catNum x
Error: Unbound value catNum



hw1 ???

fix:
let catNum x =
match x with
[] -> x::[]
| h::t -> x::[]

bad:
let catNum x
match x with
[] -> x::[]
| h::t -> x::(h::t)
Error: Syntax error


let catNum x =
match x with
[] -> x::[]
| h::t -> x::(h::t)
Error: This expression has type 'a but an expression was expected of type
         'a list
       The type variable 'a occurs inside 'a list



hw1 ???

fix:
let rec cat x y =
match x with
[] -> [y]
| h::t -> h::( cat t y)

bad:
let rec (:::) x y =
match x with
[] -> [y]
| h::t -> h::( (:::) t y)
Error: Syntax error: operator expected.



hw1 digitsOfInt

fix:
let rec digitsOfInt n =
if n = 0 then [0]
else hDigitsofInt n

let rec hDigitsofInt num =
match num with
0  -> [] 
| _  -> cat (hDigitsOfInt (num/10)) (num mod 10)

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

let _ = digitsOfInt 0

let _ = digitsOfInt 1

bad:
let rec digitsOfInt n =
if n = 0 then [0]
else let rec hDigitsofInt n = 
match n with
0  -> [] 
| _  -> cat (digitsOfInt (n/10)) (n mod 10)
Error: Syntax error


let rec digitsOfInt n =
if n = 0 then [0]
else let rec hDigitsofInt n = 
match n with
0  -> [] 
| _  -> cat (hDigitsOfInt (n/10)) (n mod 10)
Error: Syntax error


let rec digitsOfInt n =
if n = 0 then [0]
else let rec hDigitsofInt n = 
match n with
0  -> [] 
| _  -> cat (hDigitsOfInt (n/10)) (n mod 10)
Error: Syntax error



hw1 digitsOfInt

fix:
let rec digitsOfInt n =
match n with
0  -> [] 
| _  -> cat (digitsOfInt (n/10)) (n mod 10)

if n = 0 then [0]

bad:
let rec digitsOfInt n =
match n with
0  -> [] 
| _  -> cat (digitsOfInt (n/10)) (n mod 10)
if n = 0 then [0]
Error: Syntax error



hw1 digitsOfInt

fix:
let rec digitsOfInt n =
if n = 0 then [0]
else
match n with
0  -> [] 
| _  -> cat (digitsOfInt (n/10)) (n mod 10)

bad:
let rec digitsOfInt n =
if n = 0 then [0]
match n with
0  -> [] 
| _  -> cat (digitsOfInt (n/10)) (n mod 10)
Error: Syntax error



hw1 digitsOfInt

fix:
let rec digitsOfInt n =
if n = 0 then [0]
else let rec help n =
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)

;;

bad:
let rec digitsOfInt n =
if n = 0 then [0]
else let rec help n =
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)
Error: Syntax error



hw1 digitsOfInt

fix:
let rec help n =
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)

let rec digitsOfInt n =
if n = 0 then [0]
else help n

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

let _ = digitsOfInt 0

let _ = digitsOfInt 1

bad:
let rec digitsOfInt n =
if n = 0 then [0]
else let rec help n =
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)
Error: Syntax error


let rec digitsOfInt n =
if n = 0 then [0]
else let rec help n = fun
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)
Error: Syntax error


let rec digitsOfInt n =
if n = 0 then [0]
else let rec help n = fun
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)
Error: Syntax error


let rec digitsOfInt n =
if n = 0 then [0]
else let rec help n = fun
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)
Error: Syntax error


let rec digitsOfInt n =
if n = 0 then [0]
else let rec help num = fun
match num with
0  -> [] 
| _  -> cat (help (num/10)) (n mod 10)
Error: Syntax error


let rec digitsOfInt n =
if n = 0 then [0]
else let rec help n = fun |
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)
Error: Syntax error


let rec digitsOfInt n =
if n = 0 then [0]
else let rec help n = fun 
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)
Error: Syntax error


let rec digitsOfInt n =
if n = 0 then [0]
else let rec help n = 
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)
Error: Syntax error


let rec digitsOfInt n =
if n = 0 then [0]
else let rec help n in 
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)
Error: Syntax error


let rec digitsOfInt n =
if n = 0 then [0]
else fun rec help n   ->
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)
Error: Syntax error


let rec digitsOfInt n =
if n = 0 then [0]
else fun help n  ->
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)
Error: This expression should not be a function, the expected type is
int list


let rec digitsOfInt n =
if n = 0 then [0]
else let rec help n  ->
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)
Error: Syntax error


let rec digitsOfInt n =
if n = 0 then [0]
else let rec help n  =
match n with
0  -> [] 
| _  -> cat (help (n/10)) (n mod 10)
Error: Syntax error



hw1 listReverse

fix:
let rec listReverse l = 
match l with
[]   -> []
| h::t -> listReverse (t::(cat l h))

let _ = listReverse [1; 2; 3; 4]

let _ = listReverse ["a"; "b"; "c"; "d"]

bad:
let rec listReverse l = 
match l with
[]   -> []
| h::t -> listReverse ((cat l h)::t)
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 palindrome

fix:
let explode s = 
let rec go i = 
if i >= String.length s 
then [] 
else (s.[i]) :: (go (i+1)) 
in
go 0

let palindrome w = 
explode w = listReverse (explode w)

let _ = palindrome "malayalam"

let _ = palindrome "myxomatosis"

bad:
let palindrome w = 
let l = explode w
Error: Syntax error


let reverse = listReverse l
Error: Syntax error


let palindrome w = 
let l = explode w
Error: Unbound value listReverse


let reverse = listReverse l
Error: Syntax error


let palindrome w = 
let l = explode w
Error: Unbound value listReverse


let reverse = listReverse l
Error: Syntax error



hw1 additivePersistence

fix:
let _ = additivePersistence 9999

let _ = additivePersistence 312

bad:
let _ = additivePersistence (-9999)
Error: This expression has type int -> int
       but an expression was expected of type int



hw2 assoc

fix:
let rec assoc (d,k,l) = match l with
[]   -> d
| h::t -> 
if k = h then 10 else assoc (d,k,t)

bad:
let rec assoc (d,k,l) = match l with
[]   -> d
| h::t -> assoc (d,k,l) in
if k = h then 10 else assoc (d,k,t)
Error: Unbound value k



hw2 assoc

fix:
let rec assoc (d,k,l) = match l with
[]   -> d
| (n,a)::t -> 
if k = n then a else assoc (d,k,t)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

bad:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])
Error: This expression has type 'a * 'b
       but an expression was expected of type string


let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])
Error: This expression has type 'a * 'b
       but an expression was expected of type string



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then h::seen else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem (h,t) then h in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This expression has type ('a * 'a list) list -> bool
       but an expression was expected of type bool


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem (h) then h in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This expression has type 'a list -> bool
       but an expression was expected of type bool


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem (h , t) then h in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This expression has type ('a * 'a list) list -> bool
       but an expression was expected of type bool


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h t then h in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This variant expression is expected to have type unit
       The constructor [] does not belong to type unit


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h t then h::[] in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This variant expression is expected to have type unit
       The constructor :: does not belong to type unit


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h t then h@[] in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This expression has type 'a list
       but an expression was expected of type unit


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h t then [] in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This variant expression is expected to have type unit
       The constructor [] does not belong to type unit


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h t then h in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This variant expression is expected to have type unit
       The constructor [] does not belong to type unit


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h t then h::[] in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This variant expression is expected to have type unit
       The constructor :: does not belong to type unit


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h t then (h::[]) in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This variant expression is expected to have type unit
       The constructor :: does not belong to type unit


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then h@seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This expression has type 'a list list
       but an expression was expected of type 'a list
       The type variable 'a occurs inside 'a list


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This variant expression is expected to have type unit
       The constructor :: does not belong to type unit



hw2 wwhile

fix:
let rec wwhile (f,b) = match f with
(num, b00l)-> if b00l then num else wwhile (f, num)

bad:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)
Error: This expression has type int but an expression was expected of type
         bool



hw2 wwhile

fix:
let rec wwhile (f,b) = match f with
(num, b00l)-> if b00l then num else wwhile (f, num)

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)
Error: This expression has type int -> int * bool
       but an expression was expected of type 'a * bool


let rec wwhile (f,b) = match f with
f(num, b00l)-> if b00l then num else wwhile (f, num)
Error: Syntax error



hw2 wwhile

fix:
let rec wwhile (f,b) = match f b with
(num, b00l)-> if b00l then num else wwhile (f, num)

bad:
let rec wwhile (f,b) = let f b in match t with
()-> if b00l then num else wwhile (f, num)
Error: Syntax error


let rec wwhile (f,b) = fun f b in match t with
()-> if b00l then num else wwhile (f, num)
Error: Syntax error


let rec wwhile (f,b) = fun f b match t with
()-> if b00l then num else wwhile (f, num)
Error: Syntax error


let rec wwhile (f,b) = match f b with
()-> if b00l then num else wwhile (f, num)
Error: Unbound value b00l



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile (f b,b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

bad:
let fixpoint (f,b) = wwhile (fixpoint(f,b),b)
Error: This expression has type 'a -> 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'a * bool
Error: Unbound value wwhile
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type 'a -> 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'a * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((f b),b)

bad:
let fixpoint (f,b) = wwhile (b,b)
Error: This expression has type 'a -> 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'a * bool


let fixpoint (f,b) = wwhile (fixpoint (f,b),b)
Error: This expression has type 'a -> 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'a * bool
Error: Unbound value wwhile
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type 'a -> 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'a * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile (match f with num -> num,b)

bad:
let fixpoint (f,b) = wwhile (match f with num,b)
Error: Syntax error: operator expected.



hw2 fixpoint

fix:
93

let rec assoc (d,k,l) = match l with
[]   -> d
| (n,a)::t -> 
if k = n then a else assoc (d,k,t)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (0,"bob",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"ranjit",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"moose",[("ranjit",85);("william",23);("moose",44)])

9

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if not(List.mem h seen) then h::seen else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9;1]

let _ = removeDuplicates [1;1;6;6;6;9;9]

let _ = removeDuplicates []

let _ = removeDuplicates [1]

let rec wwhile (f,b) = match f b with
(num, b00l)-> if not(b00l) then num else wwhile (f, num)

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 3)

let f x = let xx = x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) = wwhile ((fun x -> let y = (f,x) in (y, y != x)),b)

bad:
let fixpoint (f,b) = wwhile ((),b)
Error: This expression has type unit but an expression was expected of type
         'a -> 'a * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((fun x -> let y = (f x) in (y, y != x)),b)

bad:
let fixpoint (f,b) = wwhile ((fun x -> let y = (f,x) in (y, y != b)),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'b
       The type variable 'b occurs inside 'a * 'b



hw2 exprToString

fix:
let rec exprToString e = match e with
VarX -> "x"
| VarY -> "y"
| Sine e -> "sin (pi*" ^ exprToString e ^")"

bad:
let rec exprToString e = match e with
Thresh (a,b,c,d) -> exprToString a b c d
Error: This expression has type 'a but an expression was expected of type
         expr -> expr -> expr -> 'a
       The type variable 'a occurs inside expr -> expr -> expr -> 'a


let rec exprToString e = match e with
Thresh (a,b,c,d) -> 
(exprToString a, exprToString b,exprToString c,exprToString d)
Error: This expression has type 'a * 'b * 'c * 'd
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a * 'b * 'c * 'd


let rec exprToString e = match e with
VarX x -> "x"
| VarY y -> "y"
| Sine s -> "sin (pi*" ^ exprString e ^")"
Error: The constructor VarX expects 0 argument(s),
       but is applied here to 1 argument(s)


let rec exprToString e = match e with
VarX -> "x"
| VarY -> "y"
| Sine e -> "sin (pi*" ^ exprString e ^")"
Error: Unbound value exprString
Hint: Did you mean exprToString?



hw2 exprToString

fix:
let rec exprToString e = match e with
VarX           -> "x"
| VarY           -> "y"
| Sine e         -> "sin (pi*" ^ exprToString e ^")"
| Cosine e       -> "cos (pi*" ^ exprToString e ^")"
| Average (e,f)  -> "((" ^ exprToString e  ^ "*" ^ exprToString f ^ ")/2)"
| Times   (e,f)  -> "(" ^ exprToString e ^ "*" ^ exprToString f ^ ")"
| Thresh (e,f,g,h) 
-> "(" ^ exprToString e ^ "<" ^ exprToString f ^ "?" ^ exprToString g ^ ":" ^ exprToString h ^ ")"

bad:
let rec exprToString e = match e with
VarX     -> "x"
| VarY     -> "y"
| Sine e   -> "sin (pi*" ^ exprToString e ^")"
| Cosine e -> "cos (pi*" ^ exprToString e ^")"
| Averages -> "((" ^ exprToString e  ^ "*" ^ exprToString e ^ ")/2)"
| Times    -> "(" ^ exprToString e ^ "*" ^ exprToString e ^ ")"
| Thresh   
-> "(" ^ exprToString e ^ "<" ^ exprToString e ^ "?" ^ exprToString e ^ ":" ^ exprToString e ^ ")"
Error: This variant pattern is expected to have type expr
       The constructor Averages does not belong to type expr
Hint: Did you mean Average?


let rec exprToString e = match e with
VarX      -> "x"
| VarY      -> "y"
| Sine e    -> "sin (pi*" ^ exprToString e ^")"
| Cosine e  -> "cos (pi*" ^ exprToString e ^")"
| Average e -> "((" ^ exprToString e  ^ "*" ^ exprToString e ^ ")/2)"
| Times e   -> "(" ^ exprToString e ^ "*" ^ exprToString e ^ ")"
| Thresh e  
-> "(" ^ exprToString e ^ "<" ^ exprToString e ^ "?" ^ exprToString e ^ ":" ^ exprToString e ^ ")"
Error: The constructor Average expects 2 argument(s),
       but is applied here to 1 argument(s)


let rec exprToString e = match e with
VarX       -> "x"
| VarY       -> "y"
| Sine e     -> "sin (pi*" ^ exprToString e ^")"
| Cosine e   -> "cos (pi*" ^ exprToString e ^")"
| Average e e-> "((" ^ exprToString e  ^ "*" ^ exprToString e ^ ")/2)"
| Times e e  -> "(" ^ exprToString e ^ "*" ^ exprToString e ^ ")"
| Thresh e e e e 
-> "(" ^ exprToString e ^ "<" ^ exprToString e ^ "?" ^ exprToString e ^ ":" ^ exprToString e ^ ")"
Error: Syntax error


let rec exprToString e = match e with
VarX       -> "x"
| VarY       -> "y"
| Sine e     -> "sin (pi*" ^ exprToString e ^")"
| Cosine e   -> "cos (pi*" ^ exprToString e ^")"
| Average e f-> "((" ^ exprToString e  ^ "*" ^ exprToString f ^ ")/2)"
| Times e f  -> "(" ^ exprToString e ^ "*" ^ exprToString f ^ ")"
| Thresh e f g h 
-> "(" ^ exprToString e ^ "<" ^ exprToString f ^ "?" ^ exprToString g ^ ":" ^ exprToString h ^ ")"
Error: Syntax error


let rec exprToString e = match e with
VarX       -> "x"
| VarY       -> "y"
| Sine e     -> "sin (pi*" ^ exprToString e ^")"
| Cosine e   -> "cos (pi*" ^ exprToString e ^")"
| Average (e,f)-> "((" ^ exprToString e  ^ "*" ^ exprToString f ^ ")/2)"
| Times (e,f)  -> "(" ^ exprToString e ^ "*" ^ exprToString f ^ ")"
| Thresh e f g h 
-> "(" ^ exprToString e ^ "<" ^ exprToString f ^ "?" ^ exprToString g ^ ":" ^ exprToString h ^ ")"
Error: Syntax error



hw2 eval

fix:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> failwith "sad"

bad:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (x,y)    -> (eval (e,x,y) +. eval(e,x,y))/.2.0
| Times   (x,y)    -> eval(e,x,y) *. eval(e,x,y)
| Thresh (e1,e2,e3,e4) -> failwith "sad"
Error: This expression has type expr but an expression was expected of type
         float



hw2 eval

fix:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)

bad:
let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )
Error: Syntax error


let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )
Error: Syntax error


let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
( eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )
Error: Syntax error


let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
( eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : e4 )
Error: Unbound type constructor e4


let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
( eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )
Error: Syntax error


let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )
Error: Syntax error


let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e3,x,y) )
Error: Syntax error


let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) )
Error: This function has type expr * float * float -> float
       It is applied to too many arguments; maybe you forgot a `;'.


let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y)
Error: Syntax error


let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y)
Error: Syntax error


let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
(val(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y))
Error: Syntax error: operator expected.


let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y))
Error: Syntax error


let rec eval (e,x,y) = match e with
VarX	         -> x
| VarY  	   -> y
| Sine e           -> sin(pi*.eval(e,x,y))
| Cosine e         -> cos(pi*.eval(e,x,y))
| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
eval(e1,x,y) < eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y)
Error: Syntax error



hw2 build

fix:
let rec build (rand, depth) = 
if(depth > 0) then
if rand mod 5 = 0 then buildSine (build(rand, depth-1) )
else if rand mod 5 = 1 then buildCosine(build(rand, depth-1) )
else if rand mod 5 = 2 then buildAverage(buildX(),buildY())
else if rand mod 5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
if rand mod 2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())

bad:
let rec build (rand, depth) = 
if(depth > 0) then
if rand%5 = 0 then buildSine (build(rand, depth-1) )
else if rand%5 = 1 then buildCosine(build(rand, depth-1) )
else if rand%5 = 2 then buildAverage(buildX(),buildY())
else if rand%5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
if rand%2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())
Error: Unbound value %


let rec build (rand, depth) = 
if(depth > 0) then
if rand%.5 = 0 then buildSine (build(rand, depth-1) )
else if rand%5 = 1 then buildCosine(build(rand, depth-1) )
else if rand%5 = 2 then buildAverage(buildX(),buildY())
else if rand%5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
if rand%2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())
Error: Unbound value %.



hw2 build

fix:
let rec build (rand, depth) = 
if(depth > 0) then
let rnd = rand 0 100 in
if rnd mod 5 = 0 then buildSine (build(rand, depth-1) )
else if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )
else if rnd mod 5 = 2 then buildAverage(buildX(),buildY())
else if rnd mod 5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
let rnd = rand 0 100 in
if rnd mod 2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())

bad:
let rec build (rand, depth) = 
if(depth > 0) then
let rnd = rand 0 100 in
if rnd mod 5 = 0 then buildSine (build(rand, depth-1) )
else if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )
else if rnd mod 5 = 2 then buildAverage(buildX(),buildY())
else if rnd mod 5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
let rnd = rand 0 100 in
if rand mod 2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())
Error: This expression has type int -> int -> int
       but an expression was expected of type int



hw2 ???

fix:
let _ = doRandomGray (10, 10,39)

bad:
let _ doRandomGray (10, 10,39)
Error: Syntax error



hw2 build

fix:
let rec build (rand, depth) = 
Format.sprintf "%d" depth in
if(depth > 0) then
let rnd = rand (0, 51) in
if rnd mod 5 = 0 then buildSine (build(rand, depth-1) )
else if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )
else if rnd mod 5 = 2 then buildAverage(buildX(),buildY())
else if rnd mod 5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
let rnd = rand (0, 51) in
if rnd mod 2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())

let g1 () = failwith "to be implemented"

let g2 () = failwith "to be implemented"

let g3 () = failwith "to be implemented"

let c1 () = failwith "to be implemented"

let c2 () = failwith "to be implemented"

let c3 () = failwith "to be implemented"

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = doRandomGray (55, 13,312)

bad:
let rec build (rand, depth) = 
Format.sprintf "%d" depth
if(depth > 0) then
let rnd = rand (0, 51) in
if rnd mod 5 = 0 then buildSine (build(rand, depth-1) )
else if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )
else if rnd mod 5 = 2 then buildAverage(buildX(),buildY())
else if rnd mod 5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
let rnd = rand (0, 51) in
if rnd mod 2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())
Error: Syntax error



hw2 build

fix:
let rec build (rand, depth) = 

if(depth > 0) then
Format.printf "%d" depth

bad:
let rec build (rand, depth) = 

if(depth > 0) then
Format.sprintf "%d" depth
Error: This expression has type string but an expression was expected of type
         unit



hw2 build

fix:
let rec build (rand, depth) = 
let _ = Format.printf "%d" depth in
if(depth > 0) then
let rnd = rand (0, 51) in
if rnd mod 5 = 0 then buildSine (build(rand, depth-1) )
else if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )
else if rnd mod 5 = 2 then buildAverage(buildX(),buildY())
else if rnd mod 5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
let rnd = rand (0, 51) in
if rnd mod 2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())

bad:
let rec build (rand, depth) = 

if(depth > 0) then
Format.printf "%d" depth in
let rnd = rand (0, 51) in
if rnd mod 5 = 0 then buildSine (build(rand, depth-1) )
else if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )
else if rnd mod 5 = 2 then buildAverage(buildX(),buildY())
else if rnd mod 5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
let rnd = rand (0, 51) in
if rnd mod 2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())
Error: Syntax error


let rec build (rand, depth) = 
Format.printf "%d" depth
if(depth > 0) then
let rnd = rand (0, 51) in
if rnd mod 5 = 0 then buildSine (build(rand, depth-1) )
else if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )
else if rnd mod 5 = 2 then buildAverage(buildX(),buildY())
else if rnd mod 5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
let rnd = rand (0, 51) in
if rnd mod 2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())
Error: Syntax error


let rec build (rand, depth) = 
let _ = Format.printf "%d" depth
if(depth > 0) then
let rnd = rand (0, 51) in
if rnd mod 5 = 0 then buildSine (build(rand, depth-1) )
else if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )
else if rnd mod 5 = 2 then buildAverage(buildX(),buildY())
else if rnd mod 5 = 3 then buildTimes(buildX(),buildY())
else 
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else
let rnd = rand (0, 51) in
if rnd mod 2 =0 then buildAverage(buildX(),buildY()) 
else buildTimes(buildX(),buildY())
Error: Syntax error



hw2 eval

fix:
let rec eval (e,x,y) = match e with
VarX	             -> x
| VarY  	       -> y
| Sine e               -> sin(pi*.eval(e,x,y))
| Cosine e             -> cos(pi*.eval(e,x,y))
| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)
| Timmy1 (e1,e2,e3)    -> 
(sin(pi*.eval(e,x,y)) +. cos(pi*.eval(e,x,y)))*.cos(pi*.eval(e,x,y))
| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/.cos(pi*.eval(e,x,y))

let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

bad:
let rec eval (e,x,y) = match e with
VarX	             -> x
| VarY  	       -> y
| Sine e               -> sin(pi*.eval(e,x,y))
| Cosine e             -> cos(pi*.eval(e,x,y))
| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0
| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> 
if eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)
| Timmy1 (e1,e2,e3)    -> 
(sin(pi*.eval(e,x,y)) +. cos(pi*.eval(e,x,y)))*cos(pi*.eval(e,x,y))
| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/cos(pi*.eval(e,x,y))
Error: This expression has type float but an expression was expected of type
         int



hw2 build

fix:
let rec build (rand, depth) = 
if(depth > 0) then
let rnd = rand (0, 5) in
if rnd mod 7 = 0 then buildSine (build(rand, depth-1) )
else if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )
else if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))
else if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))
else if rnd mod 7=4 then
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else (*if rnd mod 7=5 then*)
buildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))
(*else
buildTimmy2(build(rand, depth-1) ,build(rand, depth-1))*)
else
let rnd = rand (0, 2) in
if rnd mod 2 =0 then buildX() 
else buildY()

let g1 () = (10,10,10)

let g2 () = (7,68,488)

let g3 () = (8,84,872)

let c1 () = (9,24,987)

let c2 () = (6,0,164)

let c3 () = (8,84,282)

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

let emitColor (f1,f2,f3,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_c_"^name) in
let chan = open_out (fname^".ppm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P6 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z1 = f1 (x,y) in
let z2 = f2 (x,y) in
let z3 = f3 (x,y) in

(* Convert the result to a grayscale value *)
let iz1 = toIntensity(z1) in
let iz2 = toIntensity(z2) in
let iz3 = toIntensity(z3) in

(* Emit one byte per color for this pixel *)
output_char chan (char_of_int iz1);
output_char chan (char_of_int iz2);
output_char chan (char_of_int iz3);
)) in  
close_out chan;
ignore(Sys.command ("convert "^fname^".ppm  "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".ppm"))

let doRandomColor (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand (seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e1 = build (g, depth) in
let e2 = build (g, depth) in
let e3 = build (g, depth) in

let _ = Format.printf "red   = %s \n" (exprToString e1) in
let _ = Format.printf "green = %s \n" (exprToString e2) in
let _ = Format.printf "blue  = %s \n" (exprToString e3) in

let f1 = eval_fn e1 in
let f2 = eval_fn e2 in
let f3 = eval_fn e3 in

(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitColor (f1,f2,f3,n,name)

type test = unit -> string

let key = ""

let prefix130 = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)); ErrorCode "exception")

let explode s = 
let rec _exp i = 
if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in
_exp 0

let implode cs = 
String.concat "" (List.map (String.make 1) cs)

let drop_paren s = 
implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))

let eq_real p (r1,r2) = 
(r1 -. r2) < p || (r2 -. r1) < p

let scoreMsg () = 
Format.sprintf "Results: Score/Max = %d / %d \n" !score !max

let _ =
let report = Li

bad:
let rec build (rand, depth) = 
if(depth > 0) then
let rnd = rand (0, 5) in
if rnd mod 7 = 0 then buildSine (build(rand, depth-1) )
else if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )
else if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))
else if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))
else if rnd mod 7=4 then
buildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )
else (*if rnd mod 7=5 then*)
buildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))
(*else
buildTimmy2(build(rand, depth-1) ,build(rand, depth-1))*)
else
let rnd = rand (0, 2) in
if rnd mod 2 =0 then buildX() 
else buildY()
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = a+x in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = 0 in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let _ = pipe [] 3
Error: Unbound value pipe


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: Unbound value pipe


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: Unbound value pipe



hw3 pipe

fix:
let sqsum xs = 
let f a x = a + x*x in
let base =  0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x =  f x a  in
let base =  fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe fs = 
let f a x =  fun a -> x  in
let base =  fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  a + x  in
let base =  fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs = 
let f a x =  (fun a->x) a  in
let base =  fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  fun x -> a  in
let base =  fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'c -> 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'c -> 'a


let pipe fs = 
let f a x =  f (fun a->x)-> a  in
let base =  fun x -> x in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x =  f (fun a->x) a  in
let base =  fun x -> x in
List.fold_left f base fs
Error: Unbound value f



hw3 pipe

fix:
let pipe fs = 
let f a x =   (fun a->x) x in
let base =  fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  a (fun a->x) in
let base =  fun x -> x in
List.fold_left f base fs
Error: This expression has type (('a -> 'b) -> 'c) -> 'b -> 'c
       but an expression was expected of type
         (('a -> 'b) -> 'c) -> 'b -> ('a -> 'b) -> 'c
       The type variable 'c occurs inside ('a -> 'b) -> 'c



hw3 pipe

fix:
let pipe fs = 
let f a x =   (fun a->x) a in
let base =  fun x -> x in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

bad:
let pipe fs = 
let f a x =   (fun a>x) a in
let base =  fun x -> x in
List.fold_left f base fs
Error: Syntax error: operator expected.



hw3 pipe

fix:
let pipe fs = 
let f a x =   (fun x->a) a in
let base =  0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =   (fun x->a) a in
let base =  x in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x =   (fun x->a) a in
let base =  a in
List.fold_left f base fs
Error: Unbound value a



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep  in
let base = h in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x (a^sep)  in
let base = h in
let l = t in
List.fold_left f base l
Error: This expression has type string list
       but an expression was expected of type (string -> string) list
       Type string is not compatible with type string -> string 



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x^sep  in
let base = h in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep  in
let base = h in
let l = x in
List.fold_left f base l
Error: Unbound value x



hw3 stringOfList

fix:
let stringOfList f l =  List.map f l

bad:
let stringOfList f l = f (pipe List.map l)
Error: This expression has type ('a -> 'b) -> 'a list -> 'b list
       but an expression was expected of type ('c -> 'c) list



hw3 stringOfList

fix:
let stringOfList f l =  sepConcat "" (List.map f l)

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

bad:
let stringOfList f l =  sepConcat f (List.map f l)
Error: This expression has type string but an expression was expected of type
         'a -> 'b



hw3 stringOfList

fix:
let stringOfList f l =  sepConcat "[]" (List.map f l)

bad:
let stringOfList f l =  sepConcat (List.map f l) l
Error: This expression has type 'a list
       but an expression was expected of type string



hw3 stringOfList

fix:
let stringOfList f l =  sepConcat "" (List.map f l)

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

bad:
let stringOfList f l = (List.map f (sepConcat "" l))
Error: This expression has type string but an expression was expected of type
         'a list



hw3 clone

fix:
let rec clone x n = match n with
0    -> []
| _ ->  x::clone x (n-1)

bad:
let rec clone x n = match n with
0    -> []
| h::t ->  x::clone x (n-1)
Error: This pattern matches values of type 'a list
       but a pattern was expected which matches values of type int



hw3 clone

fix:
let rec clone x n = if n <= 0 then [] else x::clone x (n-1)

bad:
let rec clone x n = match n with
n <= 0 -> []
| _      ->  x::clone x (n-1)
Error: Syntax error


let rec clone x n = match n with
n < 0 -> []
| _      ->  x::clone x (n-1)
Error: Syntax error


let rec clone x n = match n with
n = 0 -> []
| _      ->  x::clone x (n-1)
Error: Syntax error



hw3 padZero

fix:
let padZero l1 l2 =
let s1 = List.length l1 in
let s2 = List.length l2 in
if (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) 
else if (s2<s1) then (l1, (clone 0 (s1-s2))@l2)
else (l1,l2)

bad:
let padZero l1 l2 =
let s1 = List.length l1 in
let s2 = List.length l2 in
if (s1<s2) then (clone 0 l1, l2) 
else if (s2<s1) then (l1, clone 0 l2)
else (l1,l2)
Error: This expression has type 'a list
       but an expression was expected of type int


let padZero l1 l2 =
let s1 = List.length l1 in
let s2 = List.length l2 in
if (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) 
else if (s2<s1) then (l1, (clone 0 s1-s2)@l2)
else (l1,l2)
Error: This expression has type int list
       but an expression was expected of type int



hw3 removeZero

fix:
let rec removeZero l = match l with
[]  -> []
| h1::h2::t-> if(h1=0 && h2!=0) then removeZero t else h1::removeZero t

bad:
let rec removeZero l = match l with
h   -> if (h != 0) then []
| h::t-> if(h=0) then removeZero t else h::removeZero t
Error: This expression has type int but an expression was expected of type
         'a list


let rec removeZero l = match l with
[]  -> []
| h1::h2::t-> if(h1=0 && h2!=0) then removeZero t else h::removeZero t
Error: Unbound value h



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith ""
in
let base = ([],[]) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith ""
in
let base = [] in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type 'b * 'c


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
[]   -> []
| h::t -> []
in
let base = ([],[]) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b list
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
[]   -> []
| h::t -> []
in
let base = [] in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type ('a * 'b) list
       but an expression was expected of type 'c list list
       Type 'a * 'b is not compatible with type 'c list 



hw3 bigAdd

fix:
let sqsum xs = 
let f a x = a + x*x in
let base =  0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x =   fun b -> x (a b) in
let base =  fun x -> x in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 4

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 9

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x  in
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l =  "["^(sepConcat "; " (List.map f l))^"]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n = if n <= 0 then [] else x::clone x (n-1)

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let padZero l1 l2 =
let s1 = List.length l1 in
let s2 = List.length l2 in
if (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) 
else if (s2<s1) then (l1, (clone 0 (s1-s2))@l2)
else (l1,l2)

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

let _ = padZero [1;2] [9;9]

let rec removeZero l = match l with
[]  -> []
| h::t-> if(h!=0) then h::t else removeZero t

let _ = removeZero [0;0;0;1;0;0;2]

let _ = removeZero [9;9]

let _ = removeZero [0;0;0;0]

let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
([],[])   -> []
in
let base = ([],[]) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
[]   -> ([],[])
| h::t -> ([],[])
in
let base = ([],[]) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type ('a * 'b) list
       but an expression was expected of type 'c list list
       Type 'a * 'b is not compatible with type 'c list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
([],[])   -> []
in
let base = ([],[]) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b list
       but an expression was expected of type 'c list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith ""
in
let base =  ([], []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
[]   -> []
in
let base = ([],[]) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b list
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith ""
in
let base =  [] in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type 'b * 'c



hw3 bigAdd

fix:
let sqsum xs = 
let f a x = a + x*x in
let base =  0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x =   fun b -> x (a b) in
let base =  fun x -> x in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 4

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 9

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x  in
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l =  "["^(sepConcat "; " (List.map f l))^"]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n = if n <= 0 then [] else x::clone x (n-1)

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let padZero l1 l2 =
let s1 = List.length l1 in
let s2 = List.length l2 in
if (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) 
else if (s2<s1) then (l1, (clone 0 (s1-s2))@l2)
else (l1,l2)

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

let _ = padZero [1;2] [9;9]

let rec removeZero l = match l with
[]  -> []
| h::t-> if(h!=0) then h::t else removeZero t

let _ = removeZero [0;0;0;1;0;0;2]

let _ = removeZero [9;9]

let _ = removeZero [0;0;0;0]

let _ = List.combine (List.rev [9;9]) (List.rev [0;0])

let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith ""
in
let base =  (0, []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =
([], []) -> []
in
let base =  ([], []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
([], []) -> []
in
let base =  ([], []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b list
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
([], []) -> []
in
let base =  ([], []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b list -> 'c -> 'd list
       but an expression was expected of type
         'a list * 'b list -> 'c -> 'a list * 'b list
       Type 'd list is not compatible with type 'a list * 'b list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
[] -> []
in
let base =  ([], []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b list
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
[] -> []
in
let base =  ([], []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b list
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
[] -> ([], [])
in
let base =  ([], []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type ('a * 'b) list
       but an expression was expected of type 'c list list
       Type 'a * 'b is not compatible with type 'c list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
[] -> ([], [])
in
let base =  ([], []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list -> 'b -> 'c list * 'd list
       but an expression was expected of type 'a list -> 'b -> 'a list
       Type 'c list * 'd list is not compatible with type 'a list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith ""
in
let base =  [] in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type 'b * 'c


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith ""
in
let base =  fun x -> x in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'b * 'c



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match (snd a) with
[]  -> (fst x + snd x, ((fst x + snd x)/10)::[(fst x + snd x) mod 10]) 
|h::t -> (0, [] )
in
let base =  (0, []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
(c, h::t) -> []
in
let base =  (0, []) in
let args =  List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b list -> 'c -> 'd list
       but an expression was expected of type
         'a * 'b list -> 'c -> 'a * 'b list
       Type 'd list is not compatible with type 'a * 'b list 



hw3 mulByDigit

fix:
let rec mulByDigit i l = match i with
0 -> []
| 1 -> l
| 2 -> bigAdd l l
| _ -> bigAdd (mulByDigit (i-2) l) (mulByDigit i l)

bad:
let rec mulByDigit i l = 
let lr = List.rev l in
match lr with
(_,[])   -> ((fst x * snd x)/10, [(fst x * snd x) mod 10]) 
| (c,h::t) -> 
let sum = c + (fst x * snd x) in
(sum/10, (sum mod 10)::(snd a))
Error: This pattern matches values of type 'a * 'b
       but a pattern was expected which matches values of type 'c list


let rec mulByDigit i l = match i with
0 -> []
| 1 -> l
| 2 -> bigAdd l l
| _ -> bigAdd (mulByDigit (i-2) l) (mulBydigit i l)
Error: Unbound value mulBydigit
Hint: Did you mean mulByDigit?



hw3 mulByDigit

fix:
let _ = mulByDigit 9999999999999 [9;9;9;9]

bad:
let _ = mulByDigit 99999999999999999999 [9;9;9;9]
Error: Integer literal exceeds the range of representable integers of type int



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) x)) 
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x =  match a with
(_,[])   -> mulByDigit (fst x) l1
|(c, h::t) -> (c, mulByDigit h x)
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a * 'b
       but an expression was expected of type int list


let bigMul l1 l2 = 
let f a x =  match a with
(_,[])   -> mulByDigit (fst x) l1
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a * 'b list -> int * 'c -> int list
       but an expression was expected of type
         'a * 'b list -> int * 'c -> 'a * 'b list
       Type int list is not compatible with type 'a * 'b list 


let bigMul l1 l2 = 
let f a x = (fst a, bigAdd () ()) 
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This variant expression is expected to have type int list
       The constructor () does not belong to type list



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) x )) 
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let _ = bigMul [9;9;9;9] [9;9;9;9]
Error: This expression has type int but an expression was expected of type
         int list


let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]
Error: This expression has type int but an expression was expected of type
         int list


let bigMul l1 l2 = 
let f a x = ((fst a)+1, bigAdd snd x (mulByDigit (fst a) x )) 
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This function has type int list -> int list -> int list
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) (x@ clone 0 (fst a)) )) 
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) (snd x) )) 
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list
       but an expression was expected of type 'a * 'b



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) (l1@ clone 0 (fst a)) )) 
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

let _ = bigMul [9;9;9;9] [9;9;9;9]

let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

bad:
let _ = bigMul [9;9;9;9] [9;9;9;9]
Error: This expression has type int but an expression was expected of type
         int list
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int but an expression was expected of type
         int list


let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]
Error: This expression has type int but an expression was expected of type
         int list
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int but an expression was expected of type
         int list



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = 
((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) )) 
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = ((fst a)+1, bigAdd x (mulByDigit x (l1@ clone 0 (fst a)) )) 
in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list
       but an expression was expected of type int
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int list
       but an expression was expected of type int



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = match a with
(0, [])   -> (0, mulByDigit x (l1@ clone 0 0))
| (c, a) -> (c+1, bigAdd a (mulByDigit x (l1@clone 0 c)))
(*((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))*)

in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = match a with
(0, [])   -> (0, mulByDigit x (l1@ clone 0 []))
| (c, a) -> (c+1, bigAdd a (mulByDigit x (l1@clone 0 c))
(*((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))*)

in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Characters 105-106:
  | (c, a) -> (c+1, bigAdd a (mulByDigit x (l1@clone 0 c))
              ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let bigMul l1 l2 = 
let f a x = match a with
(0, [])   -> (0, mulByDigit x (l1@ clone 0 []))
| (c, a) -> (c+1, bigAdd a (mulByDigit x (l1@clone 0 c)))
(*((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))*)

in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a list
       but an expression was expected of type int
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = match a with
(((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))

in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

let _ = bigMul [9;9;9;9] [9;9;9;9]

let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

let key = ""

let prefix130 = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)^"\n"); ErrorCode "exception")

let explode s = 
let rec _exp i = 
if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in
_exp 0

let implode cs = 
String.concat "" (List.map (String.make 1) cs)

let drop_paren s = 
implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))

let eq_real p (r1,r2) = 
(r1 -. r2) < p || (r2 -. r1) < p

let wrap_curried_2 f (a,b) = f a b

let

bad:
let bigMul l1 l2 = 
let f a x = match a with
((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))

in
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Characters 46-47:
  ((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))
   ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw1 sumList

fix:
let rec sumList xs = 
if List.length xs>0 then
List.hd xs + sumList (List.tl xs)
else
0

bad:
let rec sumList xs = 
if List.length xs>0 then
List.hd xs + sumList List.tl xs
else
0
Error: This expression has type 'a list -> 'a list
       but an expression was expected of type int list



hw1 sumList

fix:
let _ = sumList [1; 3; 5; 7; 9; 11]

bad:
let _ = sumList [1; 3; 5; 7; 9; 11]



5 mod 4
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = sumList [1; 3; 5; 7; 9; 11]



5 mod 4
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = sumList [1; 3; 5; 7; 9; 11]



5 mod 4
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n>0 then
[2]
else
[1]

bad:
let rec digitsOfInt n = 
if n>0 then
digitOfInt n/10 @ ( n mod 10 ::[])
else
[]
Error: Unbound value digitOfInt
Hint: Did you mean digitsOfInt?


let rec digitsOfInt n = 
if n>0 then
digitsOfInt n/10 @ ( n mod 10 ::[])
else
[]
Error: This expression has type int but an expression was expected of type
         'a list


let rec digitsOfInt n = 
if n>0 then
(digitsOfInt n/10) @ ( n mod 10 ::[])
else
[]
Error: This expression has type int but an expression was expected of type
         'a list


let rec digitsOfInt n = 
if n>0 then
digitsOfInt n/10 
else
[]
Error: This expression has type 'a list
       but an expression was expected of type int


let rec digitsOfInt n = 
if n>0 then
digitsOfInt n/10 
else
[1;]
Error: This expression has type 'a list
       but an expression was expected of type int


let rec digitsOfInt n = 
if n>0 then
digitsOfInt n/10 
else
[1]
Error: This expression has type 'a list
       but an expression was expected of type int


let rec digitsOfInt n = 
if n>0 then
digitsOfInt n/10 
else
[1]
Error: This expression has type 'a list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n>0 then
[5]@ digitsOfInt (n/10)
else
[1]

bad:
let rec digitsOfInt n = 
if n>0 then
digitsOfInt n/10
else
[]
Error: This expression has type 'a list
       but an expression was expected of type int


let rec digitsOfInt n = 
if n>0 then
digitsOfInt n/10
else
[]
Error: This expression has type 'a list
       but an expression was expected of type int


let rec digitsOfInt n = 
if n>0 then
[5]@ digitsOfInt n/10
else
[1]
Error: This expression has type int but an expression was expected of type
         int list



hw1 ???

fix:
digits (-23422)

bad:
digits (-23422) is [2,3,4,2,2]
Error: This function has type int -> int list
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 additivePersistence

fix:
let rec additivePersistence n =
if n>0 then
1+ additivePersistence (help n)
else
0

bad:
let rec additivePersistence n =
if n>0 then
1+ additivePersistence help  n
else
0
Error: This expression has type int -> int
       but an expression was expected of type int



hw1 listReverse

fix:
let rec listReverse l = 
if List.length l >0 then
(List.hd l ::[])
else
[]

bad:
let rec listReverse l = 
if List.length>0 then
(listReverse List.tl l) @ (List.hd l ::[])
else
[]
Error: This expression has type int but an expression was expected of type
         'a list -> int


let rec listReverse l = 
if List.length l >0 then
(listReverse List.tl l) @ (List.hd l ::[])
else
[]
Error: This expression has type 'a list -> 'a list
       but an expression was expected of type 'b list



hw1 sumList

fix:
let rec sumList xs = match xs with
[]->0
| h::x -> h+(sumList x)

bad:
let rec sumList xs = match xs with
[]->0
|List.hd xs + sumList (List.tl xs)
Error: Syntax error


let rec sumList xs = match xs with
[]->0
| List.hd xs + sumList (List.tl xs)
Error: Syntax error



hw1 listReverse

fix:
let rec listReverse l = match l with
[]->[]
|h::x->(listReverse x) @ h

bad:
let rec listReverse l = match l with
[]->[]
|h:x->(listReverse x) @ h
Error: Syntax error



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n>10 then
(n mod 10):: (digitsOfInt (n/10))
else
[n]

bad:
let rec digitsOfInt n = 
if n>10 then
(n mod 10):: (digitsOfInt (n/10)
else
[n]
Characters 51-52:
  (n mod 10):: (digitsOfInt (n/10)
               ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n>=100 then
[n mod 10]
else
[n]

bad:
let rec digitsOfInt n = 
if n>10 then
(digitsOfInt (n/10))::[n mod 10]
else
n
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec digitsOfInt n = 
if n>10 then
n::[n mod 10]
else
n
Error: This expression has type int but an expression was expected of type
         int list



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n>=10 then
app (digitsOfInt (n/10) [n mod 10])
else
[n]

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

bad:
let rec digitsOfInt n = 
if n>10 then
app ((digitsOfInt (n/10)) [n mod 10])
else
[n]
Error: This expression has type 'a list
       but an expression was expected of type int list -> int list


let rec digitsOfInt n = 
if n>10 then
app ((digitsOfInt (n/10)) [n mod 10])
else
[n]
Error: This expression has type 'a list
       but an expression was expected of type int list -> int list


let rec digitsOfInt n = 
if n>=10 then
app ((digitsOfInt (n/10)) [n mod 10])
else
n::[]
Error: This expression has type 'a list
       but an expression was expected of type int list -> int list


let rec digitsOfInt n = 
if n>=10 then
app (digitsOfInt (n/10) [n mod 10])
else




(* uncomment and run AFTER you have implemented digitsOfInt *)
let _ = digitsOfInt 3124
Error: Syntax error



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n>=10 then
digitsOfInt (n/10) @ [n mod 10]
else
[n]

bad:
let rec digitsOfInt n = 
if n>=10 then
app digitsOfInt (n/10) [n mod 10]
else
[n]
Error: This function has type 'a list -> 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n>=10 then
(digitsOfInt (n/10)) @ ([n mod 10])
else
[n]

bad:
let rec digitsOfInt n = 
if n>=10 then
app (digitsOfInt (n/10) [n mod 10])
else
[n]
Error: This expression has type 'a list
       but an expression was expected of type int list -> int list


let rec digitsOfInt n = 
if n>=10 then
app (digitsOfInt (n/10) [n mod 10])
else
n
Error: This expression has type int but an expression was expected of type
         int list -> int list


let rec digitsOfInt n = 
if n>=10 then
app ((digitsOfInt (n/10)) ([n mod 10]))
else
[n]
Error: This expression has type 'a list
       but an expression was expected of type int list -> int list


let rec digitsOfInt n = 
if n>=10 then
app ((digitsOfInt (n/10)) ([n mod 10]))
else
[n+0]
Error: This expression has type 'a list
       but an expression was expected of type int list -> int list



hw1 ???

fix:
let rec helpFac a b=
if 10*a>b then
a
else
helpFac (10*a) b

bad:
let rec helpFac a b=
if 10*a>b then
a
else
10*a b
Error: This expression has type int
       This is not a function; it cannot be applied.


let rec helpFac a b=
if 10*a>b then
a
else
helpFac 10*a b
Error: This expression has type int -> int
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n>=10 then
(n/(helpFac n 1))::digitsOfInt (n/10)
else
[n]

bad:
let rec digitsOfInt n = 
if n>=10 then
(n/(help n 1))::digitsOfInt (n/10)
else
[n]
Error: This function has type int -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 ???

fix:
helpFac 3124 1

bad:
helpFac (3124 1)
Error: This expression has type int
       This is not a function; it cannot be applied.



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n>=10 then
app [5] [n mod 10] 
else
app [3] [8]

bad:
let rec digitsOfInt n = 
if n>=10 then
app (digitsOfInt (n/10) [n mod 10]) 
else
[n]
Error: This expression has type 'a list
       but an expression was expected of type int list -> int list


let rec digitsOfInt n = 
if n>=10 then
app (digitsOfInt (n/10) [n mod 10]) 
else
app [n] []
Error: This expression has type int list
       but an expression was expected of type int list -> int list


let rec digitsOfInt n = 
if n>=10 then
app (digitsOfInt (n/10) [n mod 10]) 
else
app [n] [8]
Error: This expression has type int list
       but an expression was expected of type int list -> int list


let rec digitsOfInt n = 
if n>=10 then
app ([n/10] [n mod 10]) 
else
app [3] [8]
Error: This expression has type int list
       This is not a function; it cannot be applied.


let rec digitsOfInt n = 
if n>=10 then
app ([(n/10)] [n mod 10]) 
else
app [3] [8]
Error: This expression has type int list
       This is not a function; it cannot be applied.


let rec digitsOfInt n = 
if n>=10 then
app ([n/10] [n mod 10]) 
else
app [3] [8]
Error: This expression has type int list
       This is not a function; it cannot be applied.


let rec digitsOfInt n = 
if n>=10 then
app ([n / 10] [n mod 10]) 
else
app [3] [8]
Error: This expression has type int list
       This is not a function; it cannot be applied.



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n>=10 then
app (digitsOfInt (n/10)) [n mod 10] 
else
app [3] [8]

bad:
let rec digitsOfInt n = 
if n>=10 then
app digitsOfInt n/10 [n mod 10] 
else
app [3] [8]
Error: This expression has type int -> 'a
       but an expression was expected of type 'b list


let rec digitsOfInt n = 
if n>=10 then
app digitsOfInt (n/10) [n mod 10] 
else
app [3] [8]
Error: This function has type 'a list -> 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 digitsOfInt

fix:
let _ = digitsOfInt 3124

bad:
let _ = digitsOfInt 3124let _ =digitsOfInt 1001
Error: Syntax error



hw1 digitsOfInt

fix:
let digitsOfInt n = 
let rec driver n ls=
if n>=10 then
driver (n/10) (n mod 10::ls)
else
[n]
in
driver n []

bad:
let digitsOfInt n = 
let driver n ls=
if n>=10 then
driver n/10 (n mod 10::ls)
else
[n]
in
driver n []
Error: Unbound value driver


let digitsOfInt n = 
let rec driver n ls=
if n>=10 then
driver n/10 (n mod 10::ls)
else
[n]
in
driver n []
Error: This expression has type 'a -> 'b
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let digitsOfInt n = 
let rec driver n ls=
if n>=10 then
driver (n/10) ((n mod 10)::ls)
else
ls
in
driver (n*10) []

bad:
let digitsOfInt n = 
let rec driver n ls=
if n>=10 then
driver (n/10) ((n mod 10)::ls)
else
ls
in
driver n*10 []
Error: This expression has type int list -> int list
       but an expression was expected of type int



hw1 additivePersistence

fix:
let additivePersistence n =let rec county n=
if n>=10 then
1+ additivePersistence (help n)
else
0
in 
county n

bad:
let additivePersistence n =let rec county=
if n>=10 then
1+ additivePersistence (help n)
else
0
in 
county n
Error: This expression has type int
       This is not a function; it cannot be applied.
Error: Unbound value help
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int
       This is not a function; it cannot be applied.



hw2 removeDuplicates

fix:
let rec assoc (d,k,l) = match (d ,k,l) with
|(x,y,[])->x
|(x,y,(a,b)::t)->if a=y then
b
else
assoc (x,y,t)

let _=(assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)]))

let _=(assoc (-1,"bob",[("ranj it",85);("william",23);("moose",44)]))

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then
seen 
else
h::seen
in
let rest' = t in 
helper (seen',rest') 

in
List.rev (helper ([],l))

bad:
 _=(removeDuplicates [1,6,2,4,12,2,13,6,9])
Error: Syntax error



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then
seen 
else
h::seen
in
let rest' = t in 
helper (seen',rest') 

in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if (List.mem seen h) then
seen 
else
h::seen
in
let rest' = t in 
helper (seen',rest') 

in
List.rev (helper ([],l))
Error: This expression has type 'a list list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list list



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then
seen 
else
h::seen
in
let rest' = t in 
helper (seen',rest') 

in
List.rev (helper ([],l))

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then
seen 
else
h::seen
in
let rest' = t in 
helper (seen',rest') 

in
List.rev helper ([],l)
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.



hw2 wwhile

fix:
let rec wwhile (f,b) = match f b with
|(a,c)->if not c then
a
else
wwhile (f,a)

bad:
let rec wwhile (f,b) = match f b with
|(a,c)->if not c then
a
else
wwhile f a
Error: This expression has type 'a -> ('b -> 'c) * bool
       but an expression was expected of type ('a -> ('b -> 'c) * bool) * 'a



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile (let g y x=
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
sec (y x) x
in
g f b

,b)

bad:
let fixpoint (f,b) = wwhile ((let g y x=
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
sec (y x) x)

,b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ((let g y x=
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
(sec (y x) x) )

,b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile (let g y x=
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
(sec (y x) x)

,b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ((let g y x=
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
(sec (y x) x))

,b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile (let g y x=
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
sec (y x) x

,b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile (let g y x=
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
sec (y x) x

,b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile (let g y x=
(let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) )
in
sec (y x) x

,b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile (let g y x=f b
,b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile (let g y x=y b in
g y b
,b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile (let g y x=y b in
g f b
,b)
Error: Unbound value y



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile (let g y x=
let sec s fi m=
if s=fi then
(s,s=(m s))
else
(s,false) 
in
sec (y x) x
in
g f b

,b)

bad:
let fixpoint (f,b) = wwhile (let g y x=

in
g f b

,b)
Error: This expression has type ('a -> 'a) -> 'a * bool
       but an expression was expected of type ('a -> 'a) -> ('a -> 'a) * bool
       The type variable 'a occurs inside 'a -> 'a


let fixpoint (f,b) = wwhile (let g y x= y x

in
g f b

,b)
Error: Syntax error: operator expected.



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile (let g x=

in
(g (f b),false)

,b)

bad:
let fixpoint (f,b) = wwhile (let g y x=
((y x),false)
in
g f b

,b)
Error: This expression has type ('a -> 'a) -> 'a * bool
       but an expression was expected of type ('a -> 'a) -> ('a -> 'a) * bool
       The type variable 'a occurs inside 'a -> 'a


let fixpoint (f,b) = wwhile (let g x=
(x,false)
in
g f b

,b)
Error: This expression has type 'a * bool
       but an expression was expected of type 'b -> 'b * bool


let fixpoint (f,b) = wwhile (let g x=
(x,false)
in
g (f b)

,b)
Error: This function has type 'a -> 'a * bool
       It is applied to too many arguments; maybe you forgot a `;'.


let fixpoint (f,b) = wwhile (let g x=
x,false
in
g (f b)

,b)
Error: This expression has type 'a * bool
       but an expression was expected of type 'b -> 'b * bool


let fixpoint (f,b) = wwhile (let g x=
x
in
g (f b)

,b)
Error: This expression has type 'a * bool
       but an expression was expected of type 'b -> 'b * bool



hw2 fixpoint

fix:
let g x y= ((y x),false)

let fixpoint (f,b) = wwhile (g b f
,b)

bad:
let fixpoint (f,b) = wwhile (let g x y= ((y x),false)
in g b f
,b)
Error: This expression has type 'a * bool
       but an expression was expected of type 'b -> 'b * bool



hw2 ???

fix:
let g x y= (y (y x),false)

bad:
let g x y= ((y x),false)
Error: This expression has type 'a * bool
       but an expression was expected of type 'b -> 'b * bool



hw2 fixpoint

fix:
let h q x y=q x y

let g x f= (f x,(f x)=x)

let fixpoint (f,b) = wwhile (h  g (f) b
,b)

bad:
let fixpoint (f,b) = wwhile (g b f
,b)
Error: Syntax error: operator expected.



hw2 fixpoint

fix:
let f x = let xx = x*x*x in (xx,xx<100)

let _ =wwhile (f,2)

let h x b = b x

let fixpoint (f,b) = wwhile (h b f,
,b)

bad:
let fixpoint (f,b) = wwhile (let h x b= b x in h f b
Error: Syntax error: operator expected.


,
,b)
Characters 28-29:
  let fixpoint (f,b) = wwhile (let h x b= b x in h f b;;
                              ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let fixpoint (f,b) = wwhile ((let h x b= b x in h f b),
,b)
Error: Syntax error


let fixpoint (f,b) = wwhile ((h x b = b x 
in h f b
Error: Syntax error: operator expected.



hw2 fixpoint

fix:
let h x y = ((y x),x<100)

let fixpoint (f,b) = wwhile (h b f
,b)

bad:
let fixpoint (f,b) = wwhile (let h x y = ((y x),x=x) in
h b f
,b)
Error: This expression has type 'a * bool
       but an expression was expected of type 'b -> 'b * bool


let fixpoint (f,b) = wwhile (let h x y = ((y x),x<100) in
h b f
,b)
Error: This expression has type 'a * bool
       but an expression was expected of type 'b -> 'b * bool



hw2 fixpoint

fix:
let h x=(x*x,x<100)

let fixpoint (f,b) = wwhile (h,b)

bad:
let fixpoint (f,b) = wwhile (h b f,b)
Error: This expression has type 'a * bool
       but an expression was expected of type 'b -> 'b * bool


let fixpoint (f,b) = wwhile (f,b)
Error: This expression has type 'a * bool
       but an expression was expected of type 'b -> 'b * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile (let h a= f a
in h b,b)

bad:
let fixpoint (f,b) = wwhile (let h = f
in (h,false),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile (let h a= f
in h a,b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile (let h a= f
in h b,b)
Error: Unbound value a



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile (let h x= (f x,(f x)=x) in
h,b)

bad:
let fixpoint (f,b) = wwhile (let h x= (f x,false),b)
Error: This expression has type 'a * bool
       but an expression was expected of type 'b -> 'b * bool


let fixpoint (f,b) = wwhile (let h x= (f x,false) in
h,b)
Error: Syntax error: operator expected.



hw2 fixpoint

fix:
let rec assoc (d,k,l) = match (d ,k,l) with
|(x,y,[])->x
|(x,y,(a,b)::t)->if a=y then
b
else
assoc (x,y,t)

let _=(assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)]))

let _=(assoc (-1,"bob",[("ranj it",85);("william",23);("moose",44)]))

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then
seen 
else
h::seen
in
let rest' = t in 
helper (seen',rest') 

in
List.rev (helper ([],l))

removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) = match f b with
|(a,c)->if not c then
a
else
wwhile (f,a)

let f x = let xx = x*x*x in (xx,xx<100)

let _ =wwhile (f,2)

let fixpoint (f,b) = wwhile (let h x= let first =f x in
let second =f first in 
let third = f second 
in  (second,not ((first=second)&&(second=third)
&&(third=first)))
in
h,b)

bad:
let fixpoint (f,b) = wwhile (let h x= let first =f x in
let second =f first in 
let third = f second 
in  (second,not ((first=second)&&(second=third)
&&(third=first))
in
h,b)
Error: Syntax error: operator expected.



hw2 ???

fix:
"x""y""Z"

bad:
"a"
Error: This expression has type string
       This is not a function; it cannot be applied.



hw2 eval

fix:
let rec eval (e,x,y) =match e with
VarX -> x
| VarY -> y
| Sine  expr -> sin(pi*.(eval (expr, x ,y)))
| Cosine expr-> cos(pi*.(eval (expr, x ,y)))
| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/. 2
| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))
| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<
(eval (expr1 ,x, y))
then
eval (expr2 ,x ,y)
else
eval (expr3 ,x ,y)

bad:
let rec eval (e,x,y) =match e with
VarX -> x
| VarY -> y
| Sine  expr -> sin(pi*.(eval (expr, x ,y)))
| Cosine expr-> cos(pi*.(eval (expr, x ,y)))
| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2
| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))
| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<
(eval (expr1 ,x, y))
then
eval (expr2 ,x ,y)
else
eval (expr3 ,x ,y)
Error: This expression has type expr
       This is not a function; it cannot be applied.


let rec eval (e,x,y) =match e with
VarX -> x
| VarY -> y
| Sine  expr -> sin(pi*.(eval (expr, x ,y)))
| Cosine expr-> cos(pi*.(eval (expr, x ,y)))
| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))
| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))
| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<
(eval (expr1 ,x, y))
then
eval (expr2 ,x ,y)
else
eval (expr3 ,x ,y)
Error: This expression has type int but an expression was expected of type
         float



hw2 eval

fix:
let rec eval (e,x,y) =match e with
VarX -> x
| VarY -> y
| Sine  expr -> sin(pi*.(eval (expr, x ,y)))
| Cosine expr-> cos(pi*.(eval (expr, x ,y)))
| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.
| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))
| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<
(eval (expr1 ,x, y))
then
eval (expr2 ,x ,y)
else
eval (expr3 ,x ,y)

bad:
let rec eval (e,x,y) =match e with
VarX -> x
| VarY -> y
| Sine  expr -> sin(pi*.(eval (expr, x ,y)))
| Cosine expr-> cos(pi*.(eval (expr, x ,y)))
| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/2
| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))
| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<
(eval (expr1 ,x, y))
then
eval (expr2 ,x ,y)
else
eval (expr3 ,x ,y)
Error: This expression has type int but an expression was expected of type
         float


let rec eval (e,x,y) =match e with
VarX -> x
| VarY -> y
| Sine  expr -> sin(pi*.(eval (expr, x ,y)))
| Cosine expr-> cos(pi*.(eval (expr, x ,y)))
| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.
| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))
| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<
(eval (expr1 ,x, y))
then
eval (expr2 ,x ,y)
else
eval (expr3 ,x ,y)
Error: This expression has type float but an expression was expected of type
         int



hw2 eval

fix:
let _ = eval (sampleExpr1,0.5,0.2)

bad:
let _ = eval (sampleExpr1,0.5,0.2)
Error: This expression has type expr/2231
       but an expression was expected of type expr/2334
Error: This expression has type expr/2437
       but an expression was expected of type expr/2457
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type expr/2231
       but an expression was expected of type expr/2334



hw2 build

fix:
let rec build (rand, depth) = let res=rand(0,4) in match depth with
0-> if (res mod 2)=0 then
buildX()
else
buildY()
|_ ->let nd=depth-1 in
match res with
|0->buildAverage(build(rand,nd),build(rand,nd))
|1->buildThresh(build(rand,nd),build(rand,nd),
build(rand,nd),build(rand,nd))
|2->buildTimes(build(rand,nd),build(rand,nd))
|3->buildSine(build(rand,nd))
|4->buildCosine(build(rand,nd))
|_->buildX()

bad:
let rec build (rand, depth) = let res=rand(0,4) in match depth with
0-> if (res mod 2)=0 then
buildX()
else
buildY()
|_ ->let nd=depth-1 in
match res with
|0->buildAverage(build(rand,nd),build(rand,nd))
|1->buildThresh(build(rand,nd),build(rand,nd),
build(rand,nd),build(rand,nd))
|2->buildTimes(build(rand,nd),build(rand,nd))
|3->buildSine(build(rand,nd))
|4->buildCosine(build(rand,nd))
Error: This expression has type 'a * 'b
       but an expression was expected of type expr



hw2 exprToString

fix:
et rec exprToString e = match e 
with  
VarX -> "x"
| VarY -> "y"
| Sine  expr -> "sin(pi*"^(exprToString expr)^")"
| Cosine expr-> "cos(pi*"^(exprToString expr)^")"
| Average (expr,expr1)->"(("^(exprToString expr)^"+"
^(exprToString expr1)^")/2)"
|Times   (expr,expr1)->(exprToString expr)^"*"^(exprToString expr1)
|Nom (expr1,expr2,expr3)->let res1,res2,res3=(exprToString expr1),
(exprToString expr2),
(exprToString expr3) 
in
"("^res1^"+"^res2^"+"^res3^")/(abs("^res1^")+abs("^res2^")+abs("
^res3^"))"

|Squa expr -> let res=exprToString expr in
"abs("^res^")/(abs"^res^"+"^res^"^2)"
| Thresh  (expr,expr1,expr2,expr3)->"("^(exprToString expr)^"<"
^(exprToString expr1)^"?"
^(exprToString expr2)^":"^
(exprToString expr3)

bad:
let rec exprToString e = match e 
with  
VarX -> "x"
| VarY -> "y"
| Sine  expr -> "sin(pi*"^(exprToString expr)^")"
| Cosine expr-> "cos(pi*"^(exprToString expr)^")"
| Average (expr,expr1)->"(("^(exprToString expr)^"+"
^(exprToString expr1)^")/2)"
|Times   (expr,expr1)->(exprToString expr)^"*"^(exprToString expr1)
|Nom (expr1,expr2,expr3)->let res1,res2,res3=(exprToString expr1),
(exprToString expr2),
(exprToString expr3) 
in
"("^res1^"+"^res2^"+"^res3^")/(abs("^res1^")+abs("^res2^")+abs("
^res3^"))"

|Squa expr -> let res=exprToString expr in
"abs("^res^")/(abs"^res^"+"^res^"^2)"
| Thresh  (expr,expr1,expr2,expr3)->"("^(exprToString expr)^"<"
^(exprToString expr1)^"?"
^(exprToString expr2)^":"^
(exprToString expr3)
Error: This expression has type string but an expression was expected of type
         int



hw2 eval

fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr1,0.5,0.2)

bad:
let rec eval (e,x,y) =match e with
VarX -> x
| VarY -> y
| Sine  expr -> sin(pi*.(eval (expr, x ,y)))
| Cosine expr-> cos(pi*.(eval (expr, x ,y)))
| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.
| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))
| Squa expr->let res=eval(expr,x,y) in res /. ((abs_float res )+. 1.0)
| Nom (expr,expr1,expr2)-> let r1,r2,r3=(eval(expr,x,y),eval(expr1,x,y),
eval(expr2,x,y)) in
(r1 +. r2 +. r3) /. ((abs_float r1)+.(abs_float r2)+.(abs_float r3))

| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<
(eval (expr1 ,x, y))
then
eval (expr2 ,x ,y)
else
eval (expr3 ,x ,y)
Error: Unbound value r1



hw2 ???

fix:
let c3 () = (4,15,70)

bad:
let c3 () = (11,15,70)
Error: Syntax error



hw2 eval

fix:
let rec eval (e,x,y) =match e with
VarX -> x
| VarY -> y
| Sine  expr -> sin(pi*.(eval (expr, x ,y)))
| Cosine expr-> cos(pi*.(eval (expr, x ,y)))
| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.
| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))
| Squa expr->let res=eval(expr,x,y) in res /. ((abs_float res )+. 1.0)
| Nom (expr,expr1,expr2)-> let r1,r2,r3=(eval(expr,x,y),eval(expr1,x,y),
eval(expr2,x,y)) in
(r1 +. r2 +. r3) /. ((abs_float r1)+.(abs_float r2)+.(abs_float r3))

| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<
(eval (expr1 ,x, y))
then
eval (expr2 ,x ,y)
else
eval (expr3 ,x ,y)

bad:
let_=eval (Sine(Average(VarX,VarY)),0.3,0.3)
Error: This function has type 'a -> unit
       It is applied to too many arguments; maybe you forgot a `;'.


let _=eval (Sine(Average(VarX,VarY)),0.3,0.3)
Error: Unbound value let_



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x))

fixpoint (g,0)

bad:
let fixpoint (f,b) = wwhile (let h x= let first =x in
let second =f first 
in  (second,not ((first=second)))
in
h,b)
Error: Unbound value fixpoint



hw2 build

fix:
let buildNom(e,e1,e2)		   = Nom(e,e1,e2)

bad:
let buildNom(e,e1,e2)		   = Nom(e,e1,e2)
Error: Unbound value e



hw2 build

fix:
let _=  (build(makeRand(3,4),3))

bad:
let _= exprToString (build(makeRand(3,4),2))
Error: This function has type expr -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = (fun j y->y) in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = (fun j y->y) in 
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = (fun y->y) in 
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let _ = pipe [(fun x -> x+x); (fun x -> x + 3)]
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = (fun y->y) in 
List.fold_left f base fs

bad:
let _ = pipe [] 3
Error: This function has type (int -> int) list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = (fun y->y) in 
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = (fun z->z) in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = y in 
List.fold_left f base fs
Error: Unbound value y



hw3 pipe

fix:
let pipe fs = 
let f a x = a in
let base = fun z->z in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x =  in
let base = fun z->z in 
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = fun z->z in 
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base = (fun a->a) in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base = in 
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base =  (fun y->y) in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = x a in
let base =  a in 
List.fold_left f base fs
Error: Unbound value a


let pipe fs = 
let f a x = x a in
let base =  x in 
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = x a in
let base =  fs in 
List.fold_left f base fs
Error: This expression has type 'a but an expression was expected of type
         ('a -> 'a) list
       The type variable 'a occurs inside ('a -> 'a) list


let pipe fs = 
let f a x = x a in
let base =  *1 in 
List.fold_left f base fs
Error: Syntax error



hw3 ???

fix:
let id=(fun x->x)

bad:
let id=(x->x)
Characters 7-8:
  let id=(x->x);;
         ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw3 pipe

fix:
let pipe fs = 
let f a x = x a in
let base =  (fun x _->x) in 
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let pipe fs = 
let f a x = a x in
let base =  (fun x->x) in 
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = a x in
let base =  (fun x->x) in 
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = x in
let base =  (fun x ->x) in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base =  (fun x ->x) in 
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = fun j->fun y-> x a in
let base =  (fun x ->x) in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun j->fun x-> a in
let base =  (fun x ->x) in 
List.fold_left f base fs
Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'c -> 'd -> 'a



hw3 pipe

fix:
let pipe fs = 
let f a x = fun j->a x  in
let base =  (fun x ->x) in 
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun j->a-> x  in
let base =  (fun x ->x) in 
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let id x= x

let pipe fs = 
let f a x = fun j-> (x (a j))  in
let base =  (fun x ->x) in 
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         int -> int



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = sepConcat sep t in
List.fold_left f base l
Error: This expression has type string but an expression was expected of type
         string list



hw3 stringOfList

fix:
let stringOfList f l = List.map f l

bad:
let stringOfList f l = map f l
Error: Unbound value map
Hint: Did you mean max?


let stringOfList f l = map f l
Error: Unbound value map
Hint: Did you mean max?


let stringOfList f l = map f l
Error: Unbound value map
Hint: Did you mean max?



hw3 stringOfList

fix:
let stringOfList f l ="["^ (sepConcat "; " (List.map f l) )^"]"

bad:
let stringOfList f l ="["^ (sepConcat "; " sepList.map f l) ^"]"
Error: This function has type string -> string list -> string
       It is applied to too many arguments; maybe you forgot a `;'.


let stringOfList f l ="["^ (sepConcat "; " (sepList.map f l) )^"]"
Error: Unbound value sepList



hw3 clone

fix:
let rec clone x n = let rec  helper xs sub depth=match depth with
0->xs
|_->helper (sub::xs) sub (depth-1)
in helper [] x n

bad:
let rec clone x n = let helper xs sub depth=match depth with
0->xs
|_->help (sub::xs) sub (depth -1)
Error: Syntax error


let rec clone x n = let helper xs sub depth=match depth with
0->xs
|_->help (sub::xs) sub (depth-1)
Error: Syntax error


let rec clone x n = let helper xs sub depth=match depth with
0->xs
|_->helper (sub::xs) sub (depth-1)
Error: Syntax error


let rec clone x n = let helper xs sub depth=match depth with
0->xs
|_->helper (sub::xs) sub (depth-1)
in helper [] x n
Error: Unbound value helper



hw3 padZero

fix:
let rec padZero l1 l2 = let sizeDif= (List.length l1)-(List.length l2) in
let appendS=(clone ( abs  sizeDif ) 0) in
if sizeDif<0 then ( appendS@l1,l2)
else (l1,appendS@l2)

bad:
let rec padZero l1 l2 = let sizeDif= (List.length l1)-(List.length l2) in
let appendS=(clone ( abs  sizeDif ) 0) in
if sizeDif<0 then ( appendS@l1,l2)
else then (l1,appendS@l2)
Error: Syntax error



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in 
let car,res=(res/10),(res mod 10) in
let c1,c2=a in
match c1 with
[]->([car],res::c2)
|y::s->(car::s,(res+y)::c2) in
let base = ([],[]) in
let args = List.combine (List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in 
let car,res=(res/10),(res%10) in
let c1,c2=a in
match c1 with
[]->([car],res::c2)
|y::s->(car::s,(res+y)::c2)
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = ([10],[10])
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in 
let car,res=(res/10),(res%10) in
let c1,c2=a in
match c1 with
[]->([car],res::c2)
|y::s->(car::s,(res+y)::c2) in
let base = ([],[]) in
let args = List.combine List.rev l1 List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value %


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in 
let car,res=(res/10),(res mod 10) in
let c1,c2=a in
match c1 with
[]->([car],res::c2)
|y::s->(car::s,(res+y)::c2) in
let base = ([],[]) in
let args = List.combine List.rev l1 List.rev l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This function has type 'a list -> 'b list -> ('a * 'b) list
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in 
let car,re=(res/10),(res mod 10) in
let c1,c2=a in
match c1 with
[]->([car],re::c2)
|y::s->((car::s),((re+y)mod 10)::c2) in
let base = ([],[]) in
let args = List.combine (List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in 
let car,re=(res/10),(res mod 10) in
let c1,c2=a in
match c1 with
[]->([car],re::c2)
|y::s->((((re+y)/10)+car)::s),((re+y)mod 10)::c2
Error: Syntax error


) in
let base = ([],[]) in
let args = List.combine (List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in 
let car,re=(res/10),(res mod 10) in
let c1,c2=a in
match c1 with
[]->([car],re::c2)
|y::s->let sub=re+y in( ((sub /10) +car)::s),
((sub mod 10)::c2) in
let base = ([],[]) in
let args = List.combine (List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in 
let car,re=(res/10),(res mod 10) in
let c1,c2=a in
match c1 with
[]->([car],re::c2)
|y::s->let sub=re+y in ((((sub /10 )+car)::s),
((sub mod 10)::c2) in
let base = ([],[]) in
let args = List.combine (List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Characters 205-206:
  |y::s->let sub=re+y in ((((sub /10 )+car)::s),
                         ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in
let p1,p2=a in
match p2 with 
[]->(p1,(res/10)::(res mod 10)::[])
|a::b->let re=a+(res mod 10)  in
(p1,(re/10)::(re mod 10)::b )in
let base = ([],[]) in
let args = List.combine (List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in
let p1,p2=a in
match p2 with 
[]->(res/10)::(res mod 10)::[]
|a::b->let re=a+(res mod 10)  in
(re/10)::(re mod 10)::b in

let base = ([],[]) in
let args = List.combine (List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * int list -> int * int -> int list
       but an expression was expected of type
         'a * int list -> int * int -> 'a * int list
       Type int list is not compatible with type 'a * int list 



hw3 bigMul

fix:
let sqsum xs = 
let f a x = a+(x*x) in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = fun j-> (x (a j))  in
let base =  (fun x ->x) in 
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

let _=sepConcat ", " []

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l ="["^ (sepConcat "; " (List.map f l) )^"]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n = let rec  helper xs sub depth=match (depth>0) with
false->xs
|true->helper (sub::xs) sub (depth-1)
in helper [] x n

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let rec padZero l1 l2 = let sizeDif= (List.length l1)-(List.length l2) in
let appendS=(clone 0 ( abs  sizeDif )) in
if sizeDif<0 then ( appendS@l1,l2)
else (l1,appendS@l2)

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

let _ = padZero [9;9] [1;0]

let rec removeZero l = match l with 
[] ->[]
|h::t->if(h=0) then
removeZero t
else
l

let _ = removeZero [0;0;0;1;0;0;2]

let _ = removeZero [9;9]

let _ = removeZero [0;0;0;0]

let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
(op1,op2)->let res =op1+op2 in
let p1,p2=a in
match p2 with 
[]->(p1,(res/10)::(res mod 10)::[])
|a::b->let re=a+(res)  in
(p1,(re/10)::(re mod 10)::b )in
let base = ([],[]) in
let args = List.combine (List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

let _=bigAdd [5;0;0] [6;0;0]

let rec mulByDigit i l = let rec helper i l acc=match i with
0->acc
|_->helper (i-1) l (bigAdd l  acc)
in
helper i l [0]

let _ = mulByDigit 0 [9;9;9;9]

let bigMul l1 l2 = 
let f a x = let b,c=a in match b with 
d::t-> ((d*10)::t,bigAdd((mulByDigit d*x t) c))
|_    ->a
in

let base =(1::l2,[0]) in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = s in
let base =([0],[0]) in
let args = (l1,l2) in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value s



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = let b,c=a in match b with 
d::t-> ((d*10)::t, t)
|_    ->a
in

let base =(1::l2,[0]) in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = let b,c=a in match b with 
d::t-> ((d*10)::t,bigAdd((mulByDigit (d*x) t) c))
|_    ->a
in

let base =(1::l2,[0]) in
let args = List.rev l1 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list
       This is not a function; it cannot be applied.



hw2 fixpoint

fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

bad:
let _ = fixpoint (collatz, 1)
Error: This expression has type int -> int
       but an expression was expected of type int -> int * bool
       Type int is not compatible with type int * bool 



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile(if f b = b then f, b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

bad:
let fixpoint (f,b) = wwhile((f::(f b = b)), b)
Error: This expression has type 'a list
       but an expression was expected of type 'b -> 'b * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile((fun b ->  (f, (f b) != b)), b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

bad:
let _ = fixpoint (collatz, 3)
Error: Unbound value fixpoint


let _ = fixpoint (collatz, 48)
Error: Unbound value fixpoint


let _ = fixpoint (collatz, 107)
Error: Unbound value fixpoint



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile(fun b ->  f b, (f b != b), b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

bad:
let _ = fixpoint (collatz, 3)
Error: Unbound value fixpoint



hw2 exprToString

fix:
let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)

let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

bad:
let rec exprToString e = match e with
| VarX -> sprintf"%s" e
Error: This expression has type string
       This is not a function; it cannot be applied.


let rec exprToString e = match e with
| VarX -> sprintf(%s) e
Error: Unbound value sprintf


let rec exprToString e = match e with
| VarX -> sprintf("%s") e
Characters 55-56:
  | VarX -> sprintf(%s) e;;
                   ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let rec exprToString e = match e with
| VarX -> Output.sprintf("%s") e
Error: Unbound value sprintf


let rec exprToString e = match e with
| VarX -> Module.sprintf("%s") e
Error: Unbound module Output


let rec exprToString e = match e with
| VarX     -> "%s" e
| VarY     -> ""
| Sine  
| Cosine   
| Average  
| Times    
| Thresh
Error: Unbound module Module


let rec exprToString e = match e with
| VarX     -> "%s" e
| VarY     -> "%s" e
| Sine     ->
| Cosine   ->
| Average  ->
| Times    ->
| Thresh   ->
Error: Syntax error: pattern expected.


let rec exprToString e = match e with
| VarX     -> "%s" e
| VarY     -> "%s" e
| Sine     -> "%s" e
| Cosine   -> "%s" e
| Average  -> "%s" e
| Times    -> "%s" e
| Thresh   -> "%s" e
Error: Syntax error


let rec exprToString e = match e with
| VarX     -> "%s" e
| VarY     -> "%s" e
| Sine     -> "%s %s" e e
| Cosine   -> "%s" e
| Average  -> "%s" e
| Times    -> "%s" e
| Thresh   -> "%s" e
Error: The constructor Sine expects 1 argument(s),
       but is applied here to 0 argument(s)


let rec exprToString e = match e with
| VarX     -> "%s" e
| VarY     -> "%s" e
| Sine     -> "%s %s" e 
| Cosine   -> "%s" e
| Average  -> "%s" e
| Times    -> "%s" e
| Thresh   -> "%s" e
Error: The constructor Sine expects 1 argument(s),
       but is applied here to 0 argument(s)


let rec exprToString e = match e with
| VarX              -> "%s" e
| VarY              -> "%s" e
| Sine (e)          -> "%s" e 
| Cosine (e)        -> "%s" e
| Average (e,e)     -> "%s" e
| Times (e,e)       -> "%s" e
| Thresh (e,e,e,e)  -> "%s" e
Error: The constructor Sine expects 1 argument(s),
       but is applied here to 0 argument(s)


let rec exprToString e = match e with
| VarX              -> "%s" e
| VarY              -> "%s" e
| Sine (e1)          -> "%s" e1 
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0
Error: Variable e is bound several times in this matching


let rec exprToString e = match e with
| VarX              -> sprintf"%s" e
| VarY              -> "%s" e
| Sine (e1)          -> "%s" e1 
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0
Error: This expression has type string
       This is not a function; it cannot be applied.


let rec exprToString e = match e with
| VarX              -> Printf.sprintf"%s" e
| VarY              -> "%s" e
| Sine (e1)          -> "%s" e1 
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0
Error: Unbound value sprintf


let rec exprToString e = match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> "%s" e
| Sine (e1)          -> "%s" e1 
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0
Error: This expression has type expr but an expression was expected of type
         string


let rec exprToString e = match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> Printf.sprintf"%s" 
| Sine (e1)          -> Printf.sprintf"%s" e1 
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0
Error: This expression has type string
       This is not a function; it cannot be applied.


let rec exprToString e = match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> Printf.sprintf"%s" 
| Sine (e1)          -> Printf.sprintf"e1"
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0
Error: This expression has type expr but an expression was expected of type
         string


let rec exprToString e = match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> Printf.sprintf"%s" 
| Sine (e1)          -> Printf.printf"e1"
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0
Error: This expression has type string but an expression was expected of type
         string -> string


let rec exprToString e = match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> Printf.sprintf"%s" 
| Sine (e1)          -> Printf.sprintf"%d" e1
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0
Error: This expression has type unit but an expression was expected of type
         string -> string


let rec exprToString e = match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> Printf.sprintf"%s" 
| Sine (e1)          -> Printf.sprintf"%x" e1
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0
Error: This expression has type expr but an expression was expected of type
         int


let rec exprToString e = match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> Printf.sprintf"%s" 
| Sine (e1)          -> Printf.sprintf"e1" 
| Cosine (e2)        -> "%s" e2
| Average (e3,e4)     -> "%s %s" e3 e4
| Times (e5,e6)       -> "%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> "%s %s %s %s" e7 e8 e9 e0
Error: This expression has type expr but an expression was expected of type
         int


let rec exprToString e = match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> Printf.sprintf"%s" 
| Sine (e1)          -> Printf.sprintf"e1" 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0
Error: This expression has type string but an expression was expected of type
         string -> string


let rec exprToString e = match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> Printf.sprintf"%s" 
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0
Error: This expression has type string but an expression was expected of type
         string -> string


let rec exprToString e = match e with
| VarX              -> Printf.sprintf"%s"
| VarY              -> Printf.sprintf"%s" 
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0
| _ -> ""
Error: This expression has type string -> string
       but an expression was expected of type string


let rec exprToString e = match e with
| VarX x             -> x
| VarY y             -> y
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0
| _ -> ""
Error: This expression has type string -> string
       but an expression was expected of type string


let rec exprToString e = match e with
| VarX              -> e
| VarY y             -> y
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0
| _ -> ""
Error: The constructor VarX expects 0 argument(s),
       but is applied here to 1 argument(s)


let rec exprToString e = match e with
| VarX              -> e
| VarY y             -> e
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0
| _ -> ""
Error: The constructor VarY expects 0 argument(s),
       but is applied here to 1 argument(s)


let rec exprToString e = match e with
| VarX              -> e
| VarY              -> e
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0
| _ -> ""
Error: The constructor VarY expects 0 argument(s),
       but is applied here to 1 argument(s)


let rec exprToString e = match e with
| VarX              -> e
| VarY              -> e
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0
| _ -> ""
Error: This expression has type expr but an expression was expected of type
         string


let rec exprToString e = match e with
| VarX              -> Printf.sprintf"%s" e
| VarY              -> e
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0
| _ -> ""
Error: This expression has type expr but an expression was expected of type
         string


let rec exprToString e = match e with
| VarX e          -> e
| VarY              -> e
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" e2
| Average (e3,e4)     -> Printf.sprintf"%s %s" e3 e4
| Times (e5,e6)       -> Printf.sprintf"%s %s" e5 e6
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" e7 e8 e9 e0
| _ -> ""
Error: This expression has type expr but an expression was expected of type
         string


let rec exprToString e = match e with
| VarX e          -> e
| VarY              -> e
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4)     -> Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6)       -> Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)
| _ -> ""
Error: The constructor VarX expects 0 argument(s),
       but is applied here to 1 argument(s)


let rec exprToString e = match e with
| VarX           -> e
| VarY              -> e
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4)     -> Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6)       -> Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)
| _ -> ""
Error: The constructor VarX expects 0 argument(s),
       but is applied here to 1 argument(s)


let rec exprToString e = match e with
| VarX           -> ""::e
| VarY              -> e
| Sine (e1)          -> Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2)        -> Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4)     -> Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6)       -> Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0)  -> Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)
| _ -> ""
Error: This expression has type expr but an expression was expected of type
         string


let rec exprToString e = match e with
| VarX -> 
"%d" e
| VarY -> 
e
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)
| _ -> ""
Error: This expression has type expr but an expression was expected of type
         string list


let rec exprToString e = match e with
| VarX -> 
Printf.sprintf"%d" e
| VarY -> 
e
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)
| _ -> ""
Error: This expression has type string
       This is not a function; it cannot be applied.


let rec exprToString e = match e with
| VarX -> 
"x"
| VarY -> 
"y"
| Sine (e1) ->
Printf.sprintf"%s" (exprToString e1) 
| Cosine (e2) -> 
Printf.sprintf"%s" (exprToString e2)
| Average (e3,e4) ->
Printf.sprintf"%s %s" (exprToString e3)(exprToString e4)
| Times (e5,e6) ->
Printf.sprintf"%s %s" (exprToString e5)(exprToString e6)
| Thresh (e7,e8,e9,e0) -> 
Printf.sprintf"%s %s %s %s" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)
| _ -> ""
Error: This expression has type expr but an expression was expected of type
         int



hw2 eval

fix:
let rec eval (e,x,y) = match e with
| VarX ->
x
| VarY ->
y
| Sine e0 ->
sin(eval e0)
| Cosine e1 ->
cos(eval e1)
| Average (e2,e3)->
((eval e2)+(eval e3))/2
| Times (e4,e5) ->
(eval e4)*(eval e5)
| Thresh (e6, e7, e8, e9) ->
if (eval e6)<(eval e7) then (eval e8)
else (eval e9)

let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX ->
x
| VarY ->
y
| Sine e0 ->
sin(eval e0)
| Cosine e1 ->
cos(eval e1)
| Average (e2,e3)->
((eval e2)+(eval e3))/2
| Times (e4,e5) ->
(eval e4)*(eval e5)
| Thresh (e6, e7, e8, e9) ->
(eval e6)<(eval e7)?(eval e8):(eval e9)
Error: Syntax error


let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)
Error: Syntax error



hw2 build

fix:
let rec build (rand, depth) =
failwith "ugh"

let g1 () = failwith "to be implemented"

let g2 () = failwith "to be implemented"

let g3 () = failwith "to be implemented"

let c1 () = failwith "to be implemented"

let c2 () = failwith "to be implemented"

let c3 () = failwith "to be implemented"

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

let emitColor (f1,f2,f3,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_c_"^name) in
let chan = open_out (fname^".ppm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P6 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z1 = f1 (x,y) in
let z2 = f2 (x,y) in
let z3 = f3 (x,y) in

(* Convert the result to a grayscale value *)
let iz1 = toIntensity(z1) in
let iz2 = toIntensity(z2) in
let iz3 = toIntensity(z3) in

(* Emit one byte per color for this pixel *)
output_char chan (char_of_int iz1);
output_char chan (char_of_int iz2);
output_char chan (char_of_int iz3);
)) in  
close_out chan;
ignore(Sys.command ("convert "^fname^".ppm  "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".ppm"))

let doRandomColor (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand (seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e1 = build (g, depth) in
let e2 = build (g, depth) in
let e3 = build (g, depth) in

let _ = Format.printf "red   = %s \n" (exprToString e1) in
let _ = Format.printf "green = %s \n" (exprToString e2) in
let _ = Format.printf "blue  = %s \n" (exprToString e3) in

let f1 = eval_fn e1 in
let f2 = eval_fn e2 in
let f3 = eval_fn e3 in

(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitColor (f1,f2,f3,n,name)

type test = unit -> string

let key = ""

let prefix130 = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)); ErrorCode "exception")

let explode s = 
let rec _exp i = 
if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in
_exp 0

let implode cs = 
String.concat "" (List.map (String.make 1) cs)

let drop_paren s = 
implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))

let eq_real p (r1,r2) = 
(r1 -. r2) < p || (r2 -. r1) < p

let scoreMsg () = 
Format.sprintf "Results: Score/Max = %d / %d \n" !score !max

bad:
let rec build (rand, depth) =
if depth = 0 then 
if (rand mod 2) = 0 then buildX()
else buildY()
else if (rand mod 5) = 0 then 
buildSine(build(rand, depth - 1))
else if (rand mod 5) = 1 then 
buildCosine(build(rand, depth - 1))
else if (rand mod 5) = 2 then 
buildAverage(build(rand, depth - 1),build(rand, depth - 1))
else if (rand mod 5) = 3 then 
buildAverage(build(rand, depth - 1))
else if (rand mod 5) = 4 then 
buildThresh(build(rand, depth -1))
Error: This expression has type expr but an expression was expected of type
         expr * expr


let rec build (rand, depth) =
if depth = 0 then 
if (rand mod 2) = 0 then buildX()
else buildY()
else if (rand mod 5) = 0 then 
buildSine(build(rand, depth - 1))
else if (rand mod 5) = 1 then 
buildCosine(build(rand, depth - 1))
else if (rand mod 5) = 2 then 
buildAverage(build(rand, depth - 1),build(rand, depth - 1))
else if (rand mod 5) = 3 then 
buildTimes(build(rand, depth - 1),build(rand, depth - 1))
else if (rand mod 5) = 4 then 
buildThresh(build(rand, depth -1),build(rand, depth - 1),build(rand, depth - 1),build(rand, depth - 1))
Error: This expression has type expr but an expression was expected of type
         expr * expr



hw2 eval

fix:
let _ = eval (sampleExpr,0.5,0.2)

bad:
let _ = eval (sampleExpr,0.5,0.2)
Error: This expression has type int * int -> int
       but an expression was expected of type int



hw2 eval

fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)
Error: This expression has type int
       This is not a function; it cannot be applied.



hw2 build

fix:
let rec build (rand, depth) = 
if depth <= 0 then buildX()
else match rand with 
| 0 -> 
buildSine(build(rand, depth - 1))
| 1 -> 
buildCosine(build(rand, depth - 1))
| 2 -> 
buildAverage(build(rand, depth - 2), build(rand, depth - 2))
| 3 ->
buildTimes(build(rand, depth - 2), build(rand, depth - 2))
| 4 ->
buildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))
| _ -> buildY()

bad:
let rand = 

let rec build (rand, depth) = 
if depth <= 0 then buildX()
else match rand with 
| 0 -> 
buildSine(build(rand, depth - 1))
| 1 -> 
buildCosine(build(rand, depth - 1))
| 2 -> 
buildAverage(build(rand, depth - 2), build(rand, depth - 2))
| 3 ->
buildTimes(build(rand depth - 2), build(rand,depth - 2))
| 4 ->
buildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth -4))
Error: This expression has type int
       This is not a function; it cannot be applied.


let rand = 

let rec build (rand, depth) = 
if depth <= 0 then buildX()
else match rand with 
| 0 -> 
buildSine(build(rand, depth - 1))
| 1 -> 
buildCosine(build(rand, depth - 1))
| 2 -> 
buildAverage(build(rand, depth - 2), build(rand, depth - 2))
| 3 ->
buildTimes(build(rand, depth - 2), build(rand, depth - 2))
| 4 ->
buildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))
Error: Syntax error


let rec build (rand, depth) = 
if depth <= 0 then buildX()
else match rand with 
| 0 -> 
buildSine(build(rand, depth - 1))
| 1 -> 
buildCosine(build(rand, depth - 1))
| 2 -> 
buildAverage(build(rand, depth - 2), build(rand, depth - 2))
| 3 ->
buildTimes(build(rand, depth - 2), build(rand, depth - 2))
| 4 ->
buildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = fun g -> a (x g) in
let base = match fs with 
| h::t -> f h h
| [] -> fun x -> x in 
List.fold_left f base fs

let _ = pipe [] 3

bad:
let pipe fs = 
let f a x = fun g -> a (x g) in
let base = match fs with 
| (b, c)::t -> f b c
| [] -> fun x -> x in 
List.fold_left f base fs
Error: This expression has type (('a -> 'b) * ('b -> 'a)) list
       but an expression was expected of type ('b -> 'b) list
       Type ('a -> 'b) * ('b -> 'a) is not compatible with type 'b -> 'b 


let _ = pipe [] 3
Error: Unbound value pipe


let pipe fs = 
let f a x = fun g -> a (x g) in
let base = match fs with 
| h::t -> f h t
| [] -> fun x -> x in 
List.fold_left f base fs
Error: This expression has type ('a -> 'b) list
       but an expression was expected of type 'c -> 'a


let _ = pipe [] 3
Error: Unbound value pipe



hw3 pipe

fix:
let pipe fs = 
let f a x = fun g -> a (x g) in
let base = match fs with 
| h::t -> f (fun x -> x) h
| [] -> fun x -> x in 
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

bad:
let pipe fs = 
let f a x = fun g -> x (a g) in
let base = match fs with 
| (fun b -> c)::t -> f (fun x -> x) h
| [] -> fun x -> x in 
List.fold_left f base fs
Error: Syntax error: operator expected.



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ x in
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ x in
let base = h in
let l = h in
List.fold_left f base l
Error: This expression has type string but an expression was expected of type
         string list


let _ = sepConcat ", " ["foo";"bar";"baz"]
Error: Unbound value sepConcat



hw3 stringOfList

fix:
let stringOfList f l = match l with 
| [] -> ""
| h :: t ->
let g a x = a ^ ";" ^ x in
let base = f h in 
let x = t in
List.fold_left g base l

let _ = stringOfList string_of_int [1;2;3;4;5;6]

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: This expression has type int -> string
       but an expression was expected of type string -> string
       Type int is not compatible with type string 


let stringOfList f l = match l with 
| [] -> ""
| h :: t ->
let g a x = a ^ ";" ^ x in
let base = f h in 
let x = f t in
List.fold_left g base x
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: This expression has type int -> string
       but an expression was expected of type string -> string
       Type int is not compatible with type string 



hw3 stringOfList

fix:
let stringOfList f l = match l with 
| [] -> ""
| h :: t ->
let m b = "[" ^ b ^ "]" in
let n a x = a ^ " ;" ^ x in
let base = f h in 
List.fold_left n base t

let _ = stringOfList string_of_int [1;2;3;4;5;6]

bad:
let stringOfList f l = match l with 
| [] -> ""
| h :: t ->
let m b = "[" ^ b ^ "]" in
let n a x = a ^ " ;" ^ x in
let base = f h in 
List.fold_left g base t
Error: Unbound value g


let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: This expression has type int -> string
       but an expression was expected of type string -> string
       Type int is not compatible with type string 



hw3 stringOfList

fix:
let stringOfList f l = match l with 
| [] -> ""
| h :: t ->
let m a b = "[" ^ a ^ ";" ^ b ^ "]" in
let base = f h in 
List.fold_left m base l

bad:
let stringOfList f l = match l with 
| [] -> ""
| h :: t ->
let m a b = "[" ^ a ^ ";" b ^ "]" in
let base = f h in 
List.fold_left m base l
Error: This expression has type string
       This is not a function; it cannot be applied.



hw3 stringOfList

fix:
let stringOfList f l = match l with 
| [] -> ""
| h :: t ->
let m a b = "[" ^ a ^ ";" ^ b ^ "]" in
let base = f h in 
List.fold_left m base l

bad:
let _ = stringOfList (fun x -> x) ["foo"]
Error: This expression has type string list
       but an expression was expected of type string



hw3 stringOfList

fix:
let _ = stringOfList (fun x -> x) ["foo"]

bad:
let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]
Error: This expression has type int -> string
       but an expression was expected of type string -> string
       Type int is not compatible with type string 


let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: This expression has type int -> string
       but an expression was expected of type string -> string
       Type int is not compatible with type string 



hw3 stringOfList

fix:
let stringOfList f l = "[" ^ (sepConcat "; " (List.map f l)) ^ "]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: This expression has type int but an expression was expected of type
         string


let stringOfList f l = "[" ^ (sepConcat "; " f l) ^ "]"
Error: This function has type string -> string list -> string
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: This expression has type int but an expression was expected of type
         string



hw3 padZero

fix:
let padZero l1 l2 = 
if List.length l1 < List.length l2 then
(clone 0 (List.length l2 - List.length l1)::l1),l2
else if List.length l2 > List.length l2 then
l1, (clone 0 (List.length l1 - List.length l2)::l2)
else 
l1, l2

let _ = padZero [9;9] [1;0;0;2]

bad:
let padZero l1 l2 = 
if l1 < l2 then 0
Error: This expression has type int but an expression was expected of type
         unit



hw3 padZero

fix:
let padZero l1 l2 = 
let first = List.length l1 in
let sec = List.length l2 in
if first < sec then
List.append (clone 0 (sec - first)) l1, l2
else if first > sec then
l1, List.append (clone 0 (first - sec)) l2
else 
l1, l2

bad:
let padZero l1 l2 = 
let first = List.length l1 in
let sec = List.length l2 in
if first < sec then
((clone 0 (sec - first))::l1)
else if first > sec then
l1, ((clone 0 (first - sec))::l2)
else 
l1, l2
Error: This expression has type 'a * 'b
       but an expression was expected of type int list list


let padZero l1 l2 = 
let first = List.length l1 in
let sec = List.length l2 in
if first < sec then
List.append (clone 0 (sec - first)) l1, l2
else if first > sec then
List.append l1 ((clone 0 (first - sec))::l2)
else 
l1, l2
Error: This expression has type int list
       but an expression was expected of type int



hw3 bigAdd

fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in 
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = fun g -> x (a g) in
let base = fun y -> y in 
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = "[" ^ (sepConcat "; " (List.map f l)) ^ "]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n = 
if n <= 0 then []
else x::clone x (n-1)

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let padZero l1 l2 = 
let first = List.length l1 in
let sec = List.length l2 in
if first < sec then
List.append (clone 0 (sec - first)) l1, l2
else if first > sec then
l1, List.append (clone 0 (first - sec)) l2
else 
l1, l2

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

let rec removeZero l = match l with
| [] -> []
| h::t -> 
if h = 0 then removeZero t
else l

let _ = removeZero [0;0;0;1;0;0;2]

let _ = removeZero [9;9]

let _ = removeZero [0;0;0;0]

let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (i,j)::t -> 
if (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)
| [] -> 
(0,0) in 
let base = (0,0) in
let args = 
List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (i,j)::t -> 
if (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)
| [] -> 
(0,0) in 
let base = (0,0) in
let args = 
List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type ('a * 'b) list
       but an expression was expected of type (int * int) list list
       Type 'a * 'b is not compatible with type (int * int) list 



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (i,j) = x in
if (i + j) > 9 then (1, (i + j - 10)) 
else if (i + j) <= 9 then (0 , i + j) in
let base = (0,0) in
let args = 
List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (i,j) = x in
if (i + j) > 9 then (1, (i + j - 10)) 
else if (i + j) <= 9 then (0 , i + j) in
let base = (0,0) in
let args = 
List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type unit



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (i,j) = x in
((i+j+a)/10, (i+j+a)%10) in 
let base = (0,[]) in
let args = 
List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (i,j) = x in
if (i + j) > 9 then (1, (i + j - 10)) 
else if (i + j) <= 9 then (0 , i + j) in
let base = (0,[]) in
let args = 
List.combine (List.rev l1) (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type unit



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
let multiplier m n = 
((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in
multiplier (float_of_int i) j in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
((List.length l1) -1,(mulByDigit x*(10**i) l2)::j)in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list -> int list
       but an expression was expected of type int


let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
((List.length l1) -1,(mulByDigit (x*(10**i)) l2)::j)in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int but an expression was expected of type
         float


let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
((List.length l1) -1,(mulByDigit (x*((float_of_int 10)**i)) l2)::j)in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type float but an expression was expected of type
         int


let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
((List.length l1) -1,(mulByDigit (x*int_of_float((float_of_int 10)**i)) l2)::j)in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type
         float * int list list -> int -> int * int list list
       but an expression was expected of type
         float * int list list -> int -> float * int list list
       Type int is not compatible with type float 


let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
((List.length l1) -1,(mulByDigit (x*(int_of_float((float_of_int 10)**i))) l2)::j)in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type
         float * int list list -> int -> int * int list list
       but an expression was expected of type
         float * int list list -> int -> float * int list list
       Type int is not compatible with type float 


let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
let multiplier m n = 
((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**i))) l2)::n) in
multipler (float_of_int i) j in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value multipler
Hint: Did you mean multiplier?


let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
let multiplier m n = 
((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**i))) l2)::n) in
multiplier (float_of_int i) j in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type float but an expression was expected of type
         int


let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
let multiplier m n = 
((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10))) l2)::n) in
multiplier (float_of_int i) j in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int but an expression was expected of type
         float



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
let multiplier m n = 
(i-1, (mulByDigit x l2)::(clone 0 m)::n) in
multiplier ((List.length l1)-1) j in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
let multiplier m n = 
(i-1, ((mulByDigit x l2)*(int_of_float(10**m)))::n) in
multiplier (float_of_int ((List.length l1)-1)) j in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int list
       but an expression was expected of type int


let bigMul l1 l2 = 
let f a x =  
let (i, j) = a in
let multiplier m n = 
(i-1, (mulByDigit x l2)::(clone 0 m)::n) in
multiplier (float_of_int ((List.length l1)-1)) j in
let base = (0, []) in
let args = 
l1 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type float but an expression was expected of type
         int



hw1 sumList

fix:
let rec sumList xs =
match xs with
| [] -> 0
| x::s -> x + sumList s

bad:
let rec sumList xs =
match xs with
| [] -> 0
| x:s -> x + sumList s
Error: Syntax error



hw1 sumList

fix:
let _ = sumList [1; 3; 5; 7; 9; 11]

bad:
let _ = sumList [1; 3; 5; 7; 9; 11]

55 / 10
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n < 0 then []
else n mod 10 :: digitsOfInt (n/10)

bad:
let rec digitsOfInt n = 
if n < 0 then []
else n % 10 :: digitsOfInt (n\10)
Error: Illegal character (\\)


let rec digitsOfInt n = 
if n < 0 then []
else n % 10 :: digitsOfInt (n/10)
Error: Unbound value %



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n <= 0 then []
else n mod 10 :: digitsOfInt (n/10)

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

bad:
let rec digitsOfInt n = 
if n <= 0 then []
else digitsOfInt (n/10) :: n mod 10
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 digitsOfInt

fix:
let rec digitsOfIntHelper n = 
if n > 0 then digitsOfIntHelper (n/10) @ [n mod 10] 
else []

bad:
let rec digitsOfIntHelper n = 
if n > 0 digitsOfIntHelper (n/10) @ [n mod 10] 
else []
Error: Syntax error



hw1 additivePersistence

fix:
let rec additivePersistence n = 
if n = 0 then 0
else 1 + additivePersistence (sumList (digits n))

bad:
let rec additivePersistence n = 
if n = 0 then 0
else 1 + additivePersistence sumList (digits n)
Error: This function has type int -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let rec additivePersistence n = 
if n = 0 then 0
else 1 + additivePersistence (sumList digits n)
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n > 0 then 
let k = digitsOfInt (n/10) in
(n mod 10) :: k
else []

bad:
let rec digitsOfInt n = 
if n > 0 then 
let k = digitsOfInt (n/10) in
k :: (n mod 10)
else []
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 palindrome

fix:
let rec palindromeHelper w r = 
match w with 
| []      -> (match r with 
| [] -> true
| _  -> false)
| x :: s  -> (match r with 
| y :: t -> if (x = y) then palindromeHelper s t else false
| _ -> false)
| _ -> false

bad:
let palindromeHelper w r = 
match w with 
| []      -> (match r with 
| [] -> true
| _  -> false)
| x :: s  -> (match r with 
| y :: t -> if x == y then palindromeHelper s t
| _ -> false)
| _ -> false
Error: Unbound value palindromeHelper


let palindromeHelper w r = 
match w with 
| []      -> (match r with 
| [] -> true
| _  -> false)
| x :: s  -> (match r with 
| y :: t -> if x = y then palindromeHelper s t
| _ -> false)
Error: Unbound value palindromeHelper


let rec palindromeHelper w r = 
match w with 
| []      -> (match r with 
| [] -> true
| _  -> false)
| x :: s  -> (match r with 
| y :: t -> if x = y then  palindromeHelper s t
| _ -> false)
Error: This expression has type bool but an expression was expected of type
         unit


let rec palindromeHelper w r = 
match w with 
| []      -> (match r with 
| [] -> true
| _  -> false)
| x :: s  -> (match r with 
| y :: t -> if x = y then  palindromeHelper s t
| _ -> false)
Error: This expression has type bool but an expression was expected of type
         unit


let rec palindromeHelper w r = 
match w with 
| []      -> (match r with 
| [] -> true
| _  -> false)
| x :: s  -> (match r with 
| y :: t -> if x = y then palindromeHelper s t
| _ -> false)
Error: This expression has type bool but an expression was expected of type
         unit


let rec palindromeHelper w r = 
match w with 
| []      -> (match r with 
| [] -> true
| _  -> false)
| x :: s  -> (match r with 
| y :: t -> if x = y then palindromeHelper s t
| _ -> false)
| _ -> false
Error: This expression has type bool but an expression was expected of type
         unit


let rec palindromeHelper w r = 
match w with 
| []      -> (match r with 
| [] -> true
| _  -> false)
| x :: s  -> (match r with 
| y :: t -> if (x = y) then palindromeHelper s t
| _ -> false)
| _ -> false
Error: This expression has type bool but an expression was expected of type
         unit



hw1 palindrome

fix:
let palindrome w = 
let wl = explode w in
let rl = listReverse wl in
palindromeHelper wl rl

bad:
let _ = palindrome "malayalam"
Error: This expression has type string but an expression was expected of type
         'a list



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
let result = [] in 
let rec digitsOfIntHelper n result = 
if n > 0 then (n mod 10) :: digitsOfIntHelper (n/10) result 
else result in []

bad:
let rec digitsOfInt n = 
let result = [] in 
let rec digitsOfIntHelper n result = 
if n > 0 then (n mod 10) :: digitsOfIntHelper (n/10) result 
else result
Error: Syntax error


let rec digitsOfInt n = 
let result = [] in 
let rec digitsOfIntHelper n result = 
if n > 0 then (n mod 10) :: digitsOfIntHelper (n/10) result 
else result in 


let _ = digitsOfInt 100
Error: Syntax error



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
let rec digitsOfIntHelper n result = 
if n > 0 then digitsOfIntHelper (n/10) (n mod 10 :: result)
else result in 
digitsOfIntHelper n []

bad:
let rec digitsOfInt n = 
let rec digitsOfIntHelper n result = 
if n > 0 then digitsOfIntHelper (n/10) (n mod 10) :: result
else result in 
digitsOfIntHelper n []
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then seen else h :: seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

removeDuplicates
[1;6;2;4;12;2;13;6;9]
[1;6;2;4;12;13;9]

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then seen else h :: seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

removeDuplicates
[1;6;2;4;12;2;13;6;9]
[1;6;2;4;12;13;9]
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.



hw2 exprToString

fix:
let rec exprToString e = match e with 
| VarX -> "x"
| VarY -> "y" 
| Sine x -> "sin(pi*" ^ exprToString x ^ ")"
| Cosine x -> "cos(pi*" ^ exprToString x ^ ")"
| Average (x,y) -> "(("  ^ exprToString x ^ "*" ^ exprToString y ^ ")/2)"
| Times (x,y) -> exprToString x ^ "*" ^ exprToString y
| Thresh (a,b,c,d) -> "(" ^ exprToString a ^ "<" ^ exprToString b 
^ "?" ^ exprToString c ^ ":" ^ exprToString d

bad:
let rec exprToString e = match e with 
| VarX -> "x"
| VarY -> "y" 
| Sine x -> "sin(pi*" + exprToString x + ")"
| Cosine x -> "cos(pi*" + exprToString x + ")"
| Average x y -> "(("  + exprToString x + "*" + exprToString y + ")/2)"
| Times x y -> exprToString x + "*" + exprToString y
| Thresh a b c d -> "(" + exprToString a + "<" + exprToString b 
+ "?" exprToString c + ":" + exprToString d
Error: Syntax error


let rec exprToString e = match e with 
| VarX -> "x"
| VarY -> "y" 
| Sine x -> "sin(pi*" + exprToString x + ")"
| Cosine x -> "cos(pi*" + exprToString x + ")"
| Average (x,y) -> "(("  + exprToString x + "*" + exprToString y + ")/2)"
| Times x y -> exprToString x + "*" + exprToString y
| Thresh a b c d -> "(" + exprToString a + "<" + exprToString b 
+ "?" exprToString c + ":" + exprToString d
Error: Syntax error


let rec exprToString e = match e with 
| VarX -> "x"
| VarY -> "y" 
| Sine x -> "sin(pi*" + exprToString x + ")"
| Cosine x -> "cos(pi*" + exprToString x + ")"
| Average (x,y) -> "(("  + exprToString x + "*" + exprToString y + ")/2)"
| Times (x,y) -> exprToString x + "*" + exprToString y
| Thresh (a,b,c,d) -> "(" + exprToString a + "<" + exprToString b 
+ "?" exprToString c + ":" + exprToString d
Error: This expression has type string but an expression was expected of type
         int


let rec exprToString e = match e with 
| VarX -> "x"
| VarY -> "y" 
| Sine x -> "sin(pi*" ^ exprToString x ^ ")"
| Cosine x -> "cos(pi*" ^ exprToString x ^ ")"
| Average (x,y) -> "(("  ^ exprToString x ^ "*" ^ exprToString y ^ ")/2)"
| Times (x,y) -> exprToString x ^ "*" ^ exprToString y
| Thresh (a,b,c,d) -> "(" ^ exprToString a ^ "<" ^ exprToString b 
^ "?" exprToString c ^ ":" ^ exprToString d
Error: This expression has type string
       This is not a function; it cannot be applied.



hw2 exprToString

fix:
let rec exprToString e = match e with 
| VarX -> "x"
| VarY -> "y" 
| Sine x -> "sin(pi*" ^ exprToString x ^ ")"
| Cosine x -> "cos(pi*" ^ exprToString x ^ ")"
| Average (x,y) -> "(("  ^ exprToString x ^ "*" ^ exprToString y ^ ")/2)"
| Times (x,y) -> exprToString x ^ "*" ^ exprToString y
| Thresh (a,b,c,d) -> "(" ^ exprToString a ^ "<" ^ exprToString b 
^ "?" ^ exprToString c ^ ":" ^ exprToString d

bad:
let rec exprToString e = match e with 
| VarX -> "x"
| VarY -> "y" 
| Sine x -> "sin(pi*" ^ exprToString x ^ ")"
| Cosine x -> "cos(pi*" ^ exprToString x ^ ")"
| Average (x,y) -> "(("  ^ exprToString x ^ "*" ^ exprToString y ^ ")/2)"
| Times (x,y) -> exprToString x + "*" ^ exprToString y
| Thresh (a,b,c,d) -> "(" ^ exprToString a ^ "<" ^ exprToString b 
^"?" exprToString c ^ ":" ^ exprToString d
Error: This expression has type string but an expression was expected of type
         int


let rec exprToString e = match e with 
| VarX -> "x"
| VarY -> "y" 
| Sine x -> "sin(pi*" ^ exprToString x ^ ")"
| Cosine x -> "cos(pi*" ^ exprToString x ^ ")"
| Average (x,y) -> "(("  ^ exprToString x ^ "*" ^ exprToString y ^ ")/2)"
| Times (x,y) -> exprToString x ^ "*" ^ exprToString y
| Thresh (a,b,c,d) -> "(" ^ exprToString a ^ "<" ^ exprToString b 
^"?" exprToString c ^ ":" ^ exprToString d
Error: This expression has type string
       This is not a function; it cannot be applied.



hw2 eval

fix:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval (u,x,y) 
| Cosine u ->  cos (pi *. eval (u,x,y))
| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0
| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))
| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)

bad:
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> sin (pi *. (eval u))
| Cos u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> ((eval s) < (eval t) ? (eval u) : (eval v))
Error: Syntax error: operator expected.


let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> sin (pi *. (eval u))
| Cos u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> ((eval s) < (eval t)) ? (eval u) : (eval v)
Error: Syntax error


let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> sin (pi *. (eval u))
| Cos u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> ((eval s) < (eval t)) ? eval u : eval v
Error: Syntax error


let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> sin (pi *. (eval u))
| Cos u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> (eval s) < (eval t) ? eval u : eval v
Error: Syntax error


let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> sin (pi *. (eval u))
| Cos u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v
Error: This variant pattern is expected to have type expr
       The constructor Cos does not belong to type expr


let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> sin (pi *. (eval u))
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v
Error: This expression has type expr but an expression was expected of type
         expr * 'a * 'a


let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. (eval u)
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v
Error: This expression has type expr but an expression was expected of type
         expr * 'a * 'a


let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval u
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v
Error: This expression has type expr but an expression was expected of type
         expr * 'a * 'a


let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi 
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v
Error: This expression has type expr but an expression was expected of type
         expr * float * float


let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. (eval u)
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v
Error: This expression has type expr but an expression was expected of type
         expr * 'a * 'a


let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi .* (eval u)
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v
Error: Syntax error


let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi * (eval u)
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. (eval u)
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v
Error: This expression has type expr but an expression was expected of type
         expr * 'a * 'a


let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. (eval u) * 1 * 1
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v
Error: This expression has type expr but an expression was expected of type
         expr * 'a * 'a


let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval (u,x,y) 
| Cosine u ->  cos (pi *. (eval u))
| Average (u,v) -> ((eval u) +. (eval v)) /. 2
| Times (u,v) -> ((eval u) *. (eval v))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v
Error: This expression has type expr but an expression was expected of type
         expr * float * float


let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval (u,x,y) 
| Cosine u ->  cos (pi *. eval (u,x,y))
| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2
| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v
Error: This expression has type int but an expression was expected of type
         float


let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine u -> pi *. eval (u,x,y) 
| Cosine u ->  cos (pi *. eval (u,x,y))
| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0
| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))
| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v
Error: This expression has type expr but an expression was expected of type
         expr * float * float



hw2 build

fix:
let rec build (rand,depth) = 
if depth = 1 then 
if rand(0,1) = 0 then VarX
else VarY
else (* depth > 1 *)
match rand(0,4) with
| 0 -> Sine (build (rand, depth-1))
| 1 -> Cosine (build (rand, depth-1))
| 2 -> Average ((build (rand, depth-1)), (build (rand, depth-1)))
| 3 -> Times ((build (rand, depth-1)), (build (rand, depth-1)))
| 4 -> Thresh ((build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)))

bad:
let rec build (rand,depth) = 
if depth = 1 then 
if rand(0,1) = 0 then VarX
else VarY
else (* depth > 1 *)
match rand(0,4) with
| 0 -> Sine (build (rand, depth-1))
| 1 -> Cosine (build (rand, depth-1))
| 2 -> Average (build (rand, depth-1)), (build (rand, depth-1))
| 3 -> Times (build (rand, depth-1)) (build (rand, depth-1))
| 4 -> Thresh (build (rand, depth-1)) (build (rand, depth-1)) (build (rand, depth-1)) (build (rand, depth-1))
Error: Syntax error


let rec build (rand,depth) = 
if depth = 1 then 
if rand(0,1) = 0 then VarX
else VarY
else (* depth > 1 *)
match rand(0,4) with
| 0 -> Sine (build (rand, depth-1))
| 1 -> Cosine (build (rand, depth-1))
| 2 -> Average (build (rand, depth-1)), (build (rand, depth-1))
| 3 -> Times (build (rand, depth-1)), (build (rand, depth-1))
| 4 -> Thresh (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1))
Error: This expression has type 'a * 'b
       but an expression was expected of type expr


let rec build (rand,depth) = 
if depth = 1 then 
if rand(0,1) = 0 then VarX
else VarY
else (* depth > 1 *)
match rand(0,4) with
| 0 -> Sine (build (rand, depth-1))
| 1 -> Cosine (build (rand, depth-1))
| 2 -> Average ((build (rand, depth-1)), (build (rand, depth-1)))
| 3 -> Times (build (rand, depth-1)), (build (rand, depth-1))
| 4 -> Thresh (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1))
Error: This expression has type 'a * 'b
       but an expression was expected of type expr



hw2 ???

fix:
let fptest x = truncate (1e6 *. cos (1e-6 *. float x))

), 0

)
fptest 0

bad:
fptest 0
Error: This expression has type (int -> int) * int
       This is not a function; it cannot be applied.



hw2 ???

fix:
let fptest x = truncate (1e6 *. cos (1e-6 *. float x)),
fptest 0

bad:
)
fptest 0
Error: Syntax error



hw2 ???

fix:
fptest (fptest 0)

bad:
fptest fptest 0
Error: This function has type int -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 sqsum

fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = sum + x*x in
let base = 0 in
List.fold_left f base xs
Error: Unbound value sum



hw3 pipe

fix:
let pipe fs = 
let f a x = a in
let base = [] in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a x in
let base = f x -> x in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = a x in
let base = let f x = x in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = a x in
let base = f -> x -> x in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = a x in
let base = x in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = a x in
let base = f x in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = a x in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = a x in
let base = fun x in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = a x in
let base = (fun x -> x) in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = a x in
let base = (fun x) in
List.fold_left f base fs
Error: Syntax error: operator expected.


let pipe fs = 
let f a x = a x in
let base = x in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = a x in
let base = f in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = a x in
let base = 0 in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = a x in
let base = [] in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = a x in
let base = [] in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = fun a -> x in
let base = fun f x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> x in
let base = [] in
List.fold_left f base fs
Error: This expression has type 'a list
       but an expression was expected of type 'b -> 'c


let pipe fs = 
let f a x = fun a -> x in
let base = x in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = fun a -> x in
let base = a in
List.fold_left f base fs
Error: Unbound value a



hw3 pipe

fix:
let pipe fs = 
let f a x = fun a -> x in
let base = fun f x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = a -> x in
let base = fun f x -> x in
List.fold_left f base fs
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = fun a -> x in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun a -> x in
let base = fun f x  in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = fun a -> x in
let base = x in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = fun a -> x in
let base = [] in
List.fold_left f base fs
Error: This expression has type 'a list
       but an expression was expected of type 'b -> 'c


let pipe fs = 
let f a x = fun a -> a x in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = fun a -> x in
let base = x in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type int but an expression was expected of type
         int -> int



hw3 pipe

fix:
let pipe fs = 
let f a x = fun c -> x (a c) in
let base =  fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = fun y -> fun a -> x in
let base =  fun a -> x in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = fun y -> fun a -> x in
let base =  fun f -> x in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = fun y -> fun a -> x in
let base =  fun f in
List.fold_left f base fs
Error: Syntax error


let pipe fs = 
let f a x = fun y -> fun a -> x in
let base =  f x in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = fun y -> fun a -> x in
let base =  fun a -> x in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = fun x -> a in
let base =  fun a -> x in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = fun a -> a x in
let base =  fun a -> x in
List.fold_left f base fs
Error: Unbound value x


let pipe fs = 
let f a x = fun a -> a x in
let base =  0 in
List.fold_left f base fs
Error: This expression has type int but an expression was expected of type
         ('a -> 'b) -> 'b


let pipe fs = 
let f a x = fun a -> a x in
let base =  f -> b in
List.fold_left f base fs
Error: Syntax error



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = "" in
let l = [] in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = fun c -> a ^ sep ^ x in
let base = "" in
let l = l in
List.fold_left f base l
Error: Unbound value l


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = fun c -> a ^ sep ^ x in
let base = "" in
let l = "" in
List.fold_left f base l
Error: This expression has type string -> string -> 'a -> string
       but an expression was expected of type string -> string -> string
       Type 'a -> string is not compatible with type string 


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = "" in
let l = "" in
List.fold_left f base l
Error: This expression has type string but an expression was expected of type
         string list



hw3 padZero

fix:
let padZero l1 l2 = 
let leng1 = List.length l1 in
let leng2 = List.length l2 in
(clone 0 (leng1-leng2) @ l1 , clone 0 (leng2-leng1) @ l2)

bad:
let padZero l1 l2 = 
let leng1 = List.length l1 in
let leng2 = List.length l2 in
(clone 0 leng1-leng2 @ l1 , clone 0 leng2-leng1 @ l2)
Error: This expression has type int list
       but an expression was expected of type int



hw3 bigAdd

fix:
let sqsum xs = 
let f a x = a + x*x in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = fun c -> x (a c) in
let base =  fun x -> x in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ sep ^ x in
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = "[" ^ sepConcat ";" (List.map f l) ^ "]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let rec clone x n = 
if n <= 0 then []
else x :: (clone x (n-1))

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let padZero l1 l2 = 
let leng1 = List.length l1 in
let leng2 = List.length l2 in
(clone 0 (leng2 - leng1) @ l1 , clone 0 (leng1 - leng2) @ l2)

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

let rec removeZero l = match l with
| []    -> []
| h::t  -> if h = 0 then removeZero t else l

let _ = removeZero [0;0;0;1;0;0;2]

let _ = removeZero [9;9]

let _ = removeZero [0;0;0;0]

let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = ([], []) in
let args = List.rev List.combine (l1, l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  x in
let base = l1  in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value padZero


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  x in
let base = l1  in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value padZero


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  x in
let base = [] in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value padZero


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  x in
let base = [] in
let args = ([], []) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type 'b * 'c


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  x in
let base = ([], []) in
let args = ([], []) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b list
       but an expression was expected of type 'c list list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  x in
let base = ([], []) in
let args = 0 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b list
       but an expression was expected of type ('c list * 'd list) list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  x in
let base = ([], []) in
let args = [[],[]] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         ('a list * 'b list) list


let _ = bigAdd [9;9] [1;0;0;2]
Error: Unbound value padZero


let _ = bigAdd [9;9;9;9] [9;9;9]
Error: Unbound value bigAdd


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  x in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value bigAdd


let _ = bigAdd [9;9] [1;0;0;2]
Error: Unbound value padZero


let _ = bigAdd [9;9;9;9] [9;9;9]
Error: Unbound value bigAdd


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  x in
let base = ([]) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value bigAdd


let _ = bigAdd [9;9] [1;0;0;2]
Error: This expression has type 'a list
       but an expression was expected of type 'b * 'c


let _ = bigAdd [9;9;9;9] [9;9;9]
Error: Unbound value bigAdd


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  x in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value bigAdd


let _ = bigAdd [9;9] [1;0;0;2]
Error: Unbound value padZero


let _ = bigAdd [9;9;9;9] [9;9;9]
Error: Unbound value bigAdd


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  x.first in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value bigAdd


let _ = bigAdd [9;9] [1;0;0;2]
Error: Unbound record field first


let _ = bigAdd [9;9;9;9] [9;9;9]
Error: Unbound value bigAdd


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  (a.first + x.first, a.second + x.second) in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value bigAdd


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  (a, a) in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound record field first


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  (a, x) in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a -> 'b -> 'a * 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'a * 'a


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a -> 'b -> 'a * 'b
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a + x in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value padZero


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a + x.first in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b list
       but an expression was expected of type int


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a + x in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound record field first


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b list
       but an expression was expected of type int


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  [a] in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value padZero


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a + 1 in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a -> 'b -> 'a list
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'a list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  (a, a) in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b list
       but an expression was expected of type int


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  ([a], a) in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a -> 'b -> 'a * 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'a * 'a


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a[0] in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a -> 'b -> 'a list * 'a
       but an expression was expected of type 'a -> 'b -> 'a
       The type variable 'a occurs inside 'a list * 'a


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type (int list -> 'a) -> 'b -> 'a
       but an expression was expected of type
         (int list -> 'a) -> 'b -> int list -> 'a
       The type variable 'a occurs inside int list -> 'a


let _ = bigAdd [9;9] [1;0;0;2]
Error: Unbound value padZero


let _ = bigAdd [9;9;9;9] [9;9;9]
Error: Unbound value bigAdd


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a in
let base = ([], []) in
let args = [0] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value bigAdd


let _ = bigAdd [9;9] [1;0;0;2]
Error: Unbound value padZero


let _ = bigAdd [9;9;9;9] [9;9;9]
Error: Unbound value bigAdd


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a in
let base = ([], []) in
let args = 0 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value bigAdd


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a in
let base = ([], []) in
let args = [0] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a + 1 in
let base = ([], []) in
let args = [0] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value padZero


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a + 1 in
let base = 5 in
let args = [0] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list * 'b list
       but an expression was expected of type int


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  [5],[5] in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value padZero


let _ = bigAdd [9;9] [1;0;0;2]
Error: Unbound value padZero


let _ = bigAdd [9;9;9;9] [9;9;9]
Error: Unbound value bigAdd


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a.first,a.second in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value bigAdd


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  a.fst,a.snd in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound record field first


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  (fst a), (snd a) in
let base = ([], []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound record field fst


let _ = bigAdd [9;9] [1;0;0;2]
Error: Unbound value padZero


let _ = bigAdd [9;9;9;9] [9;9;9]
Error: Unbound value bigAdd


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  (fst a), (snd a) in
let base = (List.rev l1, List.rev l2) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value bigAdd


let _ = bigAdd [9;9] [1;0;0;2]
Error: Unbound value padZero


let _ = bigAdd [9;9;9;9] [9;9;9]
Error: Unbound value bigAdd


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x =  (fst a), (snd a) in
let base = (List.rev l1, []) in
let args = [List.rev l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value bigAdd


let _ = bigAdd [9;9] [1;0;0;2]
Error: Unbound value padZero


let _ = bigAdd [9;9;9;9] [9;9;9]
Error: Unbound value bigAdd


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| []  -> []. snd a
| h:t -> t, ((fst h + snd h) % 10 :: snd a) in
let base = (List.combine (rev l1, rev l2), []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value bigAdd


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| []  -> []. snd a
| h::t -> t, ((fst h + snd h) % 10 :: snd a) in
let base = (List.combine (rev l1, rev l2), []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| []  -> [], snd a
| h::t -> t, ((fst h + snd h) % 10 :: snd a) in
let base = (List.combine (rev l1, rev l2), []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound record field snd


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| []  -> [], snd snd a
| h::t -> t, ((fst h + snd h) % 10 :: snd a) in
let base = (List.combine (rev l1, rev l2), []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type 'b * 'c


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match snd a with
| []  -> [], snd a
| h::t -> t, ((fst h + snd h) % 10 :: snd a) in
let base = (List.combine (rev l1, rev l2), []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b -> 'b
       but an expression was expected of type 'c * ('d -> 'e)


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match snd a with
| []  -> [], snd a
| h::t -> t, ((fst h + snd h) mod 10 :: snd a) in
let base = (List.combine (rev l1, rev l2), []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Unbound value %


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match snd a with
| []  -> [], snd a
| h::t -> t, ((fst h + snd h) mod 10 :: snd a) in
let base = (List.combine (rev l1, rev l2), []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         int * int


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match fst a with
| []  -> [], snd a
| h::t -> t, ((fst h + snd h) mod 10 :: snd a) in
let base = (List.combine (rev l1, rev l2), []) in
let args = [] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         int * int



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = List.combine l1 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = ([], []) in
let args = List.rev (List.combine (l1, l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = ([], []) in
let args = List.rev (List.combine (l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = ([], []) in
let args = (List.combine (l1 l2)) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list -> ('b * 'a) list
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = ([], []) in
let args = List.combine (l1 l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list -> ('b * 'a) list
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = ([], []) in
let args = List.combine (l1, l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list -> ('b * 'a) list
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = ([], []) in
let args = [List.combine (l1, l2)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = [List.combine (l1, l2)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = [List.combine (l1, l2)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = [List.combine l1] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = [List.combine (l1, l2)] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = List.combine l1, l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list -> ('b * 'a) list
       but an expression was expected of type 'c list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = [List.combine l1, l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type ('a list -> ('b * 'a) list) * 'c
       but an expression was expected of type 'd list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = [0, 0] in
let args = [List.combine l1, l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = failwith "to be implemeneted" in
let args = [List.combine l1, l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| []    -> a
| h::t  -> ( (fst h + snd h) / 10, (fst h + snd h) mod 10 :: t )in 
let base = (0, []) in
let args = [List.combine l1, l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = (0, 0) in
let args = [List.combine l1, l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type (int * int) list
       but an expression was expected of type 'a * 'b


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "to be implemented" in 
let base = (0, []) in
let args = [List.combine l1, l2] in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         int list



hw3 ???

fix:
List.combine [9] [5]

bad:
List.combine [9], [5]
Error: This expression has type ('a * 'b) list
       but an expression was expected of type 'c list list
       Type 'a * 'b is not compatible with type 'c list 



hw3 bigAdd

fix:
let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| []    -> a
| h::t  -> a in 
let base = (0, []) in
let args = List.combine l1 l2
Error: Unbound value l1


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| []    -> a
| h::t  -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
(*let (_, res) = List.fold_left f base args in
res*)
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| []    -> a
| h::t  -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
(*let (_, res) = List.fold_left f base args in
res*)
(*in*) 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| []    -> a
| h::t  -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = failwith "3232" in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type ('a * 'b) list
       but an expression was expected of type 'c list list
       Type 'a * 'b is not compatible with type 'c list 



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| [] -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| _ -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type ('a * 'b) list
       but an expression was expected of type 'c list list
       Type 'a * 'b is not compatible with type 'c list 



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (fst x + snd x) / 10, ((fst x + snd x) mod 10 :: snd a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| () -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type ('a * 'b) list
       but an expression was expected of type 'c list list
       Type 'a * 'b is not compatible with type 'c list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| [] -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type ('a * 'b) list
       but an expression was expected of type unit list
       Type 'a * 'b is not compatible with type unit 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| ([]) -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type ('a * 'b) list
       but an expression was expected of type 'c list list
       Type 'a * 'b is not compatible with type 'c list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| 5 -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type ('a * 'b) list
       but an expression was expected of type 'c list list
       Type 'a * 'b is not compatible with type 'c list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| 'a' -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type ('a * 'b) list
       but an expression was expected of type int list
       Type 'a * 'b is not compatible with type int 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with
| (_, _) -> a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Error: This expression has type ('a * 'b) list
       but an expression was expected of type char list
       Type 'a * 'b is not compatible with type char 



hw3 bigAdd

fix:
let _ = bigAdd [9;9] [1;0;0;2]

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (fst x + snd x) / 10, (fst x + snd x) mod 10 :: snd a in 
let base = (0, []) in
let args = List.combine l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
Characters 74-75:
  let f a x = (fst x + snd x) / 10, ((fst x + snd x) mod 10 :: snd a in 
                                    ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw3 mulByDigit

fix:
let _ = mulByDigit 9 [9;9;9;9]

let _ = mulByDigit 9 [1;1;1;1]

bad:
let rec mulByDigit i l = 
let f x a = let digitRes = (x * i) + fst a in
digitRes / 10, (digitRes mod 10) :: snd a in
let base  = (0, []) in
let (_, result) = List.fold_right f (0 :: l) base in
result
Error: This expression has type 'a * 'b
       but an expression was expected of type int



hw3 bigMul

fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = 
let value = mulByDigit l1 x in
0, bigAdd value snd a in 
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value bigSum


let bigMul l1 l2 = 
let f a x = 
let value = mulByDigit l1 x in
0, bigAdd value (snd a) in 
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This function has type int list -> int list -> int list
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 bigMul

fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = 
let value = mulByDigit l1 x in
0, bigAdd value x in 
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = 
let value = mulByDigit l1 x in
0, bigAdd value x :: snd a in 
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = 
let value = mulByDigit l1 x in
0, bigAdd value x in 
let base = ([], []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a list
       but an expression was expected of type int


let _ = bigMul [9;9;9;9] [9;9;9;9]
Error: This expression has type 'a list * 'b list
       but an expression was expected of type int * int list
       Type 'a list is not compatible with type int 



hw3 bigMul

fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = 
let value = mulByDigit x l1 in
0, bigAdd value x :: snd a in 
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a list
       but an expression was expected of type int


let _ = bigMul [9;9;9;9] [9;9;9;9]
Error: This expression has type int but an expression was expected of type
         int list


let bigMul l1 l2 = 
let f a x = 
let value = mulByDigit x l1 in
0, bigAdd x value :: snd a in 
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a list
       but an expression was expected of type int


let _ = bigMul [9;9;9;9] [9;9;9;9]
Error: This expression has type int but an expression was expected of type
         int list


let bigMul l1 l2 = 
let f a x = 
let value = mulByDigit x l1 in
0, bigAdd value snd a in 
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a list
       but an expression was expected of type int


let _ = bigMul [9;9;9;9] [9;9;9;9]
Error: This function has type int list -> int list -> int list
       It is applied to too many arguments; maybe you forgot a `;'.


let bigMul l1 l2 = 
let f a x = 
let value = mulByDigit x l1 in
0, bigAdd value (snd a) in 
let base = (0, []) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a list
       but an expression was expected of type int



hw1 sumList

fix:
let rec sumList xs =
match xs with
[] -> []
| head::tail -> head + (sumList tail)

let _ = sumList [1; 2; 3; 4]

let _ = sumList [1; -2; 3; 5]

let _ = sumList [1; 3; 5; 7; 9; 11]

bad:
let rec sumList xs =
match xs with
[] -> []
| head::tail- > head + (sumList tail)
Error: Syntax error: pattern expected.



hw1 sumList

fix:
let rec sumList xs =
match xs with
[] -> 0
| head::tail -> head + (sumList tail)

let _ = sumList [1; 2; 3; 4]

bad:
let _ = sumList [1; 2; 3; 4]
Error: This expression has type int but an expression was expected of type
         int -> int



hw1 listReverse

fix:
let rec listReverse l = 
match l with 
[] -> []
| head::tail -> listReverse tail @ [head]

let _ = listReverse [1; 2; 3; 4]

let _ = listReverse ["a"; "b"; "c"; "d"]

bad:
let _ = listReverse [1; 2; 3; 4]
Error: This expression has type int but an expression was expected of type
         'a list


let _ = listReverse ["a"; "b"; "c"; "d"]
Error: This expression has type string but an expression was expected of type
         'a list



hw1 ???

fix:
let rec append_new xs1 xs2= 
match xs1 with
[] -> xs2
| head::tail -> head :: (append_new tail xs2)

bad:
let rec append_new xs1 xs2= 
match xs1 with
[] -> xs2
| head::tail -> head :: (append_new tail) :: xs2
Error: This expression has type 'a list -> 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list -> 'a list



hw2 removeDuplicates

fix:
let rec append_new xs1 xs2= 
match xs1 with
[] -> xs2
| head::tail -> head::(append_new tail xs2)

let rec assoc (d,k,l) = 
match l with 
| [] -> d
| (ki, vi)::tail -> if (k = ki) then vi
else assoc (d, k, tail)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if (List.mem h seen) then seen (* if seen, ignore*)
else append [h] seen in (* add to front *)
let rest' = t in (*recurse of rest*)
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

bad:
 _ = removeDuplicates [1;6;2;4;12;2;13;6;9]
Error: Syntax error



hw2 eval

fix:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0
| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))

bad:
let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*(eval(var1, x, y)))
| Cosine var2 -> cos(pi*(eval(var2, x, y)))
| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> (eval(var7, x, y) < (eval(var8, x, y)) ? (eval(var9, x, y)):(eval(var0, x, y)))
Error: Syntax error: operator expected.


let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*(eval(var1, x, y)))
| Cosine var2 -> cos(pi*(eval(var2, x, y)))
| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> (eval(var7, x, y) < (eval(var8, x, y)) ? (eval(var9, x, y)) : (eval(var0, x, y)))
Error: Syntax error: operator expected.


let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*(eval(var1, x, y)))
| Cosine var2 -> cos(pi*(eval(var2, x, y)))
| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if ((eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))
Characters 320-321:
  | Thresh (var7, var8, var9, var0) -> if ((eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y));;
                                          ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


)
Error: Syntax error


let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*(eval(var1, x, y)))
| Cosine var2 -> cos(pi*(eval(var2, x, y)))
| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if ((eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))
Characters 320-321:
  | Thresh (var7, var8, var9, var0) -> if ((eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y));;
                                          ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*(eval(var1, x, y)))
| Cosine var2 -> cos(pi*(eval(var2, x, y)))
| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> ((eval(var3, x, y) + eval(var4, x, y))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> (.(eval(var3, x, y) + (.eval(var4, x, y)))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))
Error: Syntax error: operator expected.


let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> ((.(eval(var3, x, y)) + (.eval(var4, x, y)))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))
Error: Syntax error: operator expected.


let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> .((.(eval(var3, x, y)) + (.eval(var4, x, y)))/2)
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))
Error: Syntax error


let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> (.(eval(var3, x, y)) + eval(var4, x, y))/2
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))
Error: Syntax error: operator expected.


let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> ((eval(var3, x, y)) + eval(var4, x, y))/2
| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = 
match e with 
| VarX -> x
| VarY -> y
| Sine var1 -> sin(pi*.(eval(var1, x, y)))
| Cosine var2 -> cos(pi*.(eval(var2, x, y)))
| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2
| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))
| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))
Error: This expression has type int but an expression was expected of type
         float



hw2 build

fix:
let rec build (rand, depth) = 
if (depth<1) then let base = (rand 0 2) in match base with 
| 0 -> buildX()
| 1 -> buildY()
else let recurse = (rand 0 5) in match recurse with
| 0 -> buildSine(build(rand, depth-1))
| 1 -> buildCosine(build(rand, depth-1))
| 2 -> buildAverage(build(rand, depth-1), build(rand, depth-1))
| 3 -> buildTimes(build(rand, depth-1), build(rand, depth-1))
| 4 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))

bad:
let rec build (rand, depth) = 
if (depth<1) then let base = (rand 0 2) in match base with 
| 0 -> buildX
| 1 -> buildY
Error: This expression has type unit -> expr
       but an expression was expected of type unit


let rec build (rand, depth) = 
if (depth<1) then let base = (rand 0 2) in match base with 
| 0 -> buildX()
| 1 -> buildY()
else 
(*
call rand get some number
switch statement to choose
1 then return expr x
0 then return expr y
*)


(* g1,g2,g3,c1,c2,c3 : unit -> int * int * int
* these functions should return the parameters needed to create your 
* top three color / grayscale pictures.
* they should return (depth,seed1,seed2)
*)

let g1 () = failwith "to be implemented"
Error: Syntax error



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = 
let index = fst a in
let newIn = index + 1 in
(newIn, bigAdd (snd a) (mulByDigit x (l1@(clone 0 index)))) in
let base = (0, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res

let _ = bigMul [9;9;9;9] [9;9;9;9]

let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = 
let index = fst a in
let newIn = index + 1 in
(newIn, bigAdd (snd a) (mulByDigit x (l1@(clone 0 index))))
Error: Syntax error


let base = (0, []) in
let args = (List.rev l2) in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value l2


let _ = bigMul [9;9;9;9] [9;9;9;9]
Error: Unbound value bigMul


let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]
Error: Unbound value bigMul



hw3 padZero

fix:
let padZero l1 l2 = 
let lenl1 = List.length l1 in 
let lenl2 = List.length l2 in 
((List.append(clone 0 (lenl1 - lenl2)) l1), (List.append (clone 0 (lenl1 - lenl2)) l2))

bad:
let padZero l1 l2 = 
let lenl1 = List.length l1 in 
let lenl2 = List.length l2 in 
(List.append(clone 0 (lenl1 - lenl2) l1, (List.append (clone 0 (lenl1 - lenl2)) l2)))
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list



hw1 digitsOfInt

fix:
let rec digitsOfInt n = 
if n<=0 then []
else explode (string_of_int n)

bad:
let rec digitsOfInt n = match n with
| isNotP n ->[]
| explode (string_of_int n)
Error: Syntax error


let rec digitsOfInt n = match n with
| if isNotP n ->[]
| explode (string_of_int n)
Error: Syntax error


let rec digitsOfInt n = match n with
| if isNotP n then n->[]
| explode (string_of_int n)
Error: Syntax error


let rec digitsOfInt n = match n with
| isNotP n then n->[]
| explode (string_of_int n)
Error: Syntax error


let rec digitsOfInt n = match n with
| if isNotP n then []
| explode (string_of_int n)
Error: Syntax error


let rec digitsOfInt n = match n with
| if isNotP n =true then []
| explode (string_of_int n)
Error: Syntax error


let rec digitsOfInt n = match n with
| if n<=0 then []
| explode (string_of_int n)
Error: Syntax error


let rec digitsOfInt n = match n with
| if n<=0 then []
| else explode (string_of_int n)
Error: Syntax error


let rec digitsOfInt n = 
| if n<=0 then []
| else explode (string_of_int n)
Error: Syntax error



hw1 additivePersistence

fix:
let rec additivePersistence n = 

sumList (digitsOfInt n)

bad:
let rec additivePersistence n = sumList digitOfInt n
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let rec additivePersistence n = 

sumList (digitOfInt n)
Error: Unbound value digitOfInt
Hint: Did you mean digitsOfInt?
Error: Unbound value digitOfInt
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value digitOfInt
Hint: Did you mean digitsOfInt?



hw1 additivePersistence

fix:
let rec additivePersistence n = 
if n<10 then a
else  additivePersistence (sumList (digitsOfInt n))

bad:
let rec additivePersistence n = match n with
if n<10 then n
else  _=sumList (digitsOfInt n)
Error: Syntax error


let rec additivePersistence n = match n with
if n<10 then n
else  n=sumList (digitsOfInt n)
Error: Syntax error


let rec additivePersistence n = 
if n<10 then n
else  n=sumList (digitsOfInt n) in 
match n with 
|0->0
|_->n
Error: This expression has type bool but an expression was expected of type
         int


let rec additivePersistence n = 
if n<10 then n
else  sumList (digitsOfInt n) in 
match n with 
|0->0
|_->n
Error: Unbound value n


let rec additivePersistence n a= 
if n<10 then a
else  sumList (digitsOfInt n) in 
match n with 
|0->0
|_->n
Error: Unbound value n



hw1 additivePersistence

fix:
let rec additivePersistence n = 
let c=0 in
let rec break(num,count)=
if num>9 then
break(sumList(digitsOfInt(num)),(count+1))
else
count
in
break(n,c)

bad:
let rec additivePersistence n = 
let c=0 in
let rec break(num,count)=
if num>9
break(sumList(digitsOfInt(num)),(count+1))
else
count
in
break(n,c)
Error: Syntax error



hw1 listReverse

fix:
let rec listReverse l = 
let rec a acc=function
|[]-> acc
|h::t -> a(h::acc) t in
a [] l

bad:
let rec listReverse l = 
let rec a acc=function
|[]-> acc
|h::t -> a(h::acc) t in
a [] list
Error: Unbound value list



hw1 palindrome

fix:
let palindrome w = 
if explode w = listReverse (explode w) then true
else false

bad:
let palindrome w = 
if explode w = listReverse (explode w)
Error: Syntax error



hw2 removeDuplicates

fix:
let rec assoc (d,k,l) = match l with
|(s,n)::t -> if s=k then n
else assoc(d,k,t)
|[]->d

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if !List.mem(h,seen) then seen@ [h]  in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

bad:
et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]
Error: Syntax error



hw2 wwhile

fix:
let rec wwhile (f,b) = match f with
| (x,true)->x

bad:
let rec wwhile (f,b) = match f with
| (x,true) -> f x
| (x,false) -> x
Error: This expression has type 'a * bool
       This is not a function; it cannot be applied.


let rec wwhile (f,b) = match f with
|(x,true) -> wwhile(f x)
| (x,false) -> x
Error: This expression has type 'a * bool
       This is not a function; it cannot be applied.


let rec wwhile (f,b) = match f with
let (n,boo) = f b
| boo=true -> wwhile(f,n)
| boo=false -> n
Error: Syntax error


let rec wwhile (f,b) = match f with
(n,boo) -> f b
| boo=true -> wwhile(f,n)
| boo=false -> n
Error: Syntax error


let rec wwhile (f,b) = match f with
(n,boo) -> f b
if boo= true then wwhile(f,n)
else n
Error: Syntax error


let rec wwhile (f,b) = match f with
(n,boo) -> f b
Error: This expression has type 'a * 'b
       This is not a function; it cannot be applied.



hw2 wwhile

fix:
let rec wwhile (f,b) = match f b with
| (x,true) -> wwhile(f,x)
| (x,false)-> x

bad:
let rec wwhile (f,b) = match f with 
let (i,r) = f b in
| r=true -> wwhile (f,i)
| r=false ->i
Error: Syntax error


let rec wwhile (f,b) = match f with 
let rec (i,r) = f b in
| r=true -> wwhile (f,i)
| r=false ->i
Error: Syntax error


let rec wwhile (f,b) = 
let  (x,y) = f b in
match (x,y) with 
| y=true -> wwhile (f,x)
| y=false -> x
Error: Syntax error


let rec wwhile (f,b) = 
let  (x,y) = f b in
match (x,y) with 
| y -> wwhile (f,x)
| !y -> x
Error: Syntax error


let rec wwhile (f,b) = 
let  (x,y) = f b in
match (x,y) with 
if y then wwhile (f,x)
else x
Error: Syntax error



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)

bad:
let fixpoint (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true)=f b-1 then (b,false)),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true)=f b-1 then (b,false) in f),b)
Error: This expression has type 'a * bool
       but an expression was expected of type int


let fixpoint (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true)=f (b-1) then (b,false) in ),b)
Error: Syntax error: operator expected.


let fixpoint (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true)=f (b-1) then (b,false) in f),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type unit


let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x<>b && (x,y)<>f (b-1))),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x<>b)),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x!=b)),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x>b||x<b)),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool


let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x<100)),b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool



hw2 exprToString

fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  exprToString e
| Cosine e-> exprToString e

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine -> VarY"/"VarX
| Cosine -> VarX"/"VarY
Error: Syntax error


let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine -> VarY@"/"@VarX
| Cosine -> VarX@"/"@VarY
Error: The constructor Sine expects 1 argument(s),
       but is applied here to 0 argument(s)


let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine -> VarY^"/"^VarX
| Cosine -> VarX^"/"^VarY
Error: The constructor Sine expects 1 argument(s),
       but is applied here to 0 argument(s)


let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine ->  exprToString e
| Cosine -> exprToString e
Error: The constructor Sine expects 1 argument(s),
       but is applied here to 0 argument(s)


let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine ->  exprToString e
| Cosine -> exprToString e
Error: The constructor Sine expects 1 argument(s),
       but is applied here to 0 argument(s)


let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine ->  exprToString VarX
| Cosine -> exprToString e
Error: The constructor Sine expects 1 argument(s),
       but is applied here to 0 argument(s)


let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  exprToString e
| Cosine -> exprToString e
Error: The constructor Cosine expects 1 argument(s),
       but is applied here to 0 argument(s)



hw2 exprToString

fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  "sin(pi*"^ exprToString e^")"
| Cosine e-> "cos(pi*"^ exprToString e^")"
| Average (e1,e2) ->"("^(exprToString e)^"+"^(exprToString e)^")/2"

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  "sin(pi*"^ exprToString e^")"
| Cosine e-> "cos(pi*"^ exprToString e^")"
| Average e1 e2 ->"("^(exprToString e1)^"+"^(exprToString e2)^")/2"
Error: Syntax error


let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  "sin(pi*"^ exprToString e^")"
| Cosine e-> "cos(pi*"^ exprToString e^")"
| Average e1 e ->"("^(exprToString e1)^"+"^(exprToString e)^")/2"
Error: Syntax error


let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  "sin(pi*"^ exprToString e^")"
| Cosine e-> "cos(pi*"^ exprToString e^")"
| Average e e ->"("^(exprToString e)^"+"^(exprToString e)^")/2"
Error: Syntax error


let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  "sin(pi*"^ exprToString e^")"
| Cosine e-> "cos(pi*"^ exprToString e^")"
| Average e ->"("^(exprToString e)^"+"^(exprToString e)^")/2"
Error: The constructor Average expects 2 argument(s),
       but is applied here to 1 argument(s)



hw2 exprToString

fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  "sin(pi*"^ exprToString e^")"
| Cosine e-> "cos(pi*"^ exprToString e^")"
| Average (e1,e2) ->"("^(exprToString e)^"+"^(exprToString e)^")/2"
| Times (e1,e2) -> exprToString e1 ^"*"^exprToString e2
| Thresh (e1,e2,e3,e4) -> "("^exprToString e1^"<"^exprToString e2^" ? "^exprToString e3^" : "^exprToString e4^")"

bad:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  "sin(pi*"^ exprToString e^")"
| Cosine e-> "cos(pi*"^ exprToString e^")"
| Average (e1,e2) ->"("^(exprToString e)^"+"^(exprToString e)^")/2"
| Times (e1,e2) -> exprToString e1 ^"*"^exprToString e2
| Thresh (e1,e2,e3,e4) -> "("^exprToString e1^"<"exprToString e2^" ? "^exprToString e3^" : "^exprToString e4^")"
Error: This expression has type string
       This is not a function; it cannot be applied.



hw2 exprToString

fix:
let aa =exprToString VarX

bad:
let aa = exprToString Average(VarX, VarY)
Error: This function has type expr -> string
       It is applied to too many arguments; maybe you forgot a `;'.


let aa =exprToString Average(VarX, VarY)
Error: This function has type expr -> string
       It is applied to too many arguments; maybe you forgot a `;'.


let aa =exprToString VarX;

let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))
Error: Syntax error



hw2 exprToString

fix:
let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  "sin(pi*"^ exprToString e^")"
| Cosine e-> "cos(pi*"^ exprToString e^")"
| Average (e1,e2) ->"("^(exprToString e1)^"+"^(exprToString e2)^")/2"
| Times (e1,e2) -> exprToString e1 ^"*"^exprToString e2
| Thresh (e1,e2,e3,e4) -> "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4^")"

let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

let _ = exprToString sampleExpr1

bad:
let aa =exprToString Average(VarY,VarX)
Error: This function has type expr -> string
       It is applied to too many arguments; maybe you forgot a `;'.



hw2 build

fix:
let rec eval (e,x,y) = match e with 
| VarX -> buildX
| VarY -> buildY

bad:
let rec eval (e,x,y) = match e with 
| VarX -> buildX
| VarY -> buildY
| Sine -> buildSine(e)
Error: The constructor Sine expects 1 argument(s),
       but is applied here to 0 argument(s)


let rec eval (e,x,y) = match e with 
| VarX -> buildX
| VarY -> buildY
| Sine e-> buildSine(e)
Error: This expression has type expr but an expression was expected of type
         unit -> expr


let rec eval (e,x,y) = match e with 
| VarX -> buildX
| VarY -> buildY
| Sine e-> buildSine(x)
Error: This expression has type expr but an expression was expected of type
         unit -> expr


let rec eval (e,x,y) = match e with 
| VarX -> buildX
| VarY -> buildY
| Sine e1-> buildSine(e1)
Error: This expression has type expr but an expression was expected of type
         unit -> expr


let rec eval (e,x,y) = match e with 
| VarX -> buildX
| VarY -> buildY
| Sine e1-> buildSine(e1)
Error: This expression has type expr but an expression was expected of type
         unit -> expr


let rec eval (e,x,y) = match e with 
| VarX -> buildX
| VarY -> buildY
| Sine e-> 0.34*e
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = match e with 
| VarX -> buildX
| VarY -> buildY
| Sine e-> build(pi*e)
Error: This expression has type float but an expression was expected of type
         int



hw2 eval

fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*x
| Cosine e-> pi*y
| Average (e1,e2)-> (e1+e2)/2
| Times (e1, e2)-> e1*e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)
Error: This expression has type float but an expression was expected of type
         int


let rec eval (e,x,y) = (-:float) match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*x
| Cosine e-> pi*y
| Average (e1,e2)-> (e1+e2)/2
| Times (e1, e2)-> e1*e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)
Characters 23-24:
  let rec eval (e,x,y) = (-:float) match e with
                         ^
Syntax error: ')' expected, the highlighted '(' might be unmatched


let rec eval (e,x,y) = (float) match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*x
| Cosine e-> pi*y
| Average (e1,e2)-> (e1+e2)/2
| Times (e1, e2)-> e1*e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)
Error: Syntax error


let rec eval (e,x,y) = match e with
| (float) VarX -> x
| VarY -> y
| Sine e -> pi*x
| Cosine e-> pi*y
| Average (e1,e2)-> (e1+e2)/2
| Times (e1, e2)-> e1*e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)
Error: Syntax error


let rec eval (e,x,y) = match e with
| VarX -> x:float
| VarY -> y
| Sine e -> pi*x
| Cosine e-> pi*y
| Average (e1,e2)-> (e1+e2)/2
| Times (e1, e2)-> e1*e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)
Error: Syntax error


let rec eval (e,x,y) = match e with
| VarX -> x of float
| VarY -> y
| Sine e -> pi*x
| Cosine e-> pi*y
| Average (e1,e2)-> (e1+e2)/2
| Times (e1, e2)-> e1*e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)
Error: Syntax error


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2)-> (e1+.e2)/2
| Times (e1, e2)-> e1*.e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)
Error: This expression has type expr but an expression was expected of type
         float


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2)-> (e1.+.e2.)/2
| Times (e1, e2)-> e1*.e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)
Error: Syntax error: operator expected.


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2)-> (float)(e1+e2)/2
| Times (e1, e2)-> e1*.e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)
Error: This expression has type expr but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2)-> (float_of_int e1+. float_of_int e2)/2
| Times (e1, e2)-> float_of_int e1*.float_of_int e2
| Thresh (e1,e2,e3,e4)->(float_of_int e1<float_of_int e2 ? float_of_int e3:float_of_int e4)
Error: This expression has type expr but an expression was expected of type
         int


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2)-> if e1=VarX then e1=x else e1=y if e2=VarX then e2=x else e2=y -> (e1+e2)/2
| Times (e1, e2)-> e1*.e2
| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)
Error: Syntax error



hw2 build

fix:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x.
| Cosine e-> pi*.y.
| Average (e1,e2) -> buildAverage(e1,e2)

let _=1.00*.5.00

bad:
let rec eval (e,x,y) =
match e with
| VarX -> x.
| VarY -> y.
| Sine e -> pi*.x.
| Cosine e-> pi*.y.
| Average (e1,e2) -> buildAverage(e1,e2)
Error: Syntax error



hw2 eval

fix:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)

bad:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> ((e1*1.00)+(e2*1.00))/.2.0
Error: This expression has type expr but an expression was expected of type
         int


let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> ((e1*1.00)+.(e2*1.00))/.2.0
Error: This expression has type expr but an expression was expected of type
         int


let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.evail(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.evail(e2,x,y)
| Thresh (e1,e2,e3,e4) ->((eval(e1,x,y))<(eval(e2,x,y)) ? (eval(e3,x,y)) : (eval(e4,x,y))

let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)
Error: Syntax error: operator expected.


let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.evail(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.evail(e2,x,y)
Error: Unbound value evail
Hint: Did you mean eval?



hw2 eval

fix:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)

bad:
let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2) -> eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y)
Error: Syntax error


let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2) -> eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y):eval(e4,x,y)
Error: Syntax error


let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2) -> (eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y) : eval(e4,x,y))
Error: Syntax error


let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y) : eval(e4,x,y))
Error: Syntax error


let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y) : eval( e4,x,y))
Error: Syntax error


let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<eval(e2,x,y)?(eval(e3,x,y)):(eval(e4,x,y))
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)
Error: Syntax error: operator expected.


let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y):eval(e4,x,y)
Error: Syntax error


let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<.eval(e2,x,y)?.eval(e3,x,y):.eval(e4,x,y))
Error: Syntax error


let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<.eval(e2,x,y)?.eval(e3,x,y) : eval(e4,x,y))
Error: Syntax error


let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> pi*.x
| Cosine e-> pi*.y
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1,e2,e3,e4) -> eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y) : eval(e4,x,y)
Error: Syntax error



hw2 assoc

fix:
let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

bad:
let rec assoc (d,k,l) = 
let rec helper(d1,k1,l1) = match l1 with
|(s,n)::t -> if s=k1 then n
else assoc(d1,k1,t)
|[]->d1
in helper(d,k,l)
Error: Syntax error



hw2 eval

fix:
let _ = eval (sampleExpr,0.5,0.2)

bad:
let _ = eval (sampleExpr1,0.5,0.2)
Error: Unbound value sampleExpr
Hint: Did you mean sampleExpr1?
Error: Unbound value sampleExpr
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value sampleExpr
Hint: Did you mean sampleExpr1?



hw2 build

fix:
let _ = eval (sampleExpr,0.5,0.2)

let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv

let sampleExpr =
buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(
buildX()),buildTimes(buildCosine (buildCosine (buildAverage
(buildTimes (buildY(),buildY()),buildCosine (buildX())))),
buildCosine (buildTimes (buildSine (buildCosine
(buildY())),buildAverage (buildSine (buildX()), buildTimes
(buildX(),buildX()))))))),buildY())))

let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))

let rec build (rand, depth) = 
match rand depth with
| (1,d) -> d=(d-1) && buildX()
| (2,d) -> d=(d-1) && buildY()

bad:
let rec build (rand, depth) = match rand depth with
Error: This expression has type expr but an expression was expected of type
         bool



hw2 build

fix:
let _ = eval (sampleExpr,0.5,0.2)

let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv

let sampleExpr =
buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(
buildX()),buildTimes(buildCosine (buildCosine (buildAverage
(buildTimes (buildY(),buildY()),buildCosine (buildX())))),
buildCosine (buildTimes (buildSine (buildCosine
(buildY())),buildAverage (buildSine (buildX()), buildTimes
(buildX(),buildX()))))))),buildY())))

let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))

let rec build (rand, depth) = match rand depth with
| (r,0) -> build (r,0)
| (r,d) -> (r,d-1)

bad:
let rec build (rand, depth) = 
match rand depth with
| (1,d) -> d=(d-1) && buildX()
| (2,d) -> d=(d-1) && buildY()
Error: This expression has type expr but an expression was expected of type
         bool



hw2 build

fix:
let _ = eval (sampleExpr,0.5,0.2)

let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv

let sampleExpr =
buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(
buildX()),buildTimes(buildCosine (buildCosine (buildAverage
(buildTimes (buildY(),buildY()),buildCosine (buildX())))),
buildCosine (buildTimes (buildSine (buildCosine
(buildY())),buildAverage (buildSine (buildX()), buildTimes
(buildX(),buildX()))))))),buildY())))

let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))

let rec build (rand, depth) = match (rand, depth) with
| (r,0) -> build (r,0)
| (r,d) -> (r,d-1)

bad:
let rec build (rand, depth) = match rand depth with
Error: This expression has type 'a but an expression was expected of type
         'b -> 'a * int
       The type variable 'a occurs inside 'b -> 'a * int



hw2 build

fix:
let _ = eval (sampleExpr,0.5,0.2)

let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv

let sampleExpr =
buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(
buildX()),buildTimes(buildCosine (buildCosine (buildAverage
(buildTimes (buildY(),buildY()),buildCosine (buildX())))),
buildCosine (buildTimes (buildSine (buildCosine
(buildY())),buildAverage (buildSine (buildX()), buildTimes
(buildX(),buildX()))))))),buildY())))

let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))

let rec build (rand, depth) = 
let buildd(r,d) = if r=1 then buildX() 
else if r=2 then buildY() 
else if r=3 then buildSine(build(r,d))
else if r=4 then buildCosine(build(r,d))
else if r=5 then buildTimes(build(r1,d1),build(r2,d2))
else buildThresh(build(r1,d1), build(r2,2), build(r2,d2), build(r2,d2)) in (depth-1,depth>0)
in buildd(rand,depth)

bad:
let rec build (rand, depth) = 
let build(r) = if r=1 then buildX() else buildY() in (depth-1,depth>0)
in build(r)
Error: Unbound value r


let rec build (rand, depth) = match rand depth with
if r=1 then buildX() else buildY() in (depth-1,depth>0)
Error: Unbound value r


let rec build (rand, depth) = match rand depth with
if rand=1 then buildX() else buildY() in (depth-1,depth>0)
Error: Syntax error



hw2 build

fix:
let rec assoc (d,k,l) = 
let rec helper(d1,k1,l1) = match l1 with
|(s,n)::t -> if s=k1 then n
else assoc(d1,k1,t)
|[]->d1
in helper(d,k,l)

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen = false then [h]@seen else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let rec wwhile (f,b) = match f b with
| (x,true) -> wwhile(f,x)
| (x,false)-> x

let f x = let xx = x*x*x in (xx, xx < 100) in wwhile (f,2)

let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,xx!=x)in a),b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

type expr = 
VarX
| VarY
| Sine     of expr
| Cosine   of expr
| Average  of expr * expr
| Times    of expr * expr
| Thresh   of expr * expr * expr * expr

let rec exprToString e = match e with
| VarX -> "x"
| VarY -> "y"
| Sine e->  "sin(pi*"^ exprToString e^")"
| Cosine e-> "cos(pi*"^ exprToString e^")"
| Average (e1,e2) ->"(("^(exprToString e1)^"+"^(exprToString e2)^")/2)"
| Times (e1,e2) -> exprToString e1 ^"*"^exprToString e2
| Thresh (e1,e2,e3,e4) -> "("^exprToString e1^"<"^exprToString e2^"?"^exprToString e3^":"^exprToString e4^")"

let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))

let _ = exprToString sampleExpr1

let buildX()                       = VarX

let buildY()                       = VarY

let buildSine(e)                   = Sine(e)

let buildCosine(e)                 = Cosine(e)

let buildAverage(e1,e2)            = Average(e1,e2)

let buildTimes(e1,e2)              = Times(e1,e2)

let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)

let pi = 4.0 *. atan 1.0

let rec eval (e,x,y) =
match e with
| VarX -> x
| VarY -> y
| Sine e -> sin(pi*.eval(e,x,y))
| Cosine e-> sin(pi*.eval(e,x,y))
| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0
| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)
| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)

let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)

let _ = eval (sampleExpr,0.5,0.2)

let eval_fn e (x,y) = 
let rv = eval (e,x,y) in
assert (-1.0 <= rv && rv <= 1.0);
rv

let sampleExpr =
buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(
buildX()),buildTimes(buildCosine (buildCosine (buildAverage
(buildTimes (buildY(),buildY()),buildCosine (buildX())))),
buildCosine (buildTimes (buildSine (buildCosine
(buildY())),buildAverage (buildSine (buildX()), buildTimes
(buildX(),buildX()))))))),buildY())))

let sampleExpr2 =
buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))

let rec build (rand, depth) = match rand depth with
|(r,depth)-> match r(0,6) with
|0->buildX()
|1->buildY()
|2->buildSine(build(r,depth-1))
|3->buildCosine(build(r,depth-1))
|4->buildAverage(build(r,depth-1),build(r,depth-1))
|5->buildTimes(build(r,depth-1),build(r,depth-1))
|6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1))

let g1 () = failwith "to be implemented"

let g2 () = failwith "to be implemented"

let g3 () = failwith "to be implemented"

let c1 () = failwith "to be implemented"

let c2 () = failwith "to be implemented"

let c3 () = failwith "to be implemented"

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let emitColor (f1,f2,f3,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_c_"^name) in
let chan = open_out (fname^".ppm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P6 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z1 = f1 (x,y) in
let z2 = f2 (x,y) in
let z3 = f3 (x,y) in

(* Convert the result to a grayscale value *)
let iz1 = toIntensity(z1) in
let iz2 = toIntensity(z2) in
let iz3 = toIntensity(z3) in

(* Emit one byte per color for this pixel *)
output_char chan (char_of_int iz1);
output_char chan (char_of_int iz2);
output_char chan (char_of_int iz3);
)) in  
close_out chan;
ignore(Sys.command ("convert "^fname^".ppm  "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".ppm"))

let doRandomColor (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand (seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e1 = build (g, depth) in
let e2 = build (g, depth) in
let e3 = build (g, depth) in

let _ = Format.printf "red   = %s \n" (exprToString e1) in
let _ = Format.printf "green = %s \n" (exprToString e2) in
let _ = Format.printf "blue  = %s \n" (exprToString e3) in

let f1 = eval_fn e1 in
let f2 = eval_fn e2 in
let f3 = eval_fn e3 in

(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitColor (f1,f2,f3,n,name)

type test = unit -> string

let key = ""

let prefix130 = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)); ErrorCode "exception")

let explode s = 
let rec _exp i = 
if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in
_exp 0

let implode cs = 
String.concat "" (List.map (String.make 1) cs)

let drop_paren s = 
implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))

let eq_real p (r1,r2) = 
(r1 -. r2) < p || (r2 -. r1) < p

let scoreMsg () = 
Format.sprintf "Results: Score/Max = %d / %d \n" !score !max

bad:
let rec build (rand, depth) = match rand depth with
|(r,depth)-> match r(0,6) with
|0->buildX()
|1->buildY()
|2->buildSine(build(r,depth-1))
|3->buildCosine(build(r,depth-1))
|4->buildAverage(build(r,depth-1),build(r,depth-1))
|5->buildTimes(build(r,depth-1),build(r,depth-1))
|6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1))
Error: This expression has type 'a list
       but an expression was expected of type unit



hw2 build

fix:
let rec build (rand, depth) = match (rand,depth) with
|(r,0)-> if r(0,1)=0 then buildX() else buildY()
|(r,depth)-> let r = rand(0,7) in match r with
|0->buildX()
|1->buildY()
|2->buildSine(build(rand,depth-1))
|3->buildCosine(build(rand,depth-1))
|4->buildAverage(build(rand,depth-1),build(rand,depth-1))
|5->buildTimes(build(rand,depth-1),build(rand,depth-1))
|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))

bad:
let rec build (rand, depth) = match (rand,depth) with
|(r,depth)-> match r(0,6) with
|0->buildX()
|1->buildY()
|2->buildSine(build(r,depth-1))
|3->buildCosine(build(r,depth-1))
|4->buildAverage(build(r,depth-1),build(r,depth-1))
|5->buildTimes(build(r,depth-1),build(r,depth-1))
|6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)
Error: This expression has type int * int -> int
       but an expression was expected of type 'a -> (int * int -> int) * 'b


let rec build (rand, depth) = match (rand,depth) with
|(r,depth)-> match r(0,7) with
|0->buildX()
|1->buildY()
|2->buildSine(build(r,depth-1))
|3->buildCosine(build(r,depth-1))
|4->buildAverage(build(r,depth-1),build(r,depth-1))
|5->buildTimes(build(r,depth-1),build(r,depth-1))
|6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)
Error: Unbound value depth


let rec build (rand, depth) = match (rand,depth) with
|(r,depth)-> match r(0,7) with
|0->buildX()
|1->buildY()
|2->buildSine(build(r,depth-1))
|3->buildCosine(build(r,depth-1))
|4->buildAverage(build(r,depth-1),build(r,depth-1))
|5->buildTimes(build(r,depth-1),build(r,depth-1))
|_->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)
Error: Unbound value depth


let rec build (rand, depth) = match (rand,depth) with
|(r,depth)-> let r = rand(0,7) in match with
|0->buildX()
|1->buildY()
|2->buildSine(build(r,depth-1))
|3->buildCosine(build(r,depth-1))
|4->buildAverage(build(r,depth-1),build(r,depth-1))
|5->buildTimes(build(r,depth-1),build(r,depth-1))
|_->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)
Error: Unbound value depth


let rec build (rand, depth) = match (rand,depth) with
|(r,depth)-> let r = rand(0,7) in match r with
|0->buildX()
|1->buildY()
|2->buildSine(build(r,depth-1))
|3->buildCosine(build(r,depth-1))
|4->buildAverage(build(r,depth-1),build(r,depth-1))
|5->buildTimes(build(r,depth-1),build(r,depth-1))
|_->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)
Error: Syntax error


let rec build (rand, depth) = match (rand,depth) with
|(_,depth)-> let r = rand(0,7) in match r with
|0->buildX()
|1->buildY()
|2->buildSine(build(r,depth-1))
|3->buildCosine(build(r,depth-1))
|4->buildAverage(build(r,depth-1),build(r,depth-1))
|5->buildTimes(build(r,depth-1),build(r,depth-1))
|_->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)
Error: This expression has type int but an expression was expected of type
         int * int -> int


let rec build (rand, depth) = match (rand,depth) with
|(r,depth)-> let r = rand(0,7) in match r with
|0->buildX()
|1->buildY()
|2->buildSine(build(rand,depth-1))
|3->buildCosine(build(rand,depth-1))
|4->buildAverage(build(rand,depth-1),build(rand,depth-1))
|5->buildTimes(build(rand,depth-1),build(rand,depth-1))
|_->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1)) in (depth, depth>=0)
Error: This expression has type int but an expression was expected of type
         int * int -> int


let rec build (rand, depth) = match (rand,depth) with
|(r,0)-> if r(0,1)=0 then buildX() else buildY()
|(r,depth)-> let r = rand(0,7) in match r with
|0->buildX()
|1->buildY()
|2->buildSine(build(rand,depth-1))
|3->buildCosine(build(rand,depth-1))
|4->buildAverage(build(rand,depth-1),build(rand,depth-1))
|5->buildTimes(build(rand,depth-1),build(rand,depth-1))
|_->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
Error: Unbound value depth



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = x^a in
let base = h^sep in
let l = sl in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = List.rev x^a in
let base = sep in
let l = sl in
List.fold_left f base l
Error: This expression has type 'a list
       but an expression was expected of type string


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = List.rev t^a in
let base = h^sep in
let l = sl in
List.fold_left f base l
Error: This expression has type 'a list
       but an expression was expected of type string



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ (x^a)in
let base = h^sep in
let l = List.rev t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a ^ (sepConcat a x)in
let base = h^sep in
let l = List.rev t in
List.fold_left f base l
Error: This expression has type string list
       but an expression was expected of type string list list
       Type string is not compatible with type string list 



hw1 sumList

fix:
let _ = sumList [1; 3; 5; 7; 9; 11];

string_of_int(32)

bad:
let _ = sumList [1; 3; 5; 7; 9; 11]

int_of_string(32)
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = sumList [1; 3; 5; 7; 9; 11];

int_of_string(32)
Error: This expression has type int but an expression was expected of type
         string



hw1 ???

fix:
let _ = 312/10

bad:
let _ = 312.4/10
Error: This expression has type float but an expression was expected of type
         int



hw1 digitsOfInt

fix:
let rec digitsOfInt n =
if n <= 0 
then []
else match n with
| n -> [] @ [(n mod 10)]

bad:
let rec digitsOfInt n =
if n <= 0 
then []
else match n with
| n -> [] @ (n mod 10)
Error: This expression has type int but an expression was expected of type
         'a list


let rec digitsOfInt n =
if n <= 0 
then []
else match n with
| n -> [] :: (n mod 10)
Error: This expression has type int but an expression was expected of type
         'a list list



hw1 digitsOfInt

fix:
let rec digitsOfInt n =
if n <= 0 
then []
else match n with
| n -> [] @ [(n mod 10)]

bad:
let rec digitsOfInt n =
if n <= 0 
then []
else match n with
| n -> [] @ (n mod 10)
Error: This expression has type int but an expression was expected of type
         'a list



hw1 digitsOfInt

fix:
let rec digitsOfInt n =
if n <= 0 
then []
else match n with
| n -> n mod 10 :: []

let _ = digitsOfInt 3124

bad:
let rec digitsOfInt n =
if n <= 0 
then []
else match n with
| n -> digitsOfInt(n % 10) :: []
Error: Unbound value %


let rec digitsOfInt n =
if n <= 0 
then []
else match n with
| n -> digitsOfInt(n mod 10) :: []
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list


let rec digitsOfInt n =
if n <= 0 
then []
else match n with
| n -> digitsOfInt(n mod 10) :: []
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list



hw1 digitsOfInt

fix:
let digitsOfInt n = 
let rec addDigit n acc = 
if n = 0 then []
else addDigit (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> addDigit n []

let _ = digitsOfInt 3124

bad:
let digitsOfInt n = 
let rec addDigit next n = 
if n < 0 then []
else addDigit ((n mod 10)::next) (n/10)
Error: Unbound value digitsOfInt


) in 
addDigit [] n
Error: Syntax error


let _ = digitsOfInt 3124
Error: Syntax error


let digitsOfInt n = 
let rec addDigit next n = 
if n < 0 then []
else addDigit ((n mod 10)::next) (n/10)
Error: Unbound value digitsOfInt


let _ = digitsOfInt 3124
Error: Syntax error


let digitsOfInt n = 
let rec addDigit next n = 
if n < 10 then n::next
else addDigit ((n mod 10)::next) (n/10)
Error: Unbound value digitsOfInt


let _ = digitsOfInt 3124
Error: Syntax error


let digitsOfInt n = 
let rec addDigit n acc = 
if n = 0 then []
else addDigit (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> loop n []
Error: Unbound value digitsOfInt


let _ = digitsOfInt 3124
Error: Unbound value loop



hw1 digitsOfInt

fix:
let digitsOfInt n = 
if n <= 0 then []
else let rec addDigit n acc = 
if n <= 0 then acc
else addDigit (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> addDigit n []

let _ = digitsOfInt -3124

bad:
let _ = digitsOfInt 3124
Error: This expression has type int -> int list
       but an expression was expected of type int



hw1 digitsOfInt

fix:
let digitsOfInt n = 
let rec addDigit n acc = 
if n <= 0 then acc
else addDigit (n/10) (n mod 10::acc) in
match n with
| 0 -> [0]
| _ -> addDigit n []

let _ = digitsOfInt (-3124)

bad:
let _ = digitsOfInt (-3124)
Error: This expression has type int -> int list
       but an expression was expected of type int



hw1 ???

fix:
lengthOfList [1;2;3] 0

bad:
let rec lengthOfList xs count =
match xs with
| [] -> 0
| hd::tl -> lengthOfList tl count+1
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list



hw1 additivePersistence

fix:
let rec additivePersistence n = 
match n with
| 0 -> 0
| _ -> (sumList (digitsOfInt n))

bad:
let rec additivePersistence n = 
match n with
| 0 -> 0
| _ -> additivePersistence sumList (digitsOfInt n)
Error: This function has type int -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let rec additivePersistence n = 
match n with
| 0 -> 0
| _ -> additivePersistence (sumList (digitsOfInt n))
Error: This function has type int -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = additivePersistence 9876
Error: Unbound value sumList



hw1 additivePersistence

fix:
let rec lengthOfList xs count =
match xs with
| [] -> 0
| hd::tl -> lengthOfList tl count+1

let rec additivePersistence n = 
match n with
| 0 -> 0
| _ -> 
if not (lengthOfList digitsOfInt n = 1)
then additivePersistence(sumList (digitsOfInt n))
else 4

bad:
let _ = additivePersistence 9876
Error: Unbound value sumList


let rec additivePersistence n = 
match n with
| _ -> (sumList (digitsOfInt n))
Error: Unbound value additivePersistence


let _ = additivePersistence 9876
Error: Unbound value sumList


let rec additivePersistence n = 
match n with
| _ -> additivePersistence(sumList (digitsOfInt n))
Error: Unbound value additivePersistence


let _ = additivePersistence 9876
Error: Unbound value sumList



hw1 additivePersistence

fix:
let digitsOfInt n = 
let rec lastDigit n acc = 
if n <= 0 then acc
else lastDigit (n/10) (n mod 10::acc) in
match n with
| _ -> lastDigit n []

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

let digits n = digitsOfInt (abs n)

let rec lengthOfList xs count =
match xs with
| [] -> 0
| hd::tl -> lengthOfList tl count+1

let sumDigits = fun x -> sumList (digitsOfInt x)

sumDigits 123

let additivePersistence n = 
let rec additiveSequence n count =
match n with
| 0 -> 0
| _ -> 
if not (lengthOfList (digitsOfInt n) 0 = 1)
then additiveSequence (sumDigits n) count+1
else count

bad:
let additivePersistence n = 
let rec additiveSequence n count =
match n with
| 0 -> 0
| _ -> 
if not (lengthOfList (digitsOfInt n) 0 = 1)
then additivePersistence sumDigits n count+1
else count
in count = 0
Error: Unbound value sumDigits


let additivePersistence n = 
let rec additiveSequence n count =
match n with
| 0 -> 0
| _ -> 
if not (lengthOfList (digitsOfInt n) 0 = 1)
then additivePersistence sumDigits n (count+1)
else count
in count = 0
Error: Unbound value digitsOfInt


let additivePersistence n = 
let rec additiveSequence n count =
match n with
| 0 -> 0
| _ -> 
if not (lengthOfList (digitsOfInt n) 0 = 1)
then additivePersistence (sumDigits n) count+1
else count
in count = 0
Error: Unbound value digitsOfInt


let additivePersistence n = 
let rec additiveSequence n count =
match n with
| 0 -> 0
| _ -> 
if not (lengthOfList (digitsOfInt n) 0 = 1)
then additiveSequence sumDigits n count+1
else count
in count = 0
Error: Unbound value digitsOfInt


let additivePersistence n = 
let rec additiveSequence n count =
match n with
| 0 -> 0
| _ -> 
if not (lengthOfList (digitsOfInt n) 0 = 1)
then additiveSequence (sumDigits n) count+1
else count
in count = 0
Error: Unbound value digitsOfInt


let additivePersistence n = 
let rec additiveSequence n count =
match n with
| 0 -> 0
| _ -> 
if not (lengthOfList (digitsOfInt n) 0 = 1)
then additiveSequence (sumDigits n) count+1
else count
Error: Unbound value digitsOfInt



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let listReverse l = 
let rec reverse l acc = 
reverse l acc in
match l with
| [] -> []
| hd::tl -> reverse l []
Error: Unbound value digitalRoot



hw1 listReverse

fix:
let digitsOfInt n = 
let rec lastDigit n accu = 
if n <= 0 then accu
else lastDigit (n/10) (n mod 10::accu) in
match n with
| _ -> lastDigit n []

let _ = digitsOfInt 3124

let _ = digitsOfInt 352663

let digits n = digitsOfInt (abs n)

let rec lengthOfList xs count =
match xs with
| [] -> 0
| hd::tl -> lengthOfList tl count+1

let additivePersistence n = 
let rec sequence n i =
if lengthOfList (digitsOfInt n) 0 = 1 then i
else sequence (sumList (digitsOfInt n)) i+1 in
match n with
| _ -> sequence n 0

let _ = additivePersistence 9876

let rec digitalRoot n =
match n with
| _ -> 
if lengthOfList (digitsOfInt n) 0 = 1 then n
else digitalRoot (sumList (digitsOfInt n))

let _ = digitalRoot 9876

let listReverse l = 
let rec accReverse l acc =
match l with
| [] -> accu
| hd::tl -> accReverse tl (hd::accu)
in accReverse l acc

bad:
let rec digitalRoot n =
match n with
| _ -> 
if lengthOfList (digitsOfInt n) 0 = 1 then n
else digitalRoot (sumList (digitsOfInt n))
Error: Unbound value additivePersistence


let _ = digitalRoot 9876
Error: Unbound value digitsOfInt


let listReverse l = 
let rec accReverse l acc =
match l with
| [] -> acc
| hd::tl -> accReverse tl (hd::acc)
Error: Unbound value digitalRoot



hw1 listReverse

fix:
let _ = listReverse [1; 2; 3; 4]

bad:
let listReverse l = 
let rec accReverse l accu =
match l with
| [] -> accu
| hd::tl -> accReverse tl (hd::accu)
in accReverse l []
Error: Unbound value accu
Hint: Did you mean acc?



hw1 palindrome

fix:
let _ = palindrome "malayalam"

let _ = palindrome "myxomatosis"

bad:
let palindrome w = fun x -> (explode s = listReverse(explode s))
Error: Unbound value at


let palindrome w = fun x -> (explode w = listReverse(explode w))
Error: Unbound value s



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
if List.mem h seen then
let seen' = h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
if List.mem h seen then
let seen' = h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This expression has type 'a list
       but an expression was expected of type unit


l
Error: Unbound value l



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = if List.mem h seen then h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This variant expression is expected to have type unit
       The constructor :: does not belong to type unit


l
Error: Unbound value l



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
if not List.mem seen h then
let seen' = h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

bad:
 _ = removeDuplicates [1;6;2;4;12;2;13;6;9]
Error: Syntax error



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
let seen' = h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

l

bad:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
if not (List.mem seen h) then
let seen' = h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This expression has type 'a but an expression was expected of type
         'a list list
       The type variable 'a occurs inside 'a list list


l
Error: Unbound value l


let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
if not (List.mem seen h) then
let seen' = h::rest in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
Error: This expression has type 'a list list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list list


l
Error: Unbound value l



hw2 removeDuplicates

fix:
let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
if List.mem h seen then
let seen' = seen' in
let rest' = t in
else
let seen' = h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

bad:
et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]
Error: Syntax error



hw2 ???

fix:
let f x = let xx = x*x*x in (xx,xx<100)

let _ = f 2

bad:
let f x = let xx = x*x*x;
let _ = f 2
Error: Syntax error


let f x = let xx = x*x*x
Error: Syntax error


let _ = f 2
Error: Unbound value f



hw2 ???

fix:
f 8

bad:
let f 8
Error: Syntax error



hw2 assoc

fix:
let rec assoc (d,k,l) = match l with
| (s,i)::t -> if s = k then i
else assoc (d,k,t)
| [] -> d

bad:
let rec assoc (d,k,l) = match l with
| (s,i):t -> if s = k then i
else assoc (d,k,t)
| [] -> d
Error: Syntax error



hw2 wwhile

fix:
let wwhile (f,b) =
let rec helper (f,b) (x,y) =
match y with
| true -> helper (f,x) (x,y)
| false -> x
in helper (f,b) (b, true)

bad:
let wwhile (f,b) =
let rec helper (f,b) (x,y) =
match y with
| true -> helper (f, x)
| false -> x
in (f,b) (b, true)
Error: This expression has type 'a * bool -> 'b
       but an expression was expected of type 'b
       The type variable 'b occurs inside 'a * bool -> 'b


let wwhile (f,b) =
let rec helper (f,b) (x,y) =
match y with
| true -> helper (f,x) (x,y)
| false -> x
in (f,b) (b, true)
Error: This expression has type 'a * 'b
       This is not a function; it cannot be applied.



hw2 wwhile

fix:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

bad:
let wwhile (f,b) =
let rec helper (f,b) (x,y) =
match y with
| true -> helper (f,x) f b
| false -> x
in helper (f,b) (b, true)
Error: Unbound value f


let wwhile (f,b) =
let rec helper (f,b) (x,y) =
match y with
| true -> helper (f,x) f b
| false -> x
in helper (f,b) (b, true)
Error: This expression has type 'a but an expression was expected of type
         'b -> 'a
       The type variable 'a occurs inside 'b -> 'a


let wwhile (f,b) =
let rec helper (f,b) (x,y) =
match y with
| true -> helper (f,x) (f b)
| false -> x
in helper (f,b) (b, true)
Error: This expression has type 'a but an expression was expected of type
         'b -> 'a
       The type variable 'a occurs inside 'b -> 'a



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) = wwhile (f,b)
Error: Unbound value wwhile


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile


let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1
Error: Unbound value fixpoint



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((f f b),b)

bad:
let fixpoint (f,b) = wwhile ((f b),b)
Error: This expression has type 'a -> 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'a * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((f b),b)

bad:
let fixpoint (f,b) = wwhile ((f (f b)),b)
Error: This expression has type 'a -> 'b -> 'c
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'b -> 'c


let fixpoint (f,b) = wwhile ((f b),b)
Error: This expression has type 'a -> 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'a * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile ((f b),b)

bad:
let fixpoint (f,b) = wwhile (f,b)
Error: This expression has type 'a -> 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'a * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile (f,f b)

bad:
let fixpoint (f,b) = wwhile ((wwhile (f b)),b)
Error: Syntax error



hw2 fixpoint

fix:
let fixpoint (f,b) = wwhile (f,b)

bad:
let fixpoint (f,b) = wwhile (f,(f b))
Error: This expression has type 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a * bool


let fixpoint (f,b) = wwhile (f,b)
Error: This expression has type 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = 
wwhile (f, if b = (f b) then b else b)

bad:
let fixpoint (f,b) = 
let f x = xx = (f x) in (xx, xx != b) in f in
wwhile (f,b)
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> 'a * bool
       The type variable 'a occurs inside 'a * bool


let fixpoint (f,b) = 
let f x = xx = (f x) in (xx, xx != b) in f
wwhile (f,b)
Error: Syntax error


let fixpoint (f,b) = 
let f x = let xx = (f x) in (xx, xx != b) in f
wwhile (f,b)
Error: Unbound value xx


let fixpoint (f,b) = 
let f x = let xx = (f x) in (xx, xx != b) in f
Error: This function has type 'a -> 'b * bool
       It is applied to too many arguments; maybe you forgot a `;'.



hw2 fixpoint

fix:
let f b = f -> f;
let fixpoint (f,b) = 
wwhile (
, b)

bad:
let fixpoint (f,b) = 
wwhile (f, if b = (f(b)) then b else b)
Error: This expression has type 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a * bool


let fixpoint (f,b) = wwhile (f, b)
Error: This expression has type 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = 
let g b = (b, (f b)) in 
wwhile (g, b)

bad:
let fixpoint (f,b) = 
let g b = b in 
wwhile ((g), b)
Error: This expression has type 'a -> 'a * bool
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'a * bool


let fixpoint (f,b) = 
let g b = b in 
wwhile (g, b)
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> 'a * bool
       The type variable 'a occurs inside 'a * bool


let fixpoint (f,b) = 
let g b = b in 
wwhile ((g,true), b)
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> 'a * bool
       The type variable 'a occurs inside 'a * bool


let fixpoint (f,b) = 
let g b = b, (f b) in 
wwhile (g, b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c -> 'c * bool



hw2 fixpoint

fix:
let fixpoint (f,b) = 
if b != f b then
let f b = b, (f b) in
wwhile(f, b)
else b

bad:
let fixpoint (f,b) = 
let g x = b, (f b) in (b = (f b)) in 
wwhile (g, b)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a * 'b


let fixpoint (f,b) = 
if b != f b then
let f x = b, (f b) in
wwhile(f, b)
else b
Error: Unbound value g



hw2 fixpoint

fix:
let rec assoc (d,k,l) = match l with
| (s,i)::t -> if s = k then i
else assoc (d,k,t)
| [] -> d

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
if List.mem h seen then
let seen' = seen in
let rest' = t in
helper (seen', rest')
else
let seen' = h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let wwhile (f,b) =
let rec helper (f,b) (x,y) =
match y with
| true -> helper (f,x) (f b)
| false -> x
in helper (f,b) (b, true)

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) = 
if b != f b then
let b = f b in
wwhile(f, b)
else b

bad:
let fixpoint (f,b) = 
if b != f b then
let b = f b in
wwhile(f, b)
else b
Error: This expression has type int -> int
       but an expression was expected of type bool -> bool
       Type int is not compatible with type bool 



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) =
if b != f b then
wwhile(f, f b)
else
b
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> 'a * bool
       The type variable 'a occurs inside 'a * bool


let fixpoint (f,b) =
if b != (f b) then
wwhile(f, f b)
else
b
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> 'a * bool
       The type variable 'a occurs inside 'a * bool


let fixpoint (f,b) =
if b != (f b) then
let f = (f, true) in
wwhile(f, f b)
else
b
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> 'a * bool
       The type variable 'a occurs inside 'a * bool


let fixpoint (f,b) =
if b != (f b) then
let f = (f b, true) in
wwhile(f, f b)
else
b
Error: This expression has type ('a -> 'a) * bool
       but an expression was expected of type 'b -> 'b * bool


let fixpoint (f,b) =
if b != (f b) then
let f b = (b, true) in
wwhile(f, f b)
else
b
Error: This expression has type 'a * bool
       but an expression was expected of type 'b -> 'b * bool


let fixpoint (f,b) =
if b != (f b) then
let f b = (b, true) in
wwhile(f, f b)
else
wwhile(f b)
Error: This expression has type 'a but an expression was expected of type
         'a * bool
       The type variable 'a occurs inside 'a * bool


let fixpoint (f,b) =
if b = f b then
f b
else
let g b = (f b, true) in
wwhile(g, f b)
Error: This expression has type 'a but an expression was expected of type
         (('a -> 'a * bool) * 'a) * bool
       The type variable 'a occurs inside (('a -> 'a * bool) * 'a) * bool



hw2 fixpoint

fix:
let fixpoint (f,b) =
let g b = (f b, (b = f b)) in
wwhile(g, f b)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

let _ = fixpoint (collatz, 3)

let _ = fixpoint (collatz, 48)

let _ = fixpoint (collatz, 107)

let _ = fixpoint (collatz, 9001)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1

let _ = fixpoint (collatz, 1)

bad:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let rec assoc (d,k,l) = match l with
| (s,i)::t -> if s = k then i
else assoc (d,k,t)
| [] -> d

let _ = assoc (-1,"william",[("ranjit",85);("william",23);("moose",44)])

let _ = assoc (-1,"bob",[("ranjit",85);("william",23);("moose",44)])

let removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
[] -> seen
| h::t -> 
if List.mem h seen then
let seen' = seen in
let rest' = t in
helper (seen', rest')
else
let seen' = h::seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]

let wwhile (f,b) =
let rec helper (f,b) (x,y) =
match y with
| true -> helper (f,x) (f b)
| false -> x
in helper (f,b) (b, true)

let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)

let fixpoint (f,b) =
let y x = (f b, (b = f b)) in
wwhile(y, b)

let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let f x = let xx = x*x*x in (xx, xx < 100) in
wwhile (f, 2)
Error: Unbound value wwhile


let fixpoint (f,b) =
let g x = (f b, (b = f b)) in
wwhile(g, b)
Error: Unbound value wwhile


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile


let fixpoint (f,b) =
let g x = (f b, (b != f b)) in
wwhile(g, b)
Error: Unbound value fixpoint


let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)
Error: Unbound value wwhile



hw2 fixpoint

fix:
let fixpoint (f,b) =
let y = f b in (y, (b = f b)) in
wwhile(y, b)

bad:
let fixpoint (f,b) =
let y x= (f b, (b = f b)) in
wwhile(y b, b)
Error: This expression has type 'a * bool
       but an expression was expected of type 'b -> 'b * bool


let fixpoint (f,b) =
let y x= (f b, (b = f b)) in
wwhile(y, b)
Error: This expression has type 'a * bool
       but an expression was expected of type 'b -> 'b * bool



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) =
let y = f b in (y, (b = f b)) in
wwhile(f, b)
Error: Unbound value y


let fixpoint (f,b) =
let y = f b in (y, (b = f b)) in
wwhile(y, b)
Error: Unbound value f


let fixpoint (f,b) = let y = f b in (y, (b = f b)) in
wwhile(y, b)
Error: Unbound value y


let fixpoint (f,b) = let y = f b in (y, (b = f b)) in
wwhile(f b, b)
Error: Unbound value y


let fixpoint (f,b) = let y x = f b in (y, (b = f b)) in
wwhile(y, b)
Error: Unbound value f


let fixpoint (f,b) =
let y x = (f b, (b = f b)) in
wwhile(y, b)
Error: Unbound value y



hw2 fixpoint

fix:
let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)

bad:
let fixpoint (f,b) =
let f x = (f b, (b = f b)) in
wwhile(f, b)
Error: This expression has type 'a -> 'a
       but an expression was expected of type 'a -> 'a * bool
       The type variable 'a occurs inside 'a * bool



hw2 fixpoint

fix:
let fixpoint (f,b) =
let f x = (f b, (f b = b)) in
wwhile(f, b)

bad:
let fixpoint (f,b) =
let f x = (f, (f b = b)) in
wwhile(f, f b)
Error: This expression has type 'a but an expression was expected of type
         'a -> 'a
       The type variable 'a occurs inside 'a -> 'a


let fixpoint (f,b) =
let f x = (f, (f b = b)) in
wwhile(f, x)
Error: This expression has type ('a -> 'a) * bool
       but an expression was expected of type 'a -> 'a


let fixpoint (f,b) =
let f x = (f, (f b = b)) in
wwhile(f b, b)
Error: Unbound value x


let fixpoint (f,b) =
let f x = (f x, (f b = b)) in
wwhile(f, b)
Error: This expression has type ('a -> 'a) * bool
       but an expression was expected of type 'b -> 'b * bool



hw2 eval

fix:
let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> sin(pi* eval e)
| Cosine e-> cos(pi* eval e)
| Average (e1,e2) -> (eval e1 + eval e2) / 2
| Times (e1,e2) -> eval e1 * eval e2
| Thresh (e1,e2,e3,e4) -> eval e1 < eval e2 ? eval e3 : eval e4
Error: Unbound value eval


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> sin(pi*. eval e)
| Cosine e-> cos(pi*. eval e)
| Average (e1,e2) -> (eval e1 +. eval e2) /. 2
| Times (e1,e2) -> eval e1 *. eval e2
| Thresh (e1,e2,e3,e4) -> if eval e1 < eval e2 then eval e3 else eval e4
Error: Syntax error


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> sin(pi*. eval(e,x,y))
| Cosine e-> cos(pi*. eval(e,x,y))
| Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2
| Times (e1,e2) -> eval(e,x,y) *. eval(e,x,y)
| Thresh (e1,e2,e3,e4) -> if eval(e,x,y) < eval(e,x,y) then eval(e,x,y) else eval(e,x,y)
Error: This expression has type expr but an expression was expected of type
         expr * 'a * 'a


let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> sin(pi*. eval(e,x,y))
| Cosine e-> cos(pi*. eval(e,x,y))
| Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2.
| Times (e1,e2) -> eval(e,x,y) *. eval(e,x,y)
| Thresh (e1,e2,e3,e4) -> if eval(e,x,y) < eval(e,x,y) then eval(e,x,y) else eval(e,x,y)
Error: This expression has type int but an expression was expected of type
         float



hw2 eval

fix:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> sin(pi*. eval(e,x,y))
| Cosine e-> cos(pi*. eval(e,x,y))
| Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2.
| Times (e1,e2) -> eval(e,x,y) *. eval(e,x,y)
| Thresh (e1,e2,e3,e4) -> if eval(e,x,y) < eval(e,x,y) then eval(e,x,y) else eval(e,x,y)

bad:
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine e -> sin(pi*. eval(e,x,y))
| Cosine e-> cos(pi*. eval(e,x,y))
| Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2.
| Times (e1,e2) -> eval(e,x,y) *. eval(e,x,y)
| Thresh (e1,e2,e3,e4) -> if eval(e,x,y) < eval(e,x,y) then eval(e,x,y) else eval(e,x,y)
Error: This expression has type expr but an expression was expected of type
         float



hw2 ???

fix:
let g1 () = failwith "to be implemented"

let g2 () = failwith "to be implemented"

let g3 () = failwith "to be implemented"

let c1 () = failwith "to be implemented"

let c2 () = failwith "to be implemented"

let c3 () = failwith "to be implemented"

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rand = makeRand(1,2)

bad:
let rand = makeRand(1,2)
Error: Unbound value rand
Hint: Did you mean land?



hw2 build

fix:
let rec build (rand, depth) = 
if depth = 0 || depth = 1 then
let r = rand(0,1) in
match r with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand(2,7) in
match r with
| 2 -> buildSine(build(rand,depth-1))
| 3 -> buildCosine(build(rand,depth-1))
| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))
| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))

bad:
let build (rand, depth) = 
let rec helper (e, rand, depth) =
if depth = 0 || depth = 1 then
let r = rand(0,1) in
match r with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand(2,7) in
match r with
| 2 -> buildSine( helper (e, rand, depth-1))
| 3 -> buildCosine( helper (e, rand, depth-1 ))
| 4 -> buildAverage(helper (e, rand, depth-1),helper (e, rand, depth-1))
Error: Syntax error


let build (rand, depth) = 
let rec helper (e, rand, depth) =
if depth = 0 || depth = 1 then
let r = rand(0,1) in
match r with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand(2,7) in
match r with
| 2 -> buildSine( helper (e, rand, depth-1))
| 3 -> buildCosine( helper (e, rand, depth-1 ))
Error: Syntax error


let build (rand, depth) = 
let rec helper (e, rand, depth) =
if depth = 0 || depth = 1 then
let r = rand(0,1) in
match r with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand(2,7) in
match r with
| 2 -> buildSine( helper (e, rand, depth-1))
| 3 -> buildCosine( helper (e, rand, depth-1 ))
Error: Syntax error


let rec build (rand, depth) = 
if depth = 0 || depth = 1 then
let r = rand(0,1) in
match r with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand(2,7) in
match r with
| 2 -> buildSine(build(rand,depth-1))
Error: Syntax error



hw2 build

fix:
let rec build (rand, depth) = 
if depth = 0 || depth = 1 then
let r = rand(0,1) in
match r with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand(2,9) in
match r with
| 2 -> buildSine(build(rand,depth-1))
| 3 -> buildCosine(build(rand,depth-1))
| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))
| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
| 7 -> buildSquared(build(rand,depth-1))
| 8 -> buildRoot(build(rand,depth-1))

let g1 () = (1, 1, 2)

let g2 () = (1, 1, 10)

let g3 () = (1, 1, 10)

let c1 () = (1, 1, 2)

let c2 () = (1, 1, 10)

let c3 () = (1, 1, 10)

let makeRand (seed1, seed2) = 
let seed = (Array.of_list [seed1;seed2]) in
let s = Random.State.make seed in
(fun (x,y) -> (x + (Random.State.int s (y-x))))

let rec rseq g r n =
if n <= 0 then [] else (g r)::(rseq g r (n-1))

let toReal (i,n) = (float_of_int i) /. (float_of_int n)

let toIntensity z = int_of_float (127.5 +. (127.5 *. z))

let rec ffor (low,high,f) = 
if low > high then () else 
let _ = f low in 
ffor (low+1,high,f)

let emitGrayscale (f,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_g_"^name) in
let chan = open_out (fname^".pgm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z = f (x,y) in
(* Convert the result to a grayscale value *)
let iz = toIntensity(z) in
(* Emit one byte for this pixel *)
output_char chan (char_of_int iz))) in 
close_out chan;
ignore(Sys.command ("convert "^fname^".pgm "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".pgm"))

let doRandomGray (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand(seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e = build (g,depth) in
let _ = print_string (exprToString e) in
let f = eval_fn e in
(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitGrayscale (f,n,name)

let _ = emitGrayscale (eval_fn sampleExpr, 150, "sample")

let emitColor (f1,f2,f3,n,name) =
(* Open the output file and write the header *)
let fname  = ("art_c_"^name) in
let chan = open_out (fname^".ppm") in
(* Picture will be 2*N+1 pixels on a side *)
let n2p1 = n*2+1 in   
let _ = output_string chan (Format.sprintf "P6 %d %d 255\n" n2p1 n2p1) in
let _ = 
ffor (-n, n, 
fun ix ->
ffor (-n, n, 
fun iy ->
(* Convert grid locations to [-1,1] *)
let x = toReal(ix,n) in
let y = toReal(iy,n) in
(* Apply the given random function *)
let z1 = f1 (x,y) in
let z2 = f2 (x,y) in
let z3 = f3 (x,y) in

(* Convert the result to a grayscale value *)
let iz1 = toIntensity(z1) in
let iz2 = toIntensity(z2) in
let iz3 = toIntensity(z3) in

(* Emit one byte per color for this pixel *)
output_char chan (char_of_int iz1);
output_char chan (char_of_int iz2);
output_char chan (char_of_int iz3);
)) in  
close_out chan;
ignore(Sys.command ("convert "^fname^".ppm  "^fname^".jpg"));
ignore(Sys.command ("rm "^fname^".ppm"))

let doRandomColor (depth,seed1,seed2) =
(* Initialize random-number generator g *)
let g = makeRand (seed1,seed2) in
(* Generate a random expression, and turn it into an ML function *)
let e1 = build (g, depth) in
let e2 = build (g, depth) in
let e3 = build (g, depth) in

let _ = Format.printf "red   = %s \n" (exprToString e1) in
let _ = Format.printf "green = %s \n" (exprToString e2) in
let _ = Format.printf "blue  = %s \n" (exprToString e3) in

let f1 = eval_fn e1 in
let f2 = eval_fn e2 in
let f3 = eval_fn e3 in

(* 301 x 301 pixels *)
let n = 150 in
(* Emit the picture *)
let name = Format.sprintf "%d_%d_%d" depth seed1 seed2 in
emitColor (f1,f2,f3,n,name)

type test = unit -> string

let key = ""

let prefix130 = "130"

let print130 s = print_string (prefix130^">>"^s)

exception ErrorCode of string

type result = Pass | Fail | ErrorCode of string

let score = ref 0

let max = ref 0

let timeout = 300

let runWTimeout (f,arg,out,time) = 
try if compare (f arg) out = 0 then Pass else Fail
with e -> (print130 ("Uncaught Exception: "^(Printexc.to_string e)); ErrorCode "exception")

let explode s = 
let rec _exp i = 
if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in
_exp 0

let implode cs = 
String.concat "" (List.map (String.make 1) cs)

let drop_paren s = 
implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))

let eq_real p (r1,r2) = 
(r1 -. r2) < p || (r2 -. r1) < p

let scoreMsg () = 
Format.sprintf "Results: Score/Max = %d / %d \n" !score !max

bad:
let rec build (rand, depth) = 
if depth = 0 || depth = 1 then
let r = rand(0,1) in
match r with
| 0 -> buildX()
| 1 -> buildY()
else
let r = rand(2,9) in
match r with
| 2 -> buildSine(build(rand,depth-1))
| 3 -> buildCosine(build(rand,depth-1))
| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))
| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))
| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))
| 7 -> buildSquared(build(rand,depth-1))
| 8 -> buildRoot(build(rand,depth-1))
Error: Unbound value buildSquare
Hint: Did you mean buildSquared?
Error: Unbound value buildSquare
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value buildSquare
Hint: Did you mean buildSquared?



hw2 eval

fix:
let _ = eval (Sine(VarX),pi,0.)

bad:
let _ = eval (Sine(VarX)),pi,0
Error: This expression has type expr but an expression was expected of type
         expr * float * float
Error: Unbound value pi
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type expr but an expression was expected of type
         expr * float * float


)
Error: This expression has type expr but an expression was expected of type
         expr * float * float
Error: Unbound value pi
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type expr but an expression was expected of type
         expr * float * float


let _ = eval ((Sine(VarX)),pi,0)
Error: Syntax error


let _ = eval ((Sine(VarX)),pi,0.)
Error: This expression has type int but an expression was expected of type
         float
Error: Unbound value pi
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int but an expression was expected of type
         float



hw3 sqsum

fix:
let sqsum xs = 
let f a x = (a*x) in
let base = 0 in
List.fold_left f base xs

bad:
let sqsum xs = 
let f a x = (fun f _ -> a*a) in
let base = 0 in
List.fold_left f base xs
Error: This expression has type int -> 'a -> 'b -> 'c -> int
       but an expression was expected of type int -> 'a -> int
       Type 'b -> 'c -> int is not compatible with type int 



hw3 sqsum

fix:
let sqsum xs = 
let f a x = (a*a) in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

bad:
let sqsum xs = 
let f a x = () in
let base = 0 in
List.fold_left f base xs
Error: This expression has type int but an expression was expected of type
         unit



hw3 sqsum

fix:
let _ = sqsum [(-1); (-2); (-3); (-4)]

let _ = sqsum [1;2;3]

bad:
let _ = sqsum [(-1); (-2); (-3); (-4)]
let_ = sqsum [1;2;3]
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 sqsum

fix:
let sqsum xs = 
let f a x = (a+x*x) in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let _ = () 3

bad:
let sqsum xs = 
let f a x = (a+x*x) in
let base = x in
List.fold_left f base xs
Error: Unbound value x



hw3 ???

fix:
let _ = fun f -> f

bad:
let _ = *3
Error: Syntax error



hw3 pipe

fix:
let pipe fs = 
let f a x = (a+x) in
let base = 0 in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (a+x) in
let base = base in
List.fold_left f base fs
Error: Unbound value base



hw3 pipe

fix:
let pipe fs = 
let f a x = (x) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (a+x) in
let base = fs in
List.fold_left f base fs
Error: This expression has type int but an expression was expected of type
         int list


let pipe fs = 
let f a x = (a+x) in
let base = fs in
List.fold_left f base fs
Error: This expression has type int but an expression was expected of type
         int list


let pipe fs = 
let f a x = (a+x) in
let base = f in
List.fold_left f base fs
Error: This expression has type int -> int -> int
       but an expression was expected of type int


let pipe fs = 
let f a x = (a+x) in
let base = [] in
List.fold_left f base fs
Error: This expression has type 'a list
       but an expression was expected of type int


let pipe fs = 
let f a x = (a+x) in
let base = (fun a->a) in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let pipe fs = 
let f a x = () in
let base = (fun x -> x) in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type unit



hw3 pipe

fix:
let pipe fs = 
let f a x = (x) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (a+x) in
let base = (fun x -> x) in
List.fold_left f base fs
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 pipe

fix:
let pipe fs = 
let f a x = fun f -> (a x) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun x y) in
let base = (fun x -> x) in
List.fold_left f base fs
Error: Syntax error: operator expected.


let pipe fs = 
let f a x = (fun x -> f (a x)) in
let base = (fun x -> x) in
List.fold_left f base fs
Error: Unbound value f



hw3 pipe

fix:
let pipe fs = 
let f a x = (x a) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (fun f -> f (a x)) in
let base = (fun x -> x) in
List.fold_left f base fs
Error: This expression has type ('a -> 'a) -> 'a -> 'a
       but an expression was expected of type ('a -> 'a) -> 'a
       The type variable 'a occurs inside 'a -> 'a


let pipe fs = 
let f a x = (fun f -> f (x)) in
let base = (fun x -> x) in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = (fun f -> a(f x)) in
let base = (fun x -> x) in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'c -> ('c -> 'a) -> 'b
       but an expression was expected of type ('a -> 'b) -> 'c -> 'a -> 'b
       The type variable 'a occurs inside 'c -> 'a


let pipe fs = 
let f a x = (a (f x)) in
let base = (fun x -> x) in
List.fold_left f base fs
Error: Unbound value f


let pipe fs = 
let f a x = (a x) in
let base = (fun x -> x) in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = (x a) in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (a x) in
let base = (fun x -> x) in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = (x)a in
let base = (fun x -> x) in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (a x) in
let base = (fun x -> x) in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 pipe

fix:
let pipe fs = 
let f a x = (a x) in
let base = _ in
List.fold_left f base fs

let _ = pipe [] 3

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int


let pipe fs = 
let f a x = (a x) in
let base = (fun x -> x) in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = (a x) in
let base = (x) in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b


let pipe fs = 
let f a x = (a x) in
let base = () in
List.fold_left f base fs
Error: This expression has type ('a -> 'b) -> 'a -> 'b
       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b
       The type variable 'b occurs inside 'a -> 'b



hw3 ???

fix:
let x = fun x -> x

bad:
let x = fun x
Error: Syntax error



hw3 sqsum

fix:
let _ = sqsum [(-1); (-2); (-3); (-4)]

List.fold_left

bad:
let _ = sqsum [(-1); (-2); (-3); (-4)]

List.fold_left
Error: This function has type int list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 pipe

fix:
let pipe fs = 
let f a x = (x a) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let pipe fs = 
let f a x = (x x) in
let base = fun x -> x in
List.fold_left f base fs
Error: This expression has type 'a -> 'b
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a -> 'b



hw3 ???

fix:
let o f g = fun x -> f (g x)

bad:
let (o) f g = fun x -> f (g x)
Error: Syntax error



hw3 ???

fix:
let o f g = fun x -> f (g x)

bad:
let foo = (fun x -> x + 1) o (fun y -> 2 *y)
Error: This function has type int -> int
       It is applied to too many arguments; maybe you forgot a `;'.


let f o g = fun x -> f (g x)
Error: Unbound value f



hw3 pipe

fix:
let pipe fs = 
let f a x = (fun y -> x (a y)) in
let base = fun x -> x in
List.fold_left f base fs

bad:
let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3
Error: This expression has type 'a -> 'a
       but an expression was expected of type int



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h in
let base = "" in
let l = h in
List.fold_left f base l
Error: This expression has type string but an expression was expected of type
         'a list


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h in
let base = "" in
let l = l in
List.fold_left f base l
Error: Unbound value l



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep in
let base = "" in
let l = sepConcat sep t in
List.fold_left f base l
Error: This expression has type string but an expression was expected of type
         'a list



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep::sepConcat(sep t) in
let base = "" in
let l = t in
List.fold_left f base l
Error: This expression has type 'a list
       but an expression was expected of type string



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep^sepConcat(sep t) in
let base = "" in
let l = t in
List.fold_left f base l
Error: This expression has type string
       This is not a function; it cannot be applied.


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep^t in
let base = "" in
let l = t in
List.fold_left f base l
Error: This expression has type string list
       but an expression was expected of type string



hw3 sepConcat

fix:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep in
let base = "" in
let l = t in
List.fold_left f base l

bad:
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep in
let base = "" in
let l = sepConcat(sep t) in
List.fold_left f base l
Error: This expression has type string
       This is not a function; it cannot be applied.


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = h^sep in
let base = "" in
let l = sepConcat sep t in
List.fold_left f base l
Error: This expression has type string but an expression was expected of type
         'a list


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = sepConcat(h^sep t) in
let base = "" in
let l = t in
List.fold_left f base l
Error: This expression has type string but an expression was expected of type
         string list -> string


let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = sepConcat h^sep t in
let base = "" in
let l = t in
List.fold_left f base l
Error: This expression has type 'a list -> string
       but an expression was expected of type string



hw3 stringOfList

fix:
let stringOfList f l = List.map sepConcat

bad:
let stringOfList f l = List.map sepConcat ""
Error: This expression has type string but an expression was expected of type
         string list



hw3 stringOfList

fix:
let stringOfList f l = List.map (sepConcat) (f l)

bad:
let stringOfList f l = List.map (sepConcat l "") f
Error: This expression has type string but an expression was expected of type
         string list


let stringOfList f l = List.map (sepConcat "" l) f
Error: This expression has type string but an expression was expected of type
         'a -> 'b


let stringOfList f l = List.map (sepConcat "" l)
Error: This expression has type string but an expression was expected of type
         'a -> 'b


let stringOfList f l = List.map (sepConcat "" (f l))
Error: This expression has type string but an expression was expected of type
         'a -> 'b


let stringOfList f l = List.map (sepConcat "" (f l))
Error: This expression has type string but an expression was expected of type
         'a -> 'b


let stringOfList f l = List.map (sepConcat) f l
Error: This function has type ('a -> 'b) -> 'a list -> 'b list
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 stringOfList

fix:
let stringOfList f l = List.map (sepConcat) (f l)

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: This expression has type int -> string
       but an expression was expected of type int -> string list
       Type string is not compatible with type string list 


let stringOfList f l = List.map (sepConcat "" (f l)) (f l)
Error: This expression has type string but an expression was expected of type
         'a -> 'b



hw3 stringOfList

fix:
let stringOfList f l = List.map (sepConcat) (f l)

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: This expression has type int but an expression was expected of type
         string



hw3 sepConcat

fix:
let _ = sepConcat "" ["foo"]

bad:
let _ = sepConcat ["foo"]
Error: This expression has type 'a list
       but an expression was expected of type string



hw3 stringOfList

fix:
let stringOfList f l = List.map (sepConcat) (l)

bad:
let stringOfList f l = List.map (sepConcat "" (f l)) (l)
Error: This expression has type string but an expression was expected of type
         'a -> 'b



hw3 stringOfList

fix:
let stringOfList f l = List.map (sepConcat) (f l)

let _ = stringOfList string_of_int [1;2;3;4;5;6]

bad:
let _ = stringOfList string_of_int [1;2;3;4;5;6]
Error: This expression has type int but an expression was expected of type
         string



hw3 stringOfList

fix:
let stringOfList f l = List.map (sepConcat) (l)

bad:
let stringOfList f l = List.map (sepConcat "" (f l)) (l)
Error: This expression has type string but an expression was expected of type
         'a -> 'b



hw3 stringOfList

fix:
let stringOfList f l = List.map (sepConcat) (f l)

bad:
let stringOfList f l = List.map (sepConcat) f(l)
Error: This function has type ('a -> 'b) -> 'a list -> 'b list
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 clone

fix:
let clone x n = 
let rec helper x n acc =
if n <= 0 then acc
else helper x (n-1) (x::acc)
in helper x n []

bad:
let rec clone x n = 
if n <= 0 then []
else x :: clone x n-1
Error: This expression has type 'a list
       but an expression was expected of type int


let rec clone x n = 
if n <= 0 then []
else x :: clone x n-1
Error: This expression has type 'a list
       but an expression was expected of type int


let rec clone x n = 
if n <= 0 then []
else x :: clone (x n-1)
Error: This expression has type int but an expression was expected of type
         int -> int


let rec clone x n = 
if n <= 0 then []
else x :: clone x n-1
Error: This expression has type 'a list
       but an expression was expected of type int


let rec clone x n = 
if n <= 0 then []
else clone x n-1
Error: This expression has type 'a list
       but an expression was expected of type int


let rec clone x n = 
if n <= 0 then []
else then x :: clone x n-1
Error: Syntax error


let rec clone x n = 
if n <= 0 then []
else x :: clone x n-1
Error: This expression has type 'a list
       but an expression was expected of type int


let clone x n = 
let rec helper x n acc =
if n <= 0 then acc
else helper x n-1 x:acc
in helper x n []
Error: Syntax error


let clone x n = 
let rec helper x n acc =
if n <= 0 then acc
else helper x n-1 x::acc
in helper x n []
Error: This expression has type 'a list -> 'a list
       but an expression was expected of type int



hw3 ???

fix:
List.length([0;0;0;9]);
[[0;0;9;9]] @ [[1;0;0;2]]

bad:
List.length([0;0;0;9])
[[0;0;9;9]] @ [[1;0;0;2]]
Error: This function has type 'a list -> int
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 ???

fix:
List.append [[0;0;9;9]] [[1;0;0;2]]

bad:
List.append([[0;0;9;9]], [[1;0;0;2]])
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list



hw3 ???

fix:
List.append [[0;0;9;9]] [[1;0;0;2]]

bad:
List.append [[0;0;9;9]] [[1;0;0;2]] [[1;2]]
Error: This function has type 'a list -> 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 padZero

fix:
let padZero l1 l2 =
if (List.length l1) < (List.length l2) then
List.append [(clone 0 (List.length l2 - List.length l1)) @ l1] [l2]
else
List.append [l1] [(clone 0 (List.length l1 - List.length l2)) @ l2]

bad:
let padZero l1 l2 =
if (List.length l1) < (List.length l2) then
List.append [(clone 0 (List.length l2 - List.length l1)) @ l1] [l2]
else (List.length l1) > (List.length l2)
List.append [l1] [(clone 0 (List.length l1 - List.length l2)) @ l2]
Error: This expression has type int
       This is not a function; it cannot be applied.



hw3 padZero

fix:
let padZero l1 l2 =
if (List.length l1) < (List.length l2) then
((clone 0 (List.length l2 - List.length l1)) @ l1, l2)
else
(l1, (clone 0 (List.length l1 - List.length l2)) @ l2)

bad:
let padZero l1 l2 =
if (List.length l1) < (List.length l2) then
([(clone 0 (List.length l2 - List.length l1)) @ l1], [l2])
else
([l1], [(clone 0 (List.length l1 - List.length l2)) @ [l2])
Error: Syntax error: operator expected.


let padZero l1 l2 =
if (List.length l1) < (List.length l2) then
([(clone 0 (List.length l2 - List.length l1)) @ l1], l2)
else
([l1], [(clone 0 (List.length l1 - List.length l2)) @ l2)
Error: Syntax error: operator expected.


let padZero l1 l2 =
if (List.length l1) < (List.length l2) then
((clone 0 (List.length l2 - List.length l1)) @ l1, l2)
else
([l1], (clone 0 (List.length l1 - List.length l2)) @ l2)
Error: This expression has type int list
       but an expression was expected of type int



hw3 padZero

fix:
let padZero l1 l2 =
if (List.length l1) < (List.length l2) then
(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)
else
(l1, List.append (clone 0 (List.length l1 - List.length l2)) l2)

bad:
let padZero l1 l2 =
if (List.length l1) < (List.length l2) then
((List.append clone 0 (List.length l2 - List.length l1)) l1, l2)
else
(l1, List.append (clone 0 (List.length l1 - List.length l2)) l2)
Error: This function has type 'a list -> 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 stringOfList

fix:
let _ = stringOfList string_of_int [9;9]

bad:
let _ = stringOfList [9;9]
Error: This expression has type 'a list
       but an expression was expected of type 'b -> string



hw3 padZero

fix:
let _ = padZero [9;9] [1;0;0;2]

bad:
let _ = List.rev List.combine( padZero([9;9] [1;0;0;2]))
Error: This function has type 'a list -> 'a list
       It is applied to too many arguments; maybe you forgot a `;'.


let _ = List.rev (List.combine( padZero([9;9] [1;0;0;2])))
Error: This expression has type int list
       This is not a function; it cannot be applied.


let _ = List.rev (List.combine( padZero [9;9] [1;0;0;2]))
Error: This expression has type int list * int list
       but an expression was expected of type 'a list



hw3 padZero

fix:
let _ = padZero [9;9] [1;0;0;2]

bad:
let _ = List.combine(padZero [9;9] [1;0;0;2])
Error: This expression has type int list * int list
       but an expression was expected of type 'a list



hw3 padZero

fix:
let _ = padZero [9;9] [1;0;0;2]

bad:
let _ = List.rev(padZero [9;9] [1;0;0;2])
Error: This expression has type int list * int list
       but an expression was expected of type 'a list



hw3 removeZero

fix:
let _ = removeZero [0;0;0;0]

let _ = int_of_list [9;9]

bad:
let _ = removeZero [0;0;0;0]

int_of_list [9;9]
Error: This function has type int list -> int list
       It is applied to too many arguments; maybe you forgot a `;'.



hw3 ???

fix:
let _ = List.combine y z

bad:
let _ = List.combine(y, z)
Error: This expression has type 'a * 'b
       but an expression was expected of type 'c list



hw3 ???

fix:
let p = match o with
| h::h2::t::(s,i)::t2 -> s+i

bad:
let p = match o with
| h::h2::t::(s,i) -> s+i
Error: This pattern matches values of type 'a * 'b
       but a pattern was expected which matches values of type
         (int * int) list


let p = match o with
| h::h2::t::(s,i)::t -> s+i
Error: Variable t is bound several times in this matching



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = [(0, [])] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = xin
Error: Syntax error


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (a,b) in
let args = (l1,l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: Unbound value a


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = (l1,l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type (int * 'c list) list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = (0,List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type int * ('a * 'b) list
       but an expression was expected of type (int * 'c list) list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = (0, l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type int * 'a
       but an expression was expected of type (int * 'b list) list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = (0, l1) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type int * 'a
       but an expression was expected of type (int * 'b list) list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = (0, []) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type int * 'a list
       but an expression was expected of type (int * 'b list) list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = [(0, [])] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = [(0, [l1,l2])] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type (int list * int list) list
       but an expression was expected of type int list
       Type int list * int list is not compatible with type int 



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = [ (3, [] ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = [ (l1+l2, [] ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type int list * int list
       but an expression was expected of type int * int
       Type int list is not compatible with type int 



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| x'::xs -> x' in
let base = (0, []) in
let args =  match l1 with
| h::t -> [[ (h, l2 ) ]] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| x::xs -> x in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type ('a * 'b) list
       but an expression was expected of type (int * 'c list) list list
       Type 'a * 'b is not compatible with type (int * 'c list) list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| x'::xs -> x' in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type ('a * 'b) list
       but an expression was expected of type (int * 'c list) list list
       Type 'a * 'b is not compatible with type (int * 'c list) list 



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (c,d) -> (c,d) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match a with
| (c,d) -> c in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b -> 'c -> 'a
       but an expression was expected of type 'a * 'b -> 'c -> 'a * 'b
       The type variable 'a occurs inside 'a * 'b



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d) -> a in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d) -> (c,a) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type 'a -> 'b * 'c -> 'b * 'a
       but an expression was expected of type 'a -> 'b * 'c -> 'a
       The type variable 'a occurs inside 'b * 'a



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d) -> a in
let base = (0, [1]) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d) -> a in
let base = (0, [1,1]) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type (int * int) list
       but an expression was expected of type int list
       Type int * int is not compatible with type int 



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> a in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d) -> c+d::a in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type int * 'a list
       but an expression was expected of type int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> c+d::a in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type int * 'a list
       but an expression was expected of type int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c+d::a,l2) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type int list -> int * int list -> int list * 'a
       but an expression was expected of type
         int list -> int * int list -> int list
       Type int list * 'a is not compatible with type int list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> c+d::a in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type int * 'a list
       but an expression was expected of type int list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c,d::t) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> c+d in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type int * 'a list
       but an expression was expected of type int


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c+d)::a in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type int * 'a list
       but an expression was expected of type int list


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> c in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type int list * int list
       but an expression was expected of type (int * 'a list) list * 'b list
       Type int is not compatible with type int * 'a list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> c,d in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type int list * int list
       but an expression was expected of type int list * 'a list list
       Type int is not compatible with type 'a list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c,d) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type int list * int list
       but an expression was expected of type int list * 'a list list
       Type int is not compatible with type 'a list 



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c,t) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c,a) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type 'a -> 'b * 'c list -> 'b * 'a
       but an expression was expected of type 'a -> 'b * 'c list -> 'a
       The type variable 'a occurs inside 'b * 'a


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c,[a]) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type 'a -> 'b * 'c list -> 'b * 'a list
       but an expression was expected of type 'a -> 'b * 'c list -> 'a
       The type variable 'a occurs inside 'b * 'a list



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c,t) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, List.rev l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c,d) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, List.rev l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type int list * int list
       but an expression was expected of type int list * 'a list list
       Type int is not compatible with type 'a list 



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c,t) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, List.rev l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (c,d::t) -> (c,c+t) in
let base = (0, []) in
let args =  match l1 with
| h::t -> [ (h, List.rev l2 ) ] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type 'a list
       but an expression was expected of type int



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1,d2) -> (d1+d2, d1+d2::
match a with 
| (a1,a2)->a2) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1,d2) -> (d1+d2, d1+d2::) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: Syntax error: operator expected.


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1,d2) -> (d1+d2, d1+d2::a) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type int list -> int * int -> int * int list
       but an expression was expected of type
         int list -> int * int -> int list
       Type int * int list is not compatible with type int list 


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1,d2) -> (d1+d2, d1+d2::(match a with | (a1,a2)->a2) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Characters 79-80:
  | (d1,d2) -> (d1+d2, d1+d2::(match a with | (a1,a2)->a2) in
               ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (o,p) = a in
match x with 
| (d1,d2) -> (((d1+d2) mod 10 -(d1+d2))/10, (d1+d2) mod 10+o::p) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1,d2) -> (((d1+d2) mod 10 -(d1+d2))/10, (d1+d2) mod 10+
match a with 
| (a1,a2)->a1)::a2 in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: Unbound value a2


let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1,d2) -> (((d1+d2) mod 10 -(d1+d2))/10, (d1+d2) mod 10+
match a with 
| (a1,a2)-> a1::a2 in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Characters 79-80:
  | (d1,d2) -> (((d1+d2) mod 10 -(d1+d2))/10, (d1+d2) mod 10+
               ^
Syntax error: ')' expected, the highlighted '(' might be unmatched



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (o,p) = a in
match x with 
| (d1,d2) -> ((d1+d2) mod 10 /10, ((d1+d2) mod 10)+o ::p) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (o,p) = a in
match x with 
| (d1,d2) -> ((d1+d2) mod 10 /10, ((d1+d2) mod 10)+o)::p
Error: Syntax error



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (o,p) = a in
match x with 
| (d1,d2) -> ( (d1+d2+o)/10, ((d1+d2+o) mod 10) ::p) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = 
let (o,p) = a in
match x with 
| (d1,d2) -> ( (d1+d2+a)/10, ((d1+d2+o) mod 10) ::p) in
let base = (0, []) in
let args = List.rev (List.combine l1 l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type 'a * 'b
       but an expression was expected of type int



hw3 bigAdd

fix:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (o,p) = a in
let (d1,d2) = x in ( (d1+d2+o)/10, ((d1+d2+o) mod 10) ::p) in
let base = (0, []) in
let args = List.rev (List.combine l1 (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

bad:
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (o,p) = a in
let (d1,d2) = x in ( (d1+d2+o)/10, ((d1+d2+o) mod 10) ::p) in
let base = (0, []) in
let args = List.rev (List.combine 0::l1 0::l2) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
Error: This expression has type int but an expression was expected of type
         'a list



hw3 mulByDigit

fix:
let mulByDigit i l = 
let rec helper i l acc =
match l with
| [] -> acc
| h::t -> (h*i) :: acc 
in helper i l []

bad:
let rec mulByDigit i l = let h::t = List.rev l in
mulByDigit (h*i)
Error: This expression has type int list -> 'a
       but an expression was expected of type 'a
       The type variable 'a occurs inside int list -> 'a



hw3 mulByDigit

fix:
let mulByDigit i l = 
let rec helper i l acc =
match l with
| [] -> acc
| h::t -> h*i :: acc 
in helper i l []

bad:
let mulByDigit i l = 
let rec helper i l acc =
match l with
| [] -> acc
| h::t -> helper(t*i) :: acc 
in helper i l []
Error: This expression has type 'a list
       but an expression was expected of type int


let mulByDigit i l = 
let rec helper i l acc =
match l with
| [] -> acc
| h::t -> helper(h*i) :: acc 
in helper i l []
Error: This expression has type int list -> 'a list -> 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside int list -> 'a list -> 'a list



hw3 mulByDigit

fix:
let rec mulByDigit i l = mulByDigit (i-1) (bigAdd l l)

bad:
let rec mulByDigit i l = mulByDigit i-1 (bigAdd l l)
Error: This expression has type 'a -> 'b
       but an expression was expected of type int



hw3 mulByDigit

fix:
let sqsum xs = 
let f a x = (a+x*x) in
let base = 0 in
List.fold_left f base xs

let _ = sqsum []

let _ = sqsum [1;2;3;4]

let _ = sqsum [(-1); (-2); (-3); (-4)]

let pipe fs = 
let f a x = fun y -> x (a y) in
let base = fun x -> x in
List.fold_left f base fs

let _ = pipe [] 3

let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3

let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3

let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = a^sep^x in
let base = h in
let l = t in
List.fold_left f base l

let _ = sepConcat ", " ["foo";"bar";"baz"]

let _ = sepConcat "---" []

let _ = sepConcat "" ["a";"b";"c";"d";"e"]

let _ = sepConcat "X" ["hello"]

let stringOfList f l = "["^sepConcat "; " (List.map f l)^"]"

let _ = stringOfList string_of_int [1;2;3;4;5;6]

let _ = stringOfList (fun x -> x) ["foo"]

let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]

let clone x n = 
let rec helper x n acc =
if n <= 0 then acc
else helper x (n-1) (x::acc)
in helper x n []

let _ = clone 3 5

let _ = clone "foo" 2

let _ = clone clone (-3)

let padZero l1 l2 =
if (List.length l1) < (List.length l2) then
(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)
else
(l1, List.append (clone 0 (List.length l1 - List.length l2)) l2)

let _ = padZero [9;9] [1;0;0;2]

let _ = padZero [1;0;0;2] [9;9]

let _ = padZero [0;0;1;2] [2;2;3;4]

let rec removeZero l = match l with
| [] -> []
| x::xs -> 
if x = 0 then removeZero xs
else x::xs

let _ = removeZero [0;0;0;1;0;0;2]

let _ = removeZero [9;9]

let _ = removeZero [0;0;0;0]

let _ = 18/10

let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = let (o,p) = a in
let (d1,d2) = x in ( (d1+d2+o)/10, ((d1+d2+o) mod 10) ::p) in
let base = (0, []) in
let args = List.rev (List.combine (0::l1) (0::l2)) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

let _ = bigAdd [9;9] [1;0;0;2]

let _ = bigAdd [9;9;9;9] [9;9;9]

let _ = bigAdd [3] []

let _ = bigAdd [9;9;9;9] [9;9;9;9]

let mulByDigit i l = 
let rec helper i l hold = 
match i with
| 0 -> hold
| _ -> helper (i-1) l (bigAdd l hold)
in helper i l []

let _ = mulByDigit 9 [9;9;9;9]

let _ = mulByDigit 3 [3;3;3]

bad:
let a1::a2::t = l1 in
(mulByDigit a2 (mulByDigit a1 l2))
Error: Unbound value bigAdd



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = let (o,p) = a in 
let h::t = x in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o) )in
let base = (0,[]) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = let (o,p) = a in 
let h::t = x in (o+1, bigAdd (mulByDigit h l2) p @ clone 0 o )in
let base = (0,[]) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value b
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value b



hw3 bigMul

fix:
let bigMul l1 l2 = 
let f a x = let (o,p) = a in 
let (h::t,y) = x in (o+1, bigAdd (mulByDigit h y) (p @ clone 0 o) ) in
let base = (0,[]) in
let args = (l1, l2) in
let (_, res) = List.fold_left f base args in
res

bad:
let bigMul l1 l2 = 
let f a x = let (o,p) = a in 
let h::t = x in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o) ) in
let base = (0,[]) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int but an expression was expected of type
         int list
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int but an expression was expected of type
         int list



hw3 bigMul

fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = let (o,p) = a in 
let (h::t,y) = x in (o+1, bigAdd (mulByDigit h y) (p @ clone 0 o) ) in
let base = (0,[]) in
let args = [(l1, l2)] in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type 'a * 'b
       but an expression was expected of type (int list * int list) list
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type 'a * 'b
       but an expression was expected of type (int list * int list) list



hw3 bigMul

fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = let (o,p) = a in 
let (h::t) = x in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o)) in
let base = (0,[]) in
let args = [l1] in
let (_, res) = List.fold_left f base args in
res
Error: Unbound value y
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: Unbound value y



hw3 bigMul

fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let _ = bigMul [[9;9;9;9]] [9;9;9;9]
Error: This expression has type int but an expression was expected of type
         int list
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int but an expression was expected of type
         int list



hw3 bigMul

fix:
let _ = bigMul [9;9;9;9] [9;9;9;9]

bad:
let bigMul l1 l2 = 
let f a x = let (o,p) = a in 
let h::t = [x] in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o)) in
let base = (0,[]) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res
Error: This expression has type int but an expression was expected of type
         int list
Error: Unbound value clone
MINIMAL PROGRAM DIFFERENT ERROR!!!!!!
Error: This expression has type int but an expression was expected of type
         int list



